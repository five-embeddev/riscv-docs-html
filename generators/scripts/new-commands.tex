
\newcommand{\ppost}{$b$ is a store, and $a$ and $b$ access overlapping memory addresses}
\newcommand{\ppofence}{There is a FENCE instruction that orders $a$ before $b$}
\newcommand{\ppoacquire}{$a$ has an acquire annotation}
\newcommand{\pporelease}{$b$ has a release annotation}
\newcommand{\pporcsc}{$a$ and $b$ both have RCsc annotations}
\newcommand{\ppoamoforward}{$a$ is generated by an AMO or SC instruction, $b$ is a load, and $b$ returns a value written by $a$}
\newcommand{\ppoaddr}{$b$ has a syntactic address dependency on $a$}
\newcommand{\ppodata}{$b$ has a syntactic data dependency on $a$}
\newcommand{\ppoctrl}{$b$ is a store, and $b$ has a syntactic control dependency on $a$}
\newcommand{\ppopair}{$a$ is paired with $b$}
\newcommand{\ppordw}{$a$ and $b$ are loads, $x$ is a byte read by both $a$ and $b$, there is no store to $x$ between $a$ and $b$ in program order, and $a$ and $b$ return values for $x$ written by different memory operations}
\newcommand{\ppoaddrdatarfi}{$b$ is a load, and there exists some store $m$ between $a$ and $b$ in program order such that $m$ has an address or data dependency on $a$, and $b$ returns a value written by $m$}
\newcommand{\ppoaddrpo}{$b$ is a store, and there exists some instruction $m$ between $a$ and $b$ in program order such that $m$ has an address dependency on $a$}
%\newcommand{\ppoctrlcfence}{$a$ and $b$ are loads, $b$ has a syntactic control dependency on $a$, and there exists a {\tt fence.i} between the branch used to form the control dependency and $b$ in program order}
%\newcommand{\ppoaddrpocfence}{$a$ is a load, there exists an instruction $m$ which has a syntactic address dependency on $a$, and there exists a {\tt fence.i} between $m$ and $b$ in program order}
\newcommand{\loadvalueaxiom}{
  Each byte of each load $i$ returns the value written to that byte by the store that is the latest in global memory order among the following stores:
  \begin{enumerate}
    \item Stores that write that byte and that precede $i$ in the global memory order
    \item Stores that write that byte and that precede $i$ in program order
  \end{enumerate}
}
\newcommand{\atomicityaxiom}{If $r$ and $w$ are paired load and store operations generated by aligned LR and SC instructions in a hart $h$, $s$ is a store to byte $x$, and $r$ returns a value written by $s$, then $s$ must precede $w$ in the global memory order, and there can be no store from a hart other than $h$ to byte $x$ following $s$ and preceding $w$ in the global memory order.}
\newcommand{\progressaxiom}{No memory operation may be preceded in the global memory order by an infinite sequence of other memory operations.}
\newcommand{\rdprime}{rd\,$'$}
\newcommand{\rsoneprime}{rs1\,$'$}
\newcommand{\rstwoprime}{rs2\,$'$}
\newcommand{\misalignedatomicityaxiom}{If $r$ and $w$ are paired misaligned load and store instructions from a hart $h$ with the same address and of the same size, then there can be no store instruction $s$ from a hart other than $h$ with the same address and of the same size as $r$ and $w$ such that a store operation generated by $s$ lies in between memory operations generated by $r$ and $w$ in the global memory order.  Furthermore, there can be no load instruction $l$ from a hart other than $h$ with the same address and of the same size as $r$ and $w$ such that a load operation generated by $l$ lies between two memory operations generated by $r$ or by $w$ in the global memory order.}
