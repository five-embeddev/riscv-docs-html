<html>
<head>
<title>RISC-V External Debug Support</title>
</head>
<body>

<table>
<tr><th colspan=2>Metadata Table</th></tr>
<tr><th>Manual Type</th><td> debug</td></tr>
<tr><th>Spec Revision</th><td> 0.13.2</td></tr>
<tr><th>Spec Release Date</th><td> 2019-03-25</td></tr>
<tr><th>Git Revision</th><td> task_group_vote-4-g4e0bb0f</td></tr>
<tr><th>Git URL</th><td><a href=https://github.com/riscv/riscv-debug-spec.git>https://github.com/riscv/riscv-debug-spec.git</a></td></tr>
<tr><th>Source</th><td>core_debug.tex</td></tr>
<tr><th>Conversion Date</th><td>2023/07/31</td></tr>
<tr><th>License</th><td><a href=https://creativecommons.org/licenses/by/4.0/>CC-by-4.0</a></td></tr>
</table>


<h1 id="sec:core_debug"><span class="header-section-number">5</span> RISC-V Debug</h1>
<p>Modifications to the RISC-V core to support debug are kept to a minimum. There
is a special execution mode (Debug Mode) and a few extra CSRs. The DM takes care
of the rest.</p>
<p>In order to be compliant with this specification an implementation must
implement everything described in this section that is not explicitly listed as
optional.</p>
<h2 id="debugmode"><span class="header-section-number">5.1</span> Debug Mode</h2>
<p>Debug Mode is a special processor mode used only when a hart is halted for
external debugging. How Debug Mode is implemented is not specified here.</p>
<p><span>When executing code from the optional Program Buffer, the hart
stays in Debug Mode and the following apply:</span></p>
<p>All operations are executed at machine mode privilege level, except that
in <span>mstatus</span>may be ignored according to .</p>
<p>All interrupts (including NMI) are masked.</p>
<p>Exceptions don’t update any registers. That includes <span>cause</span>, <span>
epc</span>, <span>tval</span>, <span>dpc</span>, and <span>mstatus</span>. They do end execution of the
Program Buffer.</p>
<p>No action is taken if a trigger matches.</p>
<p>Counters may be stopped, depending on in <span><span>dcsr</span></span>.</p>
<p>Timers may be stopped, depending on in <span><span>dcsr</span></span>.</p>
<p>The <span>wfi</span> instruction acts as a <span>nop</span>.</p>
<p>Almost all instructions that change the privilege level have undefined
behavior. This includes <span>ecall</span>, <span>mret</span>, <span>sret</span>,
and <span>uret</span>. (To change the privilege level, the debugger can write
in <span><span>dcsr</span></span>). The only exception is <span>ebreak</span>. When that is executed
in Debug Mode, it halts the hart again but without updating <span><span>dpc</span></span>or <span><span>dcsr</span></span>.</p>
<p><span id="fence" label="fence">[fence]</span> Completing Program Buffer execution is considered output for the purpose
of <span>fence</span> instructions.</p>
<p>All control transfer instructions may act as illegal instructions if
their destination is in the Program Buffer. If one such instruction acts as
an illegal instruction, all such instructions must act as an illegal
instruction.</p>
<p>All control transfer instructions may act as illegal instructions if
their destination is outside the Program Buffer. If one such instruction
acts as an illegal instruction, all such instructions must act as an
illegal instruction.</p>
<p>Instructions that depend on the value of the PC (e.g. <span>auipc</span>) may act
as illegal instructions.</p>
<p>Effective XLEN is DXLEN.</p>
<div class=commentary>
<p>In general, the debugger is expected to be able to simulate all the effects of .
The exception is the case of Sv32 systems, which need functionality in order to access
34-bit physical addresses. Other systems are likely to tie to 0.</p>
</div>
<h2 id="load-reservedstore-conditional-instructions"><span class="header-section-number">5.2</span> Load-Reserved/Store-Conditional Instructions</h2>
<p>The reservation registered by an <span>lr</span> instruction on a memory address may
be lost when entering Debug Mode or while in Debug Mode. This means that there
may be no forward progress if Debug Mode is entered between <span>lr</span> and <span>
sc</span> pairs.</p>
<div class=commentary>
<p>This is a behavior that debug users must be aware of. If they have a
breakpoint set between a <span>lr</span> and <span>sc</span> pair, or are stepping
through such code, the <span>sc</span> may never succeed. Fortunately in general use
there will be very few instructions in such a sequence, and anybody
debugging it will quickly notice that the reservation is not occurring.
The solution in that case is to set a breakpoint on the first instruction
after the <span>sc</span> and run to it. A higher level debugger may choose to
automate this.</p>
</div>
<h2 id="wait-for-interrupt-instruction"><span class="header-section-number">5.3</span> Wait for Interrupt Instruction</h2>
<p>If halt is requested while <span>wfi</span> is executing, then the hart must leave the
stalled state, completing this instruction’s execution, and then enter Debug
Mode.</p>
<h2 id="single-step"><span class="header-section-number">5.4</span> Single Step</h2>
<p>A debugger can cause a halted hart to execute a single instruction and then
re-enter Debug Mode by setting before setting .</p>
<p>If executing or fetching that instruction causes an exception, Debug Mode is
re-entered immediately after the PC is changed to the exception handler and the
appropriate <span>tval</span> and <span>cause</span> registers are updated.</p>
<p>If executing or fetching the instruction causes a trigger to fire, Debug Mode
is re-entered immediately after that trigger has fired. In that case is
set to 2 (trigger) instead of 4 (single step). Whether the instruction is
executed or not depends on the specific configuration of the trigger.</p>
<p>If the instruction that is executed causes the PC to change to an address where
an instruction fetch causes an exception, that exception does not occurr until
the next time the hart is resumed. Similarly, a trigger at the new address does
not fire until the hart actually attempts to execute that instruction.</p>
<p>If the instruction being stepped over is <span>wfi</span> and would normally stall the
hart, then instead the instruction is treated as <span>nop</span>.</p>
<h2 id="reset"><span class="header-section-number">5.5</span> Reset</h2>
<p>If the halt signal (driven by the hart’s halt request bit in the Debug Module)
or are asserted when a hart comes out of reset, the hart must
enter Debug Mode before executing any instructions, but after performing any
initialization that would usually happen before the first instruction is
executed.</p>
<h2 id="dret"><span class="header-section-number">5.6</span> <span>dret</span> Instruction</h2>
<p>To return from Debug Mode, a new instruction is defined: <span>dret</span>. It has an
encoding of 0x7b200073. On harts which support this instruction,
executing <span>dret</span> in Debug Mode changes <span>pc</span>to the value
stored in <span><span>dpc</span></span>. The current privilege level is changed to that specified by
in <span><span>dcsr</span></span>. The hart is no longer in debug mode.</p>
<p>Executing <span>dret</span> outside of Debug Mode causes an illegal instruction exception.</p>
<p>It is not necessary for the debugger to know whether an implementation supports
<span>dret</span>, as the Debug Module will ensure that it is executed if necessary.
It is defined in this specification only to reserve the opcode and
allow for reusable Debug Module implementations.</p>
<h2 id="xlen"><span class="header-section-number">5.7</span> XLEN</h2>
<p>While in Debug Mode, XLEN is DXLEN. It is up to the debugger to determine the
XLEN during normal program execution (by looking at <span>misa</span>) and to clearly
communicate this to the user.</p>
<h2 id="debreg"><span class="header-section-number">5.8</span> Core Debug Registers</h2>
<p>The supported Core Debug Registers must be implemented for each hart that can
be debugged. They are CSRs, accessible using the RISC-V <span>csr</span> opcodes and
optionally also using abstract debug commands.</p>
<p><a href="core_registers.html" data-reference-type="ref" data-reference="core_registers.tex">[core_registers.tex]</a></p>
<h2 id="virtreg"><span class="header-section-number">5.9</span> Virtual Debug Registers</h2>
<p><a href="sw_registers.html" data-reference-type="ref" data-reference="sw_registers.tex">[sw_registers.tex]</a></p>

</body>
</html>
