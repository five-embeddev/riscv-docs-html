<html>
<head>
<title>The RISC-V Instruction Set Manual, Volume II: Privileged Architecture</title>
</head>
<body>

<table>
<tr><th colspan=2>Metadata Table</th></tr>
<tr><th>Manual Type</th><td> priv</td></tr>
<tr><th>Spec Revision</th><td> 1.10</td></tr>
<tr><th>Spec Release Date</th><td> </td></tr>
<tr><th>Git Revision</th><td> riscv-priv-1.10</td></tr>
<tr><th>Git URL</th><td><a href=https://github.com/riscv/riscv-isa-manual.git>https://github.com/riscv/riscv-isa-manual.git</a></td></tr>
<tr><th>Source</th><td>src/priv-csrs.tex</td></tr>
<tr><th>Conversion Date</th><td>2023/09/28</td></tr>
<tr><th>License</th><td><a href=https://creativecommons.org/licenses/by/4.0/>CC-by-4.0</a></td></tr>
</table>


<h1 id="control-and-status-registers-csrs"><span class="header-section-number">2</span> Control and Status Registers (CSRs)</h1>
<p>The SYSTEM major opcode is used to encode all privileged instructions
in the RISC-V ISA. These can be divided into two main classes: those
that atomically read-modify-write control and status registers (CSRs),
and all other privileged instructions. In addition to the user-level
state described in Volume I of this manual, an implementation may
contain additional CSRs, accessible by some subset of the privilege
levels using the CSR instructions described in the user-level manual.
In this chapter, we map out the CSR address space. The following
chapters describe the function of each of the CSRs according to
privilege level, as well as the other privileged instructions which
are generally closely associated with a particular privilege level.
Note that although CSRs and instructions are associated with one
privilege level, they are also accessible at all higher privilege
levels.</p>
<h2 id="csr-address-mapping-conventions"><span class="header-section-number">2.1</span> CSR Address Mapping Conventions</h2>
<p>The standard RISC-V ISA sets aside a 12-bit encoding space (csr[11:0])
for up to 4,096 CSRs. By convention, the upper 4 bits of the CSR
address (csr[11:8]) are used to encode the read and write
accessibility of the CSRs according to privilege level as shown in
Table <a href="priv-csrs.html#csrrwpriv" data-reference-type="ref" data-reference="csrrwpriv">1.1</a>. The top two bits (csr[11:10]) indicate whether
the register is read/write (<span>00</span>, <span>01</span>, or <span>10</span>) or
read-only (<span>11</span>). The next two bits (csr[9:8]) encode the lowest
privilege level that can access the CSR.</p>
<div class=commentary>
<p>The CSR address convention uses the upper bits of the CSR address to
encode default access privileges. This simplifies error checking in
the hardware and provides a larger CSR space, but does constrain the
mapping of CSRs into the address space.</p>
<p>Implementations might allow a more-privileged level to trap otherwise
permitted CSR accesses by a less-privileged level to allow these
accesses to be intercepted. This change should be transparent to the
less-privileged software.</p>
</div>
<figure>
<img src="priv-csrs_00.svg" alt="Allocation of RISC-V CSR address ranges." id="csrrwpriv" /><figcaption>Allocation of RISC-V CSR address ranges.<span label="csrrwpriv"></span></figcaption>
</figure>
<p>Attempts to access a non-existent CSR raise an illegal instruction
exception. Attempts to access a CSR without appropriate privilege
level or to write a read-only register also raise illegal instruction
exceptions. A read/write register might also contain some bits that
are read-only, in which case writes to the read-only bits are ignored.</p>
<p>Table <a href="priv-csrs.html#csrrwpriv" data-reference-type="ref" data-reference="csrrwpriv">1.1</a> also indicates the convention to allocate CSR
addresses between standard and non-standard uses. The CSR addresses
reserved for non-standard uses will not be redefined by future
standard extensions.</p>
<div class=commentary>
<p>We have dropped the explicit allocation of CSR space for shadow CSRs
to leave more flexibility for allocated other CSRs. Shadow CSRs can
still be added in the appropriate R/W space. The counters are the
only shadowed CSRs in the current spec.</p>
<p>Shadows CSRs provide a read-write address via which a higher privilege
level can modify a register that is read-only at a lower privilege
level. Note that if one privilege level has already allocated a
read/write shadow address, then any higher privilege level can use the
same CSR address for read/write access to the same register.</p>
<p>Effective virtualization requires that as many instructions run
natively as possible inside a virtualized environment, while any
privileged accesses trap to the virtual machine
monitor <span class="citation" data-cites="goldbergvm"><a href="#ref-goldbergvm">[goldbergvm]</a></span>. CSRs that are read-only at some lower
privilege level are shadowed into separate CSR addresses if they are
made read-write at a higher privilege level. This avoids trapping
permitted lower-privilege accesses while still causing traps on
illegal accesses.</p>
</div>
<p>Machine-mode standard read-write CSRs <span>0x7A0</span>–<span>0x7BF</span> are
reserved for use by the debug system. Implementations should raise
illegal instruction exceptions on machine-mode access to these registers.</p>
<h2 id="csr-listing"><span class="header-section-number">2.2</span> CSR Listing</h2>
<p>Tables <a href="priv-csrs.html#ucsrnames" data-reference-type="ref" data-reference="ucsrnames">1.2</a>–<a href="priv-csrs.html#mcsrnames" data-reference-type="ref" data-reference="mcsrnames">1.5</a> list the CSRs that have
currently been allocated CSR addresses. The timers, counters, and
floating-point CSRs are standard user-level CSRs, as well as the
additional user trap registers added by the N extension. The other
registers are used by privileged code, as described in the following
chapters. Note that not all registers are required on all
implementations.</p>
<figure>
<img src="priv-csrs_01.svg" alt="Currently allocated RISC-V user-level CSR addresses." id="ucsrnames" /><figcaption>Currently allocated RISC-V user-level CSR addresses.<span label="ucsrnames"></span></figcaption>
</figure>
<figure>
<img src="priv-csrs_02.svg" alt="Currently allocated RISC-V supervisor-level CSR addresses." id="scsrnames" /><figcaption>Currently allocated RISC-V supervisor-level CSR addresses.<span label="scsrnames"></span></figcaption>
</figure>
<figure>
<img src="priv-csrs_03.svg" alt="Currently allocated RISC-V machine-level CSR addresses." id="mcsrnames" /><figcaption>Currently allocated RISC-V machine-level CSR addresses.<span label="mcsrnames"></span></figcaption>
</figure>
<figure>
<img src="priv-csrs_04.svg" alt="Currently allocated RISC-V machine-level CSR addresses." id="mcsrnames" /><figcaption>Currently allocated RISC-V machine-level CSR addresses.<span label="mcsrnames"></span></figcaption>
</figure>
<h2 id="csr-field-specifications"><span class="header-section-number">2.3</span> CSR Field Specifications</h2>
<p>The following definitions and abbreviations are used in specifying the
behavior of fields within the CSRs.</p>
<h3 id="reserved-writes-ignored-reads-ignore-values-wiri" class="unnumbered">Reserved Writes Ignored, Reads Ignore Values (WIRI)</h3>
<p>Some read-only and read/write registers have read-only fields reserved
for future use. These reserved read-only fields should be ignored on
a read. Writes to these fields have no effect, unless the whole CSR
is read-only, in which case writes might raise an illegal instruction
exception. These fields are labeled <strong>WIRI</strong> in the register
descriptions.</p>
<h3 id="reserved-writes-preserve-values-reads-ignore-values-wpri" class="unnumbered">Reserved Writes Preserve Values, Reads Ignore Values (WPRI)</h3>
<p>Some whole read/write fields are reserved for future use. Software
should ignore the values read from these fields, and should preserve
the values held in these fields when writing values to other fields of
the same register. These fields are labeled <strong>WPRI</strong> in the register
descriptions.</p>
<div class=commentary>
<p>To simplify the software model, any backward-compatible future
definition of previously reserved fields within a CSR must cope with
the possibility that a non-atomic read/modify/write sequence is used
to update other fields in the CSR. Alternatively, the original CSR
definition must specify that subfields can only be updated atomically,
which may require a two-instruction clear bit/set bit sequence in
general that can be problematic if intermediate values are not legal.</p>
</div>
<h3 id="writeread-only-legal-values-wlrl" class="unnumbered">Write/Read Only Legal Values (WLRL)</h3>
<p>Some read/write CSR fields specify behavior for only a subset of
possible bit encodings, with other bit encodings reserved. Software
should not write anything other than legal values to such a field, and
should not assume a read will return a legal value unless the last
write was of a legal value, or the register has not been written since
another operation (e.g., reset) set the register to a legal value.
These fields are labeled <strong>WLRL</strong> in the register descriptions.</p>
<div class=commentary>
<p>Hardware implementations need only implement enough state bits to
differentiate between the supported values, but must always return the
complete specified bit-encoding of any supported value when read.</p>
</div>
<p>Implementations are permitted but not required to raise an illegal
instruction exception if an instruction attempts to write a
non-supported value to a CSR field. Hardware implementations can
return arbitrary bit patterns on the read of a CSR field when the last
write was of an illegal value, but the value returned should
deterministically depend on the previous written value.</p>
<h3 id="write-any-values-reads-legal-values-warl" class="unnumbered">Write Any Values, Reads Legal Values (WARL)</h3>
<p>Some read/write CSR fields are only defined for a subset of bit
encodings, but allow any value to be written while guaranteeing to
return a legal value whenever read. Assuming that writing the CSR has
no other side effects, the range of supported values can be determined
by attempting to write a desired setting then reading to see if the
value was retained. These fields are labeled <strong>WARL</strong> in the register
descriptions.</p>
<p>Implementations will not raise an exception on writes of unsupported
values to an <strong>WARL</strong> field. Implementations must always
deterministically return the same legal value after a given illegal
value is written.</p>

</body>
</html>
