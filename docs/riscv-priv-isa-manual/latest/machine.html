<html>
<head>
<title>The RISC-V Instruction Set Manual, Volume II: Privileged Architecture</title>
</head>
<body>

<table>
<tr><th colspan=2>Metadata Table</th></tr>
<tr><th>Manual Type</th><td> priv</td></tr>
<tr><th>Spec Revision</th><td> 20211203</td></tr>
<tr><th>Spec Release Date</th><td> </td></tr>
<tr><th>Git Revision</th><td> Priv-v1.12</td></tr>
<tr><th>Git URL</th><td><a href=https://github.com/riscv/riscv-isa-manual.git>https://github.com/riscv/riscv-isa-manual.git</a></td></tr>
<tr><th>Source</th><td>src/machine.tex</td></tr>
<tr><th>Conversion Date</th><td>2023/07/31</td></tr>
<tr><th>License</th><td><a href=https://creativecommons.org/licenses/by/4.0/>CC-by-4.0</a></td></tr>
</table>


<h1 id="machine"><span class="header-section-number">3</span> Machine-Level ISA, Version 1.12</h1>
<p>This chapter describes the machine-level operations available in
machine-mode (M-mode), which is the highest privilege mode in a RISC-V
system. M-mode is used for low-level access to a
hardware platform and is the first mode entered at reset. M-mode can
also be used to implement features that are too difficult or expensive
to implement in hardware directly. The RISC-V machine-level ISA
contains a common core that is extended depending on which other
privilege levels are supported and other details of the hardware
implementation.</p>
<h2 id="machine-level-csrs"><span class="header-section-number">3.1</span> Machine-Level CSRs</h2>
<p>In addition to the machine-level CSRs described in this section,
M-mode code can access all CSRs at lower privilege levels.</p>
<h3 id="sec:misa"><span class="header-section-number">3.1.1</span> Machine ISA Register <span>misa</span></h3>
<p>The <span>misa</span> CSR is a <strong>WARL</strong> read-write register
reporting the ISA supported by the hart. This register must be
readable in any implementation, but a value of zero can be returned to
indicate the <span>misa</span> register has not been implemented, requiring
that CPU capabilities be determined through a separate non-standard
mechanism.</p>
<figure>
<img src="machine_00.svg" alt="Machine ISA register (misa)." id="misareg" /><figcaption>Machine ISA register (<span>misa</span>).<span label="misareg"></span></figcaption>
</figure>
<p>The MXL (Machine XLEN) field encodes the native base integer ISA width
as shown in Table <a href="machine.html#misabase" data-reference-type="ref" data-reference="misabase">[misabase]</a>. The MXL field may be writable in
implementations that support multiple base ISAs. The effective
XLEN in M-mode, <span><em>MXLEN</em></span>, is given by the setting of MXL, or has a
fixed value if <span>misa</span> is zero. The MXL field is always set to the
widest supported ISA variant at reset.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: right;">MXL</th>
<th style="text-align: right;">XLEN</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">1</td>
<td style="text-align: right;">32</td>
</tr>
<tr class="even">
<td style="text-align: right;">2</td>
<td style="text-align: right;">64</td>
</tr>
<tr class="odd">
<td style="text-align: right;">3</td>
<td style="text-align: right;">128</td>
</tr>
</tbody>
</table>
<p>The <span>misa</span> CSR is MXLEN bits wide. If the value read from <span>misa</span> is
nonzero, field MXL of that value always denotes the current MXLEN. If a write
to <span>misa</span> causes MXLEN to change, the position of MXL moves to the
most-significant two bits of <span>misa</span> at the new width.</p>
<div class=commentary>
<p>The base width can be quickly ascertained using branches on the sign
of the returned <span>misa</span> value, and possibly a shift left by one and
a second branch on the sign. These checks can be written in assembly
code without knowing the register width (XLEN) of the machine. The
base width is given by <span class="math inline"><em>X</em><em>L</em><em>E</em><em>N</em> = 2<sup><em>M</em><em>X</em><em>L</em> + 4</sup></span>.</p>
<p>The base width can also be found if <span>misa</span> is zero, by placing the
immediate 4 in a register then shifting the register left by 31 bits
at a time. If zero after one shift, then the machine is RV32. If
zero after two shifts, then the machine is RV64, else RV128.</p>
</div>
<p>The Extensions field encodes the presence of the standard extensions,
with a single bit per letter of the alphabet (bit 0 encodes presence
of extension “A” , bit 1 encodes presence of extension “B”,
through to bit 25 which encodes “Z”). The “I” bit will be set for
RV32I, RV64I, RV128I base ISAs, and the “E” bit will be set for
RV32E. The Extensions field is a <strong>WARL</strong> field that can contain writable bits
where the implementation allows the supported ISA to be modified. At
reset, the Extensions field shall contain the maximal set of supported
extensions, and I shall be selected over E if both are available.</p>
<p>When a standard extension is disabled by clearing its bit in <span>misa</span>, the instructions and CSRs defined or modified by the extension revert to their defined or reserved behaviors as if the extension is not implemented.</p>
<p>The design of the RV128I base ISA is not yet complete, and while much of the remainder of this
specification is expected to apply to RV128, this version of the document
focuses only on RV32 and RV64.</p>
<p>The “U” and “S” bits will be set if there is support for user and
supervisor modes respectively.</p>
<p>The “X” bit will be set if there are any non-standard extensions.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: right;">Bit</th>
<th style="text-align: right;">Character</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">0</td>
<td style="text-align: right;">A</td>
<td style="text-align: left;">Atomic extension</td>
</tr>
<tr class="even">
<td style="text-align: right;">1</td>
<td style="text-align: right;">B</td>
<td style="text-align: left;"><span><em>Tentatively reserved for Bit-Manipulation extension</em></span></td>
</tr>
<tr class="odd">
<td style="text-align: right;">2</td>
<td style="text-align: right;">C</td>
<td style="text-align: left;">Compressed extension</td>
</tr>
<tr class="even">
<td style="text-align: right;">3</td>
<td style="text-align: right;">D</td>
<td style="text-align: left;">Double-precision floating-point extension</td>
</tr>
<tr class="odd">
<td style="text-align: right;">4</td>
<td style="text-align: right;">E</td>
<td style="text-align: left;">RV32E base ISA</td>
</tr>
<tr class="even">
<td style="text-align: right;">5</td>
<td style="text-align: right;">F</td>
<td style="text-align: left;">Single-precision floating-point extension</td>
</tr>
<tr class="odd">
<td style="text-align: right;">6</td>
<td style="text-align: right;">G</td>
<td style="text-align: left;"><span><em>Reserved</em></span></td>
</tr>
<tr class="even">
<td style="text-align: right;">7</td>
<td style="text-align: right;">H</td>
<td style="text-align: left;">Hypervisor extension</td>
</tr>
<tr class="odd">
<td style="text-align: right;">8</td>
<td style="text-align: right;">I</td>
<td style="text-align: left;">RV32I/64I/128I base ISA</td>
</tr>
<tr class="even">
<td style="text-align: right;">9</td>
<td style="text-align: right;">J</td>
<td style="text-align: left;"><span><em>Tentatively reserved for Dynamically Translated Languages extension</em></span></td>
</tr>
<tr class="odd">
<td style="text-align: right;">10</td>
<td style="text-align: right;">K</td>
<td style="text-align: left;"><span><em>Reserved</em></span></td>
</tr>
<tr class="even">
<td style="text-align: right;">11</td>
<td style="text-align: right;">L</td>
<td style="text-align: left;"><span><em>Reserved</em></span></td>
</tr>
<tr class="odd">
<td style="text-align: right;">12</td>
<td style="text-align: right;">M</td>
<td style="text-align: left;">Integer Multiply/Divide extension</td>
</tr>
<tr class="even">
<td style="text-align: right;">13</td>
<td style="text-align: right;">N</td>
<td style="text-align: left;"><span><em>Tentatively reserved for User-Level Interrupts extension</em></span></td>
</tr>
<tr class="odd">
<td style="text-align: right;">14</td>
<td style="text-align: right;">O</td>
<td style="text-align: left;"><span><em>Reserved</em></span></td>
</tr>
<tr class="even">
<td style="text-align: right;">15</td>
<td style="text-align: right;">P</td>
<td style="text-align: left;"><span><em>Tentatively reserved for Packed-SIMD extension</em></span></td>
</tr>
<tr class="odd">
<td style="text-align: right;">16</td>
<td style="text-align: right;">Q</td>
<td style="text-align: left;">Quad-precision floating-point extension</td>
</tr>
<tr class="even">
<td style="text-align: right;">17</td>
<td style="text-align: right;">R</td>
<td style="text-align: left;"><span><em>Reserved</em></span></td>
</tr>
<tr class="odd">
<td style="text-align: right;">18</td>
<td style="text-align: right;">S</td>
<td style="text-align: left;">Supervisor mode implemented</td>
</tr>
<tr class="even">
<td style="text-align: right;">19</td>
<td style="text-align: right;">T</td>
<td style="text-align: left;"><span><em>Reserved</em></span></td>
</tr>
<tr class="odd">
<td style="text-align: right;">20</td>
<td style="text-align: right;">U</td>
<td style="text-align: left;">User mode implemented</td>
</tr>
<tr class="even">
<td style="text-align: right;">21</td>
<td style="text-align: right;">V</td>
<td style="text-align: left;"><span><em>Tentatively reserved for Vector extension</em></span></td>
</tr>
<tr class="odd">
<td style="text-align: right;">22</td>
<td style="text-align: right;">W</td>
<td style="text-align: left;"><span><em>Reserved</em></span></td>
</tr>
<tr class="even">
<td style="text-align: right;">23</td>
<td style="text-align: right;">X</td>
<td style="text-align: left;">Non-standard extensions present</td>
</tr>
<tr class="odd">
<td style="text-align: right;">24</td>
<td style="text-align: right;">Y</td>
<td style="text-align: left;"><span><em>Reserved</em></span></td>
</tr>
<tr class="even">
<td style="text-align: right;">25</td>
<td style="text-align: right;">Z</td>
<td style="text-align: left;"><span><em>Reserved</em></span></td>
</tr>
</tbody>
</table>
<div class=commentary>
<p>The <span>misa</span> CSR exposes a rudimentary catalog of CPU features
to machine-mode code. More extensive information can be obtained in
machine mode by probing other machine registers, and examining other
ROM storage in the system as part of the boot process.</p>
<p>We require that lower privilege levels execute environment calls
instead of reading CPU registers to determine features available at
each privilege level. This enables virtualization layers to alter the
ISA observed at any level, and supports a much richer command
interface without burdening hardware designs.</p>
</div>
<p>The “E” bit is read-only. Unless <span>misa</span> is all read-only zero, the “E”
bit always reads as the complement of the “I” bit. An implementation that
supports both RV32E and RV32I can select RV32E by clearing the “I” bit.</p>
<p>If an ISA feature <span><em>x</em></span> depends on an ISA feature <span><em>y</em></span>, then attempting
to enable feature <span><em>x</em></span> but disable feature <span><em>y</em></span> results in both features
being disabled. For example, setting “F”=0 and “D”=1 results in both
“F” and “D” being cleared.</p>
<p>An implementation may impose additional constraints on the collective setting
of two or more <span>misa</span> fields, in which case they function collectively as
a single <strong>WARL</strong> field. An attempt to write an unsupported combination causes
those bits to be set to some supported combination.</p>
<p>Writing <span>misa</span> may increase IALIGN, e.g., by disabling the “C”
extension.
If an instruction that would write <span>misa</span> increases IALIGN, and
the subsequent instruction’s address is not IALIGN-bit aligned, the
write to <span>misa</span> is suppressed, leaving <span>misa</span> unchanged.</p>
<p>When software enables an extension that was previously disabled, then all
state uniquely associated with that extension is , unless
otherwise specified by that extension.</p>
<h3 id="machine-vendor-id-register-mvendorid"><span class="header-section-number">3.1.2</span> Machine Vendor ID Register <span>mvendorid</span></h3>
<p>The <span>mvendorid</span> CSR is a 32-bit read-only register providing
the JEDEC manufacturer ID of the provider of the core. This register
must be readable in any implementation, but a value of 0 can be
returned to indicate the field is not implemented or that this is a
non-commercial implementation.</p>
<figure>
<img src="machine_01.svg" alt="Vendor ID register (mvendorid)." id="mvendorreg" /><figcaption>Vendor ID register (<span>mvendorid</span>).<span label="mvendorreg"></span></figcaption>
</figure>
<p>JEDEC manufacturer IDs are ordinarily encoded as a sequence of one-byte
continuation codes <span>0x7f</span>, terminated by a one-byte ID not equal to
<span>0x7f</span>, with an odd parity bit in the most-significant bit of each byte.
<span>mvendorid</span> encodes the number of one-byte continuation
codes in the Bank field, and encodes the final byte in the Offset field,
discarding the parity bit. For example, the JEDEC manufacturer ID
<span>0x7f 0x7f 0x7f 0x7f 0x7f 0x7f 0x7f 0x7f 0x7f 0x7f 0x7f 0x7f 0x8a</span>
(twelve continuation codes followed by <span>0x8a</span>) would be encoded in the
<span>mvendorid</span> CSR as <span>0x60a</span>.</p>
<div class=commentary>
<p>In JEDEC’s parlance, the bank number is one greater than the number of
continuation codes; hence, the <span>mvendorid</span> Bank field encodes a value
that is one less than the JEDEC bank number.</p>
</div>
<div class=commentary>
<p>Previously the vendor ID was to be a number allocated by RISC-V
International, but this duplicates the work of JEDEC in maintaining a
manufacturer ID standard. At time of writing, registering a
manufacturer ID with JEDEC has a one-time cost of $500.</p>
</div>
<h3 id="machine-architecture-id-register-marchid"><span class="header-section-number">3.1.3</span> Machine Architecture ID Register <span>marchid</span></h3>
<p>The <span>marchid</span> CSR is an MXLEN-bit read-only register encoding the
base microarchitecture of the hart. This register must be readable in
any implementation, but a value of 0 can be returned to indicate the
field is not implemented. The combination of <span>mvendorid</span> and <span>
marchid</span> should uniquely identify the type of hart microarchitecture
that is implemented.</p>
<figure>
<img src="machine_02.svg" alt="Machine Architecture ID register (marchid)." id="marchreg" /><figcaption>Machine Architecture ID register (<span>marchid</span>).<span label="marchreg"></span></figcaption>
</figure>
<p>Open-source project architecture IDs are allocated globally by
RISC-V International, and have non-zero architecture IDs with a zero
most-significant-bit (MSB). Commercial architecture IDs are allocated
by each commercial vendor independently, but must have the MSB set and
cannot contain zero in the remaining MXLEN-1 bits.</p>
<div class=commentary>
<p>The intent is for the architecture ID to represent the
microarchitecture associated with the repo around which development
occurs rather than a particular organization. Commercial fabrications
of open-source designs should (and might be required by the license
to) retain the original architecture ID. This will aid in reducing
fragmentation and tool support costs, as well as provide attribution.
Open-source architecture IDs are administered by RISC-V International
and should only be allocated to released, functioning open-source
projects. Commercial architecture IDs can be managed independently by
any registered vendor but are required to have IDs disjoint from the
open-source architecture IDs (MSB set) to prevent collisions if a
vendor wishes to use both closed-source and open-source
microarchitectures.</p>
<p>The convention adopted within the following Implementation field can
be used to segregate branches of the same architecture design,
including by organization. The <span>misa</span> register also helps
distinguish different variants of a design.</p>
</div>
<h3 id="machine-implementation-id-register-mimpid"><span class="header-section-number">3.1.4</span> Machine Implementation ID Register <span>mimpid</span></h3>
<p>The <span>mimpid</span> CSR provides a unique encoding of the version of the
processor implementation. This register must be readable in any
implementation, but a value of 0 can be returned to indicate that the
field is not implemented. The Implementation value should reflect the
design of the RISC-V processor itself and not any surrounding system.</p>
<figure>
<img src="machine_03.svg" alt="Machine Implementation ID register (mimpid)." id="mimpidreg" /><figcaption>Machine Implementation ID register (<span>mimpid</span>).<span label="mimpidreg"></span></figcaption>
</figure>
<div class=commentary>
<p>The format of this field is left to the provider of the architecture
source code, but will often be printed by standard tools as a
hexadecimal string without any leading or trailing zeros, so the
Implementation value can be left-justified (i.e., filled in from
most-significant nibble down) with subfields aligned on nibble
boundaries to ease human readability.</p>
</div>
<h3 id="hart-id-register-mhartid"><span class="header-section-number">3.1.5</span> Hart ID Register <span>mhartid</span></h3>
<p>The <span>mhartid</span> CSR is an MXLEN-bit read-only register
containing the integer ID of the hardware thread running the code.
This register must be readable in any implementation. Hart IDs might
not necessarily be numbered contiguously in a multiprocessor system,
but at least one hart must have a hart ID of zero. Hart IDs must be
unique within the execution environment.</p>
<figure>
<img src="machine_04.svg" alt="Hart ID register (mhartid)." id="mhartidreg" /><figcaption>Hart ID register (<span>mhartid</span>).<span label="mhartidreg"></span></figcaption>
</figure>
<div class=commentary>
<p>In certain cases, we must ensure exactly one hart runs some code
(e.g., at reset), and so require one hart to have a known hart ID of
zero.</p>
<p>For efficiency, system implementers should aim to reduce the magnitude
of the largest hart ID used in a system.</p>
</div>
<h3 id="machine-status-registers-mstatus-and-mstatush"><span class="header-section-number">3.1.6</span> Machine Status Registers (<span>mstatus</span> and <span>mstatush</span>)</h3>
<p>The <span>mstatus</span> register is an MXLEN-bit read/write register
formatted as shown in Figure <a href="machine.html#mstatusreg-rv32" data-reference-type="ref" data-reference="mstatusreg-rv32">1.6</a> for RV32 and
Figure <a href="machine.html#mstatusreg" data-reference-type="ref" data-reference="mstatusreg">1.7</a> for RV64. The <span>mstatus</span>
register keeps track of and controls the hart’s current operating
state. A restricted view of <span>mstatus</span> appears as the
<span>sstatus</span> register in the S-level ISA.</p>
<figure>
<img src="machine_05.svg" alt="Machine-mode status register (mstatus) for RV32." id="mstatusreg-rv32" /><figcaption>Machine-mode status register (<span>mstatus</span>) for RV32.<span label="mstatusreg-rv32"></span></figcaption>
</figure>
<figure>
<img src="machine_06.svg" alt="Machine-mode status register (mstatus) for RV64." id="mstatusreg" /><figcaption>Machine-mode status register (<span>mstatus</span>) for RV64.<span label="mstatusreg"></span></figcaption>
</figure>
<p>For RV32 only, <span>mstatush</span> is a 32-bit read/write register formatted
as shown in Figure <a href="machine.html#mstatushreg" data-reference-type="ref" data-reference="mstatushreg">1.8</a>.
Bits 30:4 of <span>mstatush</span> generally contain the same fields found in
bits 62:36 of <span>mstatus</span> for RV64.
Fields SD, SXL, and UXL do not exist in <span>mstatush</span>.</p>
<figure>
<img src="machine_07.svg" alt="Additional machine-mode status register (mstatush) for RV32." id="mstatushreg" /><figcaption>Additional machine-mode status register (<span>mstatush</span>) for RV32.<span label="mstatushreg"></span></figcaption>
</figure>
<h4 id="privstack"><span class="header-section-number">3.1.6.1</span> Privilege and Global Interrupt-Enable Stack in <span>mstatus</span> register</h4>
<p>Global interrupt-enable bits, MIE and SIE, are provided for M-mode and
S-mode respectively.
These bits are primarily used to guarantee atomicity
with respect to interrupt handlers in the current privilege mode.</p>
<div class=commentary>
<p>The global <span><em>x</em></span>IE bits are located in the low-order bits of <span>mstatus</span>,
allowing them to be atomically set or cleared with a single CSR
instruction.</p>
</div>
<p>When a hart is executing in privilege mode <span><em>x</em></span>, interrupts are
globally enabled when <span><em>x</em></span>IE=1 and globally disabled when <span>
<em>x</em></span>IE=0. Interrupts for lower-privilege modes, <span><em>w</em></span><span class="math inline">&lt;</span><span><em>x</em></span>,
are always globally disabled regardless of the setting of any global
<span><em>w</em></span>IE bit for the lower-privilege mode.
Interrupts for
higher-privilege modes, <span><em>y</em></span><span class="math inline">&gt;</span><span><em>x</em></span>, are always globally enabled
regardless of the setting of the global <span><em>y</em></span>IE bit for the
higher-privilege mode.
Higher-privilege-level code can use separate
per-interrupt enable bits to disable selected higher-privilege-mode
interrupts before ceding control to a lower-privilege mode.</p>
<div class=commentary>
<p>A higher-privilege mode <span><em>y</em></span> could disable all of its interrupts
before ceding control to a lower-privilege mode but this would be
unusual as it would leave only a synchronous trap, non-maskable
interrupt, or reset as means to regain control of the hart.</p>
</div>
<p>To support nested traps, each privilege mode <span><em>x</em></span> that can respond to
interrupts has a two-level
stack of interrupt-enable bits and privilege modes. <span><em>x</em></span>PIE
holds the value of the interrupt-enable bit active prior to the trap,
and <span><em>x</em></span>PP holds the previous privilege mode. The <span><em>x</em></span>PP
fields can only hold privilege modes up to <span><em>x</em></span>, so MPP is
two bits wide and SPP is one bit wide. When
a trap is taken from privilege mode <span><em>y</em></span> into privilege mode <span>
<em>x</em></span>, <span><em>x</em></span>PIE is set to the value of <span><em>x</em></span>IE; <span><em>x</em></span>IE is set to
0; and <span><em>x</em></span>PP is set to <span><em>y</em></span>.</p>
<div class=commentary>
<p>For lower privilege modes, any trap (synchronous or asynchronous) is
usually taken at a higher privilege mode with interrupts disabled upon entry.
The higher-level trap handler will either service the trap and return
using the stacked information, or, if not returning immediately to the
interrupted context, will save the privilege stack before re-enabling
interrupts, so only one entry per stack is required.</p>
</div>
<p>An MRET or SRET instruction is used to return from
a trap in M-mode or S-mode respectively. When
executing an <span><em>x</em></span>RET instruction, supposing <span><em>x</em></span>PP holds the
value <span><em>y</em></span>, <span><em>x</em></span>IE is set to <span><em>x</em></span>PIE; the privilege mode
is changed to <span><em>y</em></span>; <span><em>x</em></span>PIE is set to 1; and <span><em>x</em></span>PP is
set to the least-privileged supported mode (U if U-mode is implemented, else M).
If <span><em>x</em></span>PP<span class="math inline">≠</span>M, <span><em>x</em></span>RET also sets MPRV=0.</p>
<div class=commentary>
<p>Setting <span><em>x</em></span>PP to the least-privileged supported mode on an <span><em>x</em></span>RET
helps identify software bugs in the management of the two-level privilege-mode
stack.</p>
</div>
<p><span><em>x</em></span>PP fields are <strong>WARL</strong> fields that can hold only privilege mode <span><em>x</em></span>
and any implemented privilege mode lower than <span><em>x</em></span>. If privilege mode <span>
<em>x</em></span> is not implemented, then <span><em>x</em></span>PP must be read-only 0.</p>
<div class=commentary>
<p>M-mode software can determine whether a privilege mode is implemented
by writing that mode to MPP then reading it back.</p>
<p>If the machine provides only U and M modes, then only a single
hardware storage bit is required to represent either 00 or 11 in MPP.</p>
</div>
<h4 id="xlen-control"><span class="header-section-number">3.1.6.2</span> Base ISA Control in <span>mstatus</span> Register</h4>
<p>For RV64 systems, the SXL and UXL fields are <strong>WARL</strong> fields
that control the value of XLEN for S-mode and U-mode,
respectively. The encoding of these fields is the same as the MXL
field of <span>misa</span>, shown in Table <a href="machine.html#misabase" data-reference-type="ref" data-reference="misabase">[misabase]</a>. The effective
XLEN in S-mode and U-mode are termed <span><em>SXLEN</em></span> and <span><em>UXLEN</em></span>,
respectively.</p>
<p>For RV32 systems, the SXL and UXL fields do not exist, and
SXLEN=32 and UXLEN=32.</p>
<p>For RV64 systems, if S-mode is not supported, then SXL is read-only
zero. Otherwise, it is a <strong>WARL</strong> field that encodes the current value of
SXLEN. In particular, an implementation may make SXL be a read-only
field whose value always ensures that SXLEN=MXLEN.</p>
<p>For RV64 systems, if U-mode is not supported, then UXL is read-only
zero. Otherwise, it is a <strong>WARL</strong> field that encodes the current value of
UXLEN. In particular, an implementation may make UXL be a read-only
field whose value always ensures that UXLEN=MXLEN or UXLEN=SXLEN.</p>
<p>Whenever XLEN in any mode is set to a value less than the widest
supported XLEN, all operations must ignore source operand register
bits above the configured XLEN, and must sign-extend results to fill
the entire widest supported XLEN in the destination register.
Similarly, <span>pc</span> bits above XLEN are ignored, and when the <span>pc</span>
is written, it is sign-extended to fill the widest supported XLEN.
<div class=commentary>
<p>We require that operations always fill the entire underlying hardware
registers with defined values to avoid implementation-defined
behavior.</p>
<p>To reduce hardware complexity, the architecture imposes no checks that
lower-privilege modes have XLEN settings less than or equal to the
next-higher privilege mode. In practice, such settings would almost
always be a software bug, but machine operation is well-defined even in this
case.</p>
</div>
<p>If MXLEN is changed from 32 to a wider width, each of <span>mstatus</span> fields SXL and
UXL, if not restricted to a single value, gets the value corresponding to the
widest supported width not wider than the new MXLEN.</p>
<h4 id="memory-privilege-in-mstatus-register"><span class="header-section-number">3.1.6.3</span> Memory Privilege in <span>mstatus</span> Register</h4>
<p>The MPRV (Modify PRiVilege) bit modifies the <span><em>effective privilege mode</em></span>,
i.e., the privilege level at which loads
and stores execute. When MPRV=0, loads and stores
behave as normal, using the translation and protection mechanisms of the
current privilege mode.
When MPRV=1, load and store memory addresses are translated and protected, and
endianness is applied, as though the current privilege mode were set to MPP.
Instruction address-translation and protection are unaffected by the setting
of MPRV. MPRV is read-only 0 if U-mode is not supported.</p>
<p>An MRET or SRET instruction that changes the privilege mode to a mode
less privileged than M also sets MPRV=0.</p>
<p>The MXR (Make eXecutable Readable) bit modifies the privilege with which loads
access virtual memory. When MXR=0, only loads from pages marked readable (R=1
in Figure <a href="supervisor.html#sv32pte" data-reference-type="ref" data-reference="sv32pte">[sv32pte]</a>) will succeed. When MXR=1, loads from pages marked
either readable or executable (R=1 or X=1) will succeed. MXR has no effect
when page-based virtual memory is not in effect. MXR is read-only 0 if
S-mode is not supported.</p>
<div class=commentary>
<p>The MPRV and MXR mechanisms were conceived to improve the efficiency of M-mode
routines that emulate missing hardware features, e.g., misaligned loads and
stores. MPRV obviates the need to perform address translation in software.
MXR allows instruction words to be loaded from pages marked execute-only.</p>
<p>The current privilege mode and the privilege mode specified by MPP might have
different XLEN settings. When MPRV=1, load and store memory addresses are
treated as though the current XLEN were set to MPP’s XLEN, following the rules
in Section <a href="machine.html#xlen-control" data-reference-type="ref" data-reference="xlen-control">1.1.6.2</a>.</p>
</div>
<p>The SUM (permit Supervisor User Memory access) bit modifies the privilege with
which S-mode loads and stores access virtual memory.
When SUM=0, S-mode memory accesses to pages that are accessible by U-mode (U=1
in Figure <a href="supervisor.html#sv32pte" data-reference-type="ref" data-reference="sv32pte">[sv32pte]</a>) will fault. When SUM=1, these accesses are
permitted. SUM has no effect when page-based virtual memory is not in effect.
Note that, while SUM is ordinarily ignored when not executing in S-mode, it
<span><em>is</em></span> in effect when MPRV=1 and MPP=S. SUM is read-only 0 if S-mode is
not supported or if <span>satp</span>.MODE is read-only 0.</p>
<p>The MXR and SUM mechanisms only affect the interpretation of permissions
encoded in page-table entries. In particular, they have no impact on whether
access-fault exceptions are raised due to PMAs or PMP.</p>
<h4 id="endianness-control-in-mstatus-and-mstatush-registers"><span class="header-section-number">3.1.6.4</span> Endianness Control in <span>mstatus</span> and <span>mstatush</span> Registers</h4>
<p>The MBE, SBE, and UBE bits in <span>mstatus</span> and <span>mstatush</span> are
<strong>WARL</strong> fields that control the endianness of memory accesses other than
instruction fetches.
Instruction fetches are always little-endian.</p>
<p>MBE controls whether non-instruction-fetch memory accesses made from
M-mode (assuming <span>mstatus</span>.MPRV=0) are little-endian (MBE=0) or
big-endian (MBE=1).</p>
<p>If S-mode is not supported, SBE is read-only 0.
Otherwise, SBE controls whether explicit load and store memory accesses made
from S-mode are little-endian (SBE=0) or big-endian (SBE=1).</p>
<p>If U-mode is not supported, UBE is read-only 0.
Otherwise, UBE controls whether explicit load and store memory accesses made
from U-mode are little-endian (UBE=0) or big-endian (UBE=1).</p>
<p>For <span><em>implicit</em></span> accesses to supervisor-level memory management data
structures, such as page tables, endianness is always controlled by SBE.
Since changing SBE alters the implementation’s interpretation of these data
structures, if any such data structures remain in use across a change to SBE,
M-mode software must follow such a change to SBE by executing an
SFENCE.VMA instruction with <span><em>rs1</em></span>=<span>x0</span> and <span><em>rs2</em></span>=<span>x0</span>.</p>
<div class=commentary>
<p>Only in contrived scenarios will a given memory-management data structure be
interpreted as both little-endian and big-endian.
In practice, SBE will only be changed at runtime on world switches, in which
case neither the old nor new memory-management data structure will be
reinterpreted in a different endianness.
In this case, no additional SFENCE.VMA is necessary, beyond what would
ordinarily be required for a world switch.</p>
</div>
<p>If S-mode is supported, an implementation may make SBE be a read-only
copy of MBE.
If U-mode is supported, an implementation may make UBE be a read-only
copy of either MBE or SBE.</p>
<div class=commentary>
<p>An implementation supports only little-endian memory accesses if fields
MBE, SBE, and UBE are all read-only 0.
An implementation supports only big-endian memory accesses (aside from
instruction fetches) if MBE is read-only 1 and SBE and UBE are each
read-only 1 when S-mode and U-mode are supported.</p>
</div>
<div class=commentary>
<p>Volume I defines a hart’s address space as a circular sequence of
<span class="math inline">2<sup>XLEN</sup></span> bytes at consecutive addresses.
The correspondence between addresses and byte locations is fixed and not
affected by any endianness mode.
Rather, the applicable endianness mode determines the order of mapping
between memory bytes and a multibyte quantity (halfword, word, etc.).</p>
</div>
<div class=commentary>
<p>Standard RISC-V ABIs are expected to be purely little-endian-only or
big-endian-only, with no accommodation for mixing endianness.
Nevertheless, endianness control has been defined so as to permit, for
instance, an OS of one endianness to execute user-mode programs of the
opposite endianness.
Consideration has been given also to the possibility of nonstandard
usages whereby software flips the endianness of memory accesses as
needed.</p>
</div>
<div class=commentary>
<p>RISC-V instructions are uniformly little-endian to decouple instruction
encoding from the current endianness settings, for the benefit of both
hardware and software.
Otherwise, for instance, a RISC-V assembler or disassembler would always
need to know the intended active endianness, despite that the endianness
mode might change dynamically during execution.
In contrast, by giving instructions a fixed endianness, it is sometimes
possible for carefully written software to be endianness-agnostic even in
binary form, much like position-independent code.</p>
<p>The choice to have instructions be only little-endian does have
consequences, however, for RISC-V software that encodes or decodes
machine instructions.
In big-endian mode, such software must account for the fact that explicit
loads and stores have endianness opposite that of instructions, for
example by swapping byte order after loads and before stores.</p>
</div>
<h4 id="virt-control"><span class="header-section-number">3.1.6.5</span> Virtualization Support in <span>mstatus</span> Register</h4>
<p>The TVM (Trap Virtual Memory) bit is a <strong>WARL</strong> field that supports intercepting
supervisor virtual-memory management operations. When TVM=1,
attempts to read or write the <span>satp</span> CSR or execute an SFENCE.VMA or
SINVAL.VMA instruction while executing in S-mode will raise an illegal instruction
exception. When TVM=0, these operations are permitted in S-mode.
TVM is read-only 0 when S-mode is not supported.</p>
<div class=commentary>
<p>The TVM mechanism improves virtualization efficiency by permitting guest
operating systems to execute in S-mode, rather than classically virtualizing
them in U-mode. This approach obviates the need to trap accesses to most
S-mode CSRs.</p>
<p>Trapping <span>satp</span> accesses and the SFENCE.VMA and SINVAL.VMA instructions
provides the hooks necessary to lazily populate shadow page tables.</p>
</div>
<p>The TW (Timeout Wait) bit is a <strong>WARL</strong> field that supports intercepting the WFI
instruction (see Section <a href="machine.html#wfi" data-reference-type="ref" data-reference="wfi">1.3.3</a>).
When TW=0, the WFI instruction may execute in lower
privilege modes when not prevented for some other reason. When TW=1,
then if WFI is executed in any less-privileged mode, and it does not complete
within an implementation-specific, bounded time limit, the WFI instruction
causes an illegal instruction exception. The time limit may always be 0, in which
case WFI always causes an illegal instruction exception in less-privileged modes
when TW=1. TW is read-only 0 when there are no modes less privileged than
M.</p>
<div class=commentary>
<p>Trapping the WFI
instruction can trigger a world switch to another guest OS, rather than
wastefully idling in the current guest.</p>
</div>
<p>When S-mode is implemented, then executing WFI in U-mode causes an illegal
instruction exception, unless it completes within an implementation-specific,
bounded time limit. A future revision of this specification might add
a feature that allows S-mode to selectively permit WFI in U-mode. Such
a feature would only be active when TW=0.</p>
<p>The TSR (Trap SRET) bit is a <strong>WARL</strong> field that
supports intercepting the supervisor exception return
instruction, SRET. When TSR=1, attempts to execute SRET while executing in
S-mode will raise an illegal instruction exception. When TSR=0, this
operation is permitted in S-mode. TSR is read-only 0 when S-mode is not
supported.</p>
<div class=commentary>
<p>Trapping SRET is necessary to emulate the hypervisor extension
(see Chapter <a href="hypervisor.html#hypervisor" data-reference-type="ref" data-reference="hypervisor">[hypervisor]</a>) on implementations that do not provide it.</p>
</div>
<h4 id="extension-context-status-in-mstatus-register"><span class="header-section-number">3.1.6.6</span> Extension Context Status in <span>mstatus</span> Register</h4>
<p>Supporting substantial extensions is one of the primary goals of
RISC-V, and hence we define a standard interface to allow unchanged
privileged-mode code, particularly a supervisor-level OS, to support
arbitrary user-mode state extensions.</p>
<div class=commentary>
<p>To date, the V extension is the only standard extension that defines
additional state beyond the floating-point CSR and data registers.</p>
</div>
<p>The FS[1:0] and VS[1:0] <strong>WARL</strong> fields and the XS[1:0] read-only field are used
to reduce the cost of context save and restore by setting and tracking
the current state of the floating-point unit and any other user-mode
extensions respectively.
The FS field encodes the status of the floating-point unit state, including
the floating-point registers <span>f0</span>–<span>f31</span> and the CSRs
<span>fcsr</span>, <span>frm</span>, and <span>fflags</span>.
The VS field encodes the status of the vector extension state, including
the vector registers <span>v0</span>–<span>v31</span> and the CSRs
<span>vcsr</span>, <span>vxrm</span>, <span>vxsat</span>, <span>vstart</span>, <span>vl</span>, <span>vtype</span>,
and <span>vlenb</span>.
The XS field encodes the
status of additional user-mode extensions and associated state.
These fields can be checked by a context switch routine to quickly
determine whether a state save or restore is required. If a save or
restore is required, additional instructions and CSRs are typically
required to effect and optimize the process.</p>
<div class=commentary>
<p>The design anticipates that most context switches will not need to
save/restore state in either or both of the floating-point unit or
other extensions, so provides a fast check via the SD bit.</p>
</div>
<p>The FS, VS, and XS fields use the same status encoding as shown in
Table <a href="machine.html#fsxsencoding" data-reference-type="ref" data-reference="fsxsencoding">[fsxsencoding]</a>, with the four possible status values being
Off, Initial, Clean, and Dirty.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: right;">Status</th>
<th style="text-align: left;">FS and VS Meaning</th>
<th style="text-align: left;">XS Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">0</td>
<td style="text-align: left;">Off</td>
<td style="text-align: left;">All off</td>
</tr>
<tr class="even">
<td style="text-align: right;">1</td>
<td style="text-align: left;">Initial</td>
<td style="text-align: left;">None dirty or clean, some on</td>
</tr>
<tr class="odd">
<td style="text-align: right;">2</td>
<td style="text-align: left;">Clean</td>
<td style="text-align: left;">None dirty, some clean</td>
</tr>
<tr class="even">
<td style="text-align: right;">3</td>
<td style="text-align: left;">Dirty</td>
<td style="text-align: left;">Some dirty</td>
</tr>
</tbody>
</table>
<p>If the F extension is implemented, the FS field shall not be
read-only zero.</p>
<p>If neither the F extension nor S-mode is implemented, then FS is
read-only zero.
If S-mode is implemented but the F extension is not, FS may optionally
be read-only zero.</p>
<div class=commentary>
<p>Implementations with S-mode but without the F extension are
permitted, but not required, to make the FS field be read-only zero.
Some such implementations will choose <span><em>not</em></span> to have the FS
field be read-only zero, so as to enable emulation of the F extension for
both S-mode and U-mode via invisible traps into M-mode.</p>
</div>
<p>If the <span>v</span> registers are implemented, the VS field shall not be
read-only zero.</p>
<p>If neither the <span>v</span> registers nor S-mode is implemented, then VS
is read-only zero.
If S-mode is implemented but the <span>v</span> registers are not, VS may
optionally be read-only zero.</p>
<p>In systems without additional user extensions requiring new state, the
XS field is read-only zero. Every additional extension with state
provides a CSR field that encodes the equivalent of the XS states.
The XS field represents a summary of all
extensions’ status as shown in Table <a href="machine.html#fsxsencoding" data-reference-type="ref" data-reference="fsxsencoding">[fsxsencoding]</a>.</p>
<div class=commentary>
<p>The XS field effectively reports the maximum status value across all
user-extension status fields, though individual extensions can use a
different encoding than XS.</p>
</div>
<p>The SD bit is a read-only bit that summarizes whether either the FS,
VS, or XS fields signal the presence of some dirty state that will
require saving extended user context to memory. If FS, XS, and VS are all
read-only zero, then SD is also always zero.</p>
<p>When an extension’s status is set to Off, any instruction that
attempts to read or write the corresponding state will cause an illegal instruction
exception. When the status is Initial, the corresponding state should
have an initial constant value. When the status is Clean, the
corresponding state is potentially different from the initial value,
but matches the last value stored on a context swap. When the status
is Dirty, the corresponding state has potentially been modified since
the last context save.</p>
<p>During a context save, the responsible privileged code need only write
out the corresponding state if its status is Dirty, and can then reset
the extension’s status to Clean. During a context restore, the
context need only be loaded from memory if the status is Clean (it
should never be Dirty at restore). If the status is Initial, the
context must be set to an initial constant value on context restore to
avoid a security hole, but this can be done without accessing memory.
For example, the floating-point registers can all be initialized to
the immediate value 0.</p>
<p>The FS and XS fields are read by the privileged code before saving the
context. The FS field is set directly by privileged code when
resuming a user context, while the XS field is set indirectly by
writing to the status register of the individual extensions. The
status fields will also be updated during execution of instructions,
regardless of privilege mode.</p>
<p>Extensions to the user-mode ISA often include additional user-mode
state, and this state can be considerably larger than the base integer
registers. The extensions might only be used for some applications,
or might only be needed for short phases within a single application.
To improve performance, the user-mode extension can define additional
instructions to allow user-mode software to return the unit to an
initial state or even to turn off the unit.</p>
<p>For example, a coprocessor might require to be configured before use
and can be “unconfigured” after use. The unconfigured state would
be represented as the Initial state for context save. If the same
application remains running between the unconfigure and the next
configure (which would set status to Dirty), there is no need to
actually reinitialize the state at the unconfigure instruction, as all
state is local to the user process, i.e., the Initial state may only
cause the coprocessor state to be initialized to a constant value at
context restore, not at every unconfigure.</p>
<p>Executing a user-mode instruction to disable a unit and place it into
the Off state will cause an illegal instruction exception to be raised
if any subsequent instruction tries to use the unit before it is
turned back on. A user-mode instruction to turn a unit on must also
ensure the unit’s state is properly initialized, as the unit might
have been used by another context meantime.</p>
<p>Changing the setting of FS has no effect on the contents of the floating-point
register state. In particular, setting FS=Off does not destroy the state, nor
does setting FS=Initial clear the contents.
Similarly, the setting of VS has no effect on the contents of the vector register
state.
Other extensions, however, might not preserve state when set to Off.</p>
<p>Implementations may choose to track the dirtiness of the floating-point
register state imprecisely by reporting the state to be dirty even when
it has not been modified. On some implementations, some instructions that
do not mutate the floating-point state may cause the state to transition from
Initial or Clean to Dirty. On other implementations, dirtiness might not be
tracked at all, in which case the valid FS states are Off and Dirty, and an
attempt to set FS to Initial or Clean causes it to be set to Dirty.
<div class=commentary>
<p>This definition of FS does not disallow setting FS to Dirty as a result of
errant speculation. Some platforms may choose to disallow speculatively
writing FS to close a potential side channel.</p>
</div>
<p>If an instruction explicitly or implicitly writes a floating-point register or
the <span>fcsr</span> but does not alter its contents, and FS=Initial or FS=Clean, it
is implementation-defined whether FS transitions to Dirty.</p>
<p>Implementations may choose to track the dirtiness of the vector register state in an
analogous imprecise fashion, including possibly setting VS to Dirty when
software attempts to set VS=Initial or VS=Clean.
When VS=Initial or VS=Clean, it is implementation-defined whether an
instruction that writes a vector register or vector CSR but does not alter its
contents causes VS to transition to Dirty.</p>
<p>Table <a href="machine.html#fsxsstates" data-reference-type="ref" data-reference="fsxsstates">1.9</a> shows all the possible state transitions for
the FS, VS, or XS status bits. Note that the standard floating-point
and vector extensions do not support user-mode unconfigure or disable/enable
instructions.</p>
<figure>
<img src="machine_08.svg" alt="FS, VS, and XS state transitions." id="fsxsstates" /><figcaption>FS, VS, and XS state transitions.<span label="fsxsstates"></span></figcaption>
</figure>
<p>Standard privileged instructions to initialize, save, and restore
extension state are provided to insulate privileged code from details
of the added extension state by treating the state as an opaque
object.</p>
<div class=commentary>
<p>Many coprocessor extensions are only used in limited contexts that
allows software to safely unconfigure or even disable units when done.
This reduces the context-switch overhead of large stateful
coprocessors.</p>
<p>We separate out floating-point state from other extension state, as
when a floating-point unit is present the floating-point registers are
part of the standard calling convention, and so user-mode software
cannot know when it is safe to disable the floating-point unit.</p>
</div>
<p>The XS field provides a summary of all added extension state, but
additional microarchitectural bits might be maintained in the
extension to further reduce context save and restore overhead.</p>
<p>The SD bit is read-only and is set when either the FS, VS, or XS bits
encode a Dirty state (i.e., SD=((FS==11) OR (XS==11) OR (VS==11))). This allows
privileged code to quickly determine when no additional context save is
required beyond the integer register set and PC.</p>
<p>The floating-point unit state is always initialized, saved, and
restored using standard instructions (F, D, and/or Q), and privileged
code must be aware of FLEN to determine the appropriate space to
reserve for each <span>f</span> register.</p>
<p>Machine and Supervisor modes share a single copy of the FS, VS, and XS bits.
Supervisor-level software
normally uses the FS, VS, and XS bits directly to record the status with
respect to the supervisor-level saved context.
Machine-level software must be more conservative in saving and restoring the
extension state in their corresponding version of the context.</p>
<div class=commentary>
<p>In any reasonable use case, the number of context switches between
user and supervisor level should far outweigh the number of context
switches to other privilege levels. Note that coprocessors should not
require their context to be saved and restored to service asynchronous
interrupts, unless the interrupt results in a user-level context swap.</p>
</div>
<h3 id="machine-trap-vector-base-address-register-mtvec"><span class="header-section-number">3.1.7</span> Machine Trap-Vector Base-Address Register (<span>mtvec</span>)</h3>
<p>The <span>mtvec</span> register is an MXLEN-bit <strong>WARL</strong> read/write register that holds
trap vector configuration, consisting of a vector base address (BASE) and a
vector mode (MODE).</p>
<figure>
<img src="machine_09.svg" alt="Machine trap-vector base-address register (mtvec)." id="mtvecreg" /><figcaption>Machine trap-vector base-address register (<span>mtvec</span>).<span label="mtvecreg"></span></figcaption>
</figure>
<p>The <span>mtvec</span> register must always be implemented, but can contain
a read-only value. If <span>mtvec</span> is writable, the set of values
the register may hold can vary by implementation. The value in the BASE field
must always be aligned on a 4-byte boundary, and the MODE setting may impose
additional alignment constraints on the value in the BASE field.</p>
<div class=commentary>
<p>We allow for considerable flexibility in implementation of the trap
vector base address. On the one hand, we do not wish to burden low-end
implementations with a large number of state bits, but on the other
hand, we wish to allow flexibility for larger systems.</p>
</div>
<table>
<thead>
<tr class="header">
<th style="text-align: right;">Value</th>
<th style="text-align: center;">Name</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">0</td>
<td style="text-align: center;">Direct</td>
<td style="text-align: left;">All exceptions set <span>pc</span> to BASE.</td>
</tr>
<tr class="even">
<td style="text-align: right;">1</td>
<td style="text-align: center;">Vectored</td>
<td style="text-align: left;">Asynchronous interrupts set <span>pc</span> to BASE+4<span class="math inline">×</span>cause.</td>
</tr>
<tr class="odd">
<td style="text-align: right;"><span class="math inline">≥</span>2</td>
<td style="text-align: center;">—</td>
<td style="text-align: left;"><span><em>Reserved</em></span></td>
</tr>
</tbody>
</table>
<p>The encoding of the MODE field is shown in Table <a href="machine.html#mtvec-mode" data-reference-type="ref" data-reference="mtvec-mode">[mtvec-mode]</a>. When
MODE=Direct, all traps into machine mode cause the <span>pc</span> to be set to the
address in the BASE field. When MODE=Vectored, all synchronous exceptions
into machine mode cause the <span>pc</span> to be set to the address in the BASE
field, whereas interrupts cause the <span>pc</span> to be set to the address in
the BASE field plus four times the interrupt cause number. For example,
a machine-mode timer interrupt (see Table <a href="machine.html#mcauses" data-reference-type="ref" data-reference="mcauses">[mcauses]</a>) causes the <span>pc</span>
to be set to BASE+<span>0x1c</span>.</p>
<div class=commentary>
<p>When vectored interrupts are enabled, interrupt cause 0, which corresponds to
user-mode software interrupts, are vectored to the same location as
synchronous exceptions. This ambiguity does not arise in practice, since
user-mode software interrupts are either disabled or delegated to user mode.</p>
</div>
<p>An implementation may have different alignment constraints for
different modes. In particular, MODE=Vectored may have stricter
alignment constraints than MODE=Direct.</p>
<div class=commentary>
<p>Allowing coarser alignments in Vectored mode enables vectoring to be
implemented without a hardware adder circuit.</p>
</div>
<div class=commentary>
<p>Reset and NMI vector locations are given in a platform specification.</p>
</div>
<h3 id="machine-trap-delegation-registers-medeleg-and-mideleg"><span class="header-section-number">3.1.8</span> Machine Trap Delegation Registers (<span>medeleg</span> and <span>mideleg</span>)</h3>
<p>By default, all traps at any privilege level are handled in machine
mode, though a machine-mode handler can redirect traps back to the
appropriate level with the MRET instruction (Section <a href="machine.html#otherpriv" data-reference-type="ref" data-reference="otherpriv">1.3.2</a>).
To increase performance, implementations can provide individual
read/write bits within <span>medeleg</span> and <span>mideleg</span> to indicate
that certain exceptions and interrupts should be processed directly by
a lower privilege level. The machine exception delegation register
(<span>medeleg</span>) and machine interrupt delegation register (<span>
mideleg</span>) are MXLEN-bit read/write registers.</p>
<p>In systems with S-mode, the <span>medeleg</span> and <span>mideleg</span> registers
must exist, and setting a bit in
<span>medeleg</span> or <span>mideleg</span> will delegate the corresponding trap, when
occurring in S-mode or U-mode, to the S-mode trap handler.
In systems without S-mode, the <span>medeleg</span> and <span>mideleg</span> registers
should not exist.</p>
<div class=commentary>
<p>In versions 1.9.1 and earlier , these registers existed but were
hardwired to zero in M-mode only, or M/U without N systems. There
is no reason to require they return zero in those cases, as the <span>
misa</span> register indicates whether they exist.</p>
</div>
<p>When a trap is delegated to S-mode, the
<span>scause</span> register is written with the trap cause; the
<span>sepc</span> register is written with the virtual address of
the instruction that took the trap; the
<span>stval</span> register is written with an
exception-specific datum; the SPP field
of <span>mstatus</span> is written with the active privilege mode at the time of
the trap; the SPIE field of <span>mstatus</span> is written with the
value of the SIE field at the time of the trap; and
the SIE field of <span>mstatus</span> is cleared.
The <span>mcause</span>, <span>mepc</span>, and <span>mtval</span> registers and the MPP and
MPIE fields of <span>mstatus</span> are not written.</p>
<p>An
implementation can choose to subset the delegatable traps, with the
supported delegatable bits found by writing one to every bit location,
then reading back the value in <span>medeleg</span> or <span>mideleg</span> to see
which bit positions hold a one.</p>
<p>An implementation shall not have any bits of <span>medeleg</span> be read-only one, i.e.,
any synchronous trap that can be delegated must support not being delegated.
Similarly, an implementation shall not fix as read-only one any bits of
<span>mideleg</span> corresponding to machine-level interrupts (but may do so
for lower-level interrupts).</p>
<div class=commentary>
<p>Version 1.11 and earlier prohibited having any bits of <span>mideleg</span>
be read-only one.
Platform standards may always add such restrictions.</p>
</div>
<p>Traps never transition from a more-privileged mode to a less-privileged mode.
For example, if M-mode has delegated illegal instruction exceptions to S-mode, and
M-mode software later executes an illegal instruction, the trap is taken in
M-mode, rather than being delegated to S-mode. By contrast, traps may be
taken horizontally. Using the same example, if M-mode has delegated illegal
instruction exceptions to S-mode, and S-mode software later executes an illegal
instruction, the trap is taken in S-mode.</p>
<p>Delegated interrupts result in the interrupt being masked at the delegator
privilege level. For example, if the supervisor timer interrupt (STI) is
delegated to S-mode by setting <span>mideleg</span>[5], STIs will not be taken when
executing in M-mode. By contrast, if <span>mideleg</span>[5] is clear, STIs can
be taken in any mode and regardless of current mode will transfer control to
M-mode.</p>
<figure>
<img src="machine_10.svg" alt="Machine Exception Delegation Register medeleg." id="medelegreg" /><figcaption>Machine Exception Delegation Register <span>medeleg</span>.<span label="medelegreg"></span></figcaption>
</figure>
<p><span>medeleg</span> has a bit position allocated for every synchronous exception
shown in Table <a href="machine.html#mcauses" data-reference-type="ref" data-reference="mcauses">[mcauses]</a>, with the index of the bit position equal to the
value returned in the <span>mcause</span> register (i.e., setting bit 8 allows
user-mode environment calls to be delegated to a lower-privilege trap
handler).</p>
<figure>
<img src="machine_11.svg" alt="Machine Interrupt Delegation Register mideleg." id="midelegreg" /><figcaption>Machine Interrupt Delegation Register <span>mideleg</span>.<span label="midelegreg"></span></figcaption>
</figure>
<p><span>mideleg</span> holds trap delegation bits for individual interrupts, with the
layout of bits matching those in the <span>mip</span> register (i.e., STIP interrupt
delegation control is located in bit 5).</p>
<p>For exceptions that cannot occur in less privileged modes, the corresponding
<span>medeleg</span> bits should be read-only zero. In particular,
<span>medeleg</span>[11] is read-only zero.</p>
<h3 id="machine-interrupt-registers-mip-and-mie"><span class="header-section-number">3.1.9</span> Machine Interrupt Registers (<span>mip</span> and <span>mie</span>)</h3>
<p>The <span>mip</span> register is an MXLEN-bit read/write register containing
information on pending interrupts, while <span>mie</span> is the
corresponding MXLEN-bit read/write register containing interrupt enable
bits.
Interrupt cause number <em>i</em> (as reported in CSR <span>mcause</span>,
Section <a href="machine.html#sec:mcause" data-reference-type="ref" data-reference="sec:mcause">1.1.15</a>) corresponds with bit <em>i</em> in both
<span>mip</span> and <span>mie</span>.
Bits 15:0 are allocated to standard interrupt causes only, while bits 16
and above are designated for platform or custom use.</p>
<figure>
<img src="machine_12.svg" alt="Machine Interrupt-Pending Register (mip)." id="mipreg" /><figcaption>Machine Interrupt-Pending Register (<span>mip</span>).<span label="mipreg"></span></figcaption>
</figure>
<figure>
<img src="machine_13.svg" alt="Machine Interrupt-Enable Register (mie)." id="miereg" /><figcaption>Machine Interrupt-Enable Register (<span>mie</span>).<span label="miereg"></span></figcaption>
</figure>
<p>An interrupt <em>i</em> will trap to M-mode (causing the privilege mode
to change to M-mode) if all of the following are true:
(a) either the current privilege mode is M and the MIE bit in the
<span>mstatus</span> register is set, or the current privilege mode has less
privilege than M-mode;
(b) bit <em>i</em> is set in both <span>mip</span> and <span>mie</span>; and
(c) if register <span>mideleg</span> exists, bit <em>i</em> is not set in
<span>mideleg</span>.</p>
<p>These conditions for an interrupt trap to occur must be evaluated in a bounded
amount of time from when an interrupt becomes, or ceases to be,
pending in <span>mip</span>, and must
also be evaluated immediately following the execution of an <span><em>x</em></span>RET
instruction or an explicit write to a CSR on which these interrupt trap
conditions expressly depend (including <span>mip</span>, <span>mie</span>, <span>mstatus</span>,
and <span>mideleg</span>).</p>
<p>Interrupts to M-mode take priority over any interrupts to lower privilege
modes.</p>
<p>Each individual bit in register <span>mip</span> may be writable or may be
read-only.
When bit <em>i</em> in <span>mip</span> is writable, a pending interrupt
<em>i</em> can be cleared by writing 0 to this bit.
If interrupt <em>i</em> can become pending but bit <em>i</em> in
<span>mip</span> is read-only, the implementation must provide some other
mechanism for clearing the pending interrupt.</p>
<p>A bit in <span>mie</span> must be writable if the corresponding interrupt can
ever become pending.
Bits of <span>mie</span> that are not writable must be read-only zero.</p>
<p>The standard portions (bits 15:0) of registers <span>mip</span> and <span>mie</span>
are formatted as shown in Figures <a href="machine.html#mipreg-standard" data-reference-type="ref" data-reference="mipreg-standard">1.15</a> and
<a href="machine.html#miereg-standard" data-reference-type="ref" data-reference="miereg-standard">1.16</a> respectively.</p>
<figure>
<img src="machine_14.svg" alt="Standard portion (bits 15:0) of mip." id="mipreg-standard" /><figcaption>Standard portion (bits 15:0) of <span>mip</span>.<span label="mipreg-standard"></span></figcaption>
</figure>
<figure>
<img src="machine_15.svg" alt="Standard portion (bits 15:0) of mie." id="miereg-standard" /><figcaption>Standard portion (bits 15:0) of <span>mie</span>.<span label="miereg-standard"></span></figcaption>
</figure>
<div class=commentary>
<p>The machine-level interrupt registers handle a few root interrupt
sources which are assigned a fixed service priority for simplicity,
while separate external interrupt controllers can implement a more
complex prioritization scheme over a much larger set of interrupts
that are then muxed into the machine-level interrupt sources.</p>
</div>
<div class=commentary>
<p>The non-maskable interrupt is not made visible via the <span>mip</span>
register as its presence is implicitly known when executing the NMI
trap handler.</p>
</div>
<p>Bits <span>mip</span>.MEIP and <span>mie</span>.MEIE are the interrupt-pending and
interrupt-enable bits for machine-level external interrupts.
MEIP is read-only in <span>mip</span>, and is set and cleared by a
platform-specific interrupt controller.</p>
<p>Bits <span>mip</span>.MTIP and <span>mie</span>.MTIE are the interrupt-pending and
interrupt-enable bits for machine timer interrupts.
MTIP is read-only in <span>mip</span>, and is cleared by writing to the memory-mapped
machine-mode timer compare register.</p>
<p>Bits <span>mip</span>.MSIP and <span>mie</span>.MSIE are the interrupt-pending and
interrupt-enable bits for machine-level software interrupts.
MSIP is read-only in <span>mip</span>, and is written by accesses
to memory-mapped control registers, which are used by remote harts to
provide machine-level interprocessor interrupts.
A hart can write its
own MSIP bit using the same memory-mapped control register.
If a system has only one hart, or if a platform standard supports the
delivery of machine-level interprocessor interrupts through external
interrupts (MEI) instead, then <span>mip</span>.MSIP and <span>mie</span>.MSIE may
both be read-only zeros.</p>
<p>If supervisor mode is not implemented, bits SEIP, STIP, and SSIP of
<span>mip</span> and SEIE, STIE, and SSIE of <span>mie</span> are read-only zeros.</p>
<p>If supervisor mode is implemented, bits <span>mip</span>.SEIP and <span>mie</span>.SEIE
are the interrupt-pending and interrupt-enable bits for supervisor-level
external interrupts.
SEIP is writable in <span>mip</span>, and
may be written by M-mode software to indicate to S-mode that an
external interrupt is pending. Additionally, the platform-level
interrupt controller may generate supervisor-level external interrupts.
Supervisor-level external interrupts are made pending based on the
logical-OR of the software-writable SEIP bit and the signal from the
external interrupt controller.
When <span>mip</span> is read with a CSR instruction,
the value of the SEIP bit returned in the <span>rd</span> destination
register is the logical-OR of the software-writable bit and the
interrupt signal from the interrupt controller, but the signal from the
interrupt controller is not used to calculate the value written to SEIP.
Only the software-writable SEIP bit participates in the
read-modify-write sequence of a CSRRS or CSRRC instruction.</p>
<div class=commentary>
<p>For example, if we name the software-writable SEIP bit <span>B</span> and the
signal from the external interrupt controller <span>E</span>, then if <span>csrrs
t0, mip, t1</span> is executed, <span>t0[9]</span> is written with <span>B || E</span> , then
<span>B</span> is written with <span>B || t1[9]</span> .
If <span>csrrw t0, mip, t1</span> is executed, then <span>t0[9]</span> is written with
<span>B || E</span> , and <span>B</span> is simply written with <span>t1[9]</span>.
In neither case does <span>B</span> depend upon <span>E</span>.</p>
<p>The SEIP field behavior is designed to allow a higher privilege
layer to mimic external interrupts cleanly, without losing any real
external interrupts. The behavior of the CSR instructions is
slightly modified from regular CSR accesses as a result.</p>
</div>
<p>If supervisor mode is implemented, bits <span>mip</span>.STIP and <span>mie</span>.STIE
are the interrupt-pending and interrupt-enable bits for supervisor-level
timer interrupts.
STIP is writable in <span>mip</span>, and may be
written by M-mode software to deliver timer interrupts to S-mode.</p>
<p>If supervisor mode is implemented, bits <span>mip</span>.SSIP and <span>mie</span>.SSIE
are the interrupt-pending and interrupt-enable bits for supervisor-level
software interrupts.
SSIP is writable in <span>mip</span> and may also be set to 1 by a platform-specific
interrupt controller.</p>
<p>Multiple simultaneous
interrupts destined for M-mode are handled in the following
decreasing priority order: MEI, MSI, MTI, SEI, SSI, STI.</p>
<div class=commentary>
<p>The machine-level interrupt fixed-priority ordering rules were developed
with the following rationale.</p>
<p>Interrupts for higher privilege modes must be serviced before
interrupts for lower privilege modes to support preemption.</p>
<p>The platform-specific machine-level interrupt sources in bits 16 and above
have platform-specific priority, but are typically chosen to have the
highest service priority to support very fast local vectored interrupts.</p>
<p>External interrupts are handled before internal (timer/software)
interrupts as external interrupts are usually generated by devices
that might require low interrupt service times.</p>
<p>Software interrupts are handled before internal timer interrupts,
because internal timer interrupts are usually intended for time
slicing, where time precision is less important, whereas software
interrupts are used for inter-processor messaging. Software
interrupts can be avoided when high-precision timing is required, or
high-precision timer interrupts can be routed via a different
interrupt path.
Software interrupts are located in the lowest four bits of <span>mip</span>
as these are often written by software, and this position allows the
use of a single CSR instruction with a five-bit immediate.</p>
</div>
<p>Restricted views of the <span>mip</span> and <span>mie</span> registers appear as
the <span>sip</span> and <span>sie</span> registers for supervisor level.
If an interrupt is delegated to
S-mode by setting a bit in the <span>mideleg</span> register,
it becomes visible in the <span>sip</span> register and is maskable
using the <span>sie</span> register. Otherwise, the corresponding
bits in <span>sip</span> and <span>sie</span> are read-only
zero.</p>
<h3 id="hardware-performance-monitor"><span class="header-section-number">3.1.10</span> Hardware Performance Monitor</h3>
<p>M-mode includes a basic hardware performance-monitoring facility. The
<span>mcycle</span> CSR counts the number of clock cycles executed by the
processor core on which the hart is running.
The <span>minstret</span> CSR counts the number of instructions the hart has
retired. The <span>mcycle</span> and <span>minstret</span> registers have 64-bit
precision on all RV32 and RV64 systems.</p>
<p>The counter registers have an arbitrary value after the hart is reset, and
can be written with a given value. Any CSR write takes effect after
the writing instruction has otherwise completed.
The <span>mcycle</span> CSR may be shared between harts on the same core, in which
case writes to <span>mcycle</span> will be visible to those harts.
The platform should provide a mechanism to indicate which harts share an <span>
mcycle</span> CSR.</p>
<p>The hardware performance monitor includes 29 additional 64-bit event counters, <span>
mhpmcounter3</span>–<span>mhpmcounter31</span>. The event selector CSRs, <span>
mhpmevent3</span>–<span>mhpmevent31</span>, are MXLEN-bit <strong>WARL</strong> registers that control which event
causes the corresponding counter to increment. The meaning of these events is
defined by the platform, but event 0 is defined to mean “no event.”
All counters should be implemented, but a legal implementation is to make
both the counter and its corresponding event selector be read-only 0.</p>
<figure>
<img src="machine_16.svg" alt="Hardware performance monitor counters." /><figcaption>Hardware performance monitor counters.</figcaption>
</figure>
<p>The <span>mhpmcounter</span>s are <strong>WARL</strong> registers that support up to 64 bits of
precision on RV32 and RV64.</p>
<div class=commentary>
<p>A future revision of this specification will define a mechanism to generate an
interrupt when a hardware performance monitor counter overflows.</p>
</div>
<p>When MXLEN=32, reads of the <span>mcycle</span>, <span>minstret</span>, and <span>
mhpmcounter<span><em>n</em></span></span> CSRs return bits 31–0 of the corresponding counter, and
writes change only bits 31–0; reads of the <span>mcycleh</span>, <span>minstreth</span>,
and <span>mhpmcounter<span><em>n</em></span>h</span> CSRs return bits 63–32 of the corresponding
counter, and writes change only bits 63–32.</p>
<figure>
<img src="machine_17.svg" alt="Upper 32 bits of hardware performance monitor counters, RV32 only." /><figcaption>Upper 32 bits of hardware performance monitor counters, RV32 only.</figcaption>
</figure>
<h3 id="sec:mcounteren"><span class="header-section-number">3.1.11</span> Machine Counter-Enable Register (<span>mcounteren</span>)</h3>
<p>The counter-enable register <span>mcounteren</span> is a 32-bit register that
controls the availability of the hardware performance-monitoring counters to
the next-lowest privileged mode.</p>
<figure>
<img src="machine_18.svg" alt="Counter-enable register (mcounteren)." id="mcounteren" /><figcaption>Counter-enable register (<span>mcounteren</span>).<span label="mcounteren"></span></figcaption>
</figure>
<p>The settings in this register only control accessibility. The act
of reading or writing this register does not affect the underlying
counters, which continue to increment even when not accessible.</p>
<p>When the CY, TM, IR, or HPM<span><em>n</em></span> bit in the <span>mcounteren</span>
register is clear, attempts to read the <span>cycle</span>, <span>time</span>, <span>
instret</span>, or <span>hpmcounter<span><em>n</em></span></span> register while executing in
S-mode or U-mode will cause an illegal instruction exception. When
one of these bits is set, access to the corresponding register is
permitted in the next implemented privilege mode (S-mode if
implemented, otherwise U-mode).</p>
<div class=commentary>
<p>The counter-enable bits support two common use cases with minimal hardware.
For systems that do not need high-performance timers and counters,
machine-mode software can trap accesses and implement all features in
software. For systems that need high-performance timers and counters
but are not concerned with obfuscating the underlying hardware
counters, the counters can be directly exposed to lower privilege modes.</p>
</div>
<p>The <span>cycle</span>, <span>instret</span>, and <span>hpmcounter<span><em>n</em></span></span> CSRs are
read-only shadows of <span>mcycle</span>, <span>minstret</span>, and <span>mhpmcounter<span>
<em>n</em></span></span>, respectively. The <span>time</span> CSR is a read-only shadow of the
memory-mapped <span>mtime</span> register. Analogously, on RV32I the <span>cycleh</span>,
<span>instreth</span> and <span>hpmcounter<span><em>n</em></span>h</span> CSRs are read-only shadows of
<span>mcycleh</span>, <span>minstreth</span> and <span>mhpmcounter<span><em>n</em></span>h</span>, respectively.
On RV32I the <span>timeh</span> CSR is a read-only shadow of the upper 32 bits of
the memory-mapped <span>mtime</span> register, while <span>time</span> shadows only the
lower 32 bits of <span>mtime</span>.
<div class=commentary>
<p>Implementations can convert reads of the <span>time</span> and <span>timeh</span> CSRs
into loads to the memory-mapped <span>mtime</span> register, or emulate this
functionality in M-mode software.</p>
</div>
<p>In systems with U-mode, the <span>mcounteren</span> must be implemented, but all
fields are <strong>WARL</strong> and may be read-only zero,
indicating reads to the corresponding counter will
cause an illegal instruction exception when executing in a less-privileged mode.
In systems without U-mode, the <span>mcounteren</span> register should not exist.</p>
<h3 id="machine-counter-inhibit-csr-mcountinhibit"><span class="header-section-number">3.1.12</span> Machine Counter-Inhibit CSR (<span>mcountinhibit</span>)</h3>
<figure>
<img src="machine_19.svg" alt="Counter-inhibit register mcountinhibit." id="mcountinhibit" /><figcaption>Counter-inhibit register <span>mcountinhibit</span>.<span label="mcountinhibit"></span></figcaption>
</figure>
<p>The counter-inhibit register <span>mcountinhibit</span> is a 32-bit <strong>WARL</strong> register
that controls which of the hardware performance-monitoring counters increment.
The settings in this register only control whether the counters increment;
their accessibility is not affected by the setting of this register.</p>
<p>When the CY, IR, or HPM<span><em>n</em></span> bit in the <span>mcountinhibit</span> register is
clear, the <span>cycle</span>, <span>instret</span>, or <span>hpmcounter<span><em>n</em></span></span> register
increments as usual. When the CY, IR, or HPM<span><em>n</em></span> bit is set, the
corresponding counter does not increment.</p>
<p>The <span>mcycle</span> CSR may be shared between harts on the same core, in which
case the <span>mcountinhibit</span>.CY field is also shared between those harts,
and so writes to <span>mcountinhibit</span>.CY will be visible to those harts.</p>
<p>If the <span>mcountinhibit</span> register is not implemented, the implementation
behaves as though the register were set to zero.</p>
<div class=commentary>
<p>When the <span>cycle</span> and <span>instret</span> counters are not needed, it is
desirable to conditionally inhibit them to reduce energy consumption.
Providing a single CSR to inhibit all counters also allows the counters to be
atomically sampled.</p>
<p>Because the <span>time</span> counter can be shared between multiple cores, it
cannot be inhibited with the <span>mcountinhibit</span> mechanism.</p>
</div>
<h3 id="machine-scratch-register-mscratch"><span class="header-section-number">3.1.13</span> Machine Scratch Register (<span>mscratch</span>)</h3>
<p>The <span>mscratch</span> register is an MXLEN-bit read/write register
dedicated for use by machine mode. Typically, it is used to hold a
pointer to a machine-mode hart-local context space and swapped with a
user register upon entry to an M-mode trap handler.</p>
<figure>
<img src="machine_20.svg" alt="Machine-mode scratch register." id="mscratchreg" /><figcaption>Machine-mode scratch register.<span label="mscratchreg"></span></figcaption>
</figure>
<div class=commentary>
<p>The MIPS ISA allocated two user registers (<span>k0</span>/<span>k1</span>) for use
by the operating system. Although the MIPS scheme provides a fast and
simple implementation, it also reduces available user registers, and
does not scale to further privilege levels, or nested traps. It can
also require both registers are cleared before returning to user level
to avoid a potential security hole and to provide deterministic
debugging behavior.</p>
<p>The RISC-V user ISA was designed to support many possible privileged
system environments and so we did not want to infect the user-level
ISA with any OS-dependent features. The RISC-V CSR swap instructions
can quickly save/restore values to the <span>mscratch</span> register.
Unlike the MIPS design, the OS can rely on holding a value in the <span>
mscratch</span> register while the user context is running.</p>
</div>
<h3 id="machine-exception-program-counter-mepc"><span class="header-section-number">3.1.14</span> Machine Exception Program Counter (<span>mepc</span>)</h3>
<p><span>mepc</span> is an MXLEN-bit read/write register formatted as shown in
Figure <a href="machine.html#mepcreg" data-reference-type="ref" data-reference="mepcreg">1.20</a>. The low bit of <span>mepc</span> (<span>mepc[0]</span>) is
always zero. On implementations that support only IALIGN=32, the two low bits
(<span>mepc[1:0]</span>) are always zero.</p>
<p>If an implementation allows IALIGN to be either 16 or 32 (by
changing CSR <span>misa</span>, for example), then, whenever IALIGN=32, bit
<span>mepc[1]</span> is masked on reads so that it appears to be 0. This
masking occurs also for the implicit read by the MRET instruction.
Though masked, <span>mepc[1]</span> remains writable when IALIGN=32.</p>
<p><span>mepc</span> is a <strong>WARL</strong> register that must be able to hold all valid
virtual addresses. It need not be capable of holding all possible invalid
addresses.
Prior to writing <span>mepc</span>, implementations may convert an invalid address
into some other invalid address that <span>mepc</span> is capable of holding.</p>
<div class=commentary>
<p>When address translation is not in effect, virtual addresses and physical
addresses are equal.
Hence, the set of addresses <span>mepc</span> must be able to represent includes the
set of physical addresses that can be used as a valid <span>pc</span> or effective
address.</p>
</div>
<p>When a trap is taken into M-mode, <span>mepc</span> is written with the
virtual address of the instruction that was interrupted or that
encountered the exception. Otherwise, <span>mepc</span> is never written by
the implementation, though it may be explicitly written by software.</p>
<figure>
<img src="machine_21.svg" alt="Machine exception program counter register." id="mepcreg" /><figcaption>Machine exception program counter register.<span label="mepcreg"></span></figcaption>
</figure>
<h3 id="sec:mcause"><span class="header-section-number">3.1.15</span> Machine Cause Register (<span>mcause</span>)</h3>
<p>The <span>mcause</span> register is an MXLEN-bit read-write register formatted as
shown in Figure <a href="machine.html#mcausereg" data-reference-type="ref" data-reference="mcausereg">1.21</a>. When a trap is taken into M-mode, <span>
mcause</span> is written with a code indicating the event that caused the trap.
Otherwise, <span>mcause</span> is never written by the implementation, though it may be
explicitly written by software.</p>
<p>The Interrupt bit in the <span>mcause</span> register is set if the
trap was caused by an interrupt. The Exception Code field
contains a code identifying the last exception or interrupt. Table <a href="machine.html#mcauses" data-reference-type="ref" data-reference="mcauses">[mcauses]</a>
lists the possible machine-level exception codes. The Exception Code
is a <strong>WLRL</strong> field, so is only guaranteed to hold supported exception
codes.</p>
<figure>
<img src="machine_22.svg" alt="Machine Cause register mcause." id="mcausereg" /><figcaption>Machine Cause register <span>mcause</span>.<span label="mcausereg"></span></figcaption>
</figure>
<table>
<thead>
<tr class="header">
<th style="text-align: right;">Interrupt</th>
<th style="text-align: right;">Exception Code</th>
<th style="text-align: left;">Description</th>
<th style="text-align: left;"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">1</td>
<td style="text-align: right;">0</td>
<td style="text-align: left;"><span><em>Reserved</em></span></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: right;">1</td>
<td style="text-align: right;">1</td>
<td style="text-align: left;">Supervisor software interrupt</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: right;">1</td>
<td style="text-align: right;">2</td>
<td style="text-align: left;"><span><em>Reserved</em></span></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: right;">1</td>
<td style="text-align: right;">3</td>
<td style="text-align: left;">Machine software interrupt</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: right;">1</td>
<td style="text-align: right;">4</td>
<td style="text-align: left;"><span><em>Reserved</em></span></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: right;">1</td>
<td style="text-align: right;">5</td>
<td style="text-align: left;">Supervisor timer interrupt</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: right;">1</td>
<td style="text-align: right;">6</td>
<td style="text-align: left;"><span><em>Reserved</em></span></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: right;">1</td>
<td style="text-align: right;">7</td>
<td style="text-align: left;">Machine timer interrupt</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: right;">1</td>
<td style="text-align: right;">8</td>
<td style="text-align: left;"><span><em>Reserved</em></span></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: right;">1</td>
<td style="text-align: right;">9</td>
<td style="text-align: left;">Supervisor external interrupt</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: right;">1</td>
<td style="text-align: right;">10</td>
<td style="text-align: left;"><span><em>Reserved</em></span></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: right;">1</td>
<td style="text-align: right;">11</td>
<td style="text-align: left;">Machine external interrupt</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: right;">1</td>
<td style="text-align: right;">12–15</td>
<td style="text-align: left;"><span><em>Reserved</em></span></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: right;">1</td>
<td style="text-align: right;"><span class="math inline">≥</span>16</td>
<td style="text-align: left;"><span><em>Designated for platform use</em></span></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: right;">0</td>
<td style="text-align: right;">0</td>
<td style="text-align: left;">Instruction address misaligned</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: right;">0</td>
<td style="text-align: right;">1</td>
<td style="text-align: left;">Instruction access fault</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: right;">0</td>
<td style="text-align: right;">2</td>
<td style="text-align: left;">Illegal instruction</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: right;">0</td>
<td style="text-align: right;">3</td>
<td style="text-align: left;">Breakpoint</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: right;">0</td>
<td style="text-align: right;">4</td>
<td style="text-align: left;">Load address misaligned</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: right;">0</td>
<td style="text-align: right;">5</td>
<td style="text-align: left;">Load access fault</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: right;">0</td>
<td style="text-align: right;">6</td>
<td style="text-align: left;">Store/AMO address misaligned</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: right;">0</td>
<td style="text-align: right;">7</td>
<td style="text-align: left;">Store/AMO access fault</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: right;">0</td>
<td style="text-align: right;">8</td>
<td style="text-align: left;">Environment call from U-mode</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: right;">0</td>
<td style="text-align: right;">9</td>
<td style="text-align: left;">Environment call from S-mode</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: right;">0</td>
<td style="text-align: right;">10</td>
<td style="text-align: left;"><span><em>Reserved</em></span></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: right;">0</td>
<td style="text-align: right;">11</td>
<td style="text-align: left;">Environment call from M-mode</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: right;">0</td>
<td style="text-align: right;">12</td>
<td style="text-align: left;">Instruction page fault</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: right;">0</td>
<td style="text-align: right;">13</td>
<td style="text-align: left;">Load page fault</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: right;">0</td>
<td style="text-align: right;">14</td>
<td style="text-align: left;"><span><em>Reserved</em></span></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: right;">0</td>
<td style="text-align: right;">15</td>
<td style="text-align: left;">Store/AMO page fault</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: right;">0</td>
<td style="text-align: right;">16–23</td>
<td style="text-align: left;"><span><em>Reserved</em></span></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: right;">0</td>
<td style="text-align: right;">24–31</td>
<td style="text-align: left;"><span><em>Designated for custom use</em></span></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: right;">0</td>
<td style="text-align: right;">32–47</td>
<td style="text-align: left;"><span><em>Reserved</em></span></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: right;">0</td>
<td style="text-align: right;">48–63</td>
<td style="text-align: left;"><span><em>Designated for custom use</em></span></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: right;">0</td>
<td style="text-align: right;"><span class="math inline">≥</span>64</td>
<td style="text-align: left;"><span><em>Reserved</em></span></td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<p>Note that load and load-reserved instructions generate load exceptions,
whereas store, store-conditional, and AMO instructions generate store/AMO
exceptions.</p>
<div class=commentary>
<p>Interrupts can be separated from other traps with a single branch on the sign of
the <span>mcause</span> register value. A shift left can remove the
interrupt bit and scale the exception codes to index into a trap
vector table.</p>
</div>
<div class=commentary>
<p>We do not distinguish privileged instruction exceptions from illegal
opcode exceptions. This simplifies the architecture and also hides
details of which higher-privilege instructions are supported by an
implementation. The privilege level servicing the trap can implement
a policy on whether these need to be distinguished, and if so, whether
a given opcode should be treated as illegal or privileged.</p>
</div>
<p>If an instruction may raise multiple synchronous exceptions, the
decreasing priority order of Table <a href="machine.html#exception-priority" data-reference-type="ref" data-reference="exception-priority">[exception-priority]</a>
indicates which exception is taken and reported in <span>mcause</span>.
The priority of any custom synchronous exceptions is implementation-defined.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Priority</th>
<th style="text-align: right;">Exc.Code</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><span><em>Highest</em></span></td>
<td style="text-align: right;">3</td>
<td style="text-align: left;">Instruction address breakpoint</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: right;"></td>
<td style="text-align: left;">During instruction address translation:</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: right;">12, 1</td>
<td style="text-align: left;">First encountered page fault or
access fault</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: right;"></td>
<td style="text-align: left;">With physical address for instruction:</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: right;">1</td>
<td style="text-align: left;">Instruction access fault</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: right;">2</td>
<td style="text-align: left;">Illegal instruction</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: right;">0</td>
<td style="text-align: left;">Instruction address misaligned</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: right;">8, 9, 11</td>
<td style="text-align: left;">Environment call</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: right;">3</td>
<td style="text-align: left;">Environment break</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: right;">3</td>
<td style="text-align: left;">Load/store/AMO address breakpoint</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: right;"></td>
<td style="text-align: left;">Optionally:</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: right;">4, 6</td>
<td style="text-align: left;">Load/store/AMO address misaligned</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: right;"></td>
<td style="text-align: left;">During address translation for an explicit
memory access:</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: right;">13, 15, 5, 7</td>
<td style="text-align: left;">First encountered page fault or
access fault</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: right;"></td>
<td style="text-align: left;">With physical address for an explicit
memory access:</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: right;">5, 7</td>
<td style="text-align: left;">Load/store/AMO access fault</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: right;"></td>
<td style="text-align: left;">If not higher priority:</td>
</tr>
<tr class="even">
<td style="text-align: left;"><span><em>Lowest</em></span></td>
<td style="text-align: right;">4, 6</td>
<td style="text-align: left;">Load/store/AMO address misaligned</td>
</tr>
</tbody>
</table>
<p>When a virtual address is translated into
a physical address, the address translation
algorithm determines what specific exception may be raised.</p>
<p>Load/store/AMO address-misaligned exceptions may have
either higher or lower priority than load/store/AMO page-fault and
access-fault exceptions.
<div class=commentary>
<p>The relative priority of load/store/AMO address-misaligned and page-fault
exceptions is implementation-defined to flexibly cater to two design points.
Implementations that never support misaligned accesses can unconditionally
raise the misaligned-address exception without performing address translation
or protection checks.
Implementations that support misaligned accesses only to some physical
addresses must translate and check the address before determining whether the
misaligned access may proceed, in which case raising the page-fault exception
or access is more appropriate.</p>
</div>
<div class=commentary>
<p>Instruction address breakpoints have the same cause value as, but
different priority than, data address breakpoints (a.k.a. watchpoints)
and environment break exceptions (which are raised by the EBREAK instruction).</p>
</div>
<div class=commentary>
<p>Instruction address misaligned exceptions are raised by control-flow
instructions with misaligned targets, rather than by the act of fetching an
instruction. Therefore, these exceptions have lower priority than other
instruction address exceptions.</p>
</div>
<h3 id="machine-trap-value-register-mtval"><span class="header-section-number">3.1.16</span> Machine Trap Value Register (<span>mtval</span>)</h3>
<p>The <span>mtval</span> register is an MXLEN-bit read-write register formatted as shown
in Figure <a href="machine.html#mtvalreg" data-reference-type="ref" data-reference="mtvalreg">1.22</a>. When a trap is taken into M-mode, <span>mtval</span> is
either set to zero or written with exception-specific information to assist
software in handling the trap. Otherwise, <span>mtval</span> is never written by the
implementation, though it may be explicitly written by software. The hardware
platform will specify which exceptions must set <span>mtval</span> informatively and
which may unconditionally set it to zero.
If the hardware platform specifies that no exceptions set <span>mtval</span> to a
nonzero value, then <span>mtval</span> is read-only zero.</p>
<p>If <span>mtval</span> is written with a nonzero value when a breakpoint,
address-misaligned, access-fault, or page-fault exception occurs on an
instruction fetch, load, or store, then <span>mtval</span> will contain the faulting
virtual address.</p>
<div class=commentary>
<p>When page-based virtual memory is enabled, <span>mtval</span> is written with
the faulting virtual address, even for physical-memory access-fault exceptions.
This design reduces datapath cost for most implementations, particularly
those with hardware page-table walkers.</p>
</div>
<figure>
<img src="machine_23.svg" alt="Machine Trap Value register." id="mtvalreg" /><figcaption>Machine Trap Value register.<span label="mtvalreg"></span></figcaption>
</figure>
<p>If <span>mtval</span> is written with a nonzero value when a misaligned load or store
causes an access-fault or page-fault exception, then <span>mtval</span> will contain
the virtual address of the portion of the access that caused the fault.</p>
<p>If <span>mtval</span> is written with a nonzero value when an instruction
access-fault or page-fault exception occurs on a system with variable-length
instructions, then <span>mtval</span> will contain the virtual address of the portion
of the instruction that caused the fault, while <span>mepc</span> will point to the
beginning of the instruction.</p>
<p>The <span>mtval</span> register can optionally also be used to return the faulting
instruction bits on an illegal instruction exception (<span>mepc</span> points to the
faulting instruction in memory).
If <span>mtval</span> is written with a nonzero value when an illegal-instruction
exception occurs, then <span>mtval</span> will contain the shortest of:</p>
<p>the actual faulting instruction</p>
<p>the first ILEN bits of the faulting instruction</p>
<p>the first MXLEN bits of the faulting instruction</p>
<p>The value loaded into <span>mtval</span> on an illegal-instruction exception is
right-justified and all unused upper bits are cleared to zero.</p>
<div class=commentary>
<p>Capturing the faulting instruction in <span>mtval</span> reduces the
overhead of instruction emulation, potentially avoiding several
partial instruction loads if the instruction is misaligned, and
likely data cache misses or slow uncached accesses when loads are
used to fetch the instruction into a data register. There is also a
problem of atomicity if another agent is manipulating the
instruction memory, as might occur in a dynamic translation system.</p>
<p>A requirement is that the entire instruction (or at least the first
MXLEN bits) are fetched into <span>mtval</span> before taking the trap.
This should not constrain implementations, which would typically
fetch the entire instruction before attempting to decode the
instruction, and avoids complicating software handlers.</p>
<p>A value of zero in <span>mtval</span> signifies either that the feature is
not supported, or an illegal zero instruction was fetched. A load
from the instruction memory pointed to by <span>mepc</span> can be used to
distinguish these two cases (or alternatively, the system
configuration information can be interrogated to install the
appropriate trap handling before runtime).</p>
</div>
<p>For other traps, <span>mtval</span> is set to zero, but a future standard may
redefine <span>mtval</span>’s setting for other traps.</p>
<p>If <span>mtval</span> is not read-only zero, it is a <strong>WARL</strong> register that must be
able to hold all valid virtual addresses and the value zero.
It need not be capable of holding all
possible invalid addresses.
Prior to writing <span>mtval</span>, implementations may convert an invalid address
into some other invalid address that <span>mtval</span> is capable of holding.
If the feature to return the faulting instruction bits is implemented, <span>
mtval</span> must also be able to hold all values less than <span class="math inline">2<sup><em>N</em></sup></span>, where <span class="math inline"><em>N</em></span> is the
smaller of MXLEN and ILEN.</p>
<h3 id="machine-configuration-pointer-register-mconfigptr"><span class="header-section-number">3.1.17</span> Machine Configuration Pointer Register (<span>mconfigptr</span>)</h3>
<p><span>mconfigptr</span> is an MXLEN-bit read-only CSR, formatted as shown in
Figure <a href="machine.html#mconfigptrreg" data-reference-type="ref" data-reference="mconfigptrreg">1.23</a>, that holds the physical address of a configuration
data structure.
Software can traverse this data structure to discover information about
the harts, the platform, and their configuration.</p>
<figure>
<img src="machine_24.svg" alt="Machine Configuration Pointer register." id="mconfigptrreg" /><figcaption>Machine Configuration Pointer register.<span label="mconfigptrreg"></span></figcaption>
</figure>
<p>The pointer alignment in bits must be no smaller than the greatest supported
MXLEN: i.e., if the greatest supported MXLEN is <span class="math inline">8 × <em>n</em></span>, then
<span>mconfigptr</span>[<span class="math inline">log<sub>2</sub><em>n</em></span>-1:0] must be zero.</p>
<p><span>mconfigptr</span> must be implemented, but it may be zero to
indicate the configuration data structure does not exist or that an
alternative mechanism must be used to locate it.</p>
<div class=commentary>
<p>The format and schema of the configuration data structure have yet to be standardized.</p>
</div>
<div class=commentary>
<p>While <span>mconfigptr</span> will simply be hardwired in some implementations, other
implementations may provide a means to configure the value returned on CSR
reads.
For example, <span>mconfigptr</span> might present the value of a memory-mapped
register that is programmed by the platform or by M-mode software towards the
beginning of the boot process.</p>
</div>
<h3 id="machine-environment-configuration-registers-menvcfg-and-menvcfgh"><span class="header-section-number">3.1.18</span> 
Machine Environment Configuration Registers
(<span>menvcfg</span> and <span>menvcfgh</span>)
</h3>
<p>The <span>menvcfg</span> CSR is an MXLEN-bit read/write register,
formatted for MXLEN=64 as shown in Figure <a href="machine.html#fig:menvcfg" data-reference-type="ref" data-reference="fig:menvcfg">1.24</a>,
that controls certain characteristics of the execution environment
for modes less privileged than M.</p>
<figure>
<img src="machine_25.svg" alt="Machine environment configuration register (menvcfg) for MXLEN=64." id="fig:menvcfg" /><figcaption>Machine environment configuration register (<span>menvcfg</span>) for MXLEN=64.<span label="fig:menvcfg"></span></figcaption>
</figure>
<p>If bit FIOM (Fence of I/O implies Memory) is set to one in <span>menvcfg</span>,
FENCE instructions executed in modes less privileged than M are modified so
the requirement to order accesses to device I/O implies also the requirement
to order main memory accesses.
Table <a href="machine.html#tab:menvcfg-FIOM" data-reference-type="ref" data-reference="tab:menvcfg-FIOM">[tab:menvcfg-FIOM]</a> details the modified interpretation of
FENCE instruction bits PI, PO, SI, and SO for modes less privileged than M
when FIOM=1.</p>
<p>Similarly, for modes less privileged than M when FIOM=1,
if an atomic instruction that accesses a region ordered as device I/O
has its <span><em>aq</em></span> and/or <span><em>rl</em></span> bit set, then that instruction is ordered
as though it accesses both device I/O and memory.</p>
<p>If S-mode is not supported, or if <span>satp</span>.MODE is read-only zero
(always Bare), the implementation may make FIOM read-only zero.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Instruction bit</th>
<th style="text-align: left;">Meaning when set</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">PI</td>
<td style="text-align: left;">Predecessor device input and memory reads (PR implied)</td>
</tr>
<tr class="even">
<td style="text-align: center;">PO</td>
<td style="text-align: left;">Predecessor device output and memory writes (PW implied)</td>
</tr>
<tr class="odd">
<td style="text-align: center;">SI</td>
<td style="text-align: left;">Successor device input and memory reads (SR implied)</td>
</tr>
<tr class="even">
<td style="text-align: center;">SO</td>
<td style="text-align: left;">Successor device output and memory writes (SW implied)</td>
</tr>
</tbody>
</table>
<div class=commentary>
<p>Bit FIOM is needed in <span>menvcfg</span> so M-mode can emulate the
hypervisor extension of Chapter <a href="hypervisor.html#hypervisor" data-reference-type="ref" data-reference="hypervisor">[hypervisor]</a>, which has an
equivalent FIOM bit in the hypervisor CSR <span>henvcfg</span>.</p>
</div>
<p>The PBMTE bit controls whether the Svpbmt extension is available for use in
S-mode and G-stage address translation (i.e., for page tables pointed to by
<span>satp</span> or <span>hgatp</span>).
When PBMTE=1, Svpbmt is available for S-mode and G-stage address translation.
When PBMTE=0, the implementation behaves as though Svpbmt were not implemented.
If Svpbmt is not implemented, PBMTE is read-only zero.
Furthermore, for implementations with the hypervisor extension,
<span>henvcfg</span>.PBMTE is read-only zero if <span>menvcfg</span>.PBMTE is zero.</p>
<p>The definition of the STCE field will be furnished by the
forthcoming Sstc extension.
Its allocation within <span>menvcfg</span> may change prior to the ratification
of that extension.</p>
<p>The definition of the CBZE field will be furnished by the
forthcoming Zicboz extension.
Its allocation within <span>menvcfg</span> may change prior to the ratification
of that extension.</p>
<p>The definitions of the CBCFE and CBIE fields will be furnished by the
forthcoming Zicbom extension.
Their allocations within <span>menvcfg</span> may change prior to the ratification
of that extension.</p>
<p>When MXLEN=32, <span>menvcfg</span> contains the same fields as bits 31:0
of <span>menvcfg</span> when MXLEN=64.
Additionally, when MXLEN=32, <span>menvcfgh</span> is a 32-bit read/write register that
contains the same fields as bits 63:32 of <span>menvcfg</span> when
MXLEN=64.
Register <span>menvcfgh</span> does not exist when MXLEN=64.</p>
<p>If U-mode is not supported, then registers <span>menvcfg</span> and <span>menvcfgh</span> do
not exist.</p>
<h3 id="sec:mseccfg"><span class="header-section-number">3.1.19</span> Machine Security Configuration Register (<span>mseccfg</span>)</h3>
<p><span>mseccfg</span> is an optional MXLEN-bit read/write register, formatted as shown
in Figure <a href="machine.html#fig:mseccfg" data-reference-type="ref" data-reference="fig:mseccfg">1.25</a>, that controls security features.</p>
<p>When MXLEN=32 only, <span>mseccfgh</span> is a 32-bit read/write register that
contains the same fields as <span>mseccfg</span> bits 63:32 when MXLEN=64.</p>
<figure>
<img src="machine_26.svg" alt="Machine security configuration register (mseccfg)." id="fig:mseccfg" /><figcaption>Machine security configuration register (<span>mseccfg</span>).<span label="fig:mseccfg"></span></figcaption>
</figure>
<p>The definitions of the SSEED and USEED fields will be furnished by the
forthcoming entropy-source extension, Zkr.
Their allocations within <span>mseccfg</span> may change prior to the ratification
of that extension.</p>
<p>The definitions of the RLB, MMWP, and MML fields will be furnished by the
forthcoming PMP-enhancement extension, Smepmp.
Their allocations within <span>mseccfg</span> may change prior to the ratification
of that extension.</p>
<h2 id="machine-level-memory-mapped-registers"><span class="header-section-number">3.2</span> Machine-Level Memory-Mapped Registers</h2>
<h3 id="machine-timer-registers-mtime-and-mtimecmp"><span class="header-section-number">3.2.1</span> Machine Timer Registers (<span>mtime</span> and <span>mtimecmp</span>)</h3>
<p>Platforms provide a real-time counter, exposed as a memory-mapped
machine-mode read-write register, <span>mtime</span>. <span>mtime</span> must
increment at constant frequency, and the platform must provide a
mechanism for determining the period of an <span>mtime</span> tick. The <span>
mtime</span> register will wrap around if the count overflows.</p>
<p>The <span>mtime</span> register has a 64-bit precision on all RV32 and RV64
systems. Platforms provide a 64-bit memory-mapped machine-mode
timer compare register (<span>mtimecmp</span>).
A machine timer interrupt becomes pending whenever <span>mtime</span> contains
a value greater than or equal to <span>mtimecmp</span>, treating the values
as unsigned integers.
The interrupt remains posted until <span>mtimecmp</span> becomes greater than
<span>mtime</span> (typically as a result of writing <span>mtimecmp</span>).
The interrupt will only be taken if interrupts
are enabled and the MTIE bit is set in the <span>mie</span> register.</p>
<figure>
<img src="machine_27.svg" alt="Machine time register (memory-mapped control register)." /><figcaption>Machine time register (memory-mapped control register).</figcaption>
</figure>
<figure>
<img src="machine_28.svg" alt="Machine time compare register (memory-mapped control register)." /><figcaption>Machine time compare register (memory-mapped control register).</figcaption>
</figure>
<div class=commentary>
<p>The timer facility is defined to use wall-clock time rather than a
cycle counter to support modern processors that run with a highly
variable clock frequency to save energy through dynamic voltage and
frequency scaling.</p>
<p>Accurate real-time clocks (RTCs) are relatively expensive to provide
(requiring a crystal or MEMS oscillator) and have to run even when the
rest of system is powered down, and so there is usually only one in a
system located in a different frequency/voltage domain from the
processors. Hence, the RTC must be shared by all the harts in a
system and accesses to the RTC will potentially incur the penalty of a
voltage-level-shifter and clock-domain crossing. It is thus more
natural to expose <span>mtime</span> as a memory-mapped register than as a CSR.</p>
<p>Lower privilege levels do not have their own <span>timecmp</span> registers.
Instead, machine-mode software can implement any number of virtual timers on
a hart by multiplexing the next timer interrupt into the <span>mtimecmp</span>
register.</p>
<p>Simple fixed-frequency systems can use a single clock for both cycle
counting and wall-clock time.</p>
</div>
<p>Writes to <span>mtime</span> and <span>mtimecmp</span> are guaranteed to be reflected in
MTIP eventually, but not necessarily immediately.</p>
<div class=commentary>
<p>A spurious timer interrupt might occur if an interrupt handler increments <span>
mtimecmp</span> then immediately returns, because MTIP might not yet have fallen in
the interim. All software should be written to assume this event is possible,
but most software should assume this event is extremely unlikely. It is
almost always more performant to incur an occasional spurious timer interrupt
than to poll MTIP until it falls.</p>
</div>
<p>In RV32, memory-mapped writes to <span>mtimecmp</span> modify only one 32-bit
part of the register. The following code sequence sets a 64-bit <span>
mtimecmp</span> value without spuriously generating a timer interrupt due
to the intermediate value of the comparand:</p>
<figure>
<img src="machine_29.svg" alt="Sample code for setting the 64-bit time comparand in RV32, assuming a little-endian memory system and that the registers live in a strongly ordered I/O region. Storing -1 to the low-order bits of mtimecmp prevents mtimecmp from temporarily becoming smaller than the lesser of the old and new values." id="mtimecmph" /><figcaption>Sample code for setting the 64-bit time comparand in RV32, assuming
a little-endian memory system and that the registers live in a strongly
ordered I/O region. Storing -1 to the low-order bits of <span>mtimecmp</span>
prevents <span>mtimecmp</span> from temporarily becoming smaller than the lesser
of the old and new values.<span label="mtimecmph"></span></figcaption>
</figure>
<p>For RV64, naturally aligned 64-bit memory accesses to the <span>mtime</span> and <span>
mtimecmp</span> registers are additionally supported and are atomic.</p>
<h2 id="machine-mode-privileged-instructions"><span class="header-section-number">3.3</span> Machine-Mode Privileged Instructions</h2>
<h3 id="environment-call-and-breakpoint"><span class="header-section-number">3.3.1</span> Environment Call and Breakpoint</h3>
<p><img src="machine_30.svg" alt="image" /></p>
<p>The ECALL instruction is used to make a request to the supporting execution
environment. When executed in U-mode, S-mode, or M-mode, it generates an
environment-call-from-U-mode exception, environment-call-from-S-mode exception, or environment-call-from-M-mode exception, respectively, and performs no other operation.
<div class=commentary>
<p>ECALL generates a different exception for each originating privilege mode
so that environment call exceptions can be selectively delegated. A typical
use case for Unix-like operating systems is to delegate to S-mode the
environment-call-from-U-mode exception but not the others.</p>
</div>
<p>The EBREAK instruction is used by debuggers to cause control to be transferred
back to a debugging environment. It generates a breakpoint exception and
performs no other operation.
<div class=commentary>
<p>As described in the “C” Standard Extension for Compressed Instructions in
Volume I of this manual, the C.EBREAK instruction performs the same operation
as the EBREAK instruction.</p>
</div>
<p>ECALL and EBREAK cause the receiving privilege mode’s <span>epc</span> register
to be set to the address of the ECALL or EBREAK instruction itself, <span><em>not</em></span>
the address of the following instruction.
As ECALL and EBREAK cause synchronous exceptions, they are not considered to
retire, and should not increment the <span>minstret</span> CSR.</p>
<h3 id="otherpriv"><span class="header-section-number">3.3.2</span> Trap-Return Instructions</h3>
<p>Instructions to return from trap are encoded under the PRIV
minor opcode.</p>
<p><img src="machine_31.svg" alt="image" /></p>
<p>To return after handling a trap, there are separate trap return
instructions per privilege level, MRET and SRET. MRET is
always provided. SRET must be provided if supervisor mode is
supported, and should raise an illegal instruction exception otherwise. SRET
should also raise an illegal instruction exception when TSR=1 in <span>mstatus</span>,
as described in Section <a href="machine.html#virt-control" data-reference-type="ref" data-reference="virt-control">1.1.6.5</a>.
An <span><em>x</em></span>RET instruction can be executed in privilege mode <span><em>x</em></span>
or higher, where executing a lower-privilege <span><em>x</em></span>RET instruction
will pop the relevant lower-privilege interrupt enable and privilege
mode stack. In addition to manipulating the privilege stack as
described in Section <a href="machine.html#privstack" data-reference-type="ref" data-reference="privstack">1.1.6.1</a>, <span><em>x</em></span>RET sets the <span>pc</span>
to the value stored in the <span><em>x</em></span><span>epc</span> register.</p>
<p>If the A extension is supported, the <span><em>x</em></span>RET instruction is
allowed to clear any outstanding LR address reservation but is not
required to. Trap handlers should explicitly clear the reservation if
required (e.g., by using a dummy SC) before executing the <span><em>x</em></span>RET.</p>
<div class=commentary>
<p>If <span><em>x</em></span>RET instructions always cleared LR reservations, it would
be impossible to single-step through LR/SC sequences using a
debugger.</p>
</div>
<h3 id="wfi"><span class="header-section-number">3.3.3</span> Wait for Interrupt</h3>
<p>The Wait for Interrupt instruction (WFI) provides a hint to the
implementation that the current hart can be stalled until an interrupt
might need servicing. Execution of the WFI instruction can also be
used to inform the hardware platform that suitable interrupts should
preferentially be routed to this hart. WFI is available in all
privileged modes, and optionally available to U-mode. This instruction may
raise an illegal instruction exception when TW=1 in <span>mstatus</span>, as described
in Section <a href="machine.html#virt-control" data-reference-type="ref" data-reference="virt-control">1.1.6.5</a>.</p>
<p><img src="machine_32.svg" alt="image" /></p>
<p>If an enabled interrupt is present or later becomes present while the
hart is stalled, the interrupt trap will be taken on the
following instruction, i.e., execution resumes in the trap handler and
<span>mepc</span> = <span>pc</span> + 4.</p>
<div class=commentary>
<p>The following instruction takes the interrupt trap so
that a simple return from the trap handler will execute code after the
WFI instruction.</p>
</div>
<p>The purpose of the WFI instruction is to provide a hint to the implementation,
and so a legal implementation is to simply implement WFI as a NOP.</p>
<div class=commentary>
<p>If the implementation does not stall the hart on execution of the
instruction, then the interrupt will be taken on some instruction in
the idle loop containing the WFI, and on a simple return from the
handler, the idle loop will resume execution.</p>
</div>
<p>The WFI instruction can also be executed when interrupts are disabled. The
operation of WFI must be unaffected by the global interrupt bits in <span>
mstatus</span> (MIE and SIE) and the delegation register <span>mideleg</span>
(i.e., the hart must resume if a locally enabled interrupt becomes pending,
even if it has been delegated to a less-privileged mode), but should honor the
individual interrupt enables (e.g, MTIE) (i.e., implementations should
avoid resuming the hart if the interrupt is pending but not
individually enabled). WFI is also required to resume execution for
locally enabled interrupts pending at any privilege level, regardless
of the global interrupt enable at each privilege level.</p>
<p>If the event that causes the hart to resume execution does not cause
an interrupt to be taken, execution will resume at <span>pc</span> + 4, and
software must determine what action to take, including looping back to
repeat the WFI if there was no actionable event.</p>
<div class=commentary>
<p>By allowing wakeup when interrupts are disabled, an alternate entry
point to an interrupt handler can be called that does not require
saving the current context, as the current context can be saved or
discarded before the WFI is executed.</p>
<p>As implementations are free to implement WFI as a NOP, software must
explicitly check for any relevant pending but disabled interrupts in
the code following an WFI, and should loop back to the WFI if no
suitable interrupt was detected. The <span>mip</span> or <span>sip</span>
registers can be interrogated to determine the presence
of any interrupt in machine or supervisor mode
respectively.</p>
<p>The operation of WFI is unaffected by the delegation register settings.</p>
<p>WFI is defined so that an implementation can trap into a higher
privilege mode, either immediately on encountering the WFI or after
some interval to initiate a machine-mode transition to a lower power
state, for example.</p>
</div>
<div class=commentary>
<p>The same “wait-for-event” template might be used for possible future
extensions that wait on memory locations changing, or message
arrival.</p>
</div>
<h3 id="sec:customsys"><span class="header-section-number">3.3.4</span> Custom SYSTEM Instructions</h3>
<p>The subspace of the SYSTEM major opcode shown in Figure <a href="machine.html#fig:customsys" data-reference-type="ref" data-reference="fig:customsys">1.27</a>
is designated for custom use.
It is recommended that these instructions use bits 29:28 to designate the
minimum required privilege mode, as do other SYSTEM instructions.</p>
<figure>
<img src="machine_33.svg" alt="SYSTEM instruction encodings designated for custom use." id="fig:customsys" /><figcaption>SYSTEM instruction encodings designated for custom use.<span label="fig:customsys"></span></figcaption>
</figure>
<h2 id="sec:reset"><span class="header-section-number">3.4</span> Reset</h2>
<p>Upon reset, a hart’s privilege mode is set to M. The <span>mstatus</span> fields MIE
and MPRV are reset to 0.
If little-endian memory accesses are supported, the <span>mstatus</span>/<span>mstatush</span>
field MBE is reset to 0.
The <span>misa</span> register is reset to enable the maximal set of supported
extensions and widest MXLEN, as described in Section <a href="machine.html#sec:misa" data-reference-type="ref" data-reference="sec:misa">1.1.1</a>.
For implementations with the “A” standard extension, there is no valid load
reservation.
The <span>pc</span> is set to an implementation-defined
reset vector. The <span>mcause</span> register is set to a value indicating the
cause of the reset.
Writable PMP registers’ A and L fields are set to 0, unless the platform
mandates a different reset value for some PMP registers’ A and L fields.
If the hypervisor extension is implemented, the <span>hgatp</span>.MODE and
<span>vsatp</span>.MODE fields are reset to 0.
No <strong>WARL</strong> field contains an illegal value.
All other hart state is .</p>
<p>The <span>mcause</span> values after reset have implementation-specific
interpretation, but the value 0 should be returned on implementations
that do not distinguish different reset conditions. Implementations
that distinguish different reset conditions should only use 0 to
indicate the most complete reset.</p>
<div class=commentary>
<p>Some designs may have multiple causes of reset (e.g., power-on reset,
external hard reset, brownout detected, watchdog timer elapse,
sleep-mode wakeup), which machine-mode software and debuggers may wish
to distinguish.</p>
<p><span>mcause</span> reset values may alias <span>mcause</span> values following synchronous
exceptions. There should be no ambiguity in this overlap, since on reset the
<span>pc</span> is typically set to a different value than on other traps.</p>
</div>
<h2 id="sec:nmi"><span class="header-section-number">3.5</span> Non-Maskable Interrupts</h2>
<p>Non-maskable interrupts (NMIs) are only used for hardware error
conditions, and cause an immediate jump to an implementation-defined
NMI vector running in M-mode regardless of the state of a hart’s
interrupt enable bits. The <span>mepc</span> register is written with the
virtual address of the instruction that was interrupted,
and <span>mcause</span> is set to a value indicating the source of the
NMI. The NMI can thus overwrite state in an active machine-mode
interrupt handler.</p>
<p>The values written to <span>mcause</span> on an NMI are
implementation-defined. The high Interrupt bit of <span>mcause</span> should
be set to indicate that this was an interrupt. An Exception Code of 0
is reserved to mean “unknown cause” and implementations that do not
distinguish sources of NMIs via the <span>mcause</span> register should
return 0 in the Exception Code.</p>
<p>Unlike resets, NMIs do not reset processor state, enabling diagnosis,
reporting, and possible containment of the hardware error.</p>
<h2 id="sec:pma"><span class="header-section-number">3.6</span> Physical Memory Attributes</h2>
<p>The physical memory map for a complete system includes various address
ranges, some corresponding to memory regions, some to memory-mapped
control registers, and some to vacant holes in the address space. Some
memory regions might not support reads, writes, or execution; some
might not support subword or subblock accesses; some might not support
atomic operations; and some might not support cache coherence or might
have different memory models. Similarly, memory-mapped control
registers vary in their supported access widths, support for atomic
operations, and whether read and write accesses have associated side
effects. In RISC-V systems, these properties and capabilities of each
region of the machine’s physical address space are termed <span>
<em>physical memory attributes</em></span> (PMAs). This section describes RISC-V
PMA terminology and how RISC-V systems implement and check PMAs.</p>
<p>PMAs are inherent properties of the underlying hardware and rarely
change during system operation. Unlike physical memory protection
values described in Section <a href="machine.html#sec:pmp" data-reference-type="ref" data-reference="sec:pmp">1.7</a>, PMAs do not vary by
execution context. The PMAs of some memory regions are fixed at chip
design time—for example, for an on-chip ROM. Others are fixed at
board design time, depending, for example, on which other chips are
connected to off-chip buses. Off-chip buses might also support
devices that could be changed on every power cycle (cold pluggable) or
dynamically while the system is running (hot pluggable). Some devices
might be configurable at run time to support different uses that imply
different PMAs—for example, an on-chip scratchpad RAM might be
cached privately by one core in one end-application, or accessed as a
shared non-cached memory in another end-application.</p>
<p>Most systems will require that at least some PMAs are dynamically
checked in hardware later in the execution pipeline after the physical
address is known, as some operations will not be supported at all
physical memory addresses, and some operations require knowing the
current setting of a configurable PMA attribute. While many other architectures
specify some PMAs in the virtual memory page tables and use the TLB to
inform the pipeline of these properties, this approach injects platform-specific
information into a virtualized layer and can cause system errors
unless attributes are correctly initialized in each page-table entry
for each physical memory region. In addition, the available
page sizes might not be optimal for specifying attributes in the
physical memory space, leading to address-space fragmentation and
inefficient use of expensive TLB entries.</p>
<p>For RISC-V, we separate out specification and checking of PMAs into a
separate hardware structure, the <span><em>PMA checker</em></span>. In many cases,
the attributes are known at system design time for each physical
address region, and can be hardwired into the PMA checker. Where the
attributes are run-time configurable, platform-specific memory-mapped
control registers can be provided to specify these attributes at a
granularity appropriate to each region on the platform (e.g., for an
on-chip SRAM that can be flexibly divided between cacheable and
uncacheable uses). PMAs are checked for any access to physical
memory, including accesses that have undergone virtual to physical
memory translation. To aid in system debugging, we strongly recommend
that, where possible, RISC-V processors precisely trap physical memory
accesses that fail PMA checks. Precisely trapped PMA violations manifest
as instruction, load, or store access-fault exceptions, distinct from
virtual-memory page-fault exceptions. Precise PMA traps might not always be
possible, for example, when probing a legacy bus architecture that
uses access failures as part of the discovery mechanism. In this
case, error responses from slave devices will be reported as imprecise
bus-error interrupts.</p>
<p>PMAs must also be readable by software to correctly access certain
devices or to correctly configure other hardware components that
access memory, such as DMA engines. As PMAs are tightly tied to a
given physical platform’s organization, many details are inherently
platform-specific, as is the means by which software can learn the PMA
values for a platform. Some
devices, particularly legacy buses, do not support discovery of PMAs
and so will give error responses or time out if an unsupported access
is attempted. Typically, platform-specific machine-mode code will
extract PMAs and ultimately present this information to higher-level
less-privileged software using some standard representation.</p>
<p>Where platforms support dynamic reconfiguration of PMAs, an interface
will be provided to set the attributes by passing requests to a
machine-mode driver that can correctly reconfigure the platform. For
example, switching cacheability attributes on some memory regions
might involve platform-specific operations, such as cache flushes,
that are available only to machine-mode.</p>
<h3 id="main-memory-versus-io-versus-vacant-regions"><span class="header-section-number">3.6.1</span> Main Memory versus I/O versus Vacant Regions</h3>
<p>The most important characterization of a given memory address range is
whether it holds regular main memory, or I/O devices, or is vacant.
Regular main memory is required to have a number of properties,
specified below, whereas I/O devices can have a much broader range of
attributes. Memory regions that do not fit into regular main
memory, for example, device scratchpad RAMs, are categorized as I/O
regions. Vacant regions are also classified as I/O regions but with
attributes specifying that no accesses are supported.</p>
<h3 id="supported-access-type-pmas"><span class="header-section-number">3.6.2</span> Supported Access Type PMAs</h3>
<p>Access types specify which access widths, from 8-bit byte to long
multi-word burst, are supported, and also whether misaligned accesses
are supported for each access width.</p>
<div class=commentary>
<p>Although software running on a RISC-V hart cannot directly generate
bursts to memory, software might have to program DMA engines to access
I/O devices and might therefore need to know which access sizes are
supported.</p>
</div>
<p>Main memory regions always support read and write of all
access widths required by the attached devices, and can
specify whether instruction fetch is supported.</p>
<div class=commentary>
<p>Some platforms might mandate that all of main memory support instruction
fetch.
Other platforms might prohibit instruction fetch from some main memory
regions.</p>
</div>
<div class=commentary>
<p>In some cases, the design of a processor or device accessing main
memory might support other widths, but must be able to function with
the types supported by the main memory.</p>
</div>
<p>I/O regions can specify which combinations of read, write, or execute
accesses to which data widths are supported.</p>
<p>For systems with page-based virtual memory, I/O and memory regions can
specify which combinations of hardware page-table reads and hardware
page-table writes are supported.</p>
<div class=commentary>
<p>Unix-like operating systems generally require that all of cacheable main
memory supports page-table walks.</p>
</div>
<h3 id="atomicity-pmas"><span class="header-section-number">3.6.3</span> Atomicity PMAs</h3>
<p>Atomicity PMAs describes which atomic instructions are supported in
this address region.
Support for atomic instructions is divided into two
categories: <span><em>LR/SC</em></span> and <span><em>AMOs</em></span>.</p>
<div class=commentary>
<p>Some platforms might mandate that all of cacheable main memory support
all atomic operations required by the attached processors.</p>
</div>
<h4 id="amo-pma"><span class="header-section-number">3.6.3.1</span> AMO PMA</h4>
<p>Within AMOs, there are four levels of
support: <span><em>AMONone</em></span>, <span><em>AMOSwap</em></span>, <span><em>AMOLogical</em></span>, and <span>
<em>AMOArithmetic</em></span>. AMONone indicates that no AMO operations are
supported. AMOSwap indicates that only <span>amoswap</span> instructions are
supported in this address range. AMOLogical indicates that swap
instructions plus all the logical AMOs (<span>amoand</span>, <span>amoor</span>,
<span>amoxor</span>) are supported. AMOArithmetic indicates that all RISC-V
AMOs are supported. For each level of support, naturally aligned AMOs
of a given width are supported if the underlying memory region
supports reads and writes of that width.
Main memory and I/O regions may only support a subset or none of the
processor-supported atomic operations.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">AMO Class</th>
<th style="text-align: left;">Supported Operations</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">AMONone</td>
<td style="text-align: left;"><span><em>None</em></span></td>
</tr>
<tr class="even">
<td style="text-align: left;">AMOSwap</td>
<td style="text-align: left;"><span>amoswap</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">AMOLogical</td>
<td style="text-align: left;">above + <span>amoand</span>, <span>amoor</span>, <span>amoxor</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">AMOArithmetic</td>
<td style="text-align: left;">above + <span>amoadd</span>, <span>amomin</span>, <span>amomax</span>, <span>amominu</span>, <span>amomaxu</span></td>
</tr>
</tbody>
</table>
<div class=commentary>
<p>We recommend providing at least AMOLogical support for I/O regions
where possible.</p>
</div>
<h4 id="reservability-pma"><span class="header-section-number">3.6.3.2</span> Reservability PMA</h4>
<p>For <span><em>LR/SC</em></span>, there are three levels of support indicating combinations of
the reservability and eventuality properties: <span><em>RsrvNone</em></span>,
<span><em>RsrvNonEventual</em></span>, and <span><em>RsrvEventual</em></span>.
RsrvNone indicates that no LR/SC operations are supported (the location is
non-reservable). RsrvNonEventual indicates that the operations are supported
(the location is reservable), but without the eventual success guarantee
described in the unprivileged ISA specification. RsrvEventual indicates that
the operations are supported and provide the eventual success guarantee.</p>
<div class=commentary>
<p>We recommend providing RsrvEventual support for main memory regions
where possible. Most I/O regions will not support LR/SC accesses, as
these are most conveniently built on top of a cache-coherence scheme, but some
may support RsrvNonEventual or RsrvEventual.</p>
</div>
<div class=commentary>
<p>When LR/SC is used for memory locations marked RsrvNonEventual, software should
provide alternative fall-back mechanisms used when lack of progress is
detected.</p>
</div>
<h4 id="alignment"><span class="header-section-number">3.6.3.3</span> Alignment</h4>
<p>Memory regions that support aligned LR/SC or aligned AMOs might also support
misaligned LR/SC or misaligned AMOs for some addresses and access widths. If,
for a given address and access width, a misaligned LR/SC or AMO generates
an address-misaligned exception, then <span><em>all</em></span> loads, stores, LRs/SCs, and
AMOs using that address and access width must generate address-misaligned
exceptions.
<div class=commentary>
<p>The standard “A” extension does not support misaligned AMOs or LR/SC pairs.
Support for misaligned AMOs is provided by the standard “Zam” extension.
Support for misaligned LR/SC sequences is not currently standardized,
so LR and SC to misaligned addresses must raise an exception.</p>
<p>Mandating that misaligned loads and stores raise address-misaligned exceptions
wherever misaligned AMOs raise address-misaligned exceptions permits the
emulation of misaligned AMOs in an M-mode trap handler. The handler
guarantees atomicity by acquiring a global mutex and emulating the access
within the critical section. Provided that the handler for misaligned loads
and stores uses the same mutex, all accesses to a given address that use the
same word size will be mutually atomic.</p>
</div>
<p>Implementations may raise access-fault exceptions instead of address-misaligned
exceptions for some misaligned accesses, indicating the instruction should not
be emulated by a trap handler. If, for a given address and access width, all
misaligned LRs/SCs and AMOs generate access-fault exceptions, then regular
misaligned loads and stores using the same address and access width are not
required to execute atomically.</p>
<h3 id="memory-ordering-pmas"><span class="header-section-number">3.6.4</span> Memory-Ordering PMAs</h3>
<p>Regions of the address space are classified as either <span><em>main
memory</em></span> or <span><em>I/O</em></span> for the purposes of ordering by the FENCE
instruction and atomic-instruction ordering bits.</p>
<p>Accesses by one hart to main memory regions are observable not only by
other harts but also by other devices with the capability to initiate
requests in the main memory system (e.g., DMA engines).
Coherent main memory regions always have either the RVWMO or RVTSO memory
model.
Incoherent main memory regions have an implementation-defined memory model.</p>
<p>Accesses by one hart to an I/O region are observable not only by other harts
and bus mastering devices but also by targeted slave I/O devices, and I/O
regions may be accessed with either <span><em>relaxed</em></span> or <span><em>strong</em></span> ordering.
Accesses to an I/O region with relaxed ordering are generally observed by
other harts and bus mastering devices in a manner similar to the ordering of
accesses to an RVWMO memory region, as discussed in Section A.4.2 in Volume
I of this specification.
By contrast, accesses to an I/O region with strong ordering are generally
observed by other harts and bus mastering devices in program order.</p>
<p>Each strongly ordered I/O region specifies a numbered ordering
channel, which is a mechanism by which ordering guarantees can be
provided between different I/O regions. Channel 0 is used to indicate
point-to-point strong ordering only, where only accesses by the hart to the
single associated I/O region are strongly ordered.</p>
<p>Channel 1 is used to provide global strong ordering across all I/O
regions. Any accesses by a hart to any I/O region associated with
channel 1 can only be observed to have occurred in program order by all
other harts and I/O devices, including relative to accesses made by
that hart to relaxed I/O regions or strongly ordered I/O regions with
different channel numbers. In other words, any access to a region in
channel 1 is equivalent to executing a <span>fence io,io</span>
instruction before and after the instruction.</p>
<p>Other larger channel numbers provide program ordering to accesses by
that hart across any regions with the same channel number.</p>
<p>Systems might support dynamic configuration of ordering properties on
each memory region.</p>
<div class=commentary>
<p>Strong ordering can be used to improve compatibility with legacy
device driver code, or to enable increased performance compared to
insertion of explicit ordering instructions when the implementation is
known to not reorder accesses.</p>
<p>Local strong ordering (channel 0) is the default form of strong
ordering as it is often straightforward to provide if there is only a
single in-order communication path between the hart and the I/O
device.</p>
<p>Generally, different strongly ordered I/O regions can share the same
ordering channel without additional ordering hardware if they share
the same interconnect path and the path does not reorder requests.</p>
</div>
<h3 id="coherence-and-cacheability-pmas"><span class="header-section-number">3.6.5</span> Coherence and Cacheability PMAs</h3>
<p>Coherence is a property defined for a single physical address, and
indicates that writes to that address by one agent will eventually be
made visible to other agents in the system. Coherence is not to be
confused with the memory consistency model of a system, which defines
what values a memory read can return given the previous history of
reads and writes to the entire memory system. In RISC-V platforms,
the use of hardware-incoherent regions is discouraged due to software
complexity, performance, and energy impacts.</p>
<p>The cacheability of a memory region should not affect the software
view of the region except for differences reflected in other PMAs,
such as main memory versus I/O classification, memory ordering,
supported accesses and atomic operations, and coherence. For this
reason, we treat cacheability as a platform-level setting managed by
machine-mode software only.</p>
<p>Where a platform supports configurable cacheability settings for a
memory region, a platform-specific machine-mode routine will change
the settings and flush caches if necessary, so the system is only
incoherent during the transition between cacheability settings. This
transitory state should not be visible to lower privilege levels.</p>
<div class=commentary>
<p>We categorize RISC-V caches into three types: <span><em>master-private</em></span>,
<span><em>shared</em></span>, and <span><em>slave-private</em></span>. Master-private caches are
attached to a single master agent, i.e., one that issues read/write
requests to the memory system. Shared caches are located between
masters and slaves and may be hierarchically organized. Slave-private
caches do not impact coherence, as they are local to a single slave
and do not affect other PMAs at a master, so are not considered
further here. We use <span><em>private cache</em></span> to mean a master-private
cache in the following section, unless explicitly stated otherwise.</p>
<p>Coherence is straightforward to provide for a shared memory region
that is not cached by any agent. The PMA for such a region would
simply indicate it should not be cached in a private or shared cache.</p>
<p>Coherence is also straightforward for read-only regions, which can be
safely cached by multiple agents without requiring a cache-coherence
scheme. The PMA for this region would indicate that it can be cached,
but that writes are not supported.</p>
<p>Some read-write regions might only be accessed by a single agent, in
which case they can be cached privately by that agent without
requiring a coherence scheme. The PMA for such regions would indicate
they can be cached. The data can also be cached in a shared cache, as
other agents should not access the region.</p>
<p>If an agent can cache a read-write region that is accessible by other
agents, whether caching or non-caching, a cache-coherence scheme is
required to avoid use of stale values. In regions lacking hardware
cache coherence (hardware-incoherent regions), cache coherence can be
implemented entirely in software, but software coherence schemes are
notoriously difficult to implement correctly and often have severe
performance impacts due to the need for conservative software-directed
cache-flushing. Hardware cache-coherence schemes require more complex
hardware and can impact performance due to the cache-coherence probes,
but are otherwise invisible to software.</p>
<p>For each hardware cache-coherent region, the PMA would indicate that
the region is coherent and which hardware coherence controller to use
if the system has multiple coherence controllers. For some systems,
the coherence controller might be an outer-level shared cache, which
might itself access further outer-level cache-coherence controllers
hierarchically.</p>
<p>Most memory regions within a platform will be coherent to software,
because they will be fixed as either uncached, read-only, hardware
cache-coherent, or only accessed by one agent.</p>
</div>
<p>If a PMA indicates non-cacheability, then accesses to that region must
be satisfied by the memory itself, not by any caches.</p>
<div class=commentary>
<p>For implementations with a cacheability-control mechanism, the situation
may arise that a program uncacheably accesses a memory location that is
currently cache-resident.
In this situation, the cached copy must be ignored.
This constraint is necessary to prevent more-privileged modes’ speculative
cache refills from affecting the behavior of less-privileged modes’
uncacheable accesses.</p>
</div>
<h3 id="idempotency-pmas"><span class="header-section-number">3.6.6</span> Idempotency PMAs</h3>
<p>Idempotency PMAs describe whether reads and writes to an address
region are idempotent. Main memory regions are assumed to be
idempotent. For I/O regions, idempotency on reads and writes can be
specified separately (e.g., reads are idempotent but writes are not).
If accesses are non-idempotent, i.e., there is potentially a side
effect on any read or write access, then speculative or redundant
accesses must be avoided.</p>
<p>For the purposes of defining the idempotency PMAs, changes in observed
memory ordering created by redundant accesses are not considered a
side effect.</p>
<div class=commentary>
<p>While hardware should always be designed to avoid speculative or
redundant accesses to memory regions marked as non-idempotent, it is
also necessary to ensure software or compiler optimizations do not
generate spurious accesses to non-idempotent memory regions.</p>
</div>
<div class=commentary>
<p>Non-idempotent regions might not support misaligned accesses. Misaligned
accesses to such regions should raise access-fault exceptions rather than
address-misaligned exceptions, indicating that software should not emulate the
misaligned access using multiple smaller accesses, which could cause
unexpected side effects.</p>
</div>
<p>For non-idempotent regions, implicit reads and writes must not be performed
early or speculatively, with the following exceptions.
When a non-speculative implicit read is performed, an implementation is
permitted to additionally read any of the bytes within a naturally aligned
power-of-2 region containing the address of the non-speculative implicit read.
Furthermore, when a non-speculative instruction fetch is performed, an
implementation is permitted to additionally read any of the bytes within the
<span><em>next</em></span> naturally aligned power-of-2 region of the same size (with the
address of the region taken modulo <span class="math inline">2<sup>XLEN</sup></span>).
The results of these additional reads may be used to satisfy subsequent early
or speculative implicit reads.
The size of these naturally aligned power-of-2 regions is
implementation-defined, but, for systems with page-based virtual memory, must
not exceed the smallest supported page size.</p>
<h2 id="sec:pmp"><span class="header-section-number">3.7</span> Physical Memory Protection</h2>
<p>To support secure processing and contain faults, it is desirable to
limit the physical addresses accessible by software running on a hart.
An optional physical memory protection (PMP) unit provides
per-hart machine-mode control registers to allow
physical memory access privileges (read, write, execute) to be
specified for each physical memory region. The PMP values are checked
in parallel with the PMA checks described in Section <a href="machine.html#sec:pma" data-reference-type="ref" data-reference="sec:pma">1.6</a>.</p>
<p>The granularity of PMP access control settings are platform-specific,
but the standard PMP
encoding supports regions as small as four bytes. Certain regions’ privileges
can be hardwired—for example, some regions might only ever be visible in
machine mode but in no lower-privilege layers.</p>
<div class=commentary>
<p>Platforms vary widely in demands for physical memory protection, and
some platforms may provide other PMP structures in addition to or
instead of the scheme described in this section.</p>
</div>
<p>PMP checks are applied to all accesses whose effective privilege mode is S or
U, including instruction fetches in S and U mode, data accesses in S and
U mode when the MPRV bit in the <span>mstatus</span> register is clear, and data
accesses in any mode when the MPRV bit in <span>mstatus</span> is set and the MPP
field in <span>mstatus</span> contains S or U.
PMP checks are also applied to page-table
accesses for virtual-address translation, for which the effective
privilege mode is S. Optionally, PMP checks may additionally apply
to M-mode accesses, in which case the PMP registers themselves are
locked, so that even M-mode software cannot change them until the hart is
reset. In effect, PMP can <span><em>grant</em></span> permissions to S and U
modes, which by default have none, and can <span><em>revoke</em></span> permissions
from M-mode, which by default has full permissions.</p>
<p>PMP violations are always trapped precisely at the processor.</p>
<h3 id="physical-memory-protection-csrs"><span class="header-section-number">3.7.1</span> Physical Memory Protection CSRs</h3>
<p>PMP entries are described by an 8-bit configuration register and one MXLEN-bit
address register. Some PMP settings additionally use the address register
associated with the preceding PMP entry.
Up to 64 PMP entries are supported.
Implementations may implement zero, 16, or 64 PMP CSRs; the lowest-numbered
PMP CSRs must be implemented first.
All PMP CSR fields are <strong>WARL</strong> and may be read-only zero.
PMP CSRs are only accessible to M-mode.</p>
<p>The PMP configuration registers are densely packed into CSRs to minimize
context-switch time.
For RV32, sixteen CSRs, <span>pmpcfg0</span>–<span>pmpcfg15</span>, hold the configurations
<span>pmp0cfg</span>–<span>pmp63cfg</span> for the 64 PMP entries, as shown in
Figure <a href="machine.html#pmpcfg-rv32" data-reference-type="ref" data-reference="pmpcfg-rv32">1.28</a>.
For RV64, eight even-numbered CSRs,
<span>pmpcfg0</span>, <span>pmpcfg2</span>, …, <span>pmpcfg14</span>, hold the configurations
for the 64 PMP entries, as shown in Figure <a href="machine.html#pmpcfg-rv64" data-reference-type="ref" data-reference="pmpcfg-rv64">1.29</a>.
For RV64, the odd-numbered configuration registers,
<span>pmpcfg1</span>, <span>pmpcfg3</span>, …, <span>pmpcfg15</span>, are illegal.</p>
<div class=commentary>
<p>RV64 systems use <span>pmpcfg2</span>, rather than <span>pmpcfg1</span>, to hold
configurations for PMP entries 8–15. This design reduces the cost of
supporting multiple MXLEN values, since the configurations for PMP
entries 8–11 appear in <span>pmpcfg2</span>[31:0] for both RV32 and RV64.</p>
</div>
<figure>
<img src="machine_34.svg" alt="RV32 PMP configuration CSR layout." id="pmpcfg-rv32" /><figcaption>RV32 PMP configuration CSR layout.<span label="pmpcfg-rv32"></span></figcaption>
</figure>
<figure>
<img src="machine_35.svg" alt="RV64 PMP configuration CSR layout." id="pmpcfg-rv64" /><figcaption>RV64 PMP configuration CSR layout.<span label="pmpcfg-rv64"></span></figcaption>
</figure>
<p>The PMP address registers are CSRs named <span>pmpaddr0</span>–<span>pmpaddr63</span>.
Each PMP address register encodes bits 33–2 of a 34-bit physical address for
RV32, as shown in Figure <a href="machine.html#pmpaddr-rv32" data-reference-type="ref" data-reference="pmpaddr-rv32">1.30</a>. For RV64, each PMP address
register encodes bits 55–2 of a 56-bit physical address, as shown in
Figure <a href="machine.html#pmpaddr-rv64" data-reference-type="ref" data-reference="pmpaddr-rv64">1.31</a>. Not all physical address bits may be implemented,
and so the <span>pmpaddr</span> registers are <strong>WARL</strong>.</p>
<div class=commentary>
<p>The Sv32 page-based virtual-memory scheme described in Section <a href="supervisor.html#sec:sv32" data-reference-type="ref" data-reference="sec:sv32">[sec:sv32]</a>
supports 34-bit physical addresses for RV32, so the PMP scheme must support
addresses wider than XLEN for RV32.
The Sv39 and Sv48 page-based virtual-memory schemes described in
Sections <a href="supervisor.html#sec:sv39" data-reference-type="ref" data-reference="sec:sv39">[sec:sv39]</a> and <a href="supervisor.html#sec:sv48" data-reference-type="ref" data-reference="sec:sv48">[sec:sv48]</a> support a 56-bit physical address
space, so the RV64 PMP address registers impose the same limit.</p>
</div>
<figure>
<img src="machine_36.svg" alt="PMP address register format, RV32." id="pmpaddr-rv32" /><figcaption>PMP address register format, RV32.<span label="pmpaddr-rv32"></span></figcaption>
</figure>
<figure>
<img src="machine_37.svg" alt="PMP address register format, RV64." id="pmpaddr-rv64" /><figcaption>PMP address register format, RV64.<span label="pmpaddr-rv64"></span></figcaption>
</figure>
<p>Figure <a href="machine.html#pmpcfg" data-reference-type="ref" data-reference="pmpcfg">1.32</a> shows the layout of a PMP configuration register. The R,
W, and X bits, when set, indicate that the PMP entry permits read, write, and
instruction execution, respectively. When one of these bits is clear, the
corresponding access type is denied.
The R, W, and X fields form a collective <strong>WARL</strong> field for which the
combinations with R=0 and W=1 are reserved.
The remaining two fields, A and L, are described in the following sections.</p>
<figure>
<img src="machine_38.svg" alt="PMP configuration register format." id="pmpcfg" /><figcaption>PMP configuration register format.<span label="pmpcfg"></span></figcaption>
</figure>
<p>Attempting to fetch an instruction from a PMP region that does not have execute
permissions raises an instruction access-fault exception. Attempting to execute
a load or load-reserved instruction which accesses a physical address within
a PMP region without read permissions raises a load access-fault exception.
Attempting to execute a store, store-conditional,
or AMO instruction which accesses a physical address within a PMP region without
write permissions raises a store access-fault exception.</p>
<p>If MXLEN is changed, the contents of the <span>pmp<span><em>x</em></span>cfg</span> fields are
preserved, but appear in the <span>pmpcfg<span><em>y</em></span></span> CSR prescribed by the new
setting of MXLEN. For example, when MXLEN is changed from 64 to 32, <span>
pmp4cfg</span> moves from <span>pmpcfg0</span>[39:32] to <span>pmpcfg1</span>[7:0]. The <span>
pmpaddr</span> CSRs follow the usual CSR width modulation rules described in
Section <a href="priv-csrs.html#sec:csrwidthmodulation" data-reference-type="ref" data-reference="sec:csrwidthmodulation">[sec:csrwidthmodulation]</a>.</p>
<h4 id="address-matching" class="unnumbered">Address Matching</h4>
<p>The A field in a PMP entry’s configuration register encodes the
address-matching mode of the associated PMP address register. The encoding of
this field is shown in Table <a href="machine.html#pmpcfg-a" data-reference-type="ref" data-reference="pmpcfg-a">[pmpcfg-a]</a>. When A=0, this PMP entry is
disabled and matches no addresses. Two other address-matching modes are
supported: naturally aligned power-of-2 regions (NAPOT), including the special
case of naturally aligned four-byte regions (NA4); and the top boundary of an
arbitrary range (TOR). These modes support four-byte granularity.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: right;">A</th>
<th style="text-align: center;">Name</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">0</td>
<td style="text-align: center;">OFF</td>
<td style="text-align: left;">Null region (disabled)</td>
</tr>
<tr class="even">
<td style="text-align: right;">1</td>
<td style="text-align: center;">TOR</td>
<td style="text-align: left;">Top of range</td>
</tr>
<tr class="odd">
<td style="text-align: right;">2</td>
<td style="text-align: center;">NA4</td>
<td style="text-align: left;">Naturally aligned four-byte region</td>
</tr>
<tr class="even">
<td style="text-align: right;">3</td>
<td style="text-align: center;">NAPOT</td>
<td style="text-align: left;">Naturally aligned power-of-two region, <span class="math inline">≥</span>8 bytes</td>
</tr>
</tbody>
</table>
<p>NAPOT ranges make use of the low-order bits of the associated address register
to encode the size of the range, as shown in Table <a href="machine.html#pmpcfg-napot" data-reference-type="ref" data-reference="pmpcfg-napot">1.33</a>.</p>
<figure>
<img src="machine_39.svg" alt="NAPOT range encoding in PMP address and configuration registers." id="pmpcfg-napot" /><figcaption>NAPOT range encoding in PMP address and configuration registers.<span label="pmpcfg-napot"></span></figcaption>
</figure>
<p>If TOR is selected, the associated address register forms the top of the
address range, and the preceding PMP address register forms the bottom of the
address range. If PMP entry <span class="math inline"><em>i</em></span>’s A field is set to TOR, the entry matches
any address <span class="math inline"><em>y</em></span> such that <span class="math inline">${\tt pmpaddr}_{i-1}\leq y &lt; {\tt pmpaddr}_i$</span>
(irrespective of the value of <span class="math inline">${\tt pmpcfg}_{i-1}$</span>).
If
PMP entry 0’s A field is set to TOR, zero is used for the lower bound, and so
it matches any address <span class="math inline">$y &lt; {\tt pmpaddr}_0$</span>.</p>
<div class=commentary>
<p>If <span class="math inline">${\tt pmpaddr}_{i-1}\geq {\tt pmpaddr}_i$</span> and <span class="math inline">${\tt pmpcfg_i.A}$</span>=TOR,
then PMP entry <span class="math inline"><em>i</em></span> matches no addresses.</p>
</div>
<p>Although the PMP mechanism supports regions as small as four bytes, platforms
may specify coarser PMP regions. In general, the PMP grain is <span class="math inline">2<sup><em>G</em> + 2</sup></span> bytes
and must be the same across all PMP regions. When <span class="math inline"><em>G</em> ≥ 1</span>, the NA4 mode
is not selectable. When <span class="math inline"><em>G</em> ≥ 2</span> and <span class="math inline">${\tt pmpcfg}_i$</span>.A[1] is set, i.e.
the mode is NAPOT, then bits <span class="math inline">${\tt pmpaddr}_i$</span>[G-2:0] read as all ones. When
<span class="math inline"><em>G</em> ≥ 1</span> and <span class="math inline">${\tt pmpcfg}_i$</span>.A[1] is clear, i.e. the mode is OFF or TOR,
then bits <span class="math inline">${\tt pmpaddr}_i$</span>[G-1:0] read as all zeros. Bits <span class="math inline">${\tt
pmpaddr}_i$</span>[G-1:0] do not affect the TOR address-matching logic.
Although changing <span class="math inline">${\tt pmpcfg}_i$</span>.A[1] affects the value read from
<span class="math inline">${\tt pmpaddr}_i$</span>, it does not affect the underlying value stored in that
register—in particular, <span class="math inline">${\tt pmpaddr}_i$</span>[G-1] retains its original value
when <span class="math inline">${\tt pmpcfg}_i$</span>.A is changed from NAPOT to TOR/OFF then back to NAPOT.</p>
<div class=commentary>
<p>Software may determine the PMP granularity by writing zero to <span>pmp0cfg</span>,
then writing all ones to <span>pmpaddr0</span>, then reading back <span>pmpaddr0</span>.
If <span class="math inline"><em>G</em></span> is the index of the least-significant bit set,
the PMP granularity is <span class="math inline">2<sup><em>G</em> + 2</sup></span> bytes.</p>
</div>
<p>If the current XLEN is greater than MXLEN, the PMP address registers are
zero-extended from MXLEN to XLEN bits for the purposes of address matching.</p>
<h4 id="locking-and-privilege-mode" class="unnumbered">Locking and Privilege Mode</h4>
<p>The L bit indicates that the PMP entry is locked, i.e., writes to the
configuration register and associated address registers are ignored. Locked
PMP entries remain locked until the hart is reset. If PMP entry <span class="math inline"><em>i</em></span> is
locked, writes to <span>pmp</span><span class="math inline"><em>i</em></span><span>cfg</span> and <span>pmpaddr</span><span class="math inline"><em>i</em></span> are ignored.
Additionally, if PMP entry <span class="math inline"><em>i</em></span> is locked and <span>pmp</span><span class="math inline"><em>i</em></span><span>cfg</span>.A is set
to TOR, writes to <span>pmpaddr</span><span class="math inline"><em>i</em></span>-1 are ignored.</p>
<div class=commentary>
<p>Setting the L bit locks the PMP entry even when the A field is set to OFF.</p>
</div>
<p>In addition to locking the PMP entry, the L bit indicates whether the R/W/X
permissions are enforced on M-mode accesses. When the L bit is set, these
permissions are enforced for all privilege modes. When the L bit is clear,
any M-mode access matching the PMP entry will succeed; the R/W/X
permissions apply only to S and U modes.</p>
<h4 id="priority-and-matching-logic" class="unnumbered">Priority and Matching Logic</h4>
<p>PMP entries are statically prioritized. The lowest-numbered PMP entry that
matches any byte of an access determines whether that access succeeds or
fails. The matching PMP entry must match all bytes of an access, or the
access fails, irrespective of the L, R, W, and X bits. For example, if a PMP
entry is configured to match the four-byte range <span>0xC</span>–<span>0xF</span>, then an
8-byte access to the range <span>0x8</span>–<span>0xF</span> will fail, assuming that
PMP entry is the highest-priority entry that matches those addresses.</p>
<p>If a PMP entry matches all bytes of an access, then the L, R, W, and X bits
determine whether the access succeeds or fails. If the L bit is clear and the
privilege mode of the access is M, the access succeeds. Otherwise, if the
L bit is set or the privilege mode of the access is S or U, then the access
succeeds only if the R, W, or X bit corresponding to the access type is set.</p>
<p>If no PMP entry matches an M-mode access, the access succeeds. If no PMP
entry matches an S-mode or U-mode access, but at least one PMP entry is
implemented, the access fails.</p>
<div class=commentary>
<p>If at least one PMP entry is implemented, but all PMP entries’ A fields are
set to OFF, then all S-mode and U-mode memory accesses will fail.</p>
</div>
<p>Failed accesses generate an instruction, load, or store access-fault exception. Note
that a single instruction may generate multiple accesses, which may not be
mutually atomic. An access-fault exception is generated if at least one access
generated by an instruction fails, though other accesses generated by that
instruction may succeed with visible side effects. Notably, instructions that
reference virtual memory are decomposed into multiple accesses.</p>
<p>On some implementations, misaligned loads, stores, and instruction fetches may
also be decomposed into multiple accesses, some of which may succeed before an
access-fault exception occurs. In particular, a portion of a misaligned store
that passes the PMP check may become visible, even if another portion fails
the PMP check. The same behavior may manifest for floating-point stores wider
than XLEN bits (e.g., the FSD instruction in RV32D), even when the store
address is naturally aligned.</p>
<h3 id="pmp-vmem"><span class="header-section-number">3.7.2</span> Physical Memory Protection and Paging</h3>
<p>The Physical Memory Protection mechanism is designed to compose with the
page-based virtual memory systems described in Chapter <a href="supervisor.html#supervisor" data-reference-type="ref" data-reference="supervisor">[supervisor]</a>. When
paging is enabled, instructions that access virtual memory may result in
multiple physical-memory accesses, including implicit references to the page
tables. The PMP checks apply to all of these accesses. The effective
privilege mode for implicit page-table accesses is S.</p>
<p>Implementations with virtual memory are permitted to perform address
translations speculatively and earlier than required by an explicit memory
access, and are permitted to cache them in address translation cache
structures—including possibly caching the identity mappings from effective
address to physical address used in Bare translation modes and M-mode. The
PMP settings for the resulting physical address may be checked (and possibly
cached) at any point between the address translation and the explicit memory
access.
Hence, when the PMP settings are modified, M-mode software must
synchronize the PMP settings with the virtual memory system and
any PMP or address-translation caches.
This is
accomplished by executing an SFENCE.VMA instruction with <span><em>rs1</em></span>=<span>x0</span>
and <span><em>rs2</em></span>=<span>x0</span>, after the PMP CSRs are written.</p>
<p>If page-based virtual memory is not implemented,
memory accesses check the PMP settings synchronously, so no SFENCE.VMA is needed.</p>

</body>
</html>
