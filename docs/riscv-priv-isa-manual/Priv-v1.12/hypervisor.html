<html>
<head>
<title>The RISC-V Instruction Set Manual, Volume II: Privileged Architecture</title>
</head>
<body>

<table>
<tr><th colspan=2>Metadata Table</th></tr>
<tr><th>Manual Type</th><td> priv</td></tr>
<tr><th>Spec Revision</th><td> 20211203</td></tr>
<tr><th>Spec Release Date</th><td> </td></tr>
<tr><th>Git Revision</th><td> Priv-v1.12</td></tr>
<tr><th>Git URL</th><td><a href=https://github.com/riscv/riscv-isa-manual.git>https://github.com/riscv/riscv-isa-manual.git</a></td></tr>
<tr><th>Source</th><td>src/hypervisor.tex</td></tr>
<tr><th>Conversion Date</th><td>2023/09/28</td></tr>
<tr><th>License</th><td><a href=https://creativecommons.org/licenses/by/4.0/>CC-by-4.0</a></td></tr>
</table>


<h1 id="hypervisor"><span class="header-section-number">5</span> Hypervisor Extension, Version 1.0</h1>
<p>This chapter describes the RISC-V hypervisor extension, which virtualizes the
supervisor-level architecture to support the efficient hosting of guest
operating systems atop a type-1 or type-2 hypervisor.
The hypervisor extension changes supervisor mode into
<span><em>hypervisor-extended supervisor mode</em></span> (HS-mode, or <span><em>hypervisor
mode</em></span> for short), where a hypervisor or a hosting-capable operating system
runs. The hypervisor extension also adds another stage of address translation,
from <span><em>guest physical addresses</em></span> to supervisor physical addresses,
to virtualize the
memory and memory-mapped I/O subsystems for a guest operating system. HS-mode
acts the same as S-mode, but with additional instructions and CSRs that control
the new stage of address translation and support hosting a guest OS in virtual
S-mode (VS-mode).
Regular S-mode operating systems can execute without modification either in
HS-mode or as VS-mode guests.</p>
<p>In HS-mode, an OS or hypervisor interacts with the machine through the same
SBI as an OS normally does from S-mode. An HS-mode hypervisor is expected to
implement the SBI for its VS-mode guest.</p>
<p>The hypervisor extension depends on an “I” base integer ISA with
32 <span>x</span> registers (RV32I or RV64I), not RV32E, which has only
16 <span>x</span> registers.
CSR <span>mtval</span> must not be read-only zero, and
standard page-based address translation must be supported, either
Sv32 for RV32, or a minimum of Sv39 for RV64.</p>
<p>The hypervisor extension is enabled by setting bit 7 in the <span>misa</span> CSR,
which corresponds to the letter H.
RISC-V harts that implement the hypervisor extension are encouraged
not to hardwire <span>misa</span>[7], so that the extension may be disabled.</p>
<div class=commentary>
<p>The baseline privileged architecture is designed to simplify the use of classic
virtualization techniques, where a guest OS is run at user-level, as
the few privileged instructions can be easily detected and trapped.
The hypervisor extension improves virtualization performance by
reducing the frequency of these traps.</p>
<p>The hypervisor extension has been designed to be efficiently
emulable on platforms that do not implement the extension, by running
the hypervisor in S-mode and trapping into M-mode for hypervisor CSR accesses
and to maintain shadow page tables. The majority of CSR accesses for
type-2 hypervisors are valid S-mode accesses so need not be trapped.
Hypervisors can support nested virtualization analogously.</p>
</div>
<h2 id="privilege-modes"><span class="header-section-number">5.1</span> Privilege Modes</h2>
<p>The current <span><em>virtualization mode</em></span>, denoted V, indicates whether the hart
is currently executing in a guest.
When V=1, the hart is either in virtual S-mode (VS-mode), or in virtual U-mode
(VU-mode) atop a guest OS running in VS-mode.
When V=0, the hart is either in M-mode, in HS-mode, or in U-mode atop an OS
running in HS-mode.
The virtualization mode also indicates whether two-stage address translation
is active (V=1) or inactive (V=0). Table <a href="hypervisor.html#tab:HPrivModes" data-reference-type="ref" data-reference="tab:HPrivModes">1.1</a> lists the
possible privilege modes of a RISC-V hart with the hypervisor extension.</p>
<figure>
<img src="tmp.Priv-v1.12//hypervisor_00.svg" alt="Privilege modes with the hypervisor extension." id="tab:HPrivModes" /><figcaption>Privilege modes with the hypervisor extension.<span label="tab:HPrivModes"></span></figcaption>
</figure>
<p>For privilege modes U and VU, the <em>nominal privilege mode</em> is U,
and for privilege modes HS and VS, the nominal privilege mode is S.</p>
<p>HS-mode is more privileged
than VS-mode, and VS-mode is more privileged than VU-mode.
VS-mode interrupts are globally disabled when executing in U-mode.</p>
<div class=commentary>
<p>This description does not consider the possibility of U-mode or VU-mode interrupts and will be revised if an extension for user-level interrupts is adopted.</p>
</div>
<h2 id="hypervisor-and-virtual-supervisor-csrs"><span class="header-section-number">5.2</span> Hypervisor and Virtual Supervisor CSRs</h2>
<p>An OS or hypervisor running in HS-mode uses the supervisor CSRs to interact with the exception,
interrupt, and address-translation subsystems.
Additional CSRs are provided to HS-mode, but not to VS-mode, to manage
two-stage address translation and to control the behavior of a VS-mode guest:
<span>hstatus</span>, <span>hedeleg</span>, <span>hideleg</span>, <span>hvip</span>, <span>hip</span>, <span>hie</span>,
<span>hgeip</span>, <span>hgeie</span>, <span>henvcfg</span>, <span>henvcfgh</span>,
<span>hcounteren</span>, <span>htimedelta</span>, <span>htimedeltah</span>, <span>htval</span>,
<span>htinst</span>, and <span>hgatp</span>.</p>
<p>Furthermore, several <span><em>virtual supervisor</em></span> CSRs (VS CSRs) are replicas
of the normal supervisor CSRs.
For example, <span>vsstatus</span> is the VS CSR that duplicates the usual
<span>sstatus</span> CSR.</p>
<p>When V=1, the VS CSRs substitute for the corresponding supervisor CSRs,
taking over all functions of the usual supervisor CSRs except as specified
otherwise.
Instructions that normally read or modify a supervisor CSR shall instead
access the corresponding VS CSR.
When V=1, an attempt to read or write a VS CSR directly by its own
separate CSR address causes a virtual instruction exception.
(Attempts from U-mode cause an illegal instruction exception as usual.)
The VS CSRs can be accessed as themselves only from M-mode or HS-mode.</p>
<p>While V=1, the normal HS-level supervisor CSRs that are replaced by
VS CSRs retain their values but do
not affect the behavior of the machine unless specifically documented to
do so.
Conversely, when V=0, the VS CSRs do not ordinarily affect the behavior of
the machine other than being readable and writable by CSR instructions.</p>
<p>Some standard supervisor CSRs (<span>senvcfg</span>,
<span>scounteren</span>, and <span>scontext</span>,
possibly others) have no matching VS CSR.
These supervisor CSRs continue to have their usual function and
accessibility even when V=1, except with VS-mode and VU-mode substituting for
HS-mode and U-mode.
Hypervisor software is expected to manually swap the contents of these
registers as needed.</p>
<div class=commentary>
<p>Matching VS CSRs exist only for the supervisor CSRs that must be
duplicated, which are mainly those that get automatically written by
traps or that impact instruction execution immediately after trap entry
and/or right before SRET, when software alone is unable to swap a CSR at
exactly the right moment.
Currently, most supervisor CSRs fall into this category, but future ones
might not.</p>
</div>
<p>In this chapter, we use the term <span><em>HSXLEN</em></span> to refer to the effective XLEN
when executing in HS-mode, and <span><em>VSXLEN</em></span> to refer to the effective
XLEN when executing in VS-mode.</p>
<h3 id="hypervisor-status-register-hstatus"><span class="header-section-number">5.2.1</span> Hypervisor Status Register (<span>hstatus</span>)</h3>
<p>The <span>hstatus</span> register is an HSXLEN-bit read/write register
formatted as shown in Figure <a href="hypervisor.html#hstatusreg-rv32" data-reference-type="ref" data-reference="hstatusreg-rv32">1.2</a> when HSXLEN=32 and
Figure <a href="hypervisor.html#hstatusreg" data-reference-type="ref" data-reference="hstatusreg">1.3</a> when HSXLEN=64.
The <span>hstatus</span>
register provides facilities analogous to the <span>mstatus</span> register
for tracking and controlling the exception behavior of a VS-mode guest.</p>
<figure>
<img src="tmp.Priv-v1.12//hypervisor_01.svg" alt="Hypervisor status register (hstatus) when HSXLEN=32." id="hstatusreg-rv32" /><figcaption>Hypervisor status register (<span>hstatus</span>) when HSXLEN=32.<span label="hstatusreg-rv32"></span></figcaption>
</figure>
<figure>
<img src="tmp.Priv-v1.12//hypervisor_02.svg" alt="Hypervisor status register (hstatus) when HSXLEN=64." id="hstatusreg" /><figcaption>Hypervisor status register (<span>hstatus</span>) when HSXLEN=64.<span label="hstatusreg"></span></figcaption>
</figure>
<p>The VSXL field controls the effective XLEN for VS-mode (known as VSXLEN),
which may differ from the XLEN for HS-mode (HSXLEN).
When HSXLEN=32, the VSXL field does not exist, and VSXLEN=32.
When HSXLEN=64, VSXL is a <strong>WARL</strong> field that is encoded the same as the
MXL field of <span>misa</span>, shown in Table <a href="machine.html#misabase" data-reference-type="ref" data-reference="misabase">[misabase]</a> on
page .
In particular, an implementation may make VSXL be a read-only field whose
value always ensures that VSXLEN=HSXLEN.</p>
<p>If HSXLEN is changed from 32 to a wider width, and if field VSXL is not
restricted to a single value, it gets the value corresponding to the
widest supported width not wider than the new HSXLEN.</p>
<p>The <span>hstatus</span> fields VTSR, VTW, and VTVM are defined analogously to the
<span>mstatus</span> fields TSR, TW, and TVM, but affect execution only in VS-mode,
and cause virtual instruction exceptions instead of illegal instruction
exceptions.
When VTSR=1, an attempt in VS-mode to execute SRET raises a virtual
instruction exception.
When VTW=1 (and assuming <span>mstatus</span>.TW=0), an attempt in VS-mode to
execute WFI raises a virtual instruction exception if the WFI does not
complete within an implementation-specific, bounded time limit.
When VTVM=1, an attempt in VS-mode to execute SFENCE.VMA or SINVAL.VMA or to
access CSR <span>satp</span> raises a virtual instruction exception.</p>
<p>The VGEIN (Virtual Guest External Interrupt Number) field selects a guest
external interrupt source for VS-level external interrupts.
VGEIN is a <strong>WLRL</strong> field that must be able to hold values between zero
and the maximum guest external interrupt number (known as GEILEN),
inclusive.
When VGEIN=0, no guest external interrupt source is selected for VS-level
external interrupts.
GEILEN may be zero, in which case VGEIN may be read-only zero.
Guest external interrupts are explained in
Section <a href="hypervisor.html#sec:hgeinterruptregs" data-reference-type="ref" data-reference="sec:hgeinterruptregs">1.2.4</a>, and the use of VGEIN is covered
further in Section <a href="hypervisor.html#sec:hinterruptregs" data-reference-type="ref" data-reference="sec:hinterruptregs">1.2.3</a>.</p>
<p>Field HU (Hypervisor in U-mode) controls whether the virtual-machine
load/store instructions, HLV, HLVX, and HSV, can be used also in U-mode.
When HU=1, these instructions can be executed in U-mode the same as in
HS-mode.
When HU=0, all hypervisor instructions cause an illegal instruction trap
in U-mode.</p>
<div class=commentary>
<p>The HU bit allows a portion of a hypervisor to be run in U-mode for
greater protection against software bugs, while still retaining access to
a virtual machine’s memory.</p>
</div>
<p>The SPV bit (Supervisor Previous Virtualization mode) is written by the implementation
whenever a trap is taken into HS-mode.
Just as the SPP bit in <span>sstatus</span> is set to the (nominal) privilege
mode at the time of the trap, the SPV bit in <span>hstatus</span> is set to the value of the virtualization
mode V at the time of the trap. When an SRET instruction is executed when V=0,
V is set to SPV.</p>
<p>When V=1 and a trap is taken into HS-mode, bit SPVP (Supervisor Previous
Virtual Privilege) is set to the nominal privilege mode at the time of the trap,
the same as <span>sstatus</span>.SPP.
But if V=0 before a trap, SPVP is left unchanged on trap entry.
SPVP controls the effective privilege of explicit memory accesses made by
the virtual-machine load/store instructions, HLV, HLVX, and HSV.</p>
<div class=commentary>
<p>Without SPVP, if instructions HLV, HLVX, and HSV looked instead to
<span>sstatus</span>.SPP for the effective privilege of their memory accesses,
then, even with HU=1, U-mode could not access virtual machine memory at
VS-level, because to enter U-mode using SRET always leaves SPP=0.
Unlike SPP, field SPVP is untouched by transitions back-and-forth between
HS-mode and U-mode.</p>
</div>
<p>Field GVA (Guest Virtual Address) is written by the implementation
whenever a trap is taken into HS-mode.
For any trap (breakpoint, address misaligned,
access fault, page fault, or guest-page fault) that writes
a guest virtual address to <span>stval</span>, GVA is set to 1.
For any other trap into HS-mode, GVA is set to 0.</p>
<div class=commentary>
<p>For breakpoint and memory access traps
that write a nonzero value to <span>stval</span>,
GVA is redundant with field SPV (the two bits are set
the same) except when the explicit memory access of an HLV, HLVX, or HSV
instruction causes a fault.
In that case, SPV=0 but GVA=1.</p>
</div>
<p>The VSBE bit is a <strong>WARL</strong> field that controls the endianness of explicit
memory accesses made from VS-mode.
If VSBE=0, explicit load and store memory accesses made from VS-mode are
little-endian, and if VSBE=1, they are big-endian.
VSBE also controls the endianness of all implicit accesses to VS-level
memory management data structures, such as page tables.
An implementation may make VSBE a read-only field that always specifies
the same endianness as HS-mode.</p>
<h3 id="hypervisor-trap-delegation-registers-hedeleg-and-hideleg"><span class="header-section-number">5.2.2</span> Hypervisor Trap Delegation Registers (<span>hedeleg</span> and <span>hideleg</span>)</h3>
<p>Registers <span>hedeleg</span> and <span>hideleg</span> are HSXLEN-bit read/write
registers, formatted as shown in Figures <a href="hypervisor.html#hedelegreg" data-reference-type="ref" data-reference="hedelegreg">1.4</a> and
<a href="hypervisor.html#hidelegreg" data-reference-type="ref" data-reference="hidelegreg">1.5</a> respectively.
By default, all traps at any privilege level are handled in M-mode, though
M-mode usually uses the <span>medeleg</span> and <span>mideleg</span> CSRs to delegate
some traps to HS-mode. The <span>hedeleg</span> and <span>hideleg</span> CSRs allow these
traps to be further delegated to a VS-mode guest; their layout is the same
as <span>medeleg</span> and <span>mideleg</span>.</p>
<figure>
<img src="tmp.Priv-v1.12//hypervisor_03.svg" alt="Hypervisor exception delegation register (hedeleg)." id="hedelegreg" /><figcaption>Hypervisor exception delegation register (<span>hedeleg</span>).<span label="hedelegreg"></span></figcaption>
</figure>
<figure>
<img src="tmp.Priv-v1.12//hypervisor_04.svg" alt="Hypervisor interrupt delegation register (hideleg)." id="hidelegreg" /><figcaption>Hypervisor interrupt delegation register (<span>hideleg</span>).<span label="hidelegreg"></span></figcaption>
</figure>
<table>
<thead>
<tr class="header">
<th style="text-align: right;">Bit</th>
<th style="text-align: left;">Attribute</th>
<th style="text-align: left;">Corresponding Exception</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">0</td>
<td style="text-align: left;">(See text)</td>
<td style="text-align: left;">Instruction address misaligned</td>
</tr>
<tr class="even">
<td style="text-align: right;">1</td>
<td style="text-align: left;">Writable</td>
<td style="text-align: left;">Instruction access fault</td>
</tr>
<tr class="odd">
<td style="text-align: right;">2</td>
<td style="text-align: left;">Writable</td>
<td style="text-align: left;">Illegal instruction</td>
</tr>
<tr class="even">
<td style="text-align: right;">3</td>
<td style="text-align: left;">Writable</td>
<td style="text-align: left;">Breakpoint</td>
</tr>
<tr class="odd">
<td style="text-align: right;">4</td>
<td style="text-align: left;">Writable</td>
<td style="text-align: left;">Load address misaligned</td>
</tr>
<tr class="even">
<td style="text-align: right;">5</td>
<td style="text-align: left;">Writable</td>
<td style="text-align: left;">Load access fault</td>
</tr>
<tr class="odd">
<td style="text-align: right;">6</td>
<td style="text-align: left;">Writable</td>
<td style="text-align: left;">Store/AMO address misaligned</td>
</tr>
<tr class="even">
<td style="text-align: right;">7</td>
<td style="text-align: left;">Writable</td>
<td style="text-align: left;">Store/AMO access fault</td>
</tr>
<tr class="odd">
<td style="text-align: right;">8</td>
<td style="text-align: left;">Writable</td>
<td style="text-align: left;">Environment call from U-mode or VU-mode</td>
</tr>
<tr class="even">
<td style="text-align: right;">9</td>
<td style="text-align: left;">Read-only 0</td>
<td style="text-align: left;">Environment call from HS-mode</td>
</tr>
<tr class="odd">
<td style="text-align: right;">10</td>
<td style="text-align: left;">Read-only 0</td>
<td style="text-align: left;">Environment call from VS-mode</td>
</tr>
<tr class="even">
<td style="text-align: right;">11</td>
<td style="text-align: left;">Read-only 0</td>
<td style="text-align: left;">Environment call from M-mode</td>
</tr>
<tr class="odd">
<td style="text-align: right;">12</td>
<td style="text-align: left;">Writable</td>
<td style="text-align: left;">Instruction page fault</td>
</tr>
<tr class="even">
<td style="text-align: right;">13</td>
<td style="text-align: left;">Writable</td>
<td style="text-align: left;">Load page fault</td>
</tr>
<tr class="odd">
<td style="text-align: right;">15</td>
<td style="text-align: left;">Writable</td>
<td style="text-align: left;">Store/AMO page fault</td>
</tr>
<tr class="even">
<td style="text-align: right;">20</td>
<td style="text-align: left;">Read-only 0</td>
<td style="text-align: left;">Instruction guest-page fault</td>
</tr>
<tr class="odd">
<td style="text-align: right;">21</td>
<td style="text-align: left;">Read-only 0</td>
<td style="text-align: left;">Load guest-page fault</td>
</tr>
<tr class="even">
<td style="text-align: right;">22</td>
<td style="text-align: left;">Read-only 0</td>
<td style="text-align: left;">Virtual instruction</td>
</tr>
<tr class="odd">
<td style="text-align: right;">23</td>
<td style="text-align: left;">Read-only 0</td>
<td style="text-align: left;">Store/AMO guest-page fault</td>
</tr>
</tbody>
</table>
<p>A synchronous trap that has been delegated to HS-mode (using
<span>medeleg</span>) is further delegated to VS-mode if V=1 before the trap and
the corresponding <span>hedeleg</span> bit is set.
Each bit of <span>hedeleg</span> shall be either writable or read-only zero.
Many bits of <span>hedeleg</span> are required specifically to be writable or
zero, as enumerated in Table <a href="hypervisor.html#tab:hedeleg-bits" data-reference-type="ref" data-reference="tab:hedeleg-bits">[tab:hedeleg-bits]</a>.
Bit 0, corresponding to instruction address misaligned exceptions, must
be writable if IALIGN=32.</p>
<div class=commentary>
<p>Requiring that certain bits of <span>hedeleg</span> be writable reduces some of
the burden on a hypervisor to handle variations of implementation.</p>
</div>
<p>An interrupt that has been delegated to HS-mode (using <span>mideleg</span>) is
further delegated to VS-mode if the corresponding <span>hideleg</span> bit is
set.
Among bits 15:0 of <span>hideleg</span>, bits 10, 6, and 2 (corresponding
to the standard VS-level interrupts) are writable, and bits 12, 9, 5,
and 1 (corresponding to the standard S-level interrupts) are read-only
zeros.</p>
<p>When a virtual supervisor external interrupt (code 10) is delegated to
VS-mode, it is automatically translated by the machine into a supervisor
external interrupt (code 9) for VS-mode, including the value written to
<span>vscause</span> on an interrupt trap.
Likewise, a virtual supervisor timer interrupt (6) is translated into a
supervisor timer interrupt (5) for VS-mode, and a virtual supervisor
software interrupt (2) is translated into a supervisor software interrupt
(1) for VS-mode.
Similar translations may or may not be done for platform or custom
interrupt causes (codes 16 and above).</p>
<h3 id="sec:hinterruptregs"><span class="header-section-number">5.2.3</span> Hypervisor Interrupt Registers (<span>hvip</span>, <span>hip</span>, and <span>hie</span>)</h3>
<p>Register <span>hvip</span> is an HSXLEN-bit read/write register that a
hypervisor can write to indicate virtual interrupts intended for VS-mode.
Bits of <span>hvip</span> that are not writable are read-only zeros.</p>
<figure>
<img src="tmp.Priv-v1.12//hypervisor_05.svg" alt="Hypervisor virtual-interrupt-pending register (hvip)." id="hvipreg" /><figcaption>Hypervisor virtual-interrupt-pending register (<span>hvip</span>).<span label="hvipreg"></span></figcaption>
</figure>
<p>The standard portion (bits 15:0) of <span>hvip</span> is formatted as shown in
Figure <a href="hypervisor.html#hvipreg-standard" data-reference-type="ref" data-reference="hvipreg-standard">1.7</a>.
Bits VSEIP, VSTIP, and VSSIP of <span>hvip</span> are writable.
Setting VSEIP=1 in <span>hvip</span> asserts a VS-level external interrupt;
setting VSTIP asserts a VS-level timer interrupt; and setting VSSIP
asserts a VS-level software interrupt.</p>
<figure>
<img src="tmp.Priv-v1.12//hypervisor_06.svg" alt="Standard portion (bits 15:0) of hvip." id="hvipreg-standard" /><figcaption>Standard portion (bits 15:0) of <span>hvip</span>.<span label="hvipreg-standard"></span></figcaption>
</figure>
<p>Registers <span>hip</span> and <span>hie</span> are HSXLEN-bit read/write registers
that supplement HS-level’s <span>sip</span> and <span>sie</span> respectively.
The <span>hip</span> register indicates pending VS-level and hypervisor-specific
interrupts, while <span>hie</span> contains enable bits for the same interrupts.</p>
<figure>
<img src="tmp.Priv-v1.12//hypervisor_07.svg" alt="Hypervisor interrupt-pending register (hip)." id="hipreg" /><figcaption>Hypervisor interrupt-pending register (<span>hip</span>).<span label="hipreg"></span></figcaption>
</figure>
<figure>
<img src="tmp.Priv-v1.12//hypervisor_08.svg" alt="Hypervisor interrupt-enable register (hie)." id="hiereg" /><figcaption>Hypervisor interrupt-enable register (<span>hie</span>).<span label="hiereg"></span></figcaption>
</figure>
<p>For each writable bit in <span>sie</span>, the corresponding bit shall be
read-only zero in both <span>hip</span> and <span>hie</span>.
Hence, the nonzero bits in <span>sie</span> and <span>hie</span> are always mutually
exclusive, and likewise for <span>sip</span> and <span>hip</span>.</p>
<div class=commentary>
<p>The active bits of <span>hip</span> and <span>hie</span> cannot be placed in HS-level’s
<span>sip</span> and <span>sie</span> because doing so would make it impossible for
software to emulate the hypervisor extension on platforms that do not
implement it in hardware.</p>
</div>
<p>An interrupt <em>i</em> will trap to HS-mode whenever all of the
following are true:
(a) either the current operating mode is HS-mode and the SIE bit in the
<span>sstatus</span> register is set, or the current operating mode has less
privilege than HS-mode;
(b) bit <em>i</em> is set in both <span>sip</span> and <span>sie</span>, or in both
<span>hip</span> and <span>hie</span>; and
(c) bit <em>i</em> is not set in <span>hideleg</span>.</p>
<p>If bit <em>i</em> of <span>sie</span> is read-only zero, the same bit in
register <span>hip</span> may be writable or may be read-only.
When bit <em>i</em> in <span>hip</span> is writable, a pending interrupt
<em>i</em> can be cleared by writing 0 to this bit.
If interrupt <em>i</em> can become pending in <span>hip</span> but
bit <em>i</em> in <span>hip</span> is read-only, then either
the interrupt can be cleared by clearing bit <em>i</em>
of <span>hvip</span>, or the implementation must provide
some other mechanism for clearing the pending interrupt (which may
involve a call to the execution environment).</p>
<p>A bit in <span>hie</span> shall be writable if the corresponding interrupt can
ever become pending in <span>hip</span>.
Bits of <span>hie</span> that are not writable shall be read-only zero.</p>
<p>The standard portions (bits 15:0) of registers <span>hip</span> and <span>hie</span>
are formatted as shown in Figures <a href="hypervisor.html#hipreg-standard" data-reference-type="ref" data-reference="hipreg-standard">1.10</a> and
<a href="hypervisor.html#hiereg-standard" data-reference-type="ref" data-reference="hiereg-standard">1.11</a> respectively.</p>
<figure>
<img src="tmp.Priv-v1.12//hypervisor_09.svg" alt="Standard portion (bits 15:0) of hip." id="hipreg-standard" /><figcaption>Standard portion (bits 15:0) of <span>hip</span>.<span label="hipreg-standard"></span></figcaption>
</figure>
<figure>
<img src="tmp.Priv-v1.12//hypervisor_10.svg" alt="Standard portion (bits 15:0) of hie." id="hiereg-standard" /><figcaption>Standard portion (bits 15:0) of <span>hie</span>.<span label="hiereg-standard"></span></figcaption>
</figure>
<p>Bits <span>hip</span>.SGEIP and <span>hie</span>.SGEIE are the interrupt-pending and
interrupt-enable bits for guest external interrupts at supervisor level
(HS-level).
SGEIP is read-only in <span>hip</span>, and is 1 if and only if the bitwise
logical-AND of CSRs <span>hgeip</span> and <span>hgeie</span> is nonzero in any bit.
(See Section <a href="hypervisor.html#sec:hgeinterruptregs" data-reference-type="ref" data-reference="sec:hgeinterruptregs">1.2.4</a>.)</p>
<p>Bits <span>hip</span>.VSEIP and <span>hie</span>.VSEIE are the interrupt-pending and
interrupt-enable bits for VS-level external interrupts.
VSEIP is read-only in <span>hip</span>, and is the logical-OR of these interrupt
sources:</p>
<p>bit VSEIP of <span>hvip</span>;</p>
<p>the bit of <span>hgeip</span> selected by <span>hstatus</span>.VGEIN; and</p>
<p>any other platform-specific external interrupt signal directed to
VS-level.</p>
<p>Bits <span>hip</span>.VSTIP and <span>hie</span>.VSTIE are the interrupt-pending and
interrupt-enable bits for VS-level timer interrupts.
VSTIP is read-only in <span>hip</span>, and is the logical-OR of
<span>hvip</span>.VSTIP and any other platform-specific timer interrupt signal
directed to VS-level.</p>
<p>Bits <span>hip</span>.VSSIP and <span>hie</span>.VSSIE are the interrupt-pending and
interrupt-enable bits for VS-level software interrupts.
VSSIP in <span>hip</span> is an alias (writable) of the same bit in <span>hvip</span>.</p>
<p>Multiple simultaneous interrupts destined for HS-mode are handled in the
following decreasing priority order: SEI, SSI, STI, SGEI, VSEI, VSSI, VSTI.</p>
<h3 id="sec:hgeinterruptregs"><span class="header-section-number">5.2.4</span> Hypervisor Guest External Interrupt Registers (<span>hgeip</span> and <span>hgeie</span>)</h3>
<p>The <span>hgeip</span> register is an HSXLEN-bit read-only register, formatted
as shown in Figure <a href="hypervisor.html#hgeipreg" data-reference-type="ref" data-reference="hgeipreg">1.12</a>, that indicates pending guest external
interrupts for this hart.
The <span>hgeie</span> register is an HSXLEN-bit read/write register, formatted
as shown in Figure <a href="hypervisor.html#hgeiereg" data-reference-type="ref" data-reference="hgeiereg">1.13</a>, that contains enable bits for the
guest external interrupts at this hart.
Guest external interrupt number <em>i</em> corresponds with
bit <em>i</em> in both <span>hgeip</span> and <span>hgeie</span>.</p>
<figure>
<img src="tmp.Priv-v1.12//hypervisor_11.svg" alt="Hypervisor guest external interrupt-pending register (hgeip)." id="hgeipreg" /><figcaption>Hypervisor guest external interrupt-pending register (<span>hgeip</span>).<span label="hgeipreg"></span></figcaption>
</figure>
<figure>
<img src="tmp.Priv-v1.12//hypervisor_12.svg" alt="Hypervisor guest external interrupt-enable register (hgeie)." id="hgeiereg" /><figcaption>Hypervisor guest external interrupt-enable register (<span>hgeie</span>).<span label="hgeiereg"></span></figcaption>
</figure>
<p>Guest external interrupts represent interrupts directed to individual
virtual machines at VS-level.
If a RISC-V platform supports placing a physical device under the direct
control of a guest OS with minimal hypervisor intervention (known as
<em>pass-through</em> or <em>direct assignment</em> between a virtual machine
and the physical device), then, in such circumstance, interrupts from the
device are intended for a specific virtual machine.
Each bit of <span>hgeip</span> summarizes <em>all</em> pending interrupts directed
to one virtual hart, as collected and reported by an interrupt
controller.
To distinguish specific pending interrupts from multiple devices,
software must query the interrupt controller.</p>
<div class=commentary>
<p>Support for guest external interrupts requires an interrupt controller
that can collect virtual-machine-directed interrupts separately from
other interrupts.</p>
</div>
<p>The number of bits implemented in <span>hgeip</span> and <span>hgeie</span> for guest
external interrupts is  and may be zero.
This number is known as <em>GEILEN</em>.
The least-significant bits are implemented first, apart from bit 0.
Hence, if GEILEN is nonzero, bits GEILEN:1 shall be writable in
<span>hgeie</span>, and all other bit positions shall be read-only zeros in
both <span>hgeip</span> and <span>hgeie</span>.</p>
<div class=commentary>
<p>The set of guest external interrupts received and handled at one physical
hart may differ from those received at other harts.
Guest external interrupt number <em>i</em> at one physical hart is
typically expected not to be the same as guest external
interrupt <em>i</em> at any other hart.
For any one physical hart, the maximum number of virtual harts that may
directly receive guest external interrupts is limited by GEILEN.
The maximum this number can be for any implementation is 31 for RV32 and
63 for RV64, per physical hart.</p>
<p>A hypervisor is always free to <em>emulate</em> devices for any number of
virtual harts without being limited by GEILEN.
Only direct pass-through (direct assignment) of interrupts is affected by
the GEILEN limit, and the limit is on the number of virtual harts
receiving such interrupts, not the number of distinct interrupts
received.
The number of distinct interrupts a single virtual hart may receive is
determined by the interrupt controller.</p>
</div>
<p>Register <span>hgeie</span> selects the subset of guest external interrupts that
cause a supervisor-level (HS-level) guest external interrupt.
The enable bits in <span>hgeie</span> do not affect the VS-level external
interrupt signal selected from <span>hgeip</span> by <span>hstatus</span>.VGEIN.</p>
<h3 id="hypervisor-environment-configuration-registers-henvcfg-and-henvcfgh"><span class="header-section-number">5.2.5</span> 
Hypervisor Environment Configuration Registers
(<span>henvcfg</span> and <span>henvcfgh</span>)
</h3>
<p>The <span>henvcfg</span> CSR is an HSXLEN-bit read/write register,
formatted for HSXLEN=64 as shown in Figure <a href="hypervisor.html#fig:henvcfg" data-reference-type="ref" data-reference="fig:henvcfg">1.14</a>,
that controls certain
characteristics of the execution environment when virtualization mode
V=1.</p>
<figure>
<img src="tmp.Priv-v1.12//hypervisor_13.svg" alt="Hypervisor environment configuration register (henvcfg) for HSXLEN=64." id="fig:henvcfg" /><figcaption>Hypervisor environment configuration register (<span>henvcfg</span>) for HSXLEN=64.<span label="fig:henvcfg"></span></figcaption>
</figure>
<p>If bit FIOM (Fence of I/O implies Memory) is set to one in
<span>henvcfg</span>, FENCE instructions executed when V=1 are modified
so the requirement to order accesses to device I/O implies also the
requirement to order main memory accesses.
Table <a href="hypervisor.html#tab:henvcfg-FIOM" data-reference-type="ref" data-reference="tab:henvcfg-FIOM">[tab:henvcfg-FIOM]</a> details the modified interpretation of
FENCE instruction bits PI, PO, SI, and SO when FIOM=1 and V=1.</p>
<p>Similarly, when FIOM=1 and V=1,
if an atomic instruction that accesses a region ordered as device I/O
has its <span><em>aq</em></span> and/or <span><em>rl</em></span> bit set, then that instruction is ordered
as though it accesses both device I/O and memory.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Instruction bit</th>
<th style="text-align: left;">Meaning when set</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">PI</td>
<td style="text-align: left;">Predecessor device input and memory reads (PR implied)</td>
</tr>
<tr class="even">
<td style="text-align: center;">PO</td>
<td style="text-align: left;">Predecessor device output and memory writes (PW implied)</td>
</tr>
<tr class="odd">
<td style="text-align: center;">SI</td>
<td style="text-align: left;">Successor device input and memory reads (SR implied)</td>
</tr>
<tr class="even">
<td style="text-align: center;">SO</td>
<td style="text-align: left;">Successor device output and memory writes (SW implied)</td>
</tr>
</tbody>
</table>
<p>The PBMTE bit controls whether the Svpbmt extension is available for use in
VS-stage address translation.
When PBMTE=1, Svpbmt is available for VS-stage address translation.
When PBMTE=0, the implementation behaves as though Svpbmt were not implemented
for VS-stage address translation.
If Svpbmt is not implemented, PBMTE is read-only zero.</p>
<p>The definition of the VSTCE field will be furnished by the
forthcoming Sstc extension.
Its allocation within <span>henvcfg</span> may change prior to the ratification
of that extension.</p>
<p>The definition of the CBZE field will be furnished by the
forthcoming Zicboz extension.
Its allocation within <span>henvcfg</span> may change prior to the ratification
of that extension.</p>
<p>The definitions of the CBCFE and CBIE fields will be furnished by the
forthcoming Zicbom extension.
Their allocations within <span>henvcfg</span> may change prior to the ratification
of that extension.</p>
<p>When HSXLEN=32, <span>henvcfg</span> contains the same fields as bits 31:0
of <span>henvcfg</span> when HSXLEN=64.
Additionally, when HSXLEN=32, <span>henvcfgh</span> is a 32-bit read/write register that
contains the same fields as bits 63:32 of <span>henvcfg</span> when
HSXLEN=64.
Register <span>henvcfgh</span> does not exist when HSXLEN=64.</p>
<h3 id="hypervisor-counter-enable-register-hcounteren"><span class="header-section-number">5.2.6</span> Hypervisor Counter-Enable Register (<span>hcounteren</span>)</h3>
<p>The counter-enable register <span>hcounteren</span> is a 32-bit register that
controls the availability of the hardware performance monitoring counters
to the guest virtual machine.</p>
<figure>
<img src="tmp.Priv-v1.12//hypervisor_14.svg" alt="Hypervisor counter-enable register (hcounteren)." id="hcounteren" /><figcaption>Hypervisor counter-enable register (<span>hcounteren</span>).<span label="hcounteren"></span></figcaption>
</figure>
<p>When the CY, TM, IR, or HPM<span><em>n</em></span> bit in the <span>hcounteren</span> register
is clear, attempts to read the <span>cycle</span>, <span>time</span>, <span>instret</span>, or
<span>hpmcounter</span><span><em>n</em></span> register while V=1 will cause a virtual
instruction exception if the same bit in <span>mcounteren</span> is 1.
When one of these bits is set, access to the corresponding register is
permitted when V=1, unless prevented for some other reason.
In VU-mode, a counter is not readable unless the applicable bits are set
in both <span>hcounteren</span> and <span>scounteren</span>.</p>
<p><span>hcounteren</span> must be implemented.
However, any of the bits may be read-only zero,
indicating reads to the corresponding counter will cause an exception
when V=1.
Hence, they are effectively <strong>WARL</strong> fields.</p>
<h3 id="hypervisor-time-delta-registers-htimedelta-htimedeltah"><span class="header-section-number">5.2.7</span> Hypervisor Time Delta Registers (<span>htimedelta</span>, <span>htimedeltah</span>)</h3>
<p>The <span>htimedelta</span> CSR is a read/write register that contains the delta
between the value of the <span>time</span> CSR and the value returned in VS-mode or
VU-mode.
That is, reading the <span>time</span> CSR in VS or VU mode returns the sum of the
contents of <span>htimedelta</span> and the actual value of <span>time</span>.</p>
<div class=commentary>
<p>Because overflow is ignored when summing <span>htimedelta</span> and <span>time</span>,
large values of <span>htimedelta</span> may be used to represent negative time
offsets.</p>
</div>
<figure>
<img src="tmp.Priv-v1.12//hypervisor_15.svg" alt="Hypervisor time delta register, HSXLEN=64." id="hdeltareg" /><figcaption>Hypervisor time delta register, HSXLEN=64.<span label="hdeltareg"></span></figcaption>
</figure>
<p>For HSXLEN=32 only, <span>htimedelta</span> holds the lower 32 bits of the
delta, and <span>htimedeltah</span> holds the upper 32 bits of the delta.</p>
<figure>
<img src="tmp.Priv-v1.12//hypervisor_16.svg" alt="Hypervisor time delta registers, HSXLEN=32." id="hdeltahreg" /><figcaption>Hypervisor time delta registers, HSXLEN=32.<span label="hdeltahreg"></span></figcaption>
</figure>
<h3 id="hypervisor-trap-value-register-htval"><span class="header-section-number">5.2.8</span> Hypervisor Trap Value Register (<span>htval</span>)</h3>
<p>The <span>htval</span> register is an HSXLEN-bit read/write register formatted
as shown in Figure <a href="hypervisor.html#htvalreg" data-reference-type="ref" data-reference="htvalreg">1.18</a>.
When a trap is taken into HS-mode, <span>htval</span> is written with additional
exception-specific information, alongside <span>stval</span>, to assist software
in handling the trap.</p>
<figure>
<img src="tmp.Priv-v1.12//hypervisor_17.svg" alt="Hypervisor trap value register (htval)." id="htvalreg" /><figcaption>Hypervisor trap value register (<span>htval</span>).<span label="htvalreg"></span></figcaption>
</figure>
<p>When a guest-page-fault trap is taken into HS-mode, <span>htval</span> is
written with either zero or the guest physical address that faulted,
shifted right by 2 bits.
For other traps, <span>htval</span> is set to zero, but a future standard or
extension may redefine <span>htval</span>’s setting for other traps.</p>
<p>A guest-page fault may arise due to an implicit memory access during
first-stage (VS-stage) address translation, in which case a guest
physical address written to <span>htval</span> is that of the implicit memory
access that faulted—for example, the address of a VS-level page table
entry that could not be read.
(The guest physical address corresponding to the original virtual address
is unknown when VS-stage translation fails to complete.)
Additional information is provided in CSR <span>htinst</span> to disambiguate
such situations.</p>
<p>Otherwise, for misaligned loads and stores that cause guest-page faults,
a nonzero guest physical address in <span>htval</span> corresponds to the
faulting portion of the access as indicated by the virtual address in
<span>stval</span>.
For instruction guest-page faults on systems with variable-length
instructions, a nonzero <span>htval</span> corresponds to the faulting portion
of the instruction as indicated by the virtual address in <span>stval</span>.</p>
<div class=commentary>
<p>A guest physical address written to <span>htval</span> is shifted right by
2 bits to accommodate addresses wider than the current XLEN.
For RV32, the hypervisor extension permits guest physical addresses as
wide as 34 bits, and <span>htval</span> reports bits 33:2 of the address.
This shift-by-2 encoding of guest physical addresses matches the encoding
of physical addresses in PMP address registers (Section <a href="machine.html#sec:pmp" data-reference-type="ref" data-reference="sec:pmp">[sec:pmp]</a>)
and in page table entries (Sections <a href="supervisor.html#sec:sv32" data-reference-type="ref" data-reference="sec:sv32">[sec:sv32]</a>, <a href="supervisor.html#sec:sv39" data-reference-type="ref" data-reference="sec:sv39">[sec:sv39]</a>,
<a href="supervisor.html#sec:sv48" data-reference-type="ref" data-reference="sec:sv48">[sec:sv48]</a>, and <a href="supervisor.html#sec:sv57" data-reference-type="ref" data-reference="sec:sv57">[sec:sv57]</a>).</p>
<p>If the least-significant two bits of a faulting guest physical address
are needed, these bits are ordinarily the same as the least-significant
two bits of the faulting virtual address in <span>stval</span>.
For faults due to implicit memory accesses for VS-stage address
translation, the least-significant two bits are instead zeros.
These cases can be distinguished using the value provided in register
<span>htinst</span>.</p>
</div>
<p><span>htval</span> is a <strong>WARL</strong> register that must be able to hold zero and may
be capable of holding only an arbitrary subset of other 2-bit-shifted
guest physical addresses, if any.</p>
<div class=commentary>
<p>Unless it has reason to assume otherwise (such as a platform standard),
software that writes a value to <span>htval</span> should read back from
<span>htval</span> to confirm the stored value.</p>
</div>
<h3 id="hypervisor-trap-instruction-register-htinst"><span class="header-section-number">5.2.9</span> Hypervisor Trap Instruction Register (<span>htinst</span>)</h3>
<p>The <span>htinst</span> register is an HSXLEN-bit read/write register formatted
as shown in Figure <a href="hypervisor.html#htinstreg" data-reference-type="ref" data-reference="htinstreg">1.19</a>.
When a trap is taken into HS-mode, <span>htinst</span> is written with a value
that, if nonzero, provides information about the instruction that
trapped, to assist software in handling the trap.
The values that may be written to <span>htinst</span> on a trap are documented
in Section <a href="hypervisor.html#sec:tinst-vals" data-reference-type="ref" data-reference="sec:tinst-vals">1.6.3</a>.</p>
<figure>
<img src="tmp.Priv-v1.12//hypervisor_18.svg" alt="Hypervisor trap instruction register (htinst)." id="htinstreg" /><figcaption>Hypervisor trap instruction register (<span>htinst</span>).<span label="htinstreg"></span></figcaption>
</figure>
<p><span>htinst</span> is a <strong>WARL</strong> register that need only be able to hold the
values that the implementation may automatically write to it on a trap.</p>
<h3 id="sec:hgatp"><span class="header-section-number">5.2.10</span> Hypervisor Guest Address Translation and Protection Register (<span>hgatp</span>)</h3>
<p>The <span>hgatp</span> register is an HSXLEN-bit read/write register, formatted as
shown in Figure <a href="hypervisor.html#rv32hgatp" data-reference-type="ref" data-reference="rv32hgatp">1.20</a> for HSXLEN=32 and Figure <a href="hypervisor.html#rv64hgatp" data-reference-type="ref" data-reference="rv64hgatp">1.21</a> for
HSXLEN=64, which controls G-stage address translation and protection, the
second stage of two-stage translation for guest virtual addresses (see
Section <a href="hypervisor.html#sec:two-stage-translation" data-reference-type="ref" data-reference="sec:two-stage-translation">1.5</a>).
Similar to CSR <span>satp</span>, this register holds the physical page number (PPN)
of the guest-physical root page table; a virtual machine identifier (VMID),
which facilitates address-translation fences on a per-virtual-machine basis;
and the MODE field, which selects the address-translation scheme for guest
physical addresses.
When <span>mstatus</span>.TVM=1, attempts to read or write <span>hgatp</span> while executing
in HS-mode will raise an illegal instruction exception.</p>
<figure>
<img src="tmp.Priv-v1.12//hypervisor_19.svg" alt="Hypervisor guest address translation and protection register hgatp when HSXLEN=32." id="rv32hgatp" /><figcaption>Hypervisor guest address translation and protection register
<span>hgatp</span> when HSXLEN=32.<span label="rv32hgatp"></span></figcaption>
</figure>
<figure>
<img src="tmp.Priv-v1.12//hypervisor_20.svg" alt="Hypervisor guest address translation and protection register hgatp when HSXLEN=64, for MODE values Bare, Sv39x4, Sv48x4, and Sv57x4." id="rv64hgatp" /><figcaption>Hypervisor guest address translation and protection register
<span>hgatp</span> when HSXLEN=64, for MODE values Bare, Sv39x4, Sv48x4, and Sv57x4.<span label="rv64hgatp"></span></figcaption>
</figure>
<p>Table <a href="hypervisor.html#tab:hgatp-mode" data-reference-type="ref" data-reference="tab:hgatp-mode">1.22</a> shows the encodings of the MODE field when HSXLEN=32 and
HSXLEN=64.
When MODE=Bare, guest physical addresses are equal to supervisor physical
addresses, and there is no further memory protection for a guest virtual
machine beyond the physical memory protection scheme described in
Section <a href="machine.html#sec:pmp" data-reference-type="ref" data-reference="sec:pmp">[sec:pmp]</a>.
In this case, the remaining fields in <span>hgatp</span> must be set to zeros.</p>
<p>When HSXLEN=32, the only other valid setting for MODE is Sv32x4, which is a
modification of the usual Sv32 paged virtual-memory scheme, extended to support
34-bit guest physical addresses.
When HSXLEN=64, modes Sv39x4, Sv48x4, and Sv57x4 are defined as modifications of the
Sv39, Sv48, and Sv57 paged virtual-memory schemes.
All of these paged virtual-memory schemes are described in
Section <a href="hypervisor.html#sec:guest-addr-translation" data-reference-type="ref" data-reference="sec:guest-addr-translation">1.5.1</a>.</p>
<p>The remaining MODE settings when HSXLEN=64 are reserved for future use and may define
different interpretations of the other fields in <span>hgatp</span>.</p>
<figure>
<img src="tmp.Priv-v1.12//hypervisor_21.svg" alt="Encoding of hgatp MODE field." id="tab:hgatp-mode" /><figcaption>Encoding of <span>hgatp</span> MODE field.<span label="tab:hgatp-mode"></span></figcaption>
</figure>
<p>Implementations are not required to support all defined MODE
settings when HSXLEN=64.</p>
<p>A write to <span>hgatp</span> with an unsupported MODE value is not ignored as it is
for <span>satp</span>.
Instead, the fields of <span>hgatp</span> are <span><strong>WARL</strong></span> in the normal way, when so
indicated.</p>
<p>As explained in Section <a href="hypervisor.html#sec:guest-addr-translation" data-reference-type="ref" data-reference="sec:guest-addr-translation">1.5.1</a>, for the paged
virtual-memory schemes (Sv32x4, Sv39x4, Sv48x4, and Sv57x4), the root page table is
16 KiB and must be aligned to a 16-KiB boundary.
In these modes, the lowest two bits of the physical page number (PPN) in
<span>hgatp</span> always read as zeros.
An implementation that supports only the defined paged virtual-memory schemes
and/or Bare may make PPN[1:0] read-only zero.</p>
<p>The number of VMID bits is  and may be zero.
The number of implemented VMID bits, termed <span><span><em>VMIDLEN</em></span> </span>, may be
determined by writing one to every bit position in the VMID field, then reading
back the value in <span>hgatp</span> to see which bit positions in the VMID field hold
a one.
The least-significant bits of VMID are implemented first:
that is, if VMIDLEN <span class="math inline">&gt;</span> 0, VMID[VMIDLEN-1:0] is writable.
The maximal value of VMIDLEN, termed VMIDMAX, is 7 for Sv32x4 or 14 for Sv39x4,
Sv48x4, and Sv57x4.</p>
<p>The <span>hgatp</span> register is considered <span><em>active</em></span> for the purposes of the
address-translation algorithm <span><em>unless</em></span> the effective privilege mode is U
and <span>hstatus</span>.HU=0.</p>
<div class=commentary>
<p>This definition simplifies the implementation of speculative execution of
HLV, HLVX, and HSV instructions.</p>
</div>
<p>Note that writing <span>hgatp</span> does not imply any ordering constraints between
page-table updates and subsequent G-stage address translations.
If the new virtual machine’s guest physical page tables have been modified,
or if a VMID is reused,
it may be necessary to execute an HFENCE.GVMA instruction
(see Section <a href="hypervisor.html#sec:hfence.vma" data-reference-type="ref" data-reference="sec:hfence.vma">1.3.2</a>) before or after writing <span>hgatp</span>.</p>
<h3 id="virtual-supervisor-status-register-vsstatus"><span class="header-section-number">5.2.11</span> Virtual Supervisor Status Register (<span>vsstatus</span>)</h3>
<p>The <span>vsstatus</span> register is a VSXLEN-bit read/write register that is
VS-mode’s version of supervisor register <span>sstatus</span>, formatted as
shown in Figure <a href="hypervisor.html#vsstatusreg-rv32" data-reference-type="ref" data-reference="vsstatusreg-rv32">1.23</a> when VSXLEN=32 and
Figure <a href="hypervisor.html#vsstatusreg" data-reference-type="ref" data-reference="vsstatusreg">1.24</a> when VSXLEN=64.
When V=1, <span>vsstatus</span> substitutes for the usual <span>sstatus</span>, so
instructions that normally read or modify <span>sstatus</span> actually access
<span>vsstatus</span> instead.</p>
<figure>
<img src="tmp.Priv-v1.12//hypervisor_22.svg" alt="Virtual supervisor status register (vsstatus) when VSXLEN=32." id="vsstatusreg-rv32" /><figcaption>Virtual supervisor status register (<span>vsstatus</span>) when VSXLEN=32.<span label="vsstatusreg-rv32"></span></figcaption>
</figure>
<figure>
<img src="tmp.Priv-v1.12//hypervisor_23.svg" alt="Virtual supervisor status register (vsstatus) when VSXLEN=64." id="vsstatusreg" /><figcaption>Virtual supervisor status register (<span>vsstatus</span>) when VSXLEN=64.<span label="vsstatusreg"></span></figcaption>
</figure>
<p>The UXL field controls the effective XLEN for VU-mode, which may differ
from the XLEN for VS-mode (VSXLEN).
When VSXLEN=32, the UXL field does not exist, and VU-mode XLEN=32.
When VSXLEN=64, UXL is a <strong>WARL</strong> field that is encoded the same as the MXL
field of <span>misa</span>, shown in Table <a href="machine.html#misabase" data-reference-type="ref" data-reference="misabase">[misabase]</a> on
page .
In particular, an implementation may make UXL be a read-only copy of
field VSXL of <span>hstatus</span>, forcing VU-mode XLEN=VSXLEN.</p>
<p>If VSXLEN is changed from 32 to a wider width, and if field UXL is not
restricted to a single value, it gets the value corresponding to the
widest supported width not wider than the new VSXLEN.</p>
<p>When V=1, both <span>vsstatus</span>.FS and the HS-level <span>sstatus</span>.FS are in
effect. Attempts
to execute a floating-point instruction when either field is 0 (Off) raise an
illegal-instruction exception. Modifying the floating-point state when V=1
causes both fields to be set to 3 (Dirty).</p>
<div class=commentary>
<p>For a hypervisor to benefit from the extension context status, it must
have its own copy in the HS-level <span>sstatus</span>, maintained independently
of a guest OS running in VS-mode.
While a version of the extension context status obviously must exist in
<span>vsstatus</span> for VS-mode, a hypervisor cannot rely on this version
being maintained correctly, given that VS-level software can change
<span>vsstatus</span>.FS arbitrarily.
If the HS-level <span>sstatus</span>.FS were not independently active and
maintained by the hardware in parallel with <span>vsstatus</span>.FS while V=1,
hypervisors would always be forced to conservatively swap all
floating-point state when context-switching between virtual machines.</p>
</div>
<p>Similarly, when V=1, both <span>vsstatus</span>.VS and the HS-level <span>sstatus</span>.VS
are in effect.
Attempts to execute a vector instruction when either field is 0 (Off) raise an
illegal-instruction exception.
Modifying the vector state when V=1 causes both fields to be set to 3 (Dirty).</p>
<p>Read-only fields SD and XS summarize the extension context status as it
is visible to VS-mode only.
For example, the value of the HS-level <span>sstatus</span>.FS does not affect
<span>vsstatus</span>.SD.</p>
<p>An implementation may make field UBE be a read-only copy of
<span>hstatus</span>.VSBE.</p>
<p>When V=0, <span>vsstatus</span> does not directly affect the behavior of the machine,
unless a virtual-machine load/store (HLV, HLVX, or HSV)
or the MPRV feature in the <span>mstatus</span>
register is used to execute a load or store
<span><em>as though</em></span> V=1.</p>
<h3 id="virtual-supervisor-interrupt-registers-vsip-and-vsie"><span class="header-section-number">5.2.12</span> Virtual Supervisor Interrupt Registers (<span>vsip</span> and <span>vsie</span>)</h3>
<p>The <span>vsip</span> and <span>vsie</span> registers are VSXLEN-bit read/write
registers that are VS-mode’s versions of supervisor CSRs <span>sip</span> and
<span>sie</span>, formatted as shown in Figures <a href="hypervisor.html#vsipreg" data-reference-type="ref" data-reference="vsipreg">1.25</a> and <a href="hypervisor.html#vsiereg" data-reference-type="ref" data-reference="vsiereg">1.26</a>
respectively.
When V=1, <span>vsip</span> and <span>vsie</span> substitute for the usual <span>sip</span>
and <span>sie</span>, so instructions that normally read or modify
<span>sip</span>/<span>sie</span> actually access <span>vsip</span>/<span>vsie</span> instead.
However, interrupts directed to HS-level continue to be
indicated in the HS-level <span>sip</span> register, not in <span>vsip</span>, when
V=1.</p>
<figure>
<img src="tmp.Priv-v1.12//hypervisor_24.svg" alt="Virtual supervisor interrupt-pending register (vsip)." id="vsipreg" /><figcaption>Virtual supervisor interrupt-pending register (<span>vsip</span>).<span label="vsipreg"></span></figcaption>
</figure>
<figure>
<img src="tmp.Priv-v1.12//hypervisor_25.svg" alt="Virtual supervisor interrupt-enable register (vsie)." id="vsiereg" /><figcaption>Virtual supervisor interrupt-enable register (<span>vsie</span>).<span label="vsiereg"></span></figcaption>
</figure>
<p>The standard portions (bits 15:0) of registers <span>vsip</span> and <span>vsie</span>
are formatted as shown in Figures <a href="hypervisor.html#vsipreg-standard" data-reference-type="ref" data-reference="vsipreg-standard">1.27</a> and
<a href="hypervisor.html#vsiereg-standard" data-reference-type="ref" data-reference="vsiereg-standard">1.28</a> respectively.</p>
<figure>
<img src="tmp.Priv-v1.12//hypervisor_26.svg" alt="Standard portion (bits 15:0) of vsip." id="vsipreg-standard" /><figcaption>Standard portion (bits 15:0) of <span>vsip</span>.<span label="vsipreg-standard"></span></figcaption>
</figure>
<figure>
<img src="tmp.Priv-v1.12//hypervisor_27.svg" alt="Standard portion (bits 15:0) of vsie." id="vsiereg-standard" /><figcaption>Standard portion (bits 15:0) of <span>vsie</span>.<span label="vsiereg-standard"></span></figcaption>
</figure>
<p>When bit 10 of <span>hideleg</span> is zero, <span>vsip</span>.SEIP and <span>vsie</span>.SEIE
are read-only zeros.
Else, <span>vsip</span>.SEIP and <span>vsie</span>.SEIE are aliases of <span>hip</span>.VSEIP
and <span>hie</span>.VSEIE.</p>
<p>When bit 6 of <span>hideleg</span> is zero, <span>vsip</span>.STIP and <span>vsie</span>.STIE
are read-only zeros.
Else, <span>vsip</span>.STIP and <span>vsie</span>.STIE are aliases of <span>hip</span>.VSTIP
and <span>hie</span>.VSTIE.</p>
<p>When bit 2 of <span>hideleg</span> is zero, <span>vsip</span>.SSIP and <span>vsie</span>.SSIE
are read-only zeros.
Else, <span>vsip</span>.SSIP and <span>vsie</span>.SSIE are aliases of <span>hip</span>.VSSIP
and <span>hie</span>.VSSIE.</p>
<h3 id="virtual-supervisor-trap-vector-base-address-register-vstvec"><span class="header-section-number">5.2.13</span> Virtual Supervisor Trap Vector Base Address Register (<span>vstvec</span>)</h3>
<p>The <span>vstvec</span> register is a VSXLEN-bit read/write register that is
VS-mode’s version of supervisor register <span>stvec</span>, formatted as shown
in Figure <a href="hypervisor.html#vstvecreg" data-reference-type="ref" data-reference="vstvecreg">1.29</a>.
When V=1, <span>vstvec</span> substitutes for the usual <span>stvec</span>, so
instructions that normally read or modify <span>stvec</span> actually access
<span>vstvec</span> instead.
When V=0, <span>vstvec</span> does not directly affect the behavior of the
machine.</p>
<figure>
<img src="tmp.Priv-v1.12//hypervisor_28.svg" alt="Virtual supervisor trap vector base address register (vstvec)." id="vstvecreg" /><figcaption>Virtual supervisor trap vector base address register (<span>vstvec</span>).<span label="vstvecreg"></span></figcaption>
</figure>
<h3 id="virtual-supervisor-scratch-register-vsscratch"><span class="header-section-number">5.2.14</span> Virtual Supervisor Scratch Register (<span>vsscratch</span>)</h3>
<p>The <span>vsscratch</span> register is a VSXLEN-bit read/write register that is
VS-mode’s version of supervisor register <span>sscratch</span>, formatted as
shown in Figure <a href="hypervisor.html#vsscratchreg" data-reference-type="ref" data-reference="vsscratchreg">1.30</a>.
When V=1, <span>vsscratch</span> substitutes for the usual <span>sscratch</span>, so
instructions that normally read or modify <span>sscratch</span> actually access
<span>vsscratch</span> instead.
The contents of <span>vsscratch</span> never directly affect the behavior of
the machine.</p>
<figure>
<img src="tmp.Priv-v1.12//hypervisor_29.svg" alt="Virtual supervisor scratch register (vsscratch)." id="vsscratchreg" /><figcaption>Virtual supervisor scratch register (<span>vsscratch</span>).<span label="vsscratchreg"></span></figcaption>
</figure>
<h3 id="virtual-supervisor-exception-program-counter-vsepc"><span class="header-section-number">5.2.15</span> Virtual Supervisor Exception Program Counter (<span>vsepc</span>)</h3>
<p>The <span>vsepc</span> register is a VSXLEN-bit read/write register that is
VS-mode’s version of supervisor register <span>sepc</span>, formatted as shown
in Figure <a href="hypervisor.html#vsepcreg" data-reference-type="ref" data-reference="vsepcreg">1.31</a>.
When V=1, <span>vsepc</span> substitutes for the usual <span>sepc</span>, so
instructions that normally read or modify <span>sepc</span> actually access
<span>vsepc</span> instead.
When V=0, <span>vsepc</span> does not directly affect the behavior of the
machine.</p>
<p><span>vsepc</span> is a <strong>WARL</strong> register that must be able to hold the same set of
values that <span>sepc</span> can hold.</p>
<figure>
<img src="tmp.Priv-v1.12//hypervisor_30.svg" alt="Virtual supervisor exception program counter (vsepc)." id="vsepcreg" /><figcaption>Virtual supervisor exception program counter (<span>vsepc</span>).<span label="vsepcreg"></span></figcaption>
</figure>
<h3 id="virtual-supervisor-cause-register-vscause"><span class="header-section-number">5.2.16</span> Virtual Supervisor Cause Register (<span>vscause</span>)</h3>
<p>The <span>vscause</span> register is a VSXLEN-bit read/write register that is
VS-mode’s version of supervisor register <span>scause</span>, formatted as shown
in Figure <a href="hypervisor.html#vscausereg" data-reference-type="ref" data-reference="vscausereg">1.32</a>.
When V=1, <span>vscause</span> substitutes for the usual <span>scause</span>, so
instructions that normally read or modify <span>scause</span> actually access
<span>vscause</span> instead.
When V=0, <span>vscause</span> does not directly affect the behavior of the
machine.</p>
<p><span>vscause</span> is a <strong>WLRL</strong> register that must be able to hold the same set of
values that <span>scause</span> can hold.</p>
<figure>
<img src="tmp.Priv-v1.12//hypervisor_31.svg" alt="Virtual supervisor cause register (vscause)." id="vscausereg" /><figcaption>Virtual supervisor cause register (<span>vscause</span>).<span label="vscausereg"></span></figcaption>
</figure>
<h3 id="virtual-supervisor-trap-value-register-vstval"><span class="header-section-number">5.2.17</span> Virtual Supervisor Trap Value Register (<span>vstval</span>)</h3>
<p>The <span>vstval</span> register is a VSXLEN-bit read/write register that is
VS-mode’s version of supervisor register <span>stval</span>, formatted as shown
in Figure <a href="hypervisor.html#vstvalreg" data-reference-type="ref" data-reference="vstvalreg">1.33</a>.
When V=1, <span>vstval</span> substitutes for the usual <span>stval</span>, so
instructions that normally read or modify <span>stval</span> actually access
<span>vstval</span> instead.
When V=0, <span>vstval</span> does not directly affect the behavior of the
machine.</p>
<p><span>vstval</span> is a <strong>WARL</strong> register that must be able to hold the same set of
values that <span>stval</span> can hold.</p>
<figure>
<img src="tmp.Priv-v1.12//hypervisor_32.svg" alt="Virtual supervisor trap value register (vstval)." id="vstvalreg" /><figcaption>Virtual supervisor trap value register (<span>vstval</span>).<span label="vstvalreg"></span></figcaption>
</figure>
<h3 id="virtual-supervisor-address-translation-and-protection-register-vsatp"><span class="header-section-number">5.2.18</span> Virtual Supervisor Address Translation and Protection Register (<span>vsatp</span>)</h3>
<p>The <span>vsatp</span> register is a VSXLEN-bit read/write register that is
VS-mode’s version of supervisor register <span>satp</span>, formatted as shown
in Figure <a href="hypervisor.html#rv32vsatpreg" data-reference-type="ref" data-reference="rv32vsatpreg">1.34</a> for VSXLEN=32 and Figure <a href="hypervisor.html#rv64vsatpreg" data-reference-type="ref" data-reference="rv64vsatpreg">1.35</a>
for VSXLEN=64.
When V=1, <span>vsatp</span> substitutes for the usual <span>satp</span>, so
instructions that normally read or modify <span>satp</span> actually access
<span>vsatp</span> instead.
<span>vsatp</span> controls VS-stage address translation, the first stage of
two-stage translation for guest virtual addresses (see
Section <a href="hypervisor.html#sec:two-stage-translation" data-reference-type="ref" data-reference="sec:two-stage-translation">1.5</a>).</p>
<figure>
<img src="tmp.Priv-v1.12//hypervisor_33.svg" alt="Virtual supervisor address translation and protection register vsatp when VSXLEN=32." id="rv32vsatpreg" /><figcaption>Virtual supervisor address translation and protection register <span>vsatp</span> when VSXLEN=32.<span label="rv32vsatpreg"></span></figcaption>
</figure>
<figure>
<img src="tmp.Priv-v1.12//hypervisor_34.svg" alt="Virtual supervisor address translation and protection register vsatp when VSXLEN=64, for MODE values Bare, Sv39, Sv48, and Sv57." id="rv64vsatpreg" /><figcaption>Virtual supervisor address translation and protection register <span>vsatp</span> when VSXLEN=64, for MODE
values Bare, Sv39, Sv48, and Sv57.<span label="rv64vsatpreg"></span></figcaption>
</figure>
<p>The <span>vsatp</span> register is considered <span><em>active</em></span> for the purposes of the
address-translation algorithm <span><em>unless</em></span> the effective privilege mode is U
and <span>hstatus</span>.HU=0.
However, even when <span>vsatp</span> is active, VS-stage page-table entries’ A bits
must not be set as a result of speculative execution, unless the effective
privilege mode is VS or VU.</p>
<div class=commentary>
<p>In particular, virtual-machine load/store (HLV, HLVX, or HSV) instructions
that are misspeculatively executed must not cause VS-stage A bits to be set.</p>
</div>
<p>When V=0, a write to <span>vsatp</span> with an unsupported MODE value is not
ignored as it is for <span>satp</span>.
Instead, the fields of <span>vsatp</span> are <span><strong>WARL</strong></span> in the normal way.</p>
<p>When V=0, <span>vsatp</span> does not directly affect the behavior of the machine,
unless a virtual-machine load/store (HLV, HLVX, or HSV)
or the MPRV feature in the <span>mstatus</span>
register is used to execute a load or store
<span><em>as though</em></span> V=1.</p>
<h2 id="hypervisor-instructions"><span class="header-section-number">5.3</span> Hypervisor Instructions</h2>
<p>The hypervisor extension adds virtual-machine load and store instructions
and two privileged fence instructions.</p>
<h3 id="hypervisor-virtual-machine-load-and-store-instructions"><span class="header-section-number">5.3.1</span> Hypervisor Virtual-Machine Load and Store Instructions</h3>
<p><img src="tmp.Priv-v1.12//hypervisor_35.svg" alt="image" /></p>
<p>The hypervisor virtual-machine load and store instructions are valid only
in M-mode or HS-mode, or in U-mode when <span>hstatus</span>.HU=1.
Each instruction performs an explicit memory access as though V=1;
i.e., with the address translation and protection, and the endianness,
that apply to memory accesses in either VS-mode or VU-mode.
Field SPVP of <span>hstatus</span> controls the privilege level of the access.
The explicit memory access is done as though in VU-mode when SPVP=0, and
as though in VS-mode when SPVP=1.
As usual when V=1, two-stage address translation is applied, and the
HS-level <span>sstatus</span>.SUM is ignored.
HS-level <span>sstatus</span>.MXR makes execute-only pages readable for
both stages of address translation (VS-stage and G-stage), whereas
<span>vsstatus</span>.MXR affects only the first translation stage (VS-stage).</p>
<p>For every RV32I or RV64I load instruction, LB, LBU, LH, LHU, LW, LWU,
and LD, there is a corresponding virtual-machine load instruction:
HLV.B, HLV.BU, HLV.H, HLV.HU, HLV.W, HLV.WU, and HLV.D.
For every RV32I or RV64I store instruction, SB, SH, SW, and SD, there is
a corresponding virtual-machine store instruction: HSV.B, HSV.H, HSV.W,
and HSV.D.
Instructions HLV.WU, HLV.D, and HSV.D are not valid for RV32, of course.</p>
<p>Instructions HLVX.HU and HLVX.WU are the same as HLV.HU and HLV.WU,
except that <em>execute</em> permission takes the place of <em>read</em>
permission during address translation.
That is, the memory being read must be executable in both stages of
address translation, but read permission is not required.
For the supervisor physical address that results from address
translation, the supervisor physical memory attributes must grant both
<em>execute</em> and <em>read</em> permissions.
(The <em>supervisor physical memory attributes</em> are the machine’s
physical memory attributes as modified by physical memory protection,
Section <a href="machine.html#sec:pmp" data-reference-type="ref" data-reference="sec:pmp">[sec:pmp]</a>, for supervisor level.)</p>
<div class=commentary>
<p>HLVX cannot override machine-level physical memory protection (PMP),
so attempting to read memory that PMP designates as execute-only still
results in an access-fault exception.</p>
</div>
<p>HLVX.WU is valid for RV32, even though LWU and HLV.WU are not.
(For RV32, HLVX.WU can be considered a variant of HLV.W, as sign
extension is irrelevant for 32-bit values.)</p>
<p>Attempts to execute a virtual-machine load/store instruction (HLV, HLVX,
or HSV) when V=1 cause a virtual instruction trap.
Attempts to execute one of these same instructions from U-mode when
<span>hstatus</span>.HU=0 cause an illegal instruction trap.</p>
<h3 id="sec:hfence.vma"><span class="header-section-number">5.3.2</span> Hypervisor Memory-Management Fence Instructions</h3>
<p><img src="tmp.Priv-v1.12//hypervisor_36.svg" alt="image" /></p>
<p>The hypervisor memory-management fence instructions, HFENCE.VVMA
and HFENCE.GVMA, perform a function similar to SFENCE.VMA
(Section <a href="supervisor.html#sec:sfence.vma" data-reference-type="ref" data-reference="sec:sfence.vma">[sec:sfence.vma]</a>), except applying to the VS-level
memory-management data structures controlled by CSR <span>vsatp</span>
(HFENCE.VVMA) or the guest-physical memory-management data structures
controlled by CSR <span>hgatp</span> (HFENCE.GVMA).
Instruction SFENCE.VMA applies only to the memory-management data structures
controlled by the current <span>satp</span> (either the HS-level <span>satp</span> when
V=0 or <span>vsatp</span> when V=1).</p>
<p>HFENCE.VVMA is valid only in M-mode or HS-mode.
Its effect is much the
same as temporarily entering VS-mode and executing SFENCE.VMA.
Executing an HFENCE.VVMA guarantees that any previous stores already visible
to the current hart are ordered before all subsequent implicit reads by that
hart of the VS-level memory-management data structures, when those implicit
reads are for instructions that</p>
<p>are subsequent to the HFENCE.VVMA, and</p>
<p>execute when <span>hgatp</span>.VMID has the same setting as it did when HFENCE.VVMA
executed.</p>
<p>Implicit reads need not be ordered when <span>hgatp</span>.VMID is different than at
the time HFENCE.VVMA executed.
If operand <span><em>rs1</em></span><span class="math inline">≠</span><span>x0</span>, it specifies a single guest virtual
address, and if operand <span><em>rs2</em></span><span class="math inline">≠</span><span>x0</span>, it specifies a single guest
address-space identifier
(ASID).</p>
<div class=commentary>
<p>An HFENCE.VVMA instruction applies only to a single virtual machine, identified
by the setting of <span>hgatp</span>.VMID when HFENCE.VVMA executes.</p>
</div>
<p>When <span><em>rs2</em></span><span class="math inline">≠</span><span>x0</span>, bits XLEN-1:ASIDMAX of the value held in <span>
<em>rs2</em></span> are reserved for future standard use. Until their use is defined by a
standard extension, they should be zeroed by software and ignored
by current implementations.
Furthermore, if ASIDLEN <span class="math inline">&lt;</span> ASIDMAX, the implementation shall ignore bits
ASIDMAX-1:ASIDLEN of the value held in <span><em>rs2</em></span>.</p>
<div class=commentary>
<p>Simpler implementations of HFENCE.VVMA can ignore the guest virtual address in
<span><em>rs1</em></span> and the guest ASID value in <span><em>rs2</em></span>, as well as <span>hgatp</span>.VMID,
and always perform a global fence for the VS-level memory management of all
virtual machines, or even a global fence for all memory-management data
structures.</p>
</div>
<p>Neither <span>mstatus</span>.TVM nor <span>hstatus</span>.VTVM causes HFENCE.VVMA to
trap.</p>
<p>HFENCE.GVMA is valid only in HS-mode when <span>mstatus</span>.TVM=0, or in
M-mode (irrespective of <span>mstatus</span>.TVM).
Executing an HFENCE.GVMA instruction guarantees that any previous stores
already visible to the current hart are ordered before all subsequent implicit
reads by that hart of guest-physical memory-management data structures done for instructions
that follow the HFENCE.GVMA.
If operand <span><em>rs1</em></span><span class="math inline">≠</span><span>x0</span>, it specifies a single guest physical
address, shifted right by 2 bits, and if operand <span><em>rs2</em></span><span class="math inline">≠</span><span>x0</span>, it
specifies a single virtual machine identifier (VMID).</p>
<div class=commentary>
<p>Like for a guest physical address written to <span>htval</span> on a
trap, a guest physical address specified in <span><em>rs1</em></span> is shifted
right by 2 bits to accommodate addresses wider than the current XLEN.</p>
</div>
<p>When <span><em>rs2</em></span><span class="math inline">≠</span><span>x0</span>, bits XLEN-1:VMIDMAX of the value held in <span>
<em>rs2</em></span> are reserved for future standard use. Until their use is defined by a
standard extension, they should be zeroed by software and ignored
by current implementations.
Furthermore, if VMIDLEN <span class="math inline">&lt;</span> VMIDMAX, the implementation shall ignore bits
VMIDMAX-1:VMIDLEN of the value held in <span><em>rs2</em></span>.</p>
<div class=commentary>
<p>Simpler implementations of HFENCE.GVMA can ignore the guest physical address in
<span><em>rs1</em></span> and the VMID value in <span><em>rs2</em></span> and always perform a global fence for
the guest-physical memory management of all virtual machines, or even a global
fence for all memory-management data structures.</p>
</div>
<p>If <span>hgatp</span>.MODE is changed for a given VMID, an HFENCE.GVMA with
<span><em>rs1</em></span>=<span>x0</span> (and <span><em>rs2</em></span> set to either <span>x0</span> or the VMID) must
be executed to order subsequent guest translations with the MODE
change—even if the old MODE or new MODE is Bare.</p>
<p>Attempts to execute HFENCE.VVMA or HFENCE.GVMA when V=1 cause a virtual
instruction trap, while attempts to do the same in U-mode
cause an illegal instruction trap.
Attempting to execute HFENCE.GVMA in HS-mode when <span>mstatus</span>.TVM=1
also causes an illegal instruction trap.</p>
<h2 id="machine-level-csrs"><span class="header-section-number">5.4</span> Machine-Level CSRs</h2>
<p>The hypervisor extension augments or modifies machine CSRs <span>mstatus</span>,
<span>mstatush</span>, <span>mideleg</span>, <span>mip</span>, and <span>mie</span>, and
adds CSRs <span>mtval2</span> and <span>mtinst</span>.</p>
<h3 id="machine-status-registers-mstatus-and-mstatush"><span class="header-section-number">5.4.1</span> Machine Status Registers (<span>mstatus</span> and <span>mstatush</span>)</h3>
<p>The hypervisor extension adds two fields, MPV and GVA, to the
machine-level <span>mstatus</span> or <span>mstatush</span> CSR, and modifies the
behavior of several existing <span>mstatus</span> fields.
Figure <a href="hypervisor.html#hypervisor-mstatus" data-reference-type="ref" data-reference="hypervisor-mstatus">1.36</a> shows the modified <span>mstatus</span> register
when the hypervisor extension is implemented and MXLEN=64.
When MXLEN=32, the hypervisor extension adds MPV and GVA not to <span>mstatus</span>
but to <span>mstatush</span>.
Figure <a href="hypervisor.html#hypervisor-mstatush" data-reference-type="ref" data-reference="hypervisor-mstatush">1.37</a> shows the <span>mstatush</span> register when
the hypervisor extension is implemented and MXLEN=32.</p>
<figure>
<img src="tmp.Priv-v1.12//hypervisor_37.svg" alt="Machine status register (mstatus) for RV64 when the hypervisor extension is implemented." id="hypervisor-mstatus" /><figcaption>Machine status register (<span>mstatus</span>) for RV64 when the hypervisor extension is implemented.<span label="hypervisor-mstatus"></span></figcaption>
</figure>
<figure>
<img src="tmp.Priv-v1.12//hypervisor_38.svg" alt="Additional machine status register (mstatush) for RV32 when the hypervisor extension is implemented. The format of mstatus is unchanged for RV32." id="hypervisor-mstatush" /><figcaption>Additional machine status register (<span>mstatush</span>) for RV32 when the hypervisor extension is implemented.
The format of <span>mstatus</span> is unchanged for RV32.<span label="hypervisor-mstatush"></span></figcaption>
</figure>
<p>The MPV bit (Machine Previous Virtualization Mode) is written by the implementation
whenever a trap is taken into M-mode.
Just as the MPP field is set to the (nominal) privilege
mode at the time of the trap, the MPV bit is set to the value of the virtualization
mode V at the time of the trap. When an MRET instruction is executed, the
virtualization mode V is set to MPV, unless MPP=3, in which case V remains 0.</p>
<p>Field GVA (Guest Virtual Address) is written by the implementation
whenever a trap is taken into M-mode.
For any trap (breakpoint, address misaligned,
access fault, page fault, or guest-page fault) that writes
a guest virtual address to <span>mtval</span>, GVA is set to 1.
For any other trap into M-mode, GVA is set to 0.</p>
<p>The TSR and TVM fields of <span>mstatus</span> affect execution only in HS-mode,
not in VS-mode.
The TW field affects execution in all modes except M-mode.</p>
<p>Setting TVM=1 prevents HS-mode from accessing <span>hgatp</span> or executing
HFENCE.GVMA or HINVAL.GVMA, but has no effect on accesses to <span>vsatp</span> or
instructions HFENCE.VVMA or HINVAL.VVMA.</p>
<div class=commentary>
<p>TVM exists in <span>mstatus</span> to allow machine-level software to modify
the address translations managed by a supervisor-level OS, usually for
the purpose of inserting another stage of address translation below
that controlled by the OS.
The instruction traps enabled by TVM=1 permit machine level
to co-opt both <span>satp</span> and <span>hgatp</span> and substitute
<em>shadow page tables</em> that merge the OS’s chosen page translations
with M-level’s lower-stage translations, all without the OS being
aware.
M-level software needs this ability not only to emulate the hypervisor
extension if not already supported, but also to emulate any future
<span>RISC-V</span> extensions that may modify or add address translation
stages, perhaps, for example, to improve support for nested
hypervisors, i.e., running hypervisors atop other hypervisors.</p>
<p>However, setting TVM=1 does not cause traps for accesses to <span>vsatp</span>
or instructions HFENCE.VVMA or HINVAL.VVMA, or for any actions taken
in VS-mode, because M-level software is not expected to need to involve
itself in VS-stage address translation.
For virtual machines, it should be sufficient, and in all likelihood
faster as well, to leave VS-stage address translation alone and merge
all other translation stages into G-stage shadow page tables controlled
by <span>hgatp</span>.
This assumption does place some constraints on possible future
<span>RISC-V</span> extensions that current machines will be able to emulate
efficiently.</p>
</div>
<p>The hypervisor extension changes the behavior of the the Modify Privilege
field, MPRV, of <span>mstatus</span>.
When MPRV=0, translation and protection behave as normal.
When MPRV=1, explicit memory accesses are translated and protected, and
endianness is applied, as though the current virtualization mode were set
to MPV and the current nominal privilege mode were set to MPP.
Table <a href="hypervisor.html#h-mprv" data-reference-type="ref" data-reference="h-mprv">[h-mprv]</a> enumerates the cases.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">MPRV</th>
<th style="text-align: center;">MPV</th>
<th style="text-align: center;">MPP</th>
<th style="text-align: left;">Effect</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">0</td>
<td style="text-align: center;">–</td>
<td style="text-align: center;">–</td>
<td style="text-align: left;">Normal access; current privilege mode applies.</td>
</tr>
<tr class="even">
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: left;">U-level access with HS-level translation and protection only.</td>
</tr>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: left;">HS-level access with HS-level translation and protection only.</td>
</tr>
<tr class="even">
<td style="text-align: center;">1</td>
<td style="text-align: center;">–</td>
<td style="text-align: center;">3</td>
<td style="text-align: left;">M-level access with no translation.</td>
</tr>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: left;">VU-level access with two-stage translation and protection. The HS-level MXR bit makes any executable page readable. <span>vsstatus</span>.MXR makes readable those pages marked executable at the VS translation stage, but only if readable at the guest-physical translation stage.</td>
</tr>
<tr class="even">
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: left;">VS-level access with two-stage translation and protection. The HS-level MXR bit makes any executable page readable. <span>vsstatus</span>.MXR makes readable those pages marked executable at the VS translation stage, but only if readable at the guest-physical translation stage. <span>vsstatus</span>.SUM applies instead of the HS-level SUM bit.</td>
</tr>
</tbody>
</table>
<p>MPRV does not affect the virtual-machine load/store instructions, HLV,
HLVX, and HSV.
The explicit loads and stores of these instructions always act as though
V=1 and the nominal privilege mode were <span>hstatus</span>.SPVP, overriding MPRV.</p>
<p>The <span>mstatus</span> register is a superset of the HS-level <span>sstatus</span>
register but is not a superset of <span>vsstatus</span>.</p>
<h3 id="machine-interrupt-delegation-register-mideleg"><span class="header-section-number">5.4.2</span> Machine Interrupt Delegation Register (<span>mideleg</span>)</h3>
<p>When the hypervisor extension is implemented, bits 10, 6, and 2 of
<span>mideleg</span> (corresponding to the standard VS-level interrupts) are
each read-only one.
Furthermore, if any guest external interrupts are implemented (GEILEN is
nonzero), bit 12 of <span>mideleg</span> (corresponding to supervisor-level
guest external interrupts) is also read-only one.
VS-level interrupts and guest external interrupts are always delegated
past M-mode to HS-mode.</p>
<p>For bits of <span>mideleg</span> that are zero, the corresponding bits in
<span>hideleg</span>, <span>hip</span>, and <span>hie</span> are read-only zeros.</p>
<h3 id="machine-interrupt-registers-mip-and-mie"><span class="header-section-number">5.4.3</span> Machine Interrupt Registers (<span>mip</span> and <span>mie</span>)</h3>
<p>The hypervisor extension gives registers <span>mip</span> and <span>mie</span>
additional active bits for the hypervisor-added interrupts.
Figures <a href="hypervisor.html#hypervisor-mipreg-standard" data-reference-type="ref" data-reference="hypervisor-mipreg-standard">1.38</a> and
<a href="hypervisor.html#hypervisor-miereg-standard" data-reference-type="ref" data-reference="hypervisor-miereg-standard">1.39</a> show the standard portions (bits 15:0)
of registers <span>mip</span> and <span>mie</span> when the hypervisor extension is
implemented.</p>
<figure>
<img src="tmp.Priv-v1.12//hypervisor_39.svg" alt="Standard portion (bits 15:0) of mip." id="hypervisor-mipreg-standard" /><figcaption>Standard portion (bits 15:0) of <span>mip</span>.<span label="hypervisor-mipreg-standard"></span></figcaption>
</figure>
<figure>
<img src="tmp.Priv-v1.12//hypervisor_40.svg" alt="Standard portion (bits 15:0) of mie." id="hypervisor-miereg-standard" /><figcaption>Standard portion (bits 15:0) of <span>mie</span>.<span label="hypervisor-miereg-standard"></span></figcaption>
</figure>
<p>Bits SGEIP, VSEIP, VSTIP, and VSSIP in <span>mip</span> are aliases for the same bits
in hypervisor CSR <span>hip</span>, while SGEIE, VSEIE, VSTIE, and VSSIE in <span>mie</span>
are aliases for the same bits in <span>hie</span>.</p>
<h3 id="machine-second-trap-value-register-mtval2"><span class="header-section-number">5.4.4</span> Machine Second Trap Value Register (<span>mtval2</span>)</h3>
<p>The <span>mtval2</span> register is an MXLEN-bit read/write register formatted
as shown in Figure <a href="hypervisor.html#mtval2reg" data-reference-type="ref" data-reference="mtval2reg">1.40</a>.
When a trap is taken into M-mode, <span>mtval2</span> is written with additional
exception-specific information, alongside <span>mtval</span>, to assist software
in handling the trap.</p>
<figure>
<img src="tmp.Priv-v1.12//hypervisor_41.svg" alt="Machine second trap value register (mtval2)." id="mtval2reg" /><figcaption>Machine second trap value register (<span>mtval2</span>).<span label="mtval2reg"></span></figcaption>
</figure>
<p>When a guest-page-fault trap is taken into M-mode, <span>mtval2</span> is
written with either zero or the guest physical address that faulted,
shifted right by 2 bits.
For other traps, <span>mtval2</span> is set to zero, but a future standard or
extension may redefine <span>mtval2</span>’s setting for other traps.</p>
<p>If a guest-page fault is due to an implicit memory access during
first-stage (VS-stage) address translation, a guest physical address
written to <span>mtval2</span> is that of the implicit memory access that
faulted.
Additional information is provided in CSR <span>mtinst</span> to disambiguate
such situations.</p>
<p>Otherwise, for misaligned loads and stores that cause guest-page faults,
a nonzero guest physical address in <span>mtval2</span> corresponds to the
faulting portion of the access as indicated by the virtual address in
<span>mtval</span>.
For instruction guest-page faults on systems with variable-length
instructions, a nonzero <span>mtval2</span> corresponds to the faulting portion
of the instruction as indicated by the virtual address in <span>mtval</span>.</p>
<p><span>mtval2</span> is a <strong>WARL</strong> register that must be able to hold zero and may
be capable of holding only an arbitrary subset of other 2-bit-shifted
guest physical addresses, if any.</p>
<h3 id="machine-trap-instruction-register-mtinst"><span class="header-section-number">5.4.5</span> Machine Trap Instruction Register (<span>mtinst</span>)</h3>
<p>The <span>mtinst</span> register is an MXLEN-bit read/write register formatted
as shown in Figure <a href="hypervisor.html#mtinstreg" data-reference-type="ref" data-reference="mtinstreg">1.41</a>.
When a trap is taken into M-mode, <span>mtinst</span> is written with a value
that, if nonzero, provides information about the instruction that
trapped, to assist software in handling the trap.
The values that may be written to <span>mtinst</span> on a trap are documented
in Section <a href="hypervisor.html#sec:tinst-vals" data-reference-type="ref" data-reference="sec:tinst-vals">1.6.3</a>.</p>
<figure>
<img src="tmp.Priv-v1.12//hypervisor_42.svg" alt="Machine trap instruction register (mtinst)." id="mtinstreg" /><figcaption>Machine trap instruction register (<span>mtinst</span>).<span label="mtinstreg"></span></figcaption>
</figure>
<p><span>mtinst</span> is a <strong>WARL</strong> register that need only be able to hold the
values that the implementation may automatically write to it on a trap.</p>
<h2 id="sec:two-stage-translation"><span class="header-section-number">5.5</span> Two-Stage Address Translation</h2>
<p>Whenever the current virtualization mode V is 1,
two-stage address translation and protection is in
effect.
For any virtual memory access, the original virtual address is
converted in the first stage
by VS-level address translation, as controlled by the <span>vsatp</span>
register, into a <span><em>guest physical address</em></span>.
The guest physical address is then converted
in the second stage by guest physical address
translation, as controlled by the <span>hgatp</span> register, into a supervisor
physical address.
The two stages are known also as VS-stage and G-stage translation.
Although there is no option to disable two-stage address translation when V=1,
either stage of translation can be effectively disabled by zeroing the
corresponding <span>vsatp</span> or <span>hgatp</span> register.</p>
<p>The <span>vsstatus</span> field MXR, which makes execute-only pages readable, only
overrides VS-stage page protection.
Setting MXR at VS-level does not override guest-physical page protections.
Setting MXR at HS-level, however, overrides both VS-stage and G-stage
execute-only permissions.</p>
<p>When V=1, memory accesses that would normally bypass address translation are
subject to G-stage address translation alone.
This includes memory accesses made in support of VS-stage address translation,
such as reads and writes of VS-level page tables.</p>
<p>Machine-level physical memory protection applies to supervisor physical
addresses and is in effect regardless of virtualization mode.</p>
<h3 id="sec:guest-addr-translation"><span class="header-section-number">5.5.1</span> Guest Physical Address Translation</h3>
<p>The mapping of guest physical addresses to supervisor physical addresses is
controlled by CSR <span>hgatp</span> (Section <a href="hypervisor.html#sec:hgatp" data-reference-type="ref" data-reference="sec:hgatp">1.2.10</a>).</p>
<p>When the address translation scheme selected by the MODE field of <span>hgatp</span>
is Bare, guest physical addresses are equal to supervisor physical addresses
without modification, and no memory protection applies in the trivial
translation of guest physical addresses to supervisor physical addresses.</p>
<p>When <span>hgatp</span>.MODE specifies a translation scheme of Sv32x4, Sv39x4,
Sv48x4, or Sv57x4, G-stage address translation is a variation on the usual
page-based virtual address translation scheme of Sv32, Sv39, Sv48, or Sv57,
respectively.
In each case, the size of the incoming address is widened by 2 bits (to 34, 41,
or 50 bits).
To accommodate the 2 extra bits, the root page table (only) is expanded by a
factor of four to be 16 KiB instead of the usual 4 KiB.
Matching its larger size, the root page table also must be aligned to a 16 KiB
boundary instead of the usual 4 KiB page boundary.
Except as noted, all other aspects of Sv32, Sv39, Sv48, or Sv57 are adopted
unchanged for G-stage translation.
Non-root page tables and all page table entries (PTEs) have the same formats as
documented in Sections <a href="supervisor.html#sec:sv32" data-reference-type="ref" data-reference="sec:sv32">[sec:sv32]</a>, <a href="supervisor.html#sec:sv39" data-reference-type="ref" data-reference="sec:sv39">[sec:sv39]</a>, <a href="supervisor.html#sec:sv48" data-reference-type="ref" data-reference="sec:sv48">[sec:sv48]</a>,
and <a href="supervisor.html#sec:sv57" data-reference-type="ref" data-reference="sec:sv57">[sec:sv57]</a>.</p>
<p>For Sv32x4, an incoming guest physical address is partitioned into a virtual
page number (VPN) and page offset as shown in Figure <a href="hypervisor.html#sv32x4va" data-reference-type="ref" data-reference="sv32x4va">1.42</a>.
This partitioning is identical to that for an Sv32 virtual address as depicted
in Figure <a href="supervisor.html#sv32va" data-reference-type="ref" data-reference="sv32va">[sv32va]</a> (page ), except with 2 more bits at the
high end in VPN[1].
(Note that the fields of a partitioned guest physical address also correspond
one-for-one with the structure that Sv32 assigns to a physical address,
depicted in Figure <a href="supervisor.html#rv32va" data-reference-type="ref" data-reference="rv32va">[rv32va]</a>.)</p>
<figure>
<img src="tmp.Priv-v1.12//hypervisor_43.svg" alt="Sv32x4 virtual address (guest physical address)." id="sv32x4va" /><figcaption>Sv32x4 virtual address (guest physical address).<span label="sv32x4va"></span></figcaption>
</figure>
<p>For Sv39x4, an incoming guest physical address is partitioned as shown in
Figure <a href="hypervisor.html#sv39x4va" data-reference-type="ref" data-reference="sv39x4va">1.43</a>.
This partitioning is identical to that for an Sv39 virtual address as depicted
in Figure <a href="supervisor.html#sv39va" data-reference-type="ref" data-reference="sv39va">[sv39va]</a> (page ), except with 2 more bits at the
high end in VPN[2].
Address bits 63:41 must all be zeros, or else a guest-page-fault
exception occurs.</p>
<figure>
<img src="tmp.Priv-v1.12//hypervisor_44.svg" alt="Sv39x4 virtual address (guest physical address)." id="sv39x4va" /><figcaption>Sv39x4 virtual address (guest physical address).<span label="sv39x4va"></span></figcaption>
</figure>
<p>For Sv48x4, an incoming guest physical address is partitioned as shown in
Figure <a href="hypervisor.html#sv48x4va" data-reference-type="ref" data-reference="sv48x4va">1.44</a>.
This partitioning is identical to that for an Sv48 virtual address as depicted
in Figure <a href="supervisor.html#sv48va" data-reference-type="ref" data-reference="sv48va">[sv48va]</a> (page ), except with 2 more bits at the
high end in VPN[3].
Address bits 63:50 must all be zeros, or else a guest-page-fault
exception occurs.</p>
<figure>
<img src="tmp.Priv-v1.12//hypervisor_45.svg" alt="Sv48x4 virtual address (guest physical address)." id="sv48x4va" /><figcaption>Sv48x4 virtual address (guest physical address).<span label="sv48x4va"></span></figcaption>
</figure>
<p>For Sv57x4, an incoming guest physical address is partitioned as shown in
Figure <a href="hypervisor.html#sv57x4va" data-reference-type="ref" data-reference="sv57x4va">1.45</a>.
This partitioning is identical to that for an Sv57 virtual address as depicted
in Figure <a href="supervisor.html#sv57va" data-reference-type="ref" data-reference="sv57va">[sv57va]</a> (page ), except with 2 more bits at the
high end in VPN[3].
Address bits 63:50 must all be zeros, or else a guest-page-fault
exception occurs.</p>
<figure>
<img src="tmp.Priv-v1.12//hypervisor_46.svg" alt="Sv57x4 virtual address (guest physical address)." id="sv57x4va" /><figcaption>Sv57x4 virtual address (guest physical address).<span label="sv57x4va"></span></figcaption>
</figure>
<div class=commentary>
<p>The page-based G-stage address translation scheme for RV32, Sv32x4, is
defined to support a 34-bit guest physical address so that an RV32 hypervisor
need not be limited in its ability to virtualize real 32-bit RISC-V machines,
even those with 33-bit or 34-bit physical addresses.
This may include the possibility of a machine virtualizing itself, if it
happens to use 33-bit or 34-bit physical addresses.
Multiplying the size and alignment of the root page table by a factor of four
is the cheapest way to extend Sv32 to cover a 34-bit address.
The possible wastage of 12 KiB for an unnecessarily large root page table is
expected to be of negligible consequence for most (maybe all) real uses.</p>
<p>A consistent ability to virtualize machines having as much as four times the
physical address space as virtual address space is believed to be of some
utility also for RV64.
For a machine implementing 39-bit virtual addresses (Sv39), for example, this
allows the hypervisor extension to support up to a 41-bit guest physical
address space without either necessitating hardware support for 48-bit virtual
addresses (Sv48) or falling back to emulating the larger address space using
shadow page tables.</p>
</div>
<p>The conversion of an Sv32x4, Sv39x4, Sv48x4, or Sv57x4 guest physical address is
accomplished with the same algorithm used for Sv32, Sv39, Sv48, or Sv57, as
presented in Section <a href="supervisor.html#sv32algorithm" data-reference-type="ref" data-reference="sv32algorithm">[sv32algorithm]</a>, except that:</p>
<p><span>hgatp</span> substitutes for the usual <span>satp</span>;</p>
<p>for the translation to begin, the effective privilege mode must be VS-mode or
VU-mode;</p>
<p>when checking the U bit, the current privilege mode is always taken to be
U-mode; and</p>
<p>guest-page-fault exceptions are raised instead of regular page-fault
exceptions.</p>
<p>For G-stage address translation, all memory accesses (including those
made to access data structures for VS-stage address translation) are considered
to be user-level accesses, as though executed in U-mode.
Access type permissions—readable, writable, or executable—are checked
during G-stage translation the same as for VS-stage
translation.
For a memory access made to support VS-stage address translation (such as to
read/write a VS-level page table), permissions are checked as though for a load
or store, not for the original access type.
However, any exception is always reported for the original access type
(instruction, load, or store/AMO).</p>
<p>The G bit in all G-stage PTEs is reserved for future standard use. Until its
use is defined by a standard extension, it should be cleared
by software for forward compatibility, and must be ignored by hardware.</p>
<div class=commentary>
<p>G-stage address translation uses the identical format for PTEs as
regular address translation, even including the U bit, due to the
possibility of sharing some (or all) page tables between G-stage
translation and regular HS-level address translation.
Regardless of whether this usage will ever become common, we chose not to
preclude it.</p>
</div>
<h3 id="guest-page-faults"><span class="header-section-number">5.5.2</span> Guest-Page Faults</h3>
<p>Guest-page-fault traps may be delegated from M-mode to HS-mode under the
control of CSR <span>medeleg</span>, but cannot be delegated to other privilege
modes.
On a guest-page fault, CSR <span>mtval</span> or <span>stval</span> is written with the
faulting guest virtual address as usual, and <span>mtval2</span> or <span>htval</span> is
written either with zero or with the faulting guest physical address,
shifted right by 2 bits.
CSR <span>mtinst</span> or <span>htinst</span> may also be written with information
about the faulting instruction or other reason for the access, as
explained in Section <a href="hypervisor.html#sec:tinst-vals" data-reference-type="ref" data-reference="sec:tinst-vals">1.6.3</a>.</p>
<p>When an instruction fetch or a misaligned memory access straddles a page
boundary, two different address translations are involved.
When a guest-page fault occurs in such a circumstance, the faulting
virtual address written to <span>mtval</span>/<span>stval</span> is the same as would
be required for a regular page fault.
Thus, the faulting virtual address may be a page-boundary address that is
higher than the instruction’s original virtual address, if the byte at
that page boundary is among the accessed bytes.</p>
<p>When a guest-page fault is not due to an implicit
memory access for VS-stage address translation,
a nonzero guest physical address written to
<span>mtval2</span>/<span>htval</span> shall correspond
to the exact virtual address written to
<span>mtval</span>/<span>stval</span>.</p>
<h3 id="memory-management-fences"><span class="header-section-number">5.5.3</span> Memory-Management Fences</h3>
<p>The behavior of the SFENCE.VMA instruction is affected by the current
virtualization mode V. When V=0, the virtual-address argument is an HS-level
virtual address, and the ASID argument is an HS-level ASID.
The instruction orders stores only to HS-level address-translation structures
with subsequent HS-level address translations.</p>
<p>When V=1, the virtual-address argument to SFENCE.VMA is a guest virtual
address within the current virtual machine, and the ASID argument is a VS-level
ASID within the current virtual machine.
The current virtual machine is identified by the VMID field of CSR <span>hgatp</span>,
and the effective ASID can be considered to be the combination of this VMID
with the VS-level ASID.
The SFENCE.VMA instruction orders stores only to the VS-level
address-translation structures with subsequent VS-stage address translations
for the same virtual machine, i.e., only when <span>hgatp</span>.VMID is the same as
when the SFENCE.VMA executed.</p>
<p>Hypervisor instructions HFENCE.VVMA and HFENCE.GVMA provide additional
memory-management fences to complement SFENCE.VMA.
These instructions are described in Section <a href="hypervisor.html#sec:hfence.vma" data-reference-type="ref" data-reference="sec:hfence.vma">1.3.2</a>.</p>
<p>Section <a href="machine.html#pmp-vmem" data-reference-type="ref" data-reference="pmp-vmem">[pmp-vmem]</a> discusses the intersection between physical memory
protection (PMP) and page-based address translation.
It is noted there that, when PMP settings are modified in a manner that affects
either the physical memory that holds page tables or the physical memory to
which page tables point, M-mode software must synchronize the PMP settings with
the virtual memory system.
For HS-level address translation, this is accomplished by executing in M-mode
an SFENCE.VMA instruction with <span><em>rs1</em></span>=<span>x0</span> and <span><em>rs2</em></span>=<span>x0</span>, after
the PMP CSRs are written.
If G-stage address translation is in use and is not Bare,
synchronization with its data
structures is also needed.
When PMP settings are modified in a manner that affects either the physical
memory that holds guest-physical page tables or the physical memory to which
guest-physical page tables point, an HFENCE.GVMA instruction with
<span><em>rs1</em></span>=<span>x0</span> and <span><em>rs2</em></span>=<span>x0</span> must be executed in M-mode after the
PMP CSRs are written.
An HFENCE.VVMA instruction is not required.</p>
<h2 id="traps"><span class="header-section-number">5.6</span> Traps</h2>
<h3 id="trap-cause-codes"><span class="header-section-number">5.6.1</span> Trap Cause Codes</h3>
<p>The hypervisor extension augments the trap cause encoding.
Table <a href="hypervisor.html#hcauses" data-reference-type="ref" data-reference="hcauses">[hcauses]</a> lists the possible M-mode and HS-mode trap cause
codes when the hypervisor extension is implemented.
Codes are added for VS-level interrupts (interrupts 2, 6, 10), for
supervisor-level guest external interrupts (interrupt 12), for virtual
instruction exceptions (exception 22), and for guest-page faults
(exceptions 20, 21, 23).
Furthermore, environment calls from VS-mode are assigned cause 10,
whereas those from HS-mode or S-mode use cause 9 as usual.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: right;">Interrupt</th>
<th style="text-align: right;">Exception Code</th>
<th style="text-align: left;">Description</th>
<th style="text-align: left;"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">1</td>
<td style="text-align: right;">0</td>
<td style="text-align: left;"><span><em>Reserved</em></span></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: right;">1</td>
<td style="text-align: right;">1</td>
<td style="text-align: left;">Supervisor software interrupt</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: right;">1</td>
<td style="text-align: right;">2</td>
<td style="text-align: left;">Virtual supervisor software interrupt</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: right;">1</td>
<td style="text-align: right;">3</td>
<td style="text-align: left;">Machine software interrupt</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: right;">1</td>
<td style="text-align: right;">4</td>
<td style="text-align: left;"><span><em>Reserved</em></span></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: right;">1</td>
<td style="text-align: right;">5</td>
<td style="text-align: left;">Supervisor timer interrupt</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: right;">1</td>
<td style="text-align: right;">6</td>
<td style="text-align: left;">Virtual supervisor timer interrupt</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: right;">1</td>
<td style="text-align: right;">7</td>
<td style="text-align: left;">Machine timer interrupt</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: right;">1</td>
<td style="text-align: right;">8</td>
<td style="text-align: left;"><span><em>Reserved</em></span></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: right;">1</td>
<td style="text-align: right;">9</td>
<td style="text-align: left;">Supervisor external interrupt</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: right;">1</td>
<td style="text-align: right;">10</td>
<td style="text-align: left;">Virtual supervisor external interrupt</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: right;">1</td>
<td style="text-align: right;">11</td>
<td style="text-align: left;">Machine external interrupt</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: right;">1</td>
<td style="text-align: right;">12</td>
<td style="text-align: left;">Supervisor guest external interrupt</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: right;">1</td>
<td style="text-align: right;">13–15</td>
<td style="text-align: left;"><span><em>Reserved</em></span></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: right;">1</td>
<td style="text-align: right;"><span class="math inline">≥</span>16</td>
<td style="text-align: left;"><span><em>Designated for platform or custom use</em></span></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: right;">0</td>
<td style="text-align: right;">0</td>
<td style="text-align: left;">Instruction address misaligned</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: right;">0</td>
<td style="text-align: right;">1</td>
<td style="text-align: left;">Instruction access fault</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: right;">0</td>
<td style="text-align: right;">2</td>
<td style="text-align: left;">Illegal instruction</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: right;">0</td>
<td style="text-align: right;">3</td>
<td style="text-align: left;">Breakpoint</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: right;">0</td>
<td style="text-align: right;">4</td>
<td style="text-align: left;">Load address misaligned</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: right;">0</td>
<td style="text-align: right;">5</td>
<td style="text-align: left;">Load access fault</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: right;">0</td>
<td style="text-align: right;">6</td>
<td style="text-align: left;">Store/AMO address misaligned</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: right;">0</td>
<td style="text-align: right;">7</td>
<td style="text-align: left;">Store/AMO access fault</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: right;">0</td>
<td style="text-align: right;">8</td>
<td style="text-align: left;">Environment call from U-mode or VU-mode</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: right;">0</td>
<td style="text-align: right;">9</td>
<td style="text-align: left;">Environment call from HS-mode</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: right;">0</td>
<td style="text-align: right;">10</td>
<td style="text-align: left;">Environment call from VS-mode</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: right;">0</td>
<td style="text-align: right;">11</td>
<td style="text-align: left;">Environment call from M-mode</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: right;">0</td>
<td style="text-align: right;">12</td>
<td style="text-align: left;">Instruction page fault</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: right;">0</td>
<td style="text-align: right;">13</td>
<td style="text-align: left;">Load page fault</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: right;">0</td>
<td style="text-align: right;">14</td>
<td style="text-align: left;"><span><em>Reserved</em></span></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: right;">0</td>
<td style="text-align: right;">15</td>
<td style="text-align: left;">Store/AMO page fault</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: right;">0</td>
<td style="text-align: right;">16–19</td>
<td style="text-align: left;"><span><em>Reserved</em></span></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: right;">0</td>
<td style="text-align: right;">20</td>
<td style="text-align: left;">Instruction guest-page fault</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: right;">0</td>
<td style="text-align: right;">21</td>
<td style="text-align: left;">Load guest-page fault</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: right;">0</td>
<td style="text-align: right;">22</td>
<td style="text-align: left;">Virtual instruction</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: right;">0</td>
<td style="text-align: right;">23</td>
<td style="text-align: left;">Store/AMO guest-page fault</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: right;">0</td>
<td style="text-align: right;">24–31</td>
<td style="text-align: left;"><span><em>Designated for custom use</em></span></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: right;">0</td>
<td style="text-align: right;">32–47</td>
<td style="text-align: left;"><span><em>Reserved</em></span></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: right;">0</td>
<td style="text-align: right;">48–63</td>
<td style="text-align: left;"><span><em>Designated for custom use</em></span></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: right;">0</td>
<td style="text-align: right;"><span class="math inline">≥</span>64</td>
<td style="text-align: left;"><span><em>Reserved</em></span></td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<div class=commentary>
<p>HS-mode and VS-mode ECALLs use different cause values so they can be delegated
separately.</p>
</div>
<p>When V=1, a virtual instruction exception (code 22) is normally
raised instead of an illegal instruction exception if the attempted
instruction is <em>HS-qualified</em>
but is prevented from executing when V=1 either due to
insufficient privilege or because the instruction is expressly disabled
by a supervisor or hypervisor CSR such as <span>scounteren</span> or <span>hcounteren</span>.
An instruction is <em>HS-qualified</em> if it would be valid to execute
in HS-mode (for some values of the instruction’s register operands),
assuming fields TSR and TVM of CSR <span>mstatus</span> are both zero.</p>
<p>Special rules apply for CSR instructions that access <span>32-bit</span>
high-half CSRs such as <span>cycleh</span> and <span>htimedeltah</span>.
When V=1 and XLEN<span class="math inline">&gt;</span>32, an attempt to access a high-half
supervisor-level CSR, high-half hypervisor CSR, high-half VS CSR,
or high-half unprivileged CSR always raises an illegal instruction
exception.
And in VS-mode, if the XLEN for VU-mode is greater than 32, an attempt
to access a high-half user-level CSR (distinct from an unprivileged
CSR) always raises an illegal instruction exception.
On the other hand, when V=1 and XLEN=32, an invalid attempt to access a
high-half S-level, hypervisor, VS, or unprivileged CSR raises a virtual
instruction exception instead of an illegal instruction exception
if the same CSR instruction for the partner <em>low-half</em> CSR
(e.g.<span>cycle</span> or <span>htimedelta</span>) is HS-qualified.
Likewise, in VS-mode, if the XLEN for VU-mode is 32, an invalid attempt
to access a high-half user-level CSR raises a virtual instruction
exception instead of an illegal instruction exception if the same CSR
instruction for the partner low-half CSR is HS-qualified.</p>
<div class=commentary>
<p>The RISC-V Privileged Architecture currently defines no user-level
CSRs, but they might be added by a future version of this standard or
by an extension.</p>
</div>
<p>Specifically, a virtual instruction exception is raised for the
following cases:</p>
<ul>
<li><p>in VS-mode,
attempts to access a non-high-half counter CSR when the corresponding bit in
<span>hcounteren</span> is 0 and the same bit in <span>mcounteren</span> is 1;</p></li>
<li><p>in VS-mode, if XLEN=32, attempts to access a high-half
counter CSR when the corresponding bit in <span>hcounteren</span> is 0 and the
same bit in <span>mcounteren</span> is 1;</p></li>
<li><p>in VU-mode, attempts to access a non-high-half counter CSR when the
corresponding bit in either <span>hcounteren</span> or <span>scounteren</span> is 0
and the same bit in <span>mcounteren</span> is 1;</p></li>
<li><p>in VU-mode, if XLEN=32, attempts to access a high-half counter CSR when
the corresponding bit in either <span>hcounteren</span> or <span>scounteren</span>
is 0 and the same bit in <span>mcounteren</span> is 1;</p></li>
<li><p>in VS-mode or VU-mode,
attempts to execute a hypervisor instruction (HLV, HLVX, HSV, or HFENCE);</p></li>
<li><p>in VS-mode or VU-mode, attempts to access an implemented non-high-half
hypervisor CSR or VS CSR when the same access (read/write) would be
allowed in HS-mode, assuming <span>mstatus</span>.TVM=0;</p></li>
<li><p>in VS-mode or VU-mode, if XLEN=32, attempts to access an implemented
high-half hypervisor CSR or high-half VS CSR when the same access
(read/write) to the CSR’s low-half partner would be allowed in HS-mode,
assuming <span>mstatus</span>.TVM=0;</p></li>
<li><p>in VU-mode, attempts to execute WFI when <span>mstatus</span>.TW=0, or to
execute a supervisor instruction (SRET or SFENCE);</p></li>
<li><p>in VU-mode, attempts to access an implemented non-high-half supervisor
CSR when the same access (read/write) would be allowed in HS-mode,
assuming <span>mstatus</span>.TVM=0;</p></li>
<li><p>in VU-mode, if XLEN=32, attempts to access an implemented high-half
supervisor CSR when the same access to the CSR’s low-half partner would
be allowed in HS-mode, assuming <span>mstatus</span>.TVM=0;</p></li>
<li><p>in VS-mode, attempts to execute WFI when <span>hstatus</span>.VTW=1 and
<span>mstatus</span>.TW=0, unless the instruction completes within an
implementation-specific, bounded time;</p></li>
<li><p>in VS-mode, attempts to execute SRET when <span>hstatus</span>.VTSR=1; and</p></li>
<li><p>in VS-mode, attempts to execute an SFENCE.VMA or SINVAL.VMA instruction or to
access <span>satp</span>, when <span>hstatus</span>.VTVM=1.</p></li>
</ul>
<p>Other extensions to the <span>RISC-V</span> Privileged Architecture may add
to the set of circumstances that cause a virtual instruction exception
when V=1.</p>
<p>On a virtual instruction trap, <span>mtval</span> or <span>stval</span> is written the
same as for an illegal instruction trap.</p>
<div class=commentary>
<p>It is not unusual that hypervisors must emulate the
instructions that raise virtual instruction exceptions, to
support nested hypervisors or for other reasons.
Machine level is expected ordinarily to delegate virtual instruction
traps directly to HS-level, whereas illegal instruction traps are likely
to be processed first in M-mode before being conditionally delegated (by
software) to HS-level.
Consequently, virtual instruction traps are expected typically to be
handled faster than illegal instruction traps.</p>
<p>When not emulating the trapping instruction,
a hypervisor should convert a virtual
instruction trap into an illegal instruction exception for the guest
virtual machine.</p>
</div>
<div class=commentary>
<p>Because TSR and TVM in <span>mstatus</span> are intended to impact only S-mode
(HS-mode), they are ignored for determining exceptions in VS-mode.</p>
</div>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Priority</th>
<th style="text-align: right;">Exc.Code</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><span><em>Highest</em></span></td>
<td style="text-align: right;">3</td>
<td style="text-align: left;">Instruction address breakpoint</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: right;"></td>
<td style="text-align: left;">During instruction address translation:</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: right;">12, 20, 1</td>
<td style="text-align: left;">First encountered page fault,
guest-page fault, or access fault</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: right;"></td>
<td style="text-align: left;">With physical address for instruction:</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: right;">1</td>
<td style="text-align: left;">Instruction access fault</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: right;">2</td>
<td style="text-align: left;">Illegal instruction</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: right;">22</td>
<td style="text-align: left;">Virtual instruction</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: right;">0</td>
<td style="text-align: left;">Instruction address misaligned</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: right;">8, 9, 10, 11</td>
<td style="text-align: left;">Environment call</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: right;">3</td>
<td style="text-align: left;">Environment break</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: right;">3</td>
<td style="text-align: left;">Load/store/AMO address breakpoint</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: right;"></td>
<td style="text-align: left;">Optionally:</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: right;">4, 6</td>
<td style="text-align: left;">Load/store/AMO address misaligned</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: right;"></td>
<td style="text-align: left;">During address translation for an explicit
memory access:</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: right;">13, 15, 21, 23, 5, 7</td>
<td style="text-align: left;">First encountered page fault,
guest-page fault, or access fault</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: right;"></td>
<td style="text-align: left;">With physical address for an explicit
memory access:</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: right;">5, 7</td>
<td style="text-align: left;">Load/store/AMO access fault</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: right;"></td>
<td style="text-align: left;">If not higher priority:</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span><em>Lowest</em></span></td>
<td style="text-align: right;">4, 6</td>
<td style="text-align: left;">Load/store/AMO address misaligned</td>
</tr>
</tbody>
</table>
<p>If an instruction may raise multiple synchronous exceptions, the
decreasing priority order of Table <a href="hypervisor.html#tab:HSyncExcPrio" data-reference-type="ref" data-reference="tab:HSyncExcPrio">[tab:HSyncExcPrio]</a> indicates
which exception is taken and reported in <span>mcause</span> or <span>scause</span>.</p>
<h3 id="trap-entry"><span class="header-section-number">5.6.2</span> Trap Entry</h3>
<p>When a trap occurs in HS-mode or U-mode, it goes to M-mode, unless
delegated by <span>medeleg</span> or <span>mideleg</span>, in which case it goes to HS-mode.
When a trap occurs in VS-mode or VU-mode, it goes to M-mode, unless
delegated by <span>medeleg</span> or <span>mideleg</span>, in which case it goes to HS-mode,
unless further delegated by <span>hedeleg</span> or <span>hideleg</span>, in which case it
goes to VS-mode.</p>
<p>When a trap is taken into M-mode, virtualization mode V gets set to 0,
and fields MPV and MPP in <span>mstatus</span>
(or <span>mstatush</span>) are set according to
Table <a href="hypervisor.html#h-mpp" data-reference-type="ref" data-reference="h-mpp">[h-mpp]</a>.
A trap into M-mode also writes fields GVA, MPIE, and MIE in
<span>mstatus</span>/<span>mstatush</span> and writes CSRs <span>mepc</span>, <span>mcause</span>,
<span>mtval</span>, <span>mtval2</span>, and <span>mtinst</span>.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Previous Mode</th>
<th style="text-align: center;">MPV</th>
<th style="text-align: center;">MPP</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">U-mode</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="even">
<td style="text-align: left;">HS-mode</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="odd">
<td style="text-align: left;">M-mode</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">3</td>
</tr>
<tr class="even">
<td style="text-align: left;">VU-mode</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="odd">
<td style="text-align: left;">VS-mode</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
</tr>
</tbody>
</table>
<p>When a trap is taken into HS-mode, virtualization mode V is set to 0,
and <span>hstatus</span>.SPV and <span>sstatus</span>.SPP are
set according to Table <a href="hypervisor.html#h-spp" data-reference-type="ref" data-reference="h-spp">[h-spp]</a>.
If V was 1 before the trap, field SPVP in <span>hstatus</span> is set the same as
<span>sstatus</span>.SPP;
otherwise, SPVP is left unchanged.
A trap into HS-mode also writes field GVA in <span>hstatus</span>, fields
SPIE and SIE in <span>sstatus</span>, and CSRs <span>sepc</span>, <span>scause</span>,
<span>stval</span>, <span>htval</span>, and <span>htinst</span>.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Previous Mode</th>
<th style="text-align: center;">SPV</th>
<th style="text-align: center;">SPP</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">U-mode</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="even">
<td style="text-align: left;">HS-mode</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="odd">
<td style="text-align: left;">VU-mode</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="even">
<td style="text-align: left;">VS-mode</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
</tr>
</tbody>
</table>
<p>When a trap is taken into VS-mode, <span>vsstatus</span>.SPP is set according to
Table <a href="hypervisor.html#h-vspp" data-reference-type="ref" data-reference="h-vspp">[h-vspp]</a>.
Register <span>hstatus</span> and the HS-level <span>sstatus</span> are not modified,
and the virtualization mode V remains 1.
A trap into VS-mode also writes fields SPIE and SIE in
<span>vsstatus</span> and writes CSRs <span>vsepc</span>, <span>vscause</span>, and
<span>vstval</span>.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Previous Mode</th>
<th style="text-align: center;">SPP</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">VU-mode</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="even">
<td style="text-align: left;">VS-mode</td>
<td style="text-align: center;">1</td>
</tr>
</tbody>
</table>
<h3 id="sec:tinst-vals"><span class="header-section-number">5.6.3</span> Transformed Instruction or Pseudoinstruction for <span>mtinst</span> or <span>htinst</span></h3>
<p>On any trap into M-mode or HS-mode, one of these values is written
automatically into the appropriate trap instruction CSR, <span>mtinst</span> or
<span>htinst</span>:</p>
<p>zero;</p>
<p>a transformation of the trapping instruction;</p>
<p>a custom value (allowed only if the trapping instruction is nonstandard);
or</p>
<p>a special pseudoinstruction.</p>
<p>Except when a pseudoinstruction value is required (described later), the
value written to <span>mtinst</span> or <span>htinst</span> may always be zero,
indicating that the hardware is providing no information in the register
for this particular trap.</p>
<div class=commentary>
<p>The value written to the trap instruction CSR serves two purposes.
The first is to improve the speed of instruction emulation in a trap
handler, partly by allowing the handler to skip loading the trapping
instruction from memory, and partly by obviating some of the work of
decoding and executing the instruction.
The second purpose is to supply, via pseudoinstructions, additional
information about guest-page-fault exceptions caused by implicit memory
accesses done for VS-stage address translation.</p>
<p>A <em>transformation</em> of the trapping instruction is written instead of
simply a copy of the original instruction in order to minimize the burden
for hardware yet still provide to a trap handler the information needed
to emulate the instruction.
An implementation may at any time reduce its effort by substituting zero
in place of the transformed instruction.</p>
</div>
<p>On an interrupt, the value written to the trap instruction register is
always zero.
On a synchronous exception, if a nonzero value is written, one of the
following shall be true about the value:</p>
<ul>
<li><p>Bit 0 is <span>1</span>, and replacing bit 1 with <span>1</span> makes the value into a
valid encoding of a standard instruction.</p>
<p>In this case, the instruction that trapped is the same kind as indicated
by the register value, and the register value is the transformation of
the trapping instruction, as defined later.
For example, if bits 1:0 are binary <span>11</span> and the register value is
the encoding of a standard LW (load word) instruction, then the trapping
instruction is LW, and the register value is the transformation of the
trapping LW instruction.</p></li>
<li><p>Bit 0 is <span>1</span>, and replacing bit 1 with <span>1</span> makes the value into
an instruction encoding that is explicitly designated for a custom
instruction (<em>not</em> an unused reserved encoding).</p>
<p>This is a <em>custom value</em>.
The instruction that trapped is a nonstandard instruction.
The interpretation of a custom value is not otherwise specified by this
standard.</p></li>
<li><p>The value is one of the special pseudoinstructions defined later, all of
which have bits 1:0 equal to <span>00</span>.</p></li>
</ul>
<p>These three cases exclude a large number of other possible values, such
as all those having bits 1:0 equal to binary <span>10</span>.
A future standard or extension may define additional cases, thus allowing
values that are currently excluded.
Software may safely treat an unrecognized value in a trap instruction
register the same as zero.</p>
<div class=commentary>
<p>To be forward-compatible with future revisions of this standard, software
that interprets a nonzero value from <span>mtinst</span> or <span>htinst</span> must
fully verify that the value conforms to one of the cases listed above.
For instance, for RV64, discovering that bits 6:0 of <span>mtinst</span> are
<span>0000011</span> and bits 14:12 are <span>010</span> is not sufficient to establish
that the first case applies and the trapping instruction is a standard LW
instruction;
rather, software must also confirm that bits 63:32 of <span>mtinst</span> are
all zeros.
A future standard might define new values for 64-bit <span>mtinst</span> that
are nonzero in bits 63:32 yet may coincidentally have in bits 31:0 the
same bit patterns as standard RV64 instructions.</p>
</div>
<div class=commentary>
<p>Unlike for standard instructions, there is no requirement that the
instruction encoding of a custom value be of the same “kind” as the
instruction that trapped (or even have any correlation with the trapping
instruction).</p>
</div>
<p>Table <a href="hypervisor.html#tab:tinst-values" data-reference-type="ref" data-reference="tab:tinst-values">[tab:tinst-values]</a> shows the values that may be automatically
written to the trap instruction register for each standard exception
cause.
For exceptions that prevent the fetching of an instruction, only zero or
a pseudoinstruction value may be written.
A custom value may be automatically written only if the instruction that
traps is nonstandard.
A future standard or extension may permit other values to be written,
chosen from the set of allowed values established earlier.</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">Transformed</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">Pseudo-</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">Standard</td>
<td style="text-align: center;">Custom</td>
<td style="text-align: center;">instruction</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Exception</td>
<td style="text-align: center;">Zero</td>
<td style="text-align: center;">Instruction</td>
<td style="text-align: center;">Value</td>
<td style="text-align: center;">Value</td>
</tr>
<tr class="even">
<td style="text-align: left;">Instruction address misaligned</td>
<td style="text-align: center;">Yes</td>
<td style="text-align: center;">No</td>
<td style="text-align: center;">Yes</td>
<td style="text-align: center;">No</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Instruction access fault</td>
<td style="text-align: center;">Yes</td>
<td style="text-align: center;">No</td>
<td style="text-align: center;">No</td>
<td style="text-align: center;">No</td>
</tr>
<tr class="even">
<td style="text-align: left;">Illegal instruction</td>
<td style="text-align: center;">Yes</td>
<td style="text-align: center;">No</td>
<td style="text-align: center;">No</td>
<td style="text-align: center;">No</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Breakpoint</td>
<td style="text-align: center;">Yes</td>
<td style="text-align: center;">No</td>
<td style="text-align: center;">Yes</td>
<td style="text-align: center;">No</td>
</tr>
<tr class="even">
<td style="text-align: left;">Virtual instruction</td>
<td style="text-align: center;">Yes</td>
<td style="text-align: center;">No</td>
<td style="text-align: center;">Yes</td>
<td style="text-align: center;">No</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Load address misaligned</td>
<td style="text-align: center;">Yes</td>
<td style="text-align: center;">Yes</td>
<td style="text-align: center;">Yes</td>
<td style="text-align: center;">No</td>
</tr>
<tr class="even">
<td style="text-align: left;">Load access fault</td>
<td style="text-align: center;">Yes</td>
<td style="text-align: center;">Yes</td>
<td style="text-align: center;">Yes</td>
<td style="text-align: center;">No</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Store/AMO address misaligned</td>
<td style="text-align: center;">Yes</td>
<td style="text-align: center;">Yes</td>
<td style="text-align: center;">Yes</td>
<td style="text-align: center;">No</td>
</tr>
<tr class="even">
<td style="text-align: left;">Store/AMO access fault</td>
<td style="text-align: center;">Yes</td>
<td style="text-align: center;">Yes</td>
<td style="text-align: center;">Yes</td>
<td style="text-align: center;">No</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Environment call</td>
<td style="text-align: center;">Yes</td>
<td style="text-align: center;">No</td>
<td style="text-align: center;">Yes</td>
<td style="text-align: center;">No</td>
</tr>
<tr class="even">
<td style="text-align: left;">Instruction page fault</td>
<td style="text-align: center;">Yes</td>
<td style="text-align: center;">No</td>
<td style="text-align: center;">No</td>
<td style="text-align: center;">No</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Load page fault</td>
<td style="text-align: center;">Yes</td>
<td style="text-align: center;">Yes</td>
<td style="text-align: center;">Yes</td>
<td style="text-align: center;">No</td>
</tr>
<tr class="even">
<td style="text-align: left;">Store/AMO page fault</td>
<td style="text-align: center;">Yes</td>
<td style="text-align: center;">Yes</td>
<td style="text-align: center;">Yes</td>
<td style="text-align: center;">No</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Instruction guest-page fault</td>
<td style="text-align: center;">Yes</td>
<td style="text-align: center;">No</td>
<td style="text-align: center;">No</td>
<td style="text-align: center;">Yes</td>
</tr>
<tr class="even">
<td style="text-align: left;">Load guest-page fault</td>
<td style="text-align: center;">Yes</td>
<td style="text-align: center;">Yes</td>
<td style="text-align: center;">Yes</td>
<td style="text-align: center;">Yes</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Store/AMO guest-page fault</td>
<td style="text-align: center;">Yes</td>
<td style="text-align: center;">Yes</td>
<td style="text-align: center;">Yes</td>
<td style="text-align: center;">Yes</td>
</tr>
</tbody>
</table>
<p>As enumerated in the table, a synchronous exception may write to the trap
instruction register a standard transformation of the trapping
instruction only for exceptions that arise from explicit memory accesses
(from loads, stores, and AMO instructions).
Accordingly, standard transformations are currently defined only for
these memory-access instructions.
If a synchronous trap occurs for a standard instruction for which no
transformation has been defined, the trap instruction register shall be
written with zero (or, under certain circumstances, with a special
pseudoinstruction value).</p>
<p>For a standard load instruction that is not a compressed instruction and
is one of LB, LBU, LH, LHU, LW, LWU, LD, FLW, FLD, FLQ, or FLH, the
transformed instruction has the format shown in
Figure <a href="hypervisor.html#transformedloadinst" data-reference-type="ref" data-reference="transformedloadinst">1.46</a>.</p>
<figure>
<img src="tmp.Priv-v1.12//hypervisor_47.svg" alt="Transformed noncompressed load instruction (LB, LBU, LH, LHU, LW, LWU, LD, FLW, FLD, FLQ, or FLH). Fields funct3, rd, and opcode are the same as the trapping load instruction." id="transformedloadinst" /><figcaption>Transformed noncompressed load instruction (LB, LBU, LH, LHU,
LW, LWU, LD, FLW, FLD, FLQ, or FLH).
Fields funct3, rd, and opcode are the same as the trapping load
instruction.<span label="transformedloadinst"></span></figcaption>
</figure>
<p>For a standard store instruction that is not a compressed instruction and
is one of SB, SH, SW, SD, FSW, FSD, FSQ, or FSH, the transformed instruction
has the format shown in Figure <a href="hypervisor.html#transformedstoreinst" data-reference-type="ref" data-reference="transformedstoreinst">1.47</a>.</p>
<figure>
<img src="tmp.Priv-v1.12//hypervisor_48.svg" alt="Transformed noncompressed store instruction (SB, SH, SW, SD, FSW, FSD, FSQ, or FSH). Fields rs2, funct3, and opcode are the same as the trapping store instruction." id="transformedstoreinst" /><figcaption>Transformed noncompressed store instruction (SB, SH, SW, SD,
FSW, FSD, FSQ, or FSH).
Fields rs2, funct3, and opcode are the same as the trapping store
instruction.<span label="transformedstoreinst"></span></figcaption>
</figure>
<p>For a standard atomic instruction (load-reserved, store-conditional, or
AMO instruction), the transformed instruction has the format shown in
Figure <a href="hypervisor.html#transformedatomicinst" data-reference-type="ref" data-reference="transformedatomicinst">1.48</a>.</p>
<figure>
<img src="tmp.Priv-v1.12//hypervisor_49.svg" alt="Transformed atomic instruction (load-reserved, store-conditional, or AMO instruction). All fields are the same as the trapping instruction except bits 19:15, Addr. Offset." id="transformedatomicinst" /><figcaption>Transformed atomic instruction (load-reserved,
store-conditional, or AMO instruction).
All fields are the same as the trapping instruction except bits 19:15,
Addr. Offset.<span label="transformedatomicinst"></span></figcaption>
</figure>
<p>For a standard virtual-machine load/store instruction
(HLV, HLVX, or HSV), the transformed instruction has the format shown in
Figure <a href="hypervisor.html#transformedvmaccessinst" data-reference-type="ref" data-reference="transformedvmaccessinst">1.49</a>.</p>
<figure>
<img src="tmp.Priv-v1.12//hypervisor_50.svg" alt="Transformed virtual-machine load/store instruction (HLV, HLVX, HSV). All fields are the same as the trapping instruction except bits 19:15, Addr. Offset." id="transformedvmaccessinst" /><figcaption>Transformed virtual-machine load/store instruction (HLV, HLVX, HSV).
All fields are the same as the trapping instruction except bits 19:15,
Addr. Offset.<span label="transformedvmaccessinst"></span></figcaption>
</figure>
<p>In all the transformed instructions above, the Addr. Offset field that
replaces the instruction’s rs1 field in bits 19:15 is the positive
difference between the faulting virtual address (written to <span>mtval</span>
or <span>stval</span>) and the original virtual address.
This difference can be nonzero only for a misaligned memory access.
Note also that, for basic loads and stores, the transformations replace
the instruction’s immediate offset fields with zero.</p>
<p>For a standard compressed instruction (16-bit size), the transformed
instruction is found as follows:</p>
<ol>
<li><p>Expand the compressed instruction to its 32-bit equivalent.</p></li>
<li><p>Transform the 32-bit equivalent instruction.</p></li>
<li><p>Replace bit 1 with a <span>0</span>.</p></li>
</ol>
<p>Bits 1:0 of a transformed standard instruction will be binary <span>01</span> if
the trapping instruction is compressed and <span>11</span> if not.</p>
<div class=commentary>
<p>In decoding the contents of <span>mtinst</span> or <span>htinst</span>, once software
has determined that the register contains the encoding of a standard
basic load (LB, LBU, LH, LHU, LW, LWU, LD, FLW, FLD, FLQ, or FLH) or basic
store (SB, SH, SW, SD, FSW, FSD, FSQ, or FSH), it is not necessary to confirm
also that the immediate offset fields (31:25, and 24:20 or 11:7) are
zeros.
The knowledge that the register’s value is the encoding of a basic
load/store is sufficient to prove that the trapping instruction is of the
same kind.</p>
<p>A future version of this standard may add information to the fields that
are currently zeros.
However, for backwards compatiblity, any such information will be for
performance purposes only and can safely be ignored.</p>
</div>
<p>For guest-page faults, the trap instruction register is written with a
special pseudoinstruction value if:
(a) the fault is caused by an implicit memory access for VS-stage address
translation, and
(b) a nonzero value (the faulting guest physical address) is written to
<span>mtval2</span> or <span>htval</span>.
If both conditions are met, the value written to <span>mtinst</span> or
<span>htinst</span> must be taken from Table <a href="hypervisor.html#tab:pseudoinsts" data-reference-type="ref" data-reference="tab:pseudoinsts">[tab:pseudoinsts]</a>;
zero is not allowed.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Value</th>
<th style="text-align: left;">Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><span>0x00002000</span></td>
<td style="text-align: left;">32-bit read for VS-stage address translation (RV32)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><span>0x00002020</span></td>
<td style="text-align: left;">32-bit write for VS-stage address translation (RV32)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span>0x00003000</span></td>
<td style="text-align: left;">64-bit read for VS-stage address translation (RV64)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><span>0x00003020</span></td>
<td style="text-align: left;">64-bit write for VS-stage address translation (RV64)</td>
</tr>
</tbody>
</table>
<p>The defined pseudoinstruction values are designed to correspond closely
with the encodings of basic loads and stores, as illustrated by
Table <a href="hypervisor.html#tab:pseudoinsts-basis" data-reference-type="ref" data-reference="tab:pseudoinsts-basis">[tab:pseudoinsts-basis]</a>.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Encoding</th>
<th style="text-align: left;">Instruction</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><span>0x00002003</span></td>
<td style="text-align: left;"><span>lw x0,0(x0)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;"><span>0x00002023</span></td>
<td style="text-align: left;"><span>sw x0,0(x0)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span>0x00003003</span></td>
<td style="text-align: left;"><span>ld x0,0(x0)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;"><span>0x00003023</span></td>
<td style="text-align: left;"><span>sd x0,0(x0)</span></td>
</tr>
</tbody>
</table>
<p>A <em>write</em> pseudoinstruction (<span>0x00002020</span> or <span>0x00003020</span>)
is used for the case that the machine is attempting automatically to
update bits A and/or D in VS-level page tables.
All other implicit memory accesses for VS-stage address translation will
be reads.
If a machine never automatically updates bits A or D in VS-level page
tables (leaving this to software), the <em>write</em> case will never
arise.
The fact that such a page table update must actually be atomic, not just
a simple write, is ignored for the pseudoinstruction.</p>
<div class=commentary>
<p>If the conditions that necessitate a pseudoinstruction value can ever
occur for M-mode, then <span>mtinst</span> cannot be entirely read-only zero;
and likewise for HS-mode and <span>htinst</span>.
However, in that case, the trap instruction registers may minimally
support only values 0 and <span>0x00002000</span> or <span>0x00003000</span>, and
possibly <span>0x00002020</span> or <span>0x00003020</span>, requiring as few as one or
two flip-flops in hardware, per register.</p>
</div>
<div class=commentary>
<p>There is no harm here in ignoring the atomicity requirement for page
table updates, because a hypervisor is not expected in these
circumstances to emulate an implicit memory access that fails.
Rather, the hypervisor is given enough information about the faulting
access to be able to make the memory accessible (e.g. by restoring a
missing page of virtual memory) before resuming execution by retrying the
faulting instruction.</p>
</div>
<h3 id="trap-return"><span class="header-section-number">5.6.4</span> Trap Return</h3>
<p>The MRET instruction is used to return from a trap taken into M-mode.
MRET first determines what the new privilege mode will be according to
the values of MPP and MPV in <span>mstatus</span> or <span>mstatush</span>, as encoded in
Table <a href="hypervisor.html#h-mpp" data-reference-type="ref" data-reference="h-mpp">[h-mpp]</a>.
MRET then in <span>mstatus</span>/<span>mstatush</span> sets MPV=0, MPP=0, MIE=MPIE, and MPIE=1.
Lastly, MRET sets the privilege mode as previously
determined, and sets <span>pc</span>=<span>mepc</span>.</p>
<p>The SRET instruction is used to return from a trap taken into HS-mode or
VS-mode. Its behavior depends on the current virtualization mode.</p>
<p>When executed in M-mode or HS-mode (i.e., V=0), SRET first determines
what the new privilege mode will be according to the values in
<span>hstatus</span>.SPV and <span>sstatus</span>.SPP, as encoded in Table <a href="hypervisor.html#h-spp" data-reference-type="ref" data-reference="h-spp">[h-spp]</a>.
SRET then sets <span>hstatus</span>.SPV=0, and in <span>sstatus</span> sets SPP=0,
SIE=SPIE, and SPIE=1.
Lastly, SRET sets the privilege mode as previously
determined, and sets <span>pc</span>=<span>sepc</span>.</p>
<p>When executed in VS-mode (i.e., V=1), SRET sets the privilege mode according to
Table <a href="hypervisor.html#h-vspp" data-reference-type="ref" data-reference="h-vspp">[h-vspp]</a>, in <span>vsstatus</span> sets SPP=0, SIE=SPIE, and SPIE=1, and
lastly sets <span>pc</span>=<span>vsepc</span>.</p>

</body>
</html>
