<html>
<head>
<title>The RISC-V Instruction Set Manual, Volume II: Privileged Architecture</title>
</head>
<body>

<table>
<tr><th colspan=2>Metadata Table</th></tr>
<tr><th>Manual Type</th><td> priv</td></tr>
<tr><th>Spec Revision</th><td> 20211203</td></tr>
<tr><th>Spec Release Date</th><td> </td></tr>
<tr><th>Git Revision</th><td> Priv-v1.12</td></tr>
<tr><th>Git URL</th><td><a href=https://github.com/riscv/riscv-isa-manual.git>https://github.com/riscv/riscv-isa-manual.git</a></td></tr>
<tr><th>Source</th><td>src/supervisor.tex</td></tr>
<tr><th>Conversion Date</th><td>2023/10/11</td></tr>
<tr><th>License</th><td><a href=https://creativecommons.org/licenses/by/4.0/>CC-by-4.0</a></td></tr>
</table>


<h1 id="supervisor"><span class="header-section-number">4</span> Supervisor-Level ISA, Version 1.12</h1>
<p>This chapter describes the RISC-V supervisor-level architecture, which
contains a common core that is used with various supervisor-level
address translation and protection schemes.</p>
<div class=commentary>
<p>Supervisor mode is deliberately restricted in terms of interactions
with underlying physical hardware, such as physical memory and device
interrupts, to support clean virtualization.
In this spirit, certain supervisor-level facilities, including requests for
timer and interprocessor interrupts, are provided by implementation-specific
mechanisms. In some systems, a supervisor execution environment (SEE)
provides these facilities in a manner specified by a supervisor binary
interface (SBI). Other systems supply these facilities directly, through some
other implementation-defined mechanism.</p>
</div>
<h2 id="supervisor-csrs"><span class="header-section-number">4.1</span> Supervisor CSRs</h2>
<p>A number of CSRs are provided for the supervisor.</p>
<div class=commentary>
<p>The supervisor should only view CSR state that should be visible to a
supervisor-level operating system. In particular, there is no
information about the existence (or non-existence) of higher privilege
levels (machine level or other) visible in the CSRs accessible by the
supervisor.</p>
<p>Many supervisor CSRs are a subset of the equivalent machine-mode CSR,
and the machine-mode chapter should be read first to help understand
the supervisor-level CSR descriptions.</p>
</div>
<h3 id="sstatus"><span class="header-section-number">4.1.1</span> Supervisor Status Register (sstatus)</h3>
<p>The <span>sstatus</span> register is an SXLEN-bit read/write register
formatted as shown in Figure <a href="supervisor.html#sstatusreg-rv32" data-reference-type="ref" data-reference="sstatusreg-rv32">1.1</a> when SXLEN=32 and
Figure <a href="supervisor.html#sstatusreg" data-reference-type="ref" data-reference="sstatusreg">1.2</a> when SXLEN=64. The <span>sstatus</span>
register keeps track of the processor’s current operating state.</p>
<figure>
<img src="supervisor_00.svg" alt="Supervisor-mode status register (sstatus) when SXLEN=32." id="sstatusreg-rv32" /><figcaption>Supervisor-mode status register (<span>sstatus</span>) when SXLEN=32.<span label="sstatusreg-rv32"></span></figcaption>
</figure>
<figure>
<img src="supervisor_01.svg" alt="Supervisor-mode status register (sstatus) when SXLEN=64." id="sstatusreg" /><figcaption>Supervisor-mode status register (<span>sstatus</span>) when SXLEN=64.<span label="sstatusreg"></span></figcaption>
</figure>
<p>The SPP bit indicates the privilege level at which a hart was executing before
entering supervisor mode. When a trap is taken, SPP is set to 0 if the trap
originated from user mode, or 1 otherwise. When an SRET instruction
(see Section <a href="machine.html#otherpriv" data-reference-type="ref" data-reference="otherpriv">[otherpriv]</a>) is executed to return from the trap handler, the
privilege level is set to user mode if the SPP bit is 0, or supervisor mode if
the SPP bit is 1; SPP is then set to 0.</p>
<p>The SIE bit enables or disables all interrupts in supervisor mode.
When SIE is clear, interrupts are not taken while in supervisor mode.
When the hart is running in user-mode, the value in SIE is ignored, and
supervisor-level interrupts are enabled. The supervisor can disable
individual interrupt sources using the <span>sie</span> CSR.</p>
<p>The SPIE bit indicates whether supervisor interrupts were enabled prior to
trapping into supervisor mode. When a trap is taken into supervisor
mode, SPIE is set to SIE, and SIE is set to 0. When an SRET instruction is
executed, SIE is set to SPIE, then SPIE is set to 1.</p>
<p>The <span>sstatus</span> register is a subset of the <span>mstatus</span> register.</p>
<div class=commentary>
<p>In a straightforward implementation, reading or writing any field in
<span>sstatus</span> is equivalent to reading or writing the homonymous field
in <span>mstatus</span>.</p>
</div>
<h4 id="base-isa-control-in-sstatus-register"><span class="header-section-number">4.1.1.1</span> Base ISA Control in <span>sstatus</span> Register</h4>
<p>The UXL field controls the value of XLEN for U-mode, termed <span><em>UXLEN</em></span>,
which may differ from the value of XLEN for S-mode, termed <span><em>SXLEN</em></span>. The
encoding of UXL is the same as that of the MXL field of <span>misa</span>, shown in
Table <a href="machine.html#misabase" data-reference-type="ref" data-reference="misabase">[misabase]</a>.</p>
<p>When SXLEN=32, the UXL field does not exist, and UXLEN=32. When
SXLEN=64, it is a <strong>WARL</strong> field that encodes the current value of UXLEN.
In particular, an implementation may make UXL be a read-only field whose
value always ensures that UXLEN=SXLEN.</p>
<p>If UXLEN <span class="math inline">≠</span> SXLEN, instructions executed in the narrower mode must ignore
source register operand bits above the configured XLEN, and must sign-extend
results to fill the widest supported XLEN in the destination register.</p>
<p>If UXLEN <span class="math inline">&lt;</span> SXLEN, user-mode instruction-fetch addresses and load and store
effective addresses are taken modulo <span class="math inline">2<sup>UXLEN</sup></span>. For example, when UXLEN=32
and SXLEN=64, user-mode memory accesses reference the lowest <span>4</span><span>GiB</span>
of the address space.</p>
<h4 id="sec:sum"><span class="header-section-number">4.1.1.2</span> Memory Privilege in <span>sstatus</span> Register</h4>
<p>The MXR (Make eXecutable Readable) bit modifies the privilege with which loads
access virtual memory. When MXR=0, only loads from pages marked readable (R=1
in Figure <a href="supervisor.html#sv32pte" data-reference-type="ref" data-reference="sv32pte">1.19</a>) will succeed. When MXR=1, loads from pages marked
either readable or executable (R=1 or X=1) will succeed. MXR has no effect
when page-based virtual memory is not in effect.</p>
<p>The SUM (permit Supervisor User Memory access) bit modifies the privilege with
which S-mode loads and stores access virtual memory.
When SUM=0, S-mode memory accesses to pages that are accessible by U-mode (U=1
in Figure <a href="supervisor.html#sv32pte" data-reference-type="ref" data-reference="sv32pte">1.19</a>) will fault. When SUM=1, these accesses are permitted.
SUM has no effect when page-based virtual memory is not in effect, nor when
executing in U-mode. Note that S-mode can never execute instructions from user
pages, regardless of the state of SUM.</p>
<p>SUM is read-only 0 if <span>satp</span>.MODE is read-only 0.</p>
<div class=commentary>
<p>The SUM mechanism prevents supervisor software from inadvertently accessing
user memory. Operating systems can execute the majority of code with SUM clear;
the few code segments that should access user memory can temporarily set
SUM.</p>
<p>The SUM mechanism does not avail S-mode software of permission to execute
instructions in user code pages. Legitimate uses cases for execution from
user memory in supervisor context are rare in general and nonexistent in POSIX
environments. However, bugs in supervisors that lead to arbitrary code
execution are much easier to exploit if the supervisor exploit code can be
stored in a user buffer at a virtual address chosen by an attacker.</p>
<p>Some non-POSIX single address space operating systems do allow certain
privileged software to partially execute in supervisor mode, while most
programs run in user mode, all in a shared address space. This use case can
be realized by mapping the physical code pages at multiple virtual addresses
with different permissions, possibly with the assistance of the
instruction page-fault handler to direct supervisor software to use the
alternate mapping.</p>
</div>
<h4 id="endianness-control-in-sstatus-register"><span class="header-section-number">4.1.1.3</span> Endianness Control in <span>sstatus</span> Register</h4>
<p>The UBE bit is a <strong>WARL</strong> field that controls the endianness of explicit
memory accesses made from U-mode, which may differ from the endianness of
memory accesses in S-mode.
An implementation may make UBE be a read-only field that always specifies
the same endianness as for S-mode.</p>
<p>UBE controls whether explicit
load and store memory accesses made from U-mode are little-endian (UBE=0)
or big-endian (UBE=1).</p>
<p>UBE has no effect on instruction fetches, which are <span><em>implicit</em></span> memory
accesses that are always little-endian.</p>
<p>For <span><em>implicit</em></span> accesses to supervisor-level memory management data
structures, such as page tables, S-mode endianness always applies and UBE
is ignored.</p>
<div class=commentary>
<p>Standard RISC-V ABIs are expected to be purely little-endian-only or
big-endian-only, with no accommodation for mixing endianness.
Nevertheless, endianness control has been defined so as to permit an
OS of one endianness to execute user-mode programs of the opposite
endianness.</p>
</div>
<h3 id="supervisor-trap-vector-base-address-register-stvec"><span class="header-section-number">4.1.2</span> Supervisor Trap Vector Base Address Register (<span>stvec</span>)</h3>
<p>The <span>stvec</span> register is an SXLEN-bit read/write register that holds
trap vector configuration, consisting of a vector base address (BASE) and a
vector mode (MODE).</p>
<figure>
<img src="supervisor_02.svg" alt="Supervisor trap vector base address register (stvec)." id="stvecreg" /><figcaption>Supervisor trap vector base address register (<span>stvec</span>).<span label="stvecreg"></span></figcaption>
</figure>
<p>The BASE field in <span>stvec</span> is a <strong>WARL</strong> field that can hold any valid
virtual or physical address, subject to the following alignment constraints:
the address must be 4-byte aligned, and MODE settings other than Direct might
impose additional alignment constraints on the value in the BASE field.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: right;">Value</th>
<th style="text-align: center;">Name</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">0</td>
<td style="text-align: center;">Direct</td>
<td style="text-align: left;">All exceptions set <span>pc</span> to BASE.</td>
</tr>
<tr class="even">
<td style="text-align: right;">1</td>
<td style="text-align: center;">Vectored</td>
<td style="text-align: left;">Asynchronous interrupts set <span>pc</span> to BASE+4<span class="math inline">×</span>cause.</td>
</tr>
<tr class="odd">
<td style="text-align: right;"><span class="math inline">≥</span>2</td>
<td style="text-align: center;">—</td>
<td style="text-align: left;"><span><em>Reserved</em></span></td>
</tr>
</tbody>
</table>
<p>The encoding of the MODE field is shown in Table <a href="supervisor.html#stvec-mode" data-reference-type="ref" data-reference="stvec-mode">[stvec-mode]</a>. When
MODE=Direct, all traps into supervisor mode cause the <span>pc</span> to be set to the
address in the BASE field. When MODE=Vectored, all synchronous exceptions
into supervisor mode cause the <span>pc</span> to be set to the address in the BASE
field, whereas interrupts cause the <span>pc</span> to be set to the address in
the BASE field plus four times the interrupt cause number. For example,
a supervisor-mode timer interrupt (see Table <a href="supervisor.html#scauses" data-reference-type="ref" data-reference="scauses">[scauses]</a>) causes the <span>pc</span>
to be set to BASE+<span>0x14</span>.
Setting MODE=Vectored may impose a stricter alignment constraint on BASE.</p>
<h3 id="supervisor-interrupt-registers-sip-and-sie"><span class="header-section-number">4.1.3</span> Supervisor Interrupt Registers (<span>sip</span> and <span>sie</span>)</h3>
<p>The <span>sip</span> register is an SXLEN-bit read/write register containing
information on pending interrupts, while <span>sie</span> is the corresponding
SXLEN-bit read/write register containing interrupt enable bits.
Interrupt cause number <em>i</em> (as reported in CSR <span>scause</span>,
Section <a href="supervisor.html#sec:scause" data-reference-type="ref" data-reference="sec:scause">1.1.8</a>) corresponds with bit <em>i</em> in both
<span>sip</span> and <span>sie</span>.
Bits 15:0 are allocated to standard interrupt causes only, while bits 16
and above are designated for platform or custom use.</p>
<figure>
<img src="supervisor_03.svg" alt="Supervisor interrupt-pending register (sip)." id="sipreg" /><figcaption>Supervisor interrupt-pending register (<span>sip</span>).<span label="sipreg"></span></figcaption>
</figure>
<figure>
<img src="supervisor_04.svg" alt="Supervisor interrupt-enable register (sie)." id="siereg" /><figcaption>Supervisor interrupt-enable register (<span>sie</span>).<span label="siereg"></span></figcaption>
</figure>
<p>An interrupt <em>i</em> will trap to S-mode if both of the
following are true:
(a) either the current privilege mode is S and the SIE bit in the
<span>sstatus</span> register is set, or the current privilege mode has less
privilege than S-mode; and
(b) bit <em>i</em> is set in both <span>sip</span> and <span>sie</span>.</p>
<p>These conditions for an interrupt trap to occur must be evaluated in a bounded
amount of time from when an interrupt becomes, or ceases to be,
pending in <span>sip</span>, and must
also be evaluated immediately following the execution of an SRET instruction
or an explicit write to a CSR on which these interrupt trap conditions
expressly depend (including <span>sip</span>, <span>sie</span> and <span>sstatus</span>).</p>
<p>Interrupts to S-mode take priority over any interrupts to lower privilege
modes.</p>
<p>Each individual bit in register <span>sip</span> may be writable or may be
read-only.
When bit <em>i</em> in <span>sip</span> is writable, a pending interrupt
<em>i</em> can be cleared by writing 0 to this bit.
If interrupt <em>i</em> can become pending but bit <em>i</em> in
<span>sip</span> is read-only, the implementation must provide some other
mechanism for clearing the pending interrupt (which may involve a call to
the execution environment).</p>
<p>A bit in <span>sie</span> must be writable if the corresponding interrupt can
ever become pending.
Bits of <span>sie</span> that are not writable are read-only zero.</p>
<p>The standard portions (bits 15:0) of registers <span>sip</span> and <span>sie</span>
are formatted as shown in Figures <a href="supervisor.html#sipreg-standard" data-reference-type="ref" data-reference="sipreg-standard">1.6</a> and
<a href="supervisor.html#siereg-standard" data-reference-type="ref" data-reference="siereg-standard">1.7</a> respectively.</p>
<figure>
<img src="supervisor_05.svg" alt="Standard portion (bits 15:0) of sip." id="sipreg-standard" /><figcaption>Standard portion (bits 15:0) of <span>sip</span>.<span label="sipreg-standard"></span></figcaption>
</figure>
<figure>
<img src="supervisor_06.svg" alt="Standard portion (bits 15:0) of sie." id="siereg-standard" /><figcaption>Standard portion (bits 15:0) of <span>sie</span>.<span label="siereg-standard"></span></figcaption>
</figure>
<p>Bits <span>sip</span>.SEIP and <span>sie</span>.SEIE are the interrupt-pending and
interrupt-enable bits for supervisor-level external interrupts.
If implemented, SEIP is read-only in <span>sip</span>, and is set and cleared by
the execution environment, typically through a platform-specific
interrupt controller.</p>
<p>Bits <span>sip</span>.STIP and <span>sie</span>.STIE are the interrupt-pending and
interrupt-enable bits for supervisor-level timer interrupts.
If implemented, STIP is read-only in <span>sip</span>, and is set and cleared by
the execution environment.</p>
<p>Bits <span>sip</span>.SSIP and <span>sie</span>.SSIE are the interrupt-pending and
interrupt-enable bits for supervisor-level software interrupts.
If implemented, SSIP is writable in <span>sip</span> and may also be set
to 1 by a platform-specific interrupt controller.</p>
<div class=commentary>
<p>Interprocessor interrupts are sent to other harts by implementation-specific
means, which will ultimately cause the SSIP bit to be set in the recipient
hart’s <span>sip</span> register.</p>
</div>
<p>Each standard interrupt type (SEI, STI, or SSI) may not be implemented,
in which case the corresponding interrupt-pending and interrupt-enable
bits are read-only zeros.
All bits in <span>sip</span> and <span>sie</span> are <strong>WARL</strong> fields.
The implemented interrupts may be found by writing one to every bit
location in <span>sie</span>, then reading back to see which bit positions hold
a one.</p>
<div class=commentary>
<p>The <span>sip</span> and <span>sie</span> registers are subsets of the <span>mip</span> and <span>
mie</span> registers. Reading any implemented field,
or writing any writable field, of <span>sip</span>/<span>sie</span>
effects a read or write of the homonymous field of <span>mip</span>/<span>mie</span>.</p>
<p>Bits 3, 7, and 11 of <span>sip</span> and <span>sie</span> correspond to the machine-mode
software, timer, and external interrupts, respectively. Since most platforms
will choose not to make these interrupts delegatable from M-mode to S-mode,
they are shown as 0 in Figures <a href="supervisor.html#sipreg-standard" data-reference-type="ref" data-reference="sipreg-standard">1.6</a> and
<a href="supervisor.html#siereg-standard" data-reference-type="ref" data-reference="siereg-standard">1.7</a>.</p>
</div>
<p>Multiple simultaneous
interrupts destined for supervisor mode are handled in the following
decreasing priority order: SEI, SSI, STI.</p>
<h3 id="supervisor-timers-and-performance-counters"><span class="header-section-number">4.1.4</span> Supervisor Timers and Performance Counters</h3>
<p>Supervisor software uses the same hardware performance monitoring facility
as user-mode software, including the <span>time</span>, <span>cycle</span>, and <span>instret</span>
CSRs. The implementation should provide a mechanism to modify the
counter values.</p>
<p>The implementation must provide a facility for scheduling timer interrupts in
terms of the real-time counter, <span>time</span>.</p>
<h3 id="counter-enable-register-scounteren"><span class="header-section-number">4.1.5</span> Counter-Enable Register (<span>scounteren</span>)</h3>
<figure>
<img src="supervisor_07.svg" alt="Counter-enable register (scounteren)." id="scounteren" /><figcaption>Counter-enable register (<span>scounteren</span>).<span label="scounteren"></span></figcaption>
</figure>
<p>The counter-enable register <span>scounteren</span> is a 32-bit register that
controls the availability of the hardware performance monitoring counters to
U-mode.</p>
<p>When the CY, TM, IR, or HPM<span><em>n</em></span> bit in the <span>scounteren</span> register is
clear, attempts to read the <span>cycle</span>, <span>time</span>, <span>instret</span>, or
<span>hpmcounter<span><em>n</em></span></span> register while executing in U-mode
will cause an illegal instruction exception. When one of these bits is set,
access to the corresponding register is permitted.</p>
<p><span>scounteren</span> must be implemented. However, any of the bits may be
read-only zero, indicating reads to the corresponding counter will
cause an exception when executing in U-mode.
Hence, they are effectively <strong>WARL</strong> fields.</p>
<div class=commentary>
<p>The setting of a bit in <span>mcounteren</span> does not affect whether the
corresponding bit in <span>scounteren</span> is writable.
However, U-mode may only access a counter if the corresponding bits in <span>
scounteren</span> and <span>mcounteren</span> are both set.</p>
</div>
<h3 id="supervisor-scratch-register-sscratch"><span class="header-section-number">4.1.6</span> Supervisor Scratch Register (<span>sscratch</span>)</h3>
<p>The <span>sscratch</span> register is an SXLEN-bit read/write register,
dedicated for use by the supervisor. Typically, <span>sscratch</span> is
used to hold a pointer to the hart-local supervisor context while the
hart is executing user code. At the beginning of a trap handler, <span>
sscratch</span> is swapped with a user register to provide an initial
working register.</p>
<figure>
<img src="supervisor_08.svg" alt="Supervisor Scratch Register." id="kregs" /><figcaption>Supervisor Scratch Register.<span label="kregs"></span></figcaption>
</figure>
<h3 id="supervisor-exception-program-counter-sepc"><span class="header-section-number">4.1.7</span> Supervisor Exception Program Counter (<span>sepc</span>)</h3>
<p><span>sepc</span> is an SXLEN-bit read/write register formatted as shown in
Figure <a href="supervisor.html#epcreg" data-reference-type="ref" data-reference="epcreg">1.10</a>. The low bit of <span>sepc</span> (<span>sepc[0]</span>) is
always zero. On implementations that support only IALIGN=32, the two low bits
(<span>sepc[1:0]</span>) are always zero.</p>
<p>If an implementation allows IALIGN to be either 16 or 32 (by
changing CSR <span>misa</span>, for example), then, whenever IALIGN=32, bit
<span>sepc[1]</span> is masked on reads so that it appears to be 0. This
masking occurs also for the implicit read by the SRET instruction.
Though masked, <span>sepc[1]</span> remains writable when IALIGN=32.</p>
<p><span>sepc</span> is a <strong>WARL</strong> register that must be able to hold all valid
virtual addresses. It need not be capable of holding all possible invalid
addresses.
Prior to writing <span>sepc</span>, implementations may convert an invalid address
into some other invalid address that <span>sepc</span> is capable of holding.</p>
<p>When a trap is taken into S-mode, <span>sepc</span> is written with the
virtual address of the instruction that was interrupted or that
encountered the exception. Otherwise, <span>sepc</span> is never written by
the implementation, though it may be explicitly written by software.</p>
<figure>
<img src="supervisor_09.svg" alt="Supervisor exception program counter register." id="epcreg" /><figcaption>Supervisor exception program counter register.<span label="epcreg"></span></figcaption>
</figure>
<h3 id="sec:scause"><span class="header-section-number">4.1.8</span> Supervisor Cause Register (<span>scause</span>)</h3>
<p>The <span>scause</span> register is an SXLEN-bit read-write register formatted as
shown in Figure <a href="supervisor.html#scausereg" data-reference-type="ref" data-reference="scausereg">1.11</a>. When a trap is taken into S-mode, <span>
scause</span> is written with a code indicating the event that caused the trap.
Otherwise, <span>scause</span> is never written by the implementation, though it may be
explicitly written by software.</p>
<p>The Interrupt bit in the <span>scause</span> register is set if the
trap was caused by an interrupt. The Exception Code field
contains a code identifying the last exception or interrupt. Table <a href="supervisor.html#scauses" data-reference-type="ref" data-reference="scauses">[scauses]</a>
lists the possible exception codes for the current supervisor ISAs.
The Exception Code is a <strong>WLRL</strong> field. It is required to hold
the values 0–31 (i.e., bits 4–0 must be implemented), but otherwise
it is only guaranteed to hold supported exception codes.</p>
<figure>
<img src="supervisor_10.svg" alt="Supervisor Cause register scause." id="scausereg" /><figcaption>Supervisor Cause register <span>scause</span>.<span label="scausereg"></span></figcaption>
</figure>
<table>
<thead>
<tr class="header">
<th style="text-align: right;">Interrupt</th>
<th style="text-align: right;">Exception Code</th>
<th style="text-align: left;">Description</th>
<th style="text-align: left;"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">1</td>
<td style="text-align: right;">0</td>
<td style="text-align: left;"><span><em>Reserved</em></span></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: right;">1</td>
<td style="text-align: right;">1</td>
<td style="text-align: left;">Supervisor software interrupt</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: right;">1</td>
<td style="text-align: right;">2–4</td>
<td style="text-align: left;"><span><em>Reserved</em></span></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: right;">1</td>
<td style="text-align: right;">5</td>
<td style="text-align: left;">Supervisor timer interrupt</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: right;">1</td>
<td style="text-align: right;">6–8</td>
<td style="text-align: left;"><span><em>Reserved</em></span></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: right;">1</td>
<td style="text-align: right;">9</td>
<td style="text-align: left;">Supervisor external interrupt</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: right;">1</td>
<td style="text-align: right;">10–15</td>
<td style="text-align: left;"><span><em>Reserved</em></span></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: right;">1</td>
<td style="text-align: right;"><span class="math inline">≥</span>16</td>
<td style="text-align: left;"><span><em>Designated for platform use</em></span></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: right;">0</td>
<td style="text-align: right;">0</td>
<td style="text-align: left;">Instruction address misaligned</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: right;">0</td>
<td style="text-align: right;">1</td>
<td style="text-align: left;">Instruction access fault</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: right;">0</td>
<td style="text-align: right;">2</td>
<td style="text-align: left;">Illegal instruction</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: right;">0</td>
<td style="text-align: right;">3</td>
<td style="text-align: left;">Breakpoint</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: right;">0</td>
<td style="text-align: right;">4</td>
<td style="text-align: left;">Load address misaligned</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: right;">0</td>
<td style="text-align: right;">5</td>
<td style="text-align: left;">Load access fault</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: right;">0</td>
<td style="text-align: right;">6</td>
<td style="text-align: left;">Store/AMO address misaligned</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: right;">0</td>
<td style="text-align: right;">7</td>
<td style="text-align: left;">Store/AMO access fault</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: right;">0</td>
<td style="text-align: right;">8</td>
<td style="text-align: left;">Environment call from U-mode</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: right;">0</td>
<td style="text-align: right;">9</td>
<td style="text-align: left;">Environment call from S-mode</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: right;">0</td>
<td style="text-align: right;">10–11</td>
<td style="text-align: left;"><span><em>Reserved</em></span></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: right;">0</td>
<td style="text-align: right;">12</td>
<td style="text-align: left;">Instruction page fault</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: right;">0</td>
<td style="text-align: right;">13</td>
<td style="text-align: left;">Load page fault</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: right;">0</td>
<td style="text-align: right;">14</td>
<td style="text-align: left;"><span><em>Reserved</em></span></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: right;">0</td>
<td style="text-align: right;">15</td>
<td style="text-align: left;">Store/AMO page fault</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: right;">0</td>
<td style="text-align: right;">16–23</td>
<td style="text-align: left;"><span><em>Reserved</em></span></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: right;">0</td>
<td style="text-align: right;">24–31</td>
<td style="text-align: left;"><span><em>Designated for custom use</em></span></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: right;">0</td>
<td style="text-align: right;">32–47</td>
<td style="text-align: left;"><span><em>Reserved</em></span></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: right;">0</td>
<td style="text-align: right;">48–63</td>
<td style="text-align: left;"><span><em>Designated for custom use</em></span></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: right;">0</td>
<td style="text-align: right;"><span class="math inline">≥</span>64</td>
<td style="text-align: left;"><span><em>Reserved</em></span></td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<h3 id="supervisor-trap-value-stval-register"><span class="header-section-number">4.1.9</span> Supervisor Trap Value (<span>stval</span>) Register</h3>
<p>The <span>stval</span> register is an SXLEN-bit read-write register formatted as shown
in Figure <a href="supervisor.html#stvalreg" data-reference-type="ref" data-reference="stvalreg">1.12</a>. When a trap is taken into S-mode, <span>stval</span> is
written with exception-specific information to assist software in handling the
trap. Otherwise, <span>stval</span> is never written by the implementation, though
it may be explicitly written by software. The hardware platform will specify
which exceptions must set <span>stval</span> informatively and which may
unconditionally set it to zero.</p>
<p>If <span>stval</span> is written with a nonzero value when a breakpoint,
address-misaligned, access-fault, or page-fault exception occurs on an
instruction fetch, load, or store, then <span>stval</span> will contain the faulting
virtual address.</p>
<figure>
<img src="supervisor_11.svg" alt="Supervisor Trap Value register." id="stvalreg" /><figcaption>Supervisor Trap Value register.<span label="stvalreg"></span></figcaption>
</figure>
<p>If <span>stval</span> is written with a nonzero value when a misaligned load or store
causes an access-fault or page-fault exception, then <span>stval</span> will contain
the virtual address of the portion of the access that caused the fault.</p>
<p>If <span>stval</span> is written with a nonzero value when an instruction access-fault
or page-fault exception occurs on a system with variable-length instructions,
then <span>stval</span> will contain the virtual address of the portion of the
instruction that caused the fault, while <span>sepc</span> will point to the beginning
of the instruction.</p>
<p>The <span>stval</span> register can optionally also be used to return the faulting
instruction bits on an illegal instruction exception (<span>sepc</span> points to the
faulting instruction in memory).
If <span>stval</span> is written with a nonzero value when an illegal-instruction
exception occurs, then <span>stval</span> will contain the shortest of:</p>
<p>the actual faulting instruction</p>
<p>the first ILEN bits of the faulting instruction</p>
<p>the first SXLEN bits of the faulting instruction</p>
<p>The value loaded into <span>stval</span> on an illegal-instruction exception is
right-justified and all unused upper bits are cleared to zero.</p>
<p>For other traps, <span>stval</span> is set to zero, but a future standard may
redefine <span>stval</span>’s setting for other traps.</p>
<p><span>stval</span> is a <strong>WARL</strong> register that must be able to hold all valid
virtual addresses and the value 0. It need not be capable of holding all
possible invalid addresses.
Prior to writing <span>stval</span>, implementations may convert an invalid address
into some other invalid address that <span>stval</span> is capable of holding.
If the feature to return the faulting instruction bits is implemented, <span>
stval</span> must also be able to hold all values less than <span class="math inline">2<sup><em>N</em></sup></span>, where <span class="math inline"><em>N</em></span> is the
smaller of SXLEN and ILEN.</p>
<h3 id="supervisor-environment-configuration-register-senvcfg"><span class="header-section-number">4.1.10</span> Supervisor Environment Configuration Register (<span>senvcfg</span>)</h3>
<p>The <span>senvcfg</span> CSR is an SXLEN-bit read/write register,
formatted as shown in Figure <a href="supervisor.html#fig:senvcfg" data-reference-type="ref" data-reference="fig:senvcfg">1.13</a>,
that controls certain characteristics of the U-mode execution environment.</p>
<figure>
<img src="supervisor_12.svg" alt="Supervisor environment configuration register (senvcfg)." id="fig:senvcfg" /><figcaption>Supervisor environment configuration register (<span>senvcfg</span>).<span label="fig:senvcfg"></span></figcaption>
</figure>
<p>If bit FIOM (Fence of I/O implies Memory) is set to one in <span>senvcfg</span>,
FENCE instructions executed in U-mode are modified so
the requirement to order accesses to device I/O implies also the requirement
to order main memory accesses.
Table <a href="supervisor.html#tab:senvcfg-FIOM" data-reference-type="ref" data-reference="tab:senvcfg-FIOM">[tab:senvcfg-FIOM]</a> details the modified interpretation of
FENCE instruction bits PI, PO, SI, and SO in U-mode when FIOM=1.</p>
<p>Similarly, for U-mode when FIOM=1,
if an atomic instruction that accesses a region ordered as device I/O
has its <span><em>aq</em></span> and/or <span><em>rl</em></span> bit set, then that instruction is ordered
as though it accesses both device I/O and memory.</p>
<p>If <span>satp</span>.MODE is read-only zero (always Bare), the implementation may make FIOM read-only zero.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Instruction bit</th>
<th style="text-align: left;">Meaning when set</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">PI</td>
<td style="text-align: left;">Predecessor device input and memory reads (PR implied)</td>
</tr>
<tr class="even">
<td style="text-align: center;">PO</td>
<td style="text-align: left;">Predecessor device output and memory writes (PW implied)</td>
</tr>
<tr class="odd">
<td style="text-align: center;">SI</td>
<td style="text-align: left;">Successor device input and memory reads (SR implied)</td>
</tr>
<tr class="even">
<td style="text-align: center;">SO</td>
<td style="text-align: left;">Successor device output and memory writes (SW implied)</td>
</tr>
</tbody>
</table>
<div class=commentary>
<p>Bit FIOM exists for a specific circumstance when an I/O device is
being emulated for U-mode and both of the following are true:
(a) the emulated device has a memory buffer that should be I/O space
but is actually mapped to main memory via address translation, and
(b) multiple physical harts are involved in accessing this emulated
device from U-mode.</p>
<p>A hypervisor running in S-mode without the benefit of the hypervisor
extension of Chapter <a href="hypervisor.html#hypervisor" data-reference-type="ref" data-reference="hypervisor">[hypervisor]</a> may need to emulate a device for
U-mode if paravirtualization cannot be employed.
If the same hypervisor provides a virtual machine (VM) with multiple
virtual harts, mapped one-to-one to real harts, then multiple harts may
concurrently access the emulated device, perhaps because:
(a) the guest OS within the VM assigns device interrupt handling to one
hart while the device is also accessed by a different hart outside of
an interrupt handler, or
(b) control of the device (or partial control) is being migrated
from one hart to another, such as for interrupt load balancing within
the VM.
For such cases, guest software within the VM is expected to properly
coordinate access to the (emulated) device across multiple harts using
mutex locks and/or interprocessor interrupts as usual, which in part
entails executing I/O fences.
But those I/O fences may not be sufficient if some of the device
“I/O” is actually main memory, unknown to the guest.
Setting FIOM=1 modifies those fences (and all other I/O fences executed
in U-mode) to include main memory, too.</p>
<p>Software can always avoid the need to set FIOM by never using main
memory to emulate a device memory buffer that should be I/O space.
However, this choice usually requires trapping all U-mode accesses
to the emulated buffer, which might have a noticeable impact on
performance.
The alternative offered by FIOM is sufficiently inexpensive to implement that
we consider it worth supporting even if only rarely enabled.</p>
</div>
<p>The definition of the CBZE field will be furnished by the
forthcoming Zicboz extension.
Its allocation within <span>senvcfg</span> may change prior to the ratification
of that extension.</p>
<p>The definitions of the CBCFE and CBIE fields will be furnished by the
forthcoming Zicbom extension.
Their allocations within <span>senvcfg</span> may change prior to the ratification
of that extension.</p>
<h3 id="sec:satp"><span class="header-section-number">4.1.11</span> Supervisor Address Translation and Protection (<span>satp</span>) Register</h3>
<p>The <span>satp</span> register is an SXLEN-bit read/write register, formatted as shown
in Figure <a href="supervisor.html#rv32satp" data-reference-type="ref" data-reference="rv32satp">1.14</a> for SXLEN=32 and Figure <a href="supervisor.html#rv64satp" data-reference-type="ref" data-reference="rv64satp">1.15</a> for SXLEN=64, which
controls supervisor-mode address translation and protection.
This register holds the physical page number (PPN) of the root page
table, i.e., its supervisor physical address divided by <span>4</span><span>KiB</span>;
an address space identifier (ASID), which facilitates address-translation
fences on a per-address-space basis; and the MODE field, which selects the
current address-translation scheme. Further details on the access to this
register are described in Section <a href="machine.html#virt-control" data-reference-type="ref" data-reference="virt-control">[virt-control]</a>.</p>
<figure>
<img src="supervisor_13.svg" alt=" Supervisor address translation and protection register satp when SXLEN=32. " id="rv32satp" /><figcaption>
Supervisor address translation and protection register <span>satp</span>
when SXLEN=32.
<span label="rv32satp"></span></figcaption>
</figure>
<div class=commentary>
<p>Storing a PPN in <span>satp</span>, rather than a physical address, supports
a physical address space larger than <span>4</span><span>GiB</span> for RV32.</p>
<p>The <span>satp</span>.PPN field might not be capable of holding all physical page
numbers.
Some platform standards might place constraints on the values <span>satp</span>.PPN
may assume, e.g., by requiring that all physical page numbers corresponding to
main memory be representable.</p>
</div>
<figure>
<img src="supervisor_14.svg" alt=" Supervisor address translation and protection register satp when SXLEN=64, for MODE values Bare, Sv39, Sv48, and Sv57. " id="rv64satp" /><figcaption>
Supervisor address translation and protection register <span>satp</span>
when SXLEN=64, for MODE values Bare, Sv39, Sv48, and Sv57.
<span label="rv64satp"></span></figcaption>
</figure>
<div class=commentary>
<p>We store the ASID and the page table base address in the same CSR to allow the
pair to be changed atomically on a context switch. Swapping them
non-atomically could pollute the old virtual address space with new
translations, or vice-versa. This approach also slightly reduces the cost of
a context switch.</p>
</div>
<p>Table <a href="supervisor.html#tab:satp-mode" data-reference-type="ref" data-reference="tab:satp-mode">1.16</a> shows the encodings of the MODE field when SXLEN=32 and
SXLEN=64. When MODE=Bare, supervisor virtual addresses are equal to
supervisor physical addresses, and there is no additional memory protection
beyond the physical memory protection scheme described in
Section <a href="machine.html#sec:pmp" data-reference-type="ref" data-reference="sec:pmp">[sec:pmp]</a>.
To select MODE=Bare, software must write zero to the remaining fields of
<span>satp</span> (bits 30–0 when SXLEN=32, or bits 59–0 when SXLEN=64).
Attempting to select MODE=Bare with a nonzero pattern in the remaining fields
has an  effect on the value that the remaining fields assume
and an  effect on address translation and protection behavior.</p>
<p>When SXLEN=32, the <span>satp</span> encodings corresponding to MODE=Bare and ASID[8:7]=3 are designated
for custom use, whereas the encodings corresponding to MODE=Bare and ASID[8:7]<span class="math inline">≠</span>3 are
reserved for future standard use.
When SXLEN=64, all <span>satp</span> encodings corresponding to MODE=Bare are reserved for future
standard use.</p>
<div class=commentary>
<p>Version 1.11 of this standard stated that the remaining fields in <span>satp</span>
had no effect when MODE=Bare.
Making these fields reserved facilitates future definition of
additional translation and protection modes, particularly in RV32, for which
all patterns of the existing MODE field have already been allocated.</p>
</div>
<p>When SXLEN=32, the only other valid setting for MODE is Sv32, a paged
virtual-memory scheme described in Section <a href="supervisor.html#sec:sv32" data-reference-type="ref" data-reference="sec:sv32">1.3</a>.</p>
<p>When SXLEN=64, three paged virtual-memory schemes are defined: Sv39, Sv48, and Sv57,
described in Sections <a href="supervisor.html#sec:sv39" data-reference-type="ref" data-reference="sec:sv39">1.4</a>, <a href="supervisor.html#sec:sv48" data-reference-type="ref" data-reference="sec:sv48">1.5</a>, and <a href="supervisor.html#sec:sv57" data-reference-type="ref" data-reference="sec:sv57">1.6</a>, respectively.
One additional scheme, Sv64, will be defined in a later version
of this specification. The remaining MODE settings are reserved
for future use and may define different interpretations of the other fields in
<span>satp</span>.</p>
<p>Implementations are not required to support all MODE settings,
and if <span>satp</span> is written with an unsupported MODE, the entire write has
no effect; no fields in <span>satp</span> are modified.</p>
<figure>
<img src="supervisor_15.svg" alt="Encoding of satp MODE field." id="tab:satp-mode" /><figcaption>Encoding of <span>satp</span> MODE field.<span label="tab:satp-mode"></span></figcaption>
</figure>
<p>The number of ASID bits is  and may be zero. The
number of implemented ASID bits, termed <span><span><em>ASIDLEN</em></span> </span>, may be
determined by writing one to every bit position in the ASID field, then
reading back the value in <span>satp</span> to see which bit positions in the ASID
field hold a one. The least-significant bits of ASID are implemented first:
that is, if ASIDLEN <span class="math inline">&gt;</span> 0, ASID[ASIDLEN-1:0] is writable. The maximal value
of ASIDLEN, termed ASIDMAX, is 9 for Sv32 or 16 for Sv39, Sv48, and Sv57.</p>
<div class=commentary>
<p>For many applications, the choice of page size has a substantial
performance impact. A large page size increases TLB reach and loosens
the associativity constraints on virtually indexed, physically tagged
caches. At the same time, large pages exacerbate internal
fragmentation, wasting physical memory and possibly cache capacity.</p>
<p>After much deliberation, we have settled on a conventional page size
of 4 KiB for both RV32 and RV64. We expect this decision to ease the
porting of low-level runtime software and device drivers. The TLB
reach problem is ameliorated by transparent superpage support in
modern operating systems <span class="citation" data-cites="transparent-superpages"><a href="#ref-transparent-superpages">[transparent-superpages]</a></span>. Additionally,
multi-level TLB hierarchies are quite inexpensive relative to the
multi-level cache hierarchies whose address space they map.</p>
</div>
<p>The <span>satp</span> register is considered <span><em>active</em></span> when the effective
privilege mode is S-mode or U-mode.
Executions of the
address-translation algorithm may only begin using a given value of <span>satp</span>
when <span>satp</span> is active.</p>
<div class=commentary>
<p>Translations that began while <span>satp</span> was active are not required to
complete or terminate when <span>satp</span> is no longer active, unless an
SFENCE.VMA instruction matching the address and ASID is executed. The
SFENCE.VMA instruction must be used to ensure that updates to the
address-translation data structures are observed by subsequent implicit reads
to those structures by a hart.</p>
</div>
<p>Note that writing <span>satp</span> does not imply any ordering constraints
between page-table updates and subsequent address translations, nor does
it imply any invalidation of address-translation caches.
If the new address space’s page tables have been modified, or if an
ASID is reused, it may be necessary to execute an SFENCE.VMA instruction
(see Section <a href="supervisor.html#sec:sfence.vma" data-reference-type="ref" data-reference="sec:sfence.vma">1.2.1</a>) after, or in some cases before,
writing <span>satp</span>.</p>
<div class=commentary>
<p>Not imposing upon implementations to flush address-translation caches
upon <span>satp</span> writes reduces the cost of context switches, provided
a sufficiently large ASID space.</p>
</div>
<h2 id="supervisor-instructions"><span class="header-section-number">4.2</span> Supervisor Instructions</h2>
<p>In addition to the SRET instruction defined in
Section <a href="machine.html#otherpriv" data-reference-type="ref" data-reference="otherpriv">[otherpriv]</a>, one new supervisor-level instruction is
provided.</p>
<h3 id="sec:sfence.vma"><span class="header-section-number">4.2.1</span> Supervisor Memory-Management Fence Instruction</h3>
<p><img src="supervisor_16.svg" alt="image" /></p>
<p>The supervisor memory-management fence instruction SFENCE.VMA is used to
synchronize updates to in-memory memory-management data structures with
current execution. Instruction execution causes implicit reads and writes to
these data structures; however, these implicit references are ordinarily not
ordered with respect to explicit loads and stores. Executing
an SFENCE.VMA instruction guarantees that any previous stores already visible
to the current RISC-V hart are ordered before certain implicit references by
subsequent instructions in that hart to the memory-management data structures.
The specific set of operations ordered by SFENCE.VMA is
determined by <span><em>rs1</em></span> and <span><em>rs2</em></span>, as described below.
SFENCE.VMA is also used to invalidate entries in the
address-translation cache associated with a hart (see
Section <a href="supervisor.html#sv32algorithm" data-reference-type="ref" data-reference="sv32algorithm">1.3.2</a>).
Further details on the behavior of this instruction are
described in Section <a href="machine.html#virt-control" data-reference-type="ref" data-reference="virt-control">[virt-control]</a> and Section <a href="machine.html#pmp-vmem" data-reference-type="ref" data-reference="pmp-vmem">[pmp-vmem]</a>.</p>
<div class=commentary>
<p>The SFENCE.VMA is used to flush any local hardware caches related to
address translation. It is specified as a fence rather than a TLB
flush to provide cleaner semantics with respect to which instructions
are affected by the flush operation and to support a wider variety of
dynamic caching structures and memory-management schemes. SFENCE.VMA
is also used by higher privilege levels to synchronize page table
writes and the address translation hardware.</p>
</div>
<p>SFENCE.VMA orders only the local hart’s implicit references to the
memory-management data structures.</p>
<div class=commentary>
<p>Consequently, other harts must be notified separately when the
memory-management data structures have been modified.
One approach is to use 1)
a local data fence to ensure local writes are visible globally, then
2) an interprocessor interrupt to the other thread, then 3) a local
SFENCE.VMA in the interrupt handler of the remote thread, and finally
4) signal back to originating thread that operation is complete. This
is, of course, the RISC-V analog to a TLB shootdown.</p>
</div>
<p>For the common case that the translation data structures have only been
modified for a single address mapping (i.e., one page or superpage), <span><em>rs1</em></span>
can specify a virtual address within that mapping to effect a translation
fence for that mapping only. Furthermore, for the common case that the
translation data structures have only been modified for a single address-space
identifier, <span><em>rs2</em></span> can specify the address space. The behavior of
SFENCE.VMA depends on <span><em>rs1</em></span> and <span><em>rs2</em></span> as follows:</p>
<ul>
<li><p>If <span><em>rs1</em></span>=<span>x0</span> and <span><em>rs2</em></span>=<span>x0</span>, the fence orders all
reads and writes made to any level of the page tables, for all
address spaces. The fence also invalidates all address-translation
cache entries, for all address spaces.</p></li>
<li><p>If <span><em>rs1</em></span>=<span>x0</span> and <span><em>rs2</em></span><span class="math inline">≠</span><span>x0</span>, the fence orders
all reads and writes made to any level of the page tables, but only
for the address space identified by integer register <span><em>rs2</em></span>.
Accesses to <span><em>global</em></span> mappings (see Section <a href="supervisor.html#sec:translation" data-reference-type="ref" data-reference="sec:translation">1.3.1</a>)
are not ordered. The fence also invalidates all address-translation
cache entries matching the address space identified by integer register
<span><em>rs2</em></span>, except for entries containing global mappings.</p></li>
<li><p>If <span><em>rs1</em></span><span class="math inline">≠</span><span>x0</span> and <span><em>rs2</em></span>=<span>x0</span>, the fence orders
only reads and writes made to leaf page table entries corresponding
to the virtual address in <span><em>rs1</em></span>, for all address spaces.
The fence also invalidates all address-translation cache entries that
contain leaf page table entries corresponding to the virtual address
in <span><em>rs1</em></span>, for all address spaces.</p></li>
<li><p>If <span><em>rs1</em></span><span class="math inline">≠</span><span>x0</span> and <span><em>rs2</em></span><span class="math inline">≠</span><span>x0</span>, the fence
orders only reads and writes made to leaf page table entries
corresponding to the virtual address in <span><em>rs1</em></span>, for the address
space identified by integer register <span><em>rs2</em></span>.
Accesses to global mappings are not ordered. The fence also
invalidates all address-translation cache entries that contain leaf
page table entries corresponding to the virtual address in <span><em>rs1</em></span>
and that match the address space identified by integer register <span>
<em>rs2</em></span>, except for entries containing global mappings.</p></li>
</ul>
<p>If the value held in <span><em>rs1</em></span> is not a valid virtual address, then the
SFENCE.VMA instruction has no effect. No exception is raised in this case.</p>
<p>When <span><em>rs2</em></span><span class="math inline">≠</span><span>x0</span>, bits SXLEN-1:ASIDMAX of the value held in <span>
<em>rs2</em></span> are reserved for future standard use. Until their use is defined by a
standard extension, they should be zeroed by software and ignored
by current implementations. Furthermore, if ASIDLEN <span class="math inline">&lt;</span> ASIDMAX, the
implementation shall ignore bits ASIDMAX-1:ASIDLEN of the value held in <span>
<em>rs2</em></span>.</p>
<div class=commentary>
<p>It is always legal to over-fence, e.g., by fencing only based on a subset
of the bits in <span><em>rs1</em></span> and/or <span><em>rs2</em></span>, and/or by simply treating all
SFENCE.VMA instructions as having <span><em>rs1</em></span>=<span>x0</span> and/or
<span><em>rs2</em></span>=<span>x0</span>. For example, simpler implementations can ignore the
virtual address in <span><em>rs1</em></span> and the ASID value in <span><em>rs2</em></span> and always perform
a global fence. The choice not to raise an exception when an invalid virtual
address is held in <span><em>rs1</em></span> facilitates this type of simplification.</p>
</div>
<p>An implicit read of the memory-management data structures may return any
translation for an address that was valid at
any time since the most recent SFENCE.VMA that subsumes that address. The
ordering implied by SFENCE.VMA does not place implicit reads and writes to the
memory-management data structures into the global memory order in a way that
interacts cleanly with the standard RVWMO ordering rules. In particular, even
though an SFENCE.VMA orders prior explicit accesses before subsequent implicit
accesses, and those implicit accesses are ordered before their associated
explicit accesses, SFENCE.VMA does not necessarily place prior explicit
accesses before subsequent explicit accesses in the global memory order. These
implicit loads also need not otherwise obey normal program order semantics with
respect to prior loads or stores to the same address.</p>
<div class=commentary>
<p>A consequence of this specification is that an implementation may use any
translation for an address that was valid at any time since the most recent
SFENCE.VMA that subsumes that address.
In particular, if a leaf PTE is modified but a subsuming SFENCE.VMA is not
executed, either the old translation or the new translation will be used, but
the choice is unpredictable.
The behavior is otherwise well-defined.</p>
<p>In a conventional TLB design, it is possible for multiple entries to match a
single address if, for example, a page is upgraded to a superpage without first
clearing the original non-leaf PTE’s valid bit and executing an SFENCE.VMA with
<span><em>rs1</em></span>=<span>x0</span>.
In this case, a similar remark applies: it is unpredictable whether the old
non-leaf PTE or the new leaf PTE is used, but the behavior is otherwise well
defined.</p>
<p>Another consequence of this specification is that it is generally unsafe to
update a PTE using a set of stores of a width less than the width of the PTE,
as it is legal for the implementation to read the PTE at any time, including
when only some of the partial stores have taken effect.</p>
</div>
<div class=commentary>
<p>This specification permits the caching of PTEs whose V (Valid) bit is clear.
Operating systems must be written to cope with this possibility, but implementers
are reminded that eagerly caching invalid PTEs will reduce performance by causing
additional page faults.</p>
</div>
<p>Implementations must only perform implicit reads of the translation
data structures pointed to by the current contents of the <span>satp</span>
register or a subsequent valid (V=1) translation data structure entry,
and must only raise exceptions for implicit accesses that are
generated as a result of instruction execution, not those that are
performed speculatively.</p>
<p>Changes to the <span>sstatus</span> fields SUM and MXR take effect immediately,
without the need to execute an SFENCE.VMA instruction.
Changing <span>satp</span>.MODE from Bare to other modes and vice versa also
takes effect immediately, without the need to execute an SFENCE.VMA
instruction.
Likewise, changes to <span>satp</span>.ASID take effect immediately.</p>
<div class=commentary>
<p>The following common situations typically require executing an
SFENCE.VMA instruction:</p>
<ul>
<li><p>When software recycles an ASID (i.e., reassociates it with a different
page table), it should <span><em>first</em></span> change <span>satp</span> to point to the new page
table using the recycled ASID, <span><em>then</em></span> execute SFENCE.VMA with <span>
<em>rs1</em></span>=<span>x0</span> and <span><em>rs2</em></span> set to the recycled ASID. Alternatively, software
can execute the same SFENCE.VMA instruction while a different ASID is loaded
into <span>satp</span>, provided the next time <span>satp</span> is loaded with the recycled
ASID, it is simultaneously loaded with the new page table.</p></li>
<li><p>If the implementation does not provide ASIDs, or software chooses to
always use ASID 0, then after every <span>satp</span> write, software should execute
SFENCE.VMA with <span><em>rs1</em></span>=<span>x0</span>. In the common case that no global
translations have been modified, <span><em>rs2</em></span> should be set to a register other than
<span>x0</span> but which contains the value zero, so that global translations are
not flushed.</p></li>
<li><p>If software modifies a non-leaf PTE, it should execute SFENCE.VMA with
<span><em>rs1</em></span>=<span>x0</span>. If any PTE along the traversal path had its G bit set,
<span><em>rs2</em></span> must be <span>x0</span>; otherwise, <span><em>rs2</em></span> should be set to the ASID for
which the translation is being modified.</p></li>
<li><p>If software modifies a leaf PTE, it should execute SFENCE.VMA with <span>
<em>rs1</em></span> set to a virtual address within the page. If any PTE along the traversal
path had its G bit set, <span><em>rs2</em></span> must be <span>x0</span>; otherwise, <span><em>rs2</em></span>
should be set to the ASID for which the translation is being modified.</p></li>
<li><p>For the special cases of increasing the permissions on a leaf PTE and
changing an invalid PTE to a valid leaf, software may choose to execute
the SFENCE.VMA lazily. After modifying the PTE but before executing
SFENCE.VMA, either the new or old permissions will be used. In the latter
case, a page-fault exception might occur, at which point software should
execute SFENCE.VMA in accordance with the previous bullet point.</p></li>
</ul>
</div>
<p>If a hart employs an address-translation cache, that cache must appear to be
private to that hart.
In particular, the meaning of an ASID is local to a hart; software may choose
to use the same ASID to refer to different address spaces on different harts.</p>
<div class=commentary>
<p>A future extension could redefine ASIDs to be global across the SEE, enabling
such options as shared translation caches and hardware support for broadcast
TLB shootdown.
However, as OSes have evolved to significantly reduce the scope of TLB
shootdowns using novel ASID-management techniques, we expect the local-ASID
scheme to remain attractive for its simplicity and possibly better
scalability.</p>
</div>
<p>For implementations that make <span>satp</span>.MODE read-only zero (always Bare), attempts to
execute an SFENCE.VMA instruction might raise an illegal instruction
exception.</p>
<h2 id="sec:sv32"><span class="header-section-number">4.3</span> Sv32: Page-Based 32-bit Virtual-Memory Systems</h2>
<p>When Sv32 is written to the MODE field in the <span>satp</span> register (see
Section <a href="supervisor.html#sec:satp" data-reference-type="ref" data-reference="sec:satp">1.1.11</a>), the supervisor operates in a 32-bit paged
virtual-memory system. In this mode, supervisor and user virtual addresses
are translated into supervisor physical addresses by traversing a radix-tree
page table. Sv32 is supported when SXLEN=32 and is designed to include
mechanisms sufficient for supporting modern Unix-based operating systems.</p>
<div class=commentary>
<p>The initial RISC-V paged virtual-memory architectures have been
designed as straightforward implementations to support existing
operating systems. We have architected page table layouts to support
a hardware page-table walker. Software TLB refills are a performance
bottleneck on high-performance systems, and are especially troublesome
with decoupled specialized coprocessors. An implementation can choose
to implement software TLB refills using a machine-mode trap handler as
an extension to M-mode.</p>
</div>
<div class=commentary>
<p>Some ISAs architecturally expose <em>virtually indexed, physically tagged</em>
caches, in that accesses to the same physical address via different virtual
addresses might not be coherent unless the virtual addresses lie within the
same cache set.
Implicitly, this specification does not permit such behavior to be
architecturally exposed.</p>
</div>
<h3 id="sec:translation"><span class="header-section-number">4.3.1</span> Addressing and Memory Protection</h3>
<p>Sv32 implementations support a 32-bit virtual address space, divided
into <span>4</span><span>KiB</span> pages. An Sv32 virtual address is partitioned
into a virtual page number (VPN) and page offset, as shown in
Figure <a href="supervisor.html#sv32va" data-reference-type="ref" data-reference="sv32va">1.17</a>. When Sv32 virtual memory mode is selected in the
MODE field of the <span>satp</span> register, supervisor virtual addresses
are translated into supervisor physical addresses via a two-level page
table. The 20-bit VPN is translated into a 22-bit physical page
number (PPN), while the 12-bit page offset is untranslated. The
resulting supervisor-level physical addresses are then checked using
any physical memory protection structures (Sections <a href="machine.html#sec:pmp" data-reference-type="ref" data-reference="sec:pmp">[sec:pmp]</a>),
before being directly converted to machine-level physical addresses.
If necessary, supervisor-level physical addresses are zero-extended
to the number of physical address bits found in the implementation.</p>
<div class=commentary>
<p>For example, consider an RV32 system supporting 34 bits of physical
address. When the value of <span>satp</span>.MODE is Sv32, a 34-bit physical
address is produced directly, and therefore no zero-extension is needed.
When the value of <span>satp</span>.MODE is Bare, the 32-bit virtual address is
translated (unmodified) into a 32-bit physical address, and then that
physical address is zero-extended into a 34-bit machine-level physical
address.</p>
</div>
<figure>
<img src="supervisor_17.svg" alt="Sv32 virtual address." id="sv32va" /><figcaption>Sv32 virtual address.<span label="sv32va"></span></figcaption>
</figure>
<figure>
<img src="supervisor_18.svg" alt="Sv32 physical address." id="rv32va" /><figcaption>Sv32 physical address.<span label="rv32va"></span></figcaption>
</figure>
<figure>
<img src="supervisor_19.svg" alt="Sv32 page table entry." id="sv32pte" /><figcaption>Sv32 page table entry.<span label="sv32pte"></span></figcaption>
</figure>
<p>Sv32 page tables consist of <span class="math inline">2<sup>10</sup></span> page-table entries (PTEs), each
of four bytes. A page table is exactly the size of a page and must
always be aligned to a page boundary. The physical page number of the
root page table is stored in the <span>satp</span> register.</p>
<p>The PTE format for Sv32 is shown in Figures <a href="supervisor.html#sv32pte" data-reference-type="ref" data-reference="sv32pte">1.19</a>. The V bit
indicates whether the PTE is valid; if it is 0, all other bits in the PTE are
don’t-cares and may be used freely by software. The permission bits, R, W,
and X, indicate whether the page is readable, writable, and executable,
respectively. When all three are zero, the PTE is a pointer to the next level
of the page table; otherwise, it is a leaf PTE. Writable pages must also be
marked readable; the contrary combinations are reserved for future use.
Table <a href="supervisor.html#pteperm" data-reference-type="ref" data-reference="pteperm">[pteperm]</a> summarizes the encoding of the permission bits.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">X</th>
<th style="text-align: center;">W</th>
<th style="text-align: center;">R</th>
<th style="text-align: left;">Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: left;">Pointer to next level of page table.</td>
</tr>
<tr class="even">
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: left;">Read-only page.</td>
</tr>
<tr class="odd">
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: left;"><span><em>Reserved for future use.</em></span></td>
</tr>
<tr class="even">
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: left;">Read-write page.</td>
</tr>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: left;">Execute-only page.</td>
</tr>
<tr class="even">
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: left;">Read-execute page.</td>
</tr>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: left;"><span><em>Reserved for future use.</em></span></td>
</tr>
<tr class="even">
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: left;">Read-write-execute page.</td>
</tr>
</tbody>
</table>
<p>Attempting to fetch an instruction from a page that does not have execute
permissions raises a fetch page-fault exception. Attempting to execute
a load or load-reserved instruction whose effective address lies within
a page without read permissions raises a load page-fault exception.
Attempting to execute a store, store-conditional,
or AMO instruction whose effective address lies within a page without
write permissions raises a store page-fault exception.
<div class=commentary>
<p>AMOs never raise load page-fault exceptions. Since any unreadable page is
also unwritable, attempting to perform an AMO on an unreadable page always
raises a store page-fault exception.</p>
</div>
<p>The U bit indicates whether the page is accessible to user mode.
U-mode software may only access the page when U=1. If the SUM bit
in the <span>sstatus</span> register is
set, supervisor mode software may also access pages with U=1.
However, supervisor code normally operates with the SUM bit clear, in
which case, supervisor code will fault on accesses to user-mode pages.
Irrespective of SUM, the supervisor may not execute code on pages with U=1.</p>
<div class=commentary>
<p>An alternative PTE format would support different permissions for supervisor
and user. We omitted this feature because it would be largely redundant with
the SUM mechanism (see Section <a href="supervisor.html#sec:sum" data-reference-type="ref" data-reference="sec:sum">1.1.1.2</a>) and would require more encoding
space in the PTE.</p>
</div>
<p>The G bit designates a <span><em>global</em></span> mapping. Global mappings are those that
exist in all address spaces. For non-leaf PTEs, the global setting implies
that all mappings in the subsequent levels of the page table are global. Note
that failing to mark a global mapping as global merely reduces performance,
whereas marking a non-global mapping as global is a software bug that,
after switching to an address space with a different non-global mapping for
that address range, can unpredictably result in either mapping being used.</p>
<div class=commentary>
<p>Global mappings need not be stored redundantly in address-translation caches
for multiple ASIDs. Additionally, they need not be flushed from local
address-translation caches when an SFENCE.VMA instruction is executed with
<span><em>rs2</em></span><span class="math inline">≠</span><span>x0</span>.</p>
</div>
<p>The RSW field is reserved for use by supervisor software; the implementation
shall ignore this field.</p>
<p>Each leaf PTE contains an accessed (A) and dirty (D) bit. The A bit indicates
the virtual page has been read, written, or fetched from since the last time
the A bit was cleared. The D bit indicates the virtual page has been written
since the last time the D bit was cleared.</p>
<p>Two schemes to manage the A and D bits are permitted:</p>
<ul>
<li><p>When a virtual page is accessed and the A bit is clear, or is
written and the D bit is clear, a page-fault exception is raised.</p></li>
<li><p>When a virtual page is accessed and the A bit is clear, or is
written and the D bit is clear, the implementation sets the
corresponding bit(s) in the PTE. The PTE update must be atomic with
respect to other accesses to the PTE, and must atomically check
that the PTE is valid and grants sufficient permissions. Updates
of the A bit may be performed as a result of speculation, but updates
to the D bit must be exact (i.e., not speculative), and observed
in program order by the local hart. Furthermore, the PTE update
must appear in the global memory order no later than the explicit
memory access, or any subsequent explicit memory access to that
virtual page by the local hart. The ordering on loads and stores
provided by FENCE instructions and the acquire/release bits on atomic
instructions also orders the PTE updates associated with those loads
and stores as observed by remote harts.</p>
<p>The PTE update is not required to be atomic with respect to the explicit
memory access that caused the update, and the sequence is interruptible.
However, the hart must not perform the explicit memory access before the
PTE update is globally visible.</p></li>
</ul>
<p>All harts in a system must employ the same PTE-update scheme as each other.</p>
<div class=commentary>
<p>Prior versions of this specification required PTE A bit updates to be exact,
but allowing the A bit to be updated as a result of speculation simplifies
the implementation of address translation prefetchers. System software
typically uses the A bit as a page replacement policy hint, but does not
require exactness for functional correctness. On the other hand, D bit updates
are still required to be exact and performed in program order, as the D bit
affects the functional correctness of page eviction.</p>
<p>Implementations are of course still permitted to perform both A and D bit
updates only in an exact manner.</p>
<p>In both cases, requiring atomicity ensures that the PTE update will not be
interrupted by other intervening writes to the page table, as such interruptions
could lead to A/D bits being set on PTEs that have been reused for other
purposes, on memory that has been reclaimed for other purposes, and so on.
Simple implementations may instead generate page-fault exceptions.</p>
<p>The A and D bits are never cleared by the implementation. If the
supervisor software does not rely on accessed and/or dirty bits,
e.g. if it does not swap memory pages to secondary storage or if the
pages are being used to map I/O space, it should always set them to 1
in the PTE to improve performance.</p>
</div>
<p>Any level of PTE may be a leaf PTE, so in addition to 4 KiB pages, Sv32
supports 4 MiB <span><em>megapages</em></span>. A megapage must be virtually and
physically aligned to a 4 MiB boundary; a page-fault exception is raised
if the physical address is insufficiently aligned.</p>
<p>For non-leaf PTEs, the D, A, and U bits are reserved for future standard
use. Until their use is defined by a standard extension, they
must be cleared by software for forward compatibility.</p>
<p>For implementations with both page-based virtual memory and the “A” standard
extension, the LR/SC reservation set must lie completely within a single
base page (i.e., a naturally aligned <span>4</span><span>KiB</span> region).</p>
<h3 id="sv32algorithm"><span class="header-section-number">4.3.2</span> Virtual Address Translation Process</h3>
<p>A virtual address <span class="math inline"><em>v</em><em>a</em></span> is translated into a physical address <span class="math inline"><em>p</em><em>a</em></span> as
follows:</p>
<ol>
<li><p>Let <span class="math inline"><em>a</em></span> be <span class="math inline">${\tt satp}.ppn \times \textrm{PAGESIZE}$</span>, and let <span class="math inline"><em>i</em> = LEVELS − 1</span>. (For Sv32, PAGESIZE=<span class="math inline">2<sup>12</sup></span> and LEVELS=2.)
The <span>satp</span> register must be <span><em>active</em></span>, i.e., the effective privilege
mode must be S-mode or U-mode.</p></li>
<li><p>Let <span class="math inline"><em>p</em><em>t</em><em>e</em></span> be the value of the PTE at address
<span class="math inline"><em>a</em> + <em>v</em><em>a</em>.<em>v</em><em>p</em><em>n</em>[<em>i</em>] × PTESIZE</span>. (For Sv32, PTESIZE=4.)
If accessing <span class="math inline"><em>p</em><em>t</em><em>e</em></span> violates a PMA or PMP check, raise an
access-fault exception corresponding to the original access type.</p></li>
<li><p>If <span class="math inline"><em>p</em><em>t</em><em>e</em>.<em>v</em> = 0</span>, or if <span class="math inline"><em>p</em><em>t</em><em>e</em>.<em>r</em> = 0</span> and <span class="math inline"><em>p</em><em>t</em><em>e</em>.<em>w</em> = 1</span>, or if any bits or encodings
that are reserved for future standard use are set within <span class="math inline"><em>p</em><em>t</em><em>e</em></span>, stop and
raise a page-fault exception corresponding to the original access type.</p></li>
<li><p>Otherwise, the PTE is valid.
If <span class="math inline"><em>p</em><em>t</em><em>e</em>.<em>r</em> = 1</span> or <span class="math inline"><em>p</em><em>t</em><em>e</em>.<em>x</em> = 1</span>, go to step 5.
Otherwise, this PTE is a pointer to the next level of the page table. Let
<span class="math inline"><em>i</em> = <em>i</em> − 1</span>. If <span class="math inline"><em>i</em> &lt; 0</span>, stop and raise a page-fault exception
corresponding to the original access type. Otherwise, let
<span class="math inline"><em>a</em> = <em>p</em><em>t</em><em>e</em>.<em>p</em><em>p</em><em>n</em> × PAGESIZE</span> and go to step 2.</p></li>
<li><p>A leaf PTE has been found. Determine if the requested memory access is
allowed by the <span class="math inline"><em>p</em><em>t</em><em>e</em>.<em>r</em></span>, <span class="math inline"><em>p</em><em>t</em><em>e</em>.<em>w</em></span>, <span class="math inline"><em>p</em><em>t</em><em>e</em>.<em>x</em></span>, and <span class="math inline"><em>p</em><em>t</em><em>e</em>.<em>u</em></span> bits, given the
current privilege mode and the value of the SUM and MXR fields of
the <span>mstatus</span> register. If not, stop and raise a page-fault
exception corresponding to the original access type.</p></li>
<li><p>If <span class="math inline"><em>i</em> &gt; 0</span> and <span class="math inline"><em>p</em><em>t</em><em>e</em>.<em>p</em><em>p</em><em>n</em>[<em>i</em> − 1 : 0] ≠ 0</span>, this is a misaligned superpage;
stop and raise a page-fault exception corresponding to the original access type.</p></li>
<li><p>If <span class="math inline"><em>p</em><em>t</em><em>e</em>.<em>a</em> = 0</span>, or if the original memory access is a store and <span class="math inline"><em>p</em><em>t</em><em>e</em>.<em>d</em> = 0</span>, either
raise a page-fault exception corresponding to the original access type, or:</p>
<ul>
<li><p>If a store to <span class="math inline"><em>p</em><em>t</em><em>e</em></span> would violate a PMA or PMP check, raise an
access-fault exception corresponding to the original access type.</p></li>
<li><p>Perform the following steps atomically:</p>
<ul>
<li><p>Compare <span class="math inline"><em>p</em><em>t</em><em>e</em></span> to the value of the PTE at address <span class="math inline"><em>a</em> + <em>v</em><em>a</em>.<em>v</em><em>p</em><em>n</em>[<em>i</em>] × PTESIZE</span>.</p></li>
<li><p>If the values match, set <span class="math inline"><em>p</em><em>t</em><em>e</em>.<em>a</em></span> to 1 and, if the original memory
access is a store, also set <span class="math inline"><em>p</em><em>t</em><em>e</em>.<em>d</em></span> to 1.</p></li>
<li><p>If the comparison fails, return to step 2</p></li>
</ul></li>
</ul></li>
<li><p>The translation is successful. The translated physical address is
given as follows:</p>
<ul>
<li><p><span class="math inline"><em>pa.pgoff</em> = <em>va.pgoff</em></span>.</p></li>
<li><p>If <span class="math inline"><em>i</em> &gt; 0</span>, then this is a superpage translation and <span class="math inline"><em>p</em><em>a</em>.<em>p</em><em>p</em><em>n</em>[<em>i</em> − 1 : 0] = <em>v</em><em>a</em>.<em>v</em><em>p</em><em>n</em>[<em>i</em> − 1 : 0]</span>.</p></li>
<li><p><span class="math inline"><em>p</em><em>a</em>.<em>p</em><em>p</em><em>n</em>[LEVELS − 1 : <em>i</em>] = <em>p</em><em>t</em><em>e</em>.<em>p</em><em>p</em><em>n</em>[LEVELS − 1 : <em>i</em>]</span>.</p></li>
</ul></li>
</ol>
<p>All implicit accesses to the address-translation data structures in this
algorithm are performed using width PTESIZE.</p>
<div class=commentary>
<p>This implies, for example, that an Sv48 implementation may not use two separate
4B reads to non-atomically access a single 8B PTE, and that A/D bit updates
performed by the implementation are treated as atomically updating the entire
PTE, rather than just the A and/or D bit alone (even though the PTE value does
not otherwise change).</p>
</div>
<p>The results of implicit address-translation reads in step 2 may be held in a
read-only, incoherent <span><em>address-translation cache</em></span> but not shared with other
harts. The address-translation cache may hold an arbitrary number of entries,
including an arbitrary number of entries for the same address and ASID.
Entries in the address-translation cache may then satisfy subsequent step 2
reads if the ASID associated with the entry matches the ASID loaded in step 0
or if the entry is associated with a <span><em>global</em></span> mapping. To ensure that
implicit reads observe writes to the same memory locations, an SFENCE.VMA
instruction must be executed after the writes to flush the relevant cached
translations.</p>
<p>The address-translation cache cannot be used in step 7; accessed and
dirty bits may only be updated in memory directly.</p>
<div class=commentary>
<p>It is permitted for multiple address-translation cache entries to co-exist
for the same address. This represents the fact that in a conventional TLB
hierarchy, it is possible for multiple entries to match a single address if, for
example, a page is upgraded to a superpage without first clearing the
original non-leaf PTE’s valid bit and executing an SFENCE.VMA with <span>
<em>rs1</em></span>=<span>x0</span>, or if multiple TLBs exist in parallel at a given level of the
hierarchy. In this case, just as if an SFENCE.VMA is not executed between
a write to the memory-management tables and subsequent implicit read of the
same address: it is unpredictable whether the old non-leaf PTE or the new leaf
PTE is used, but the behavior is otherwise well defined.</p>
</div>
<p>Implementations may also execute the address-translation algorithm
speculatively at any time, for any virtual address, as long as <span>satp</span> is
active (as defined in Section <a href="supervisor.html#sec:satp" data-reference-type="ref" data-reference="sec:satp">1.1.11</a>). Such speculative executions
have the effect of pre-populating the address-translation cache.</p>
<p>Speculative executions of the address-translation algorithm behave as
non-speculative executions of the algorithm do, except that they must not set the
dirty bit for a PTE, they must not trigger an exception, and they must not create
address-translation cache entries if those entries would have been invalidated
by any SFENCE.VMA instruction executed by the hart since the speculative
execution of the algorithm began.</p>
<div class=commentary>
<p>For instance, it is illegal for both non-speculative and speculative
executions of the translation algorithm to begin, read the level 2 page table,
pause while the hart executes an SFENCE.VMA with <span><em>rs1</em></span>=<span><em>rs2</em></span>=<span>x0</span>,
then resume using the now-stale level 2 PTE, as subsequent implicit reads
could populate the address-translation cache with stale PTEs.</p>
<p>In many implementations, an SFENCE.VMA instruction with <span><em>rs1</em></span>=<span>x0</span>
will therefore either terminate all previously-launched speculative
executions of the address-translation algorithm (for the specified ASID, if
applicable), or simply wait for them to complete (in which case any
address-translation cache entries created will be invalidated by the
SFENCE.VMA as appropriate). Likewise, an SFENCE.VMA instruction with <span>
<em>rs1</em></span><span class="math inline">≠</span><span>x0</span> generally must either ensure that previously-launched
speculative executions of the address-translation algorithm (for the specified
ASID, if applicable) are prevented from creating new address-translation cache
entries mapping leaf PTEs, or wait for them to complete.</p>
<p>A consequence of implementations being permitted to read the translation data
structures arbitrarily early and speculatively is that at any time, all
page table entries reachable by executing the algorithm may be loaded into
the address-translation cache.</p>
<p>Although it would be uncommon to place page tables in non-idempotent memory,
there is no explicit prohibition against doing so. Since the algorithm may
only touch page tables reachable from the root page table indicated in <span>
satp</span>, the range of addresses that an implementation’s page table walker will
touch is fully under supervisor control.</p>
</div>
<div class=commentary>
<p>The algorithm does not admit the possibility of ignoring high-order PPN bits
for implementations with narrower physical addresses.</p>
</div>
<h2 id="sec:sv39"><span class="header-section-number">4.4</span> Sv39: Page-Based 39-bit Virtual-Memory System</h2>
<p>This section describes a simple paged virtual-memory system
for SXLEN=64, which supports 39-bit virtual address spaces. The
design of Sv39 follows the overall scheme of Sv32, and this section
details only the differences between the schemes.</p>
<div class=commentary>
<p>We specified multiple virtual memory systems for RV64 to relieve the tension
between providing a large address space and minimizing address-translation
cost. For many systems, <span>512</span><span>GiB</span> of virtual-address space is ample,
and so Sv39 suffices. Sv48 increases the virtual address space to
<span>256</span><span>TiB</span>, but increases the physical memory
capacity dedicated to page tables, the latency of page-table traversals, and
the size of hardware structures that store virtual addresses. Sv57 increases
the virtual address space, page table capacity requirement, and translation
latency even further.</p>
</div>
<h3 id="addressing-and-memory-protection"><span class="header-section-number">4.4.1</span> Addressing and Memory Protection</h3>
<p>Sv39 implementations support a 39-bit virtual address space, divided
into <span>4</span><span>KiB</span> pages. An Sv39 address is partitioned as
shown in Figure <a href="supervisor.html#sv39va" data-reference-type="ref" data-reference="sv39va">1.20</a>.
Instruction fetch addresses and load and store effective addresses,
which are 64 bits, must have bits 63–39 all equal to bit 38, or else
a page-fault exception will occur. The 27-bit VPN is translated into a
44-bit PPN via a three-level page table, while the 12-bit page offset
is untranslated.</p>
<div class=commentary>
<p>When mapping between narrower and wider addresses, RISC-V
zero-extends a narrower physical address to a wider size. The mapping
between 64-bit virtual addresses and the 39-bit usable address
space of Sv39 is not based on zero-extension but instead follows an
entrenched convention that allows an OS to use one or a few of the
most-significant bits of a full-size (64-bit) virtual address to
quickly distinguish user and supervisor address regions.</p>
</div>
<figure>
<img src="supervisor_20.svg" alt="Sv39 virtual address." id="sv39va" /><figcaption>Sv39 virtual address.<span label="sv39va"></span></figcaption>
</figure>
<figure>
<img src="supervisor_21.svg" alt="Sv39 physical address." id="sv39pa" /><figcaption>Sv39 physical address.<span label="sv39pa"></span></figcaption>
</figure>
<figure>
<img src="supervisor_22.svg" alt="Sv39 page table entry." id="sv39pte" /><figcaption>Sv39 page table entry.<span label="sv39pte"></span></figcaption>
</figure>
<p>Sv39 page tables contain <span class="math inline">2<sup>9</sup></span> page table entries (PTEs), eight
bytes each. A page table is exactly the size of a page and must
always be aligned to a page boundary. The physical page number of the
root page table is stored in the <span>satp</span> register’s PPN field.</p>
<p>The PTE format for Sv39 is shown in Figure <a href="supervisor.html#sv39pte" data-reference-type="ref" data-reference="sv39pte">1.22</a>. Bits 9–0
have the same meaning as for Sv32.
Bit 63 is reserved for use by the Svnapot extension in
Chapter <a href="supervisor.html#svnapot" data-reference-type="ref" data-reference="svnapot">2</a>. If Svnapot is not implemented, bit 63 remains
reserved and must be zeroed by software for forward compatibility,
or else a page-fault exception is raised.
Bits 62–61 are reserved for use by the Svpbmt extension in
Chapter <a href="supervisor.html#svpbmt" data-reference-type="ref" data-reference="svpbmt">3</a>. If Svpbmt is not implemented, bits 62–61 remain
reserved and must be zeroed by software for forward compatibility,
or else a page-fault exception is raised.
Bits 60–54 are reserved
for future standard use and, until their use is defined by some standard
extension, must be zeroed by software for forward compatibility.
If any of these bits are set, a page-fault exception is raised.</p>
<div class=commentary>
<p>We reserved several PTE bits for a possible extension that improves
support for sparse address spaces by allowing page-table levels to be
skipped, reducing memory usage and TLB refill latency. These reserved
bits may also be used to facilitate research experimentation. The
cost is reducing the physical address space, but <span>64</span><span>PiB</span> is
presently ample. When it no longer suffices, the reserved
bits that remain unallocated could be used to expand the physical
address space.</p>
</div>
<p>Any level of PTE may be a leaf PTE, so in addition to <span>4</span><span>KiB</span>
pages, Sv39 supports <span>2</span><span>MiB</span> <span><em>megapages</em></span> and
<span>1</span><span>GiB</span> <span><em>gigapages</em></span>, each of which must be virtually and
physically aligned to a boundary equal to its size.
A page-fault exception is raised if the physical address is insufficiently
aligned.</p>
<p>The algorithm for virtual-to-physical address translation is the same as in
Section <a href="supervisor.html#sv32algorithm" data-reference-type="ref" data-reference="sv32algorithm">1.3.2</a>, except LEVELS equals 3 and PTESIZE equals 8.</p>
<h2 id="sec:sv48"><span class="header-section-number">4.5</span> Sv48: Page-Based 48-bit Virtual-Memory System</h2>
<p>This section describes a simple paged virtual-memory system
for SXLEN=64, which supports 48-bit virtual address spaces. Sv48
is intended for systems for which a 39-bit virtual address space is
insufficient. It closely follows the design of Sv39, simply adding an
additional level of page table, and so this chapter only details the
differences between the two schemes.</p>
<p>Implementations that support Sv48 must also support Sv39.</p>
<div class=commentary>
<p>Systems that support Sv48 can also support Sv39 at essentially no cost, and so
should do so to maintain compatibility with supervisor software that assumes
Sv39.</p>
</div>
<h3 id="addressing-and-memory-protection-1"><span class="header-section-number">4.5.1</span> Addressing and Memory Protection</h3>
<p>Sv48 implementations support a 48-bit virtual address space, divided
into <span>4</span><span>KiB</span> pages. An Sv48 address is partitioned as
shown in Figure <a href="supervisor.html#sv48va" data-reference-type="ref" data-reference="sv48va">1.23</a>.
Instruction fetch addresses and load and store effective addresses,
which are 64 bits, must have bits 63–48 all equal to bit 47, or else
a page-fault exception will occur. The 36-bit VPN is translated into a
44-bit PPN via a four-level page table, while the 12-bit page offset
is untranslated.</p>
<figure>
<img src="supervisor_23.svg" alt="Sv48 virtual address." id="sv48va" /><figcaption>Sv48 virtual address.<span label="sv48va"></span></figcaption>
</figure>
<figure>
<img src="supervisor_24.svg" alt="Sv48 physical address." id="sv48pa" /><figcaption>Sv48 physical address.<span label="sv48pa"></span></figcaption>
</figure>
<figure>
<img src="supervisor_25.svg" alt="Sv48 page table entry." id="sv48pte" /><figcaption>Sv48 page table entry.<span label="sv48pte"></span></figcaption>
</figure>
<p>The PTE format for Sv48 is shown in Figure <a href="supervisor.html#sv48pte" data-reference-type="ref" data-reference="sv48pte">1.25</a>. Bits 63–54 and 9–0
have the same meaning as for Sv39. Any level of PTE may be a leaf
PTE, so in addition to <span>4</span><span>KiB</span> pages, Sv48 supports
<span>2</span><span>MiB</span> <span><em>megapages</em></span>, <span>1</span><span>GiB</span> <span><em>gigapages</em></span>, and
<span>512</span><span>GiB</span> <span><em>terapages</em></span>, each of which must be virtually and
physically aligned to a boundary equal to its size.
A page-fault exception is raised if the physical address is insufficiently
aligned.</p>
<p>The algorithm for virtual-to-physical address translation is the same
as in Section <a href="supervisor.html#sv32algorithm" data-reference-type="ref" data-reference="sv32algorithm">1.3.2</a>, except LEVELS equals 4 and PTESIZE
equals 8.</p>
<h2 id="sec:sv57"><span class="header-section-number">4.6</span> Sv57: Page-Based 57-bit Virtual-Memory System</h2>
<p>This section describes a simple paged virtual-memory system designed
for RV64 systems, which supports 57-bit virtual address spaces. Sv57
is intended for systems for which a 48-bit virtual address space is
insufficient. It closely follows the design of Sv48, simply adding an
additional level of page table, and so this chapter only details the
differences between the two schemes.</p>
<p>Implementations that support Sv57 must also support Sv48.</p>
<div class=commentary>
<p>Systems that support Sv57 can also support Sv48 at essentially no cost, and so
should do so to maintain compatibility with supervisor software that assumes
Sv48.</p>
</div>
<h3 id="addressing-and-memory-protection-2"><span class="header-section-number">4.6.1</span> Addressing and Memory Protection</h3>
<p>Sv57 implementations support a 57-bit virtual address space, divided
into <span>4</span><span>KiB</span> pages. An Sv57 address is partitioned as
shown in Figure <a href="supervisor.html#sv57va" data-reference-type="ref" data-reference="sv57va">1.26</a>.
Instruction fetch addresses and load and store effective addresses,
which are 64 bits, must have bits 63–57 all equal to bit 56, or else
a page-fault exception will occur. The 45-bit VPN is translated into a
44-bit PPN via a five-level page table, while the 12-bit page offset
is untranslated.</p>
<figure>
<img src="supervisor_26.svg" alt="Sv57 virtual address." id="sv57va" /><figcaption>Sv57 virtual address.<span label="sv57va"></span></figcaption>
</figure>
<figure>
<img src="supervisor_27.svg" alt="Sv57 physical address." id="sv57pa" /><figcaption>Sv57 physical address.<span label="sv57pa"></span></figcaption>
</figure>
<figure>
<img src="supervisor_28.svg" alt="Sv57 page table entry." id="sv57pte" /><figcaption>Sv57 page table entry.<span label="sv57pte"></span></figcaption>
</figure>
<p>The PTE format for Sv57 is shown in Figure <a href="supervisor.html#sv57pte" data-reference-type="ref" data-reference="sv57pte">1.28</a>. Bits 63–54 and 9–0
have the same meaning as for Sv39. Any level of PTE may be a leaf
PTE, so in addition to <span>4</span><span>KiB</span> pages, Sv57 supports
<span>2</span><span>MiB</span> <span><em>megapages</em></span>, <span>1</span><span>GiB</span> <span><em>gigapages</em></span>,
<span>512</span><span>GiB</span> <span><em>terapages</em></span>, and <span>256</span><span>TiB</span> <span><em>petapages</em></span>,
each of which must be virtually and physically aligned to a boundary equal
to its size. A page-fault exception is raised if the physical address is
insufficiently aligned.</p>
<p>The algorithm for virtual-to-physical address translation is the same
as in Section <a href="supervisor.html#sv32algorithm" data-reference-type="ref" data-reference="sv32algorithm">1.3.2</a>, except LEVELS equals 5 and PTESIZE
equals 8.</p>
<h1 id="svnapot"><span class="header-section-number">5</span> “Svnapot” Standard Extension for NAPOT Translation Contiguity, Version 1.0</h1>
<p>In Sv39, Sv48, and Sv57, when a PTE has N=1, the PTE represents a
translation that is part of a range of contiguous virtual-to-physical
translations with the same values for PTE bits 5–0. Such ranges must be of a
naturally aligned power-of-2 (NAPOT) granularity larger than the base page
size.</p>
<p>The Svnapot extension depends on Sv39.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">i</th>
<th style="text-align: center;"><span class="math inline"><em>p</em><em>t</em><em>e</em>.<em>p</em><em>p</em><em>n</em>[<em>i</em>]</span></th>
<th style="text-align: left;">Description</th>
<th style="text-align: center;"><span class="math inline"><em>p</em><em>t</em><em>e</em>.<em>n</em><em>a</em><em>p</em><em>o</em><em>t</em>_<em>b</em><em>i</em><em>t</em><em>s</em></span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">0</td>
<td style="text-align: center;"><span>x xxxx xxx1</span></td>
<td style="text-align: left;"><span><em>Reserved</em></span></td>
<td style="text-align: center;"><span class="math inline">−</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">0</td>
<td style="text-align: center;"><span>x xxxx xx1x</span></td>
<td style="text-align: left;"><span><em>Reserved</em></span></td>
<td style="text-align: center;"><span class="math inline">−</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;">0</td>
<td style="text-align: center;"><span>x xxxx x1xx</span></td>
<td style="text-align: left;"><span><em>Reserved</em></span></td>
<td style="text-align: center;"><span class="math inline">−</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">0</td>
<td style="text-align: center;"><span>x xxxx 1000</span></td>
<td style="text-align: left;">64 KiB contiguous region</td>
<td style="text-align: center;">4</td>
</tr>
<tr class="odd">
<td style="text-align: center;">0</td>
<td style="text-align: center;"><span>x xxxx 0xxx</span></td>
<td style="text-align: left;"><span><em>Reserved</em></span></td>
<td style="text-align: center;"><span class="math inline">−</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline"> ≥ 1</span></td>
<td style="text-align: center;"><span>x xxxx xxxx</span></td>
<td style="text-align: left;"><span><em>Reserved</em></span></td>
<td style="text-align: center;"><span class="math inline">−</span></td>
</tr>
</tbody>
</table>
<p>NAPOT PTEs behave identically to non-NAPOT PTEs within the address-translation
algorithm in Section <a href="supervisor.html#sv32algorithm" data-reference-type="ref" data-reference="sv32algorithm">1.3.2</a>, except that:</p>
<ul>
<li><p>If the encoding in <span class="math inline"><em>p</em><em>t</em><em>e</em></span> is valid according to Table <a href="supervisor.html#ptenapot" data-reference-type="ref" data-reference="ptenapot">[ptenapot]</a>,
then instead of returning the original value of <span class="math inline"><em>p</em><em>t</em><em>e</em></span>, implicit reads of a
NAPOT PTE return a copy of <span class="math inline"><em>p</em><em>t</em><em>e</em></span> in which <span class="math inline"><em>p</em><em>t</em><em>e</em>.<em>p</em><em>p</em><em>n</em>[<em>p</em><em>t</em><em>e</em>.<em>n</em><em>a</em><em>p</em><em>o</em><em>t</em>_<em>b</em><em>i</em><em>t</em><em>s</em> − 1 : 0]</span> is
replaced by <span class="math inline"><em>v</em><em>p</em><em>n</em>[<em>i</em>][<em>p</em><em>t</em><em>e</em>.<em>n</em><em>a</em><em>p</em><em>o</em><em>t</em>_<em>b</em><em>i</em><em>t</em><em>s</em> − 1 : 0]</span>. If the encoding in <span class="math inline"><em>p</em><em>t</em><em>e</em></span> is
reserved according to Table <a href="supervisor.html#ptenapot" data-reference-type="ref" data-reference="ptenapot">[ptenapot]</a>, then a page-fault exception
must be raised.</p></li>
<li><p>Implicit reads of NAPOT page table entries may create address-translation cache
entries mapping <span class="math inline"><em>a</em> + <em>v</em><em>a</em>.<em>v</em><em>p</em><em>n</em>[<em>j</em>] × PTESIZE</span> to a copy of <span class="math inline"><em>p</em><em>t</em><em>e</em></span>
in which <span class="math inline"><em>p</em><em>t</em><em>e</em>.<em>p</em><em>p</em><em>n</em>[<em>p</em><em>t</em><em>e</em>.<em>n</em><em>a</em><em>p</em><em>o</em><em>t</em>_<em>b</em><em>i</em><em>t</em><em>s</em> − 1 : 0]</span> is replaced by
<span class="math inline"><em>v</em><em>p</em><em>n</em>[0][<em>p</em><em>t</em><em>e</em>.<em>n</em><em>a</em><em>p</em><em>o</em><em>t</em>_<em>b</em><em>i</em><em>t</em><em>s</em> − 1 : 0]</span>, for any or all <span class="math inline"><em>j</em></span> such that
<span class="math inline"><em>j</em>[8 : <em>n</em><em>a</em><em>p</em><em>o</em><em>t</em>_<em>b</em><em>i</em><em>t</em><em>s</em>] = <em>i</em>[8 : <em>n</em><em>a</em><em>p</em><em>o</em><em>t</em>_<em>b</em><em>i</em><em>t</em><em>s</em>]</span>, all for the address space identified
in <span><em>satp</em></span> as loaded by step 0.</p></li>
</ul>
<div class=commentary>
<p>The motivation for a NAPOT PTE is that it can be cached in a TLB as one or
more entries representing the contiguous region as if it were a single
(large) page covered by a single translation. This compaction can help
relieve TLB pressure in some scenarios. The encoding is designed to fit
within the pre-existing Sv39, Sv48, and Sv57 PTE formats so as not to disrupt
existing implementations or designs that choose not to implement the scheme.
It is also designed so as not to complicate the definition of the
address-translation algorithm.</p>
<p>The address translation cache abstraction captures the behavior that would result from the creation
of a single TLB entry covering the entire NAPOT region. It is also designed
to be consistent with implementations that support NAPOT PTEs by splitting
the NAPOT region into TLB entries covering any smaller power-of-two region
sizes. For example, a 64 KiB NAPOT PTE might trigger the creation of 16
standard 4 KiB TLB entries, all with contents generated from the NAPOT PTE
(even if the PTEs for the other 4 KiB regions have different contents).</p>
<p>In typical usage scenarios, NAPOT PTEs in the same region will have the same
attributes, same PPNs, and same values for bits 5–0. RSW remains reserved
for supervisor software control. It is the responsibility of the OS and/or
hypervisor to configure the page tables in such a way that there are no
inconsistencies between NAPOT PTEs and other NAPOT or non-NAPOT PTEs that
overlap the same address range. If an update needs to be made, the OS
generally should first mark all of the PTEs invalid, then issue SFENCE.VMA
instruction(s) covering all 4 KiB regions within the range (either via a
single SFENCE.VMA with <span><em>rs1</em></span>=<span>x0</span>, or with multiple SFENCE.VMA
instructions with <span><em>rs1</em></span><span class="math inline">≠</span><span>x0</span>), then update the PTE(s), as
described in Section <a href="supervisor.html#sec:sfence.vma" data-reference-type="ref" data-reference="sec:sfence.vma">1.2.1</a>, unless any inconsistencies are
known to be benign. If any inconsistencies do exist, then the effect is the
same as when SFENCE.VMA is used incorrectly: one of the translations will be
chosen, but the choice is unpredictable.</p>
<p>If an implementation chooses to use a NAPOT PTE (or cached version thereof),
it might not consult the PTE directly specified by the algorithm in
Section <a href="supervisor.html#sv32algorithm" data-reference-type="ref" data-reference="sv32algorithm">1.3.2</a> at all. Therefore, the D and A bits may not be
identical across all mappings of the same address range even in typical use
cases The operating system must query all NAPOT aliases of a page to
determine whether that page has been accessed and/or is dirty. If the OS
manually sets the A and/or D bits for a page, it is recommended that the OS
also set the A and/or D bits for other NAPOT aliases as appropriate in order
to avoid unnecessary traps.</p>
<p>Just as with normal PTEs, TLBs are permitted to cache NAPOT PTEs whose V
(Valid) bit is clear.</p>
<p>Depending on need, the NAPOT scheme may be extended to other intermediate
page sizes and/or to other levels of the page table in the future. The
encoding is designed to accommodate other NAPOT sizes should that need
arise. For example:</p>
<p><em></em></p>
<p><img src="supervisor_29.svg" alt="image" /></p>
<p>In such a case, an implementation may or may not support all options. The
discoverability mechanism for this extension would be extended to allow
system software to determine which sizes are supported.</p>
<p>Other sizes may remain deliberately excluded, so that PPN bits not being
used to indicate a valid NAPOT region size (e.g., the least-significant bit
of <span class="math inline"><em>p</em><em>t</em><em>e</em>.<em>p</em><em>p</em><em>n</em>[<em>i</em>]</span>) may be repurposed for other uses in the future.</p>
<p>However, in case finer-grained intermediate page size support proves not to
be useful, we have chosen to standardize only 64 KiB support as a first step.</p>
</div>
<h1 id="svpbmt"><span class="header-section-number">6</span> “Svpbmt” Standard Extension for Page-Based Memory Types, Version 1.0</h1>
<p>In Sv39, Sv48, and Sv57, bits 62–61 of a leaf page table entry indicate the use
of page-based memory types that override the PMA(s) for the associated memory
pages. The encoding for the PBMT bits is captured in Table <a href="supervisor.html#pbmt" data-reference-type="ref" data-reference="pbmt">[pbmt]</a>.</p>
<p>The Svpbmt extension depends on Sv39.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Mode</th>
<th style="text-align: center;">Value</th>
<th style="text-align: left;">Requested Memory Attributes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">PMA</td>
<td style="text-align: center;">0</td>
<td style="text-align: left;">None</td>
</tr>
<tr class="even">
<td style="text-align: center;">NC</td>
<td style="text-align: center;">1</td>
<td style="text-align: left;">Non-cacheable, idempotent, weakly-ordered (RVWMO), main memory</td>
</tr>
<tr class="odd">
<td style="text-align: center;">IO</td>
<td style="text-align: center;">2</td>
<td style="text-align: left;">Non-cacheable, non-idempotent, strongly-ordered (I/O ordering), I/O</td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">−</span></td>
<td style="text-align: center;">3</td>
<td style="text-align: left;"><span><em>Reserved for future standard use</em></span></td>
</tr>
</tbody>
</table>
<div class=commentary>
<p>Future extensions may provide more and/or finer-grained control over which PMAs
can be overridden.</p>
</div>
<p>For non-leaf PTEs, bits 62–61 are reserved for future standard use. Until
their use is defined by a standard extension, they must be cleared by software
for forward compatibility, or else a page-fault exception is raised.</p>
<p>When PBMT settings override a main memory page into I/O or vice versa, memory
accesses to such pages obey the memory ordering rules of the final effective
attribute, as follows.</p>
<p>If the underlying physical memory attribute for a page is I/O, and the page has
PBMT=NC, then accesses to that page obey RVWMO.
However, accesses to such pages are
considered to be <span><em>both</em></span> I/O and main memory accesses for the purposes of FENCE,
<span><em>.aq</em></span>, and <span><em>.rl</em></span>.</p>
<p>If the underlying physical memory attribute for a page is main memory, and the
page has PBMT=IO, then accesses to that page obey strong channel 0 I/O ordering
rules with respect to other accesses to physical main memory and to other
accesses to pages with PBMT=IO.
However, accesses to such pages are
considered to be <span><em>both</em></span> I/O and main memory accesses for the purposes of FENCE,
<span><em>.aq</em></span>, and <span><em>.rl</em></span>.</p>
<div class=commentary>
<p>A device driver written to rely on I/O strong ordering rules will not
operate correctly if the address range is mapped with PBMT=NC.
As such, this configuration is discouraged.</p>
<p>It will often still be useful to map physical I/O regions using PBMT=NC so that
write combining and speculative accesses can be performed. Such optimizations
will likely improve performance when applied with adequate care.</p>
</div>
<p>When Svpbmt is used with non-zero PBMT encodings,
it is possible for multiple virtual aliases of the same
physical page to exist simultaneously with different memory attributes. It is
also possible for a U-mode or S-mode mapping through a PTE with Svpbmt enabled
to observe different memory attributes for a given region of physical memory
than a concurrent access to the same page performed by M-mode or when
MODE=Bare. In such cases, the behaviors dictated by the attributes (including
coherence, which is otherwise unaffected) may be violated.</p>
<p>Accessing the same location using different attributes that are both non-cacheable
(e.g., NC and IO) does not cause loss of coherence, but might result in weaker
memory ordering than the stricter attribute ordinarily guarantees.
Executing a <span>fence iorw, iorw</span> instruction between such accesses suffices
to prevent loss of memory ordering.</p>
<p>Accessing the same location using different cacheability attributes may cause loss
of coherence.
Executing the following sequence between such accesses prevents both loss of
coherence and loss of memory ordering:
<span>fence iorw, iorw</span>, followed by <span>cbo.flush</span> to an address of
that location, followed by a <span>fence iorw, iorw</span>.</p>
<div class=commentary>
<p>It follows that, if the same location might later be referenced using the
original attributes, then this sequence must be repeated beforehand.</p>
</div>
<div class=commentary>
<p>In certain cases, a weaker sequence might suffice to prevent loss of
coherence.
These situations will be detailed following the forthcoming formalization of
the interaction of the RVWMO memory model with the instructions in the Zicbom
extension.</p>
</div>
<p>When two-stage address translation is enabled within the H extension, the
page-based memory types are also applied in two stages. First, if
<span>hgatp</span>.MODE is not equal to zero, non-zero G-stage PTE PBMT bits override
the attributes in the PMA to produce an intermediate set of attributes.
Otherwise, the PMAs serve as the intermediate attributes. Second, if
<span>vsatp</span>.MODE is not equal to zero, non-zero VS-stage PTE PBMT bits override
the intermediate attributes to produce the final set of attributes used by
accesses to the page in question. Otherwise, the intermediate attributes are
used as the final set of attributes.</p>
<h1 id="svinval"><span class="header-section-number">7</span> “Svinval” Standard Extension for Fine-Grained Address-Translation Cache Invalidation, Version 1.0</h1>
<p>The Svinval extension splits SFENCE.VMA, HFENCE.VVMA, and HFENCE.GVMA
instructions into finer-grained invalidation and ordering operations that can
be more efficiently batched or pipelined on certain classes of high-performance
implementation.</p>
<p><img src="supervisor_30.svg" alt="image" /></p>
<p>The SINVAL.VMA instruction invalidates any address-translation cache entries
that an SFENCE.VMA instruction with the same values of <span><em>rs1</em></span> and <span><em>rs2</em></span>
would invalidate. However, unlike SFENCE.VMA, SINVAL.VMA instructions are only
ordered with respect to SFENCE.VMA, SFENCE.W.INVAL, and SFENCE.INVAL.IR
instructions as defined below.</p>
<p><img src="supervisor_31.svg" alt="image" /></p>
<p><img src="supervisor_32.svg" alt="image" /></p>
<p>The SFENCE.W.INVAL instruction guarantees that any previous stores already
visible to the current RISC-V hart are ordered before subsequent SINVAL.VMA
instructions executed by the same hart. The SFENCE.INVAL.IR instruction
guarantees that any previous SINVAL.VMA instructions executed by the current hart
are ordered before subsequent implicit references by that hart to the
memory-management data structures.</p>
<p>When executed in order (but not necessarily consecutively) by a single hart, the
sequence SFENCE.W.INVAL, SINVAL.VMA, and SFENCE.INVAL.IR has the same effect as
a hypothetical SFENCE.VMA instruction in which:</p>
<ul>
<li><p>the values of <span><em>rs1</em></span> and <span><em>rs2</em></span> for the SFENCE.VMA are the same
as those used in the SINVAL.VMA,</p></li>
<li><p>reads and writes prior to the SFENCE.W.INVAL are considered to be those
prior to the SFENCE.VMA, and</p></li>
<li><p>reads and writes following the SFENCE.INVAL.IR are considered to be
those subsequent to the SFENCE.VMA.</p></li>
</ul>
<p><img src="supervisor_33.svg" alt="image" /></p>
<p><img src="supervisor_34.svg" alt="image" /></p>
<p>If the hypervisor extension is implemented, the Svinval extension also provides two
additional instructions: HINVAL.VVMA and HINVAL.GVMA. These have the same
semantics as SINVAL.VMA, except that they combine with SFENCE.W.INVAL and
SFENCE.INVAL.IR to replace HFENCE.VVMA and HFENCE.GVMA, respectively, instead
of SFENCE.VMA. In addition, HINVAL.GVMA uses VMIDs instead of ASIDs.</p>
<p>SINVAL.VMA, HINVAL.VVMA, and HINVAL.GVMA require the same permissions and raise
the same exceptions as SFENCE.VMA, HFENCE.VVMA, and HFENCE.GVMA, respectively.
In particular, an attempt to execute any of these instructions in
U-mode always raises an illegal instruction exception, and an attempt
to execute SINVAL.VMA or HINVAL.GVMA in S-mode or HS-mode when
<span>mstatus</span>.TVM=1 also raises an illegal instruction exception.
An attempt to execute HINVAL.VVMA or HINVAL.GVMA in VS-mode or VU-mode,
or to execute SINVAL.VMA in VU-mode, raises a virtual instruction
exception.
When <span>hstatus</span>.VTVM=1, an attempt to execute SINVAL.VMA in VS-mode
also raises a virtual instruction exception.</p>
<div class=commentary>
<p>SFENCE.W.INVAL and SFENCE.INVAL.IR instructions do not need to be trapped when
<span>mstatus</span>.TVM=1 or when <span>hstatus</span>.VTVM=1, as they only have ordering
effects but no visible side effects. Trapping of the SINVAL.VMA instruction
is sufficient to enable emulation of the intended overall TLB maintenance
functionality.</p>
<p>In typical usage, software will invalidate a range of virtual addresses in
the address-translation caches by executing an SFENCE.W.INVAL instruction,
executing a series of SINVAL.VMA, HINVAL.VVMA, or HINVAL.GVMA instructions to
the addresses (and optionally ASIDs or VMIDs) in question, and then executing
an SFENCE.INVAL.IR instruction.</p>
<p>High-performance implementations will be able to pipeline the
address-translation cache invalidation operations, and will defer any
pipeline stalls or other memory ordering enforcement until an SFENCE.W.INVAL,
SFENCE.INVAL.IR, SFENCE.VMA, HFENCE.GVMA, or HFENCE.VVMA instruction is
executed.</p>
<p>Simpler implementations may implement SINVAL.VMA, HINVAL.VVMA, and
HINVAL.GVMA identically to SFENCE.VMA, HFENCE.VVMA, and HFENCE.GVMA,
respectively, while implementing SFENCE.W.INVAL and SFENCE.INVAL.IR
instructions as no-ops.</p>
</div>

</body>
</html>
