<html>
<head>
<title>RISC-V Instruction Set Manual, Volume I: RISC-V User-Level ISA</title>
</head>
<body>

<table>
<tr><th colspan=2>Metadata Table</th></tr>
<tr><th>Manual Type</th><td> user</td></tr>
<tr><th>Spec Revision</th><td> 20191214-</td></tr>
<tr><th>Spec Release Date</th><td> December 2019</td></tr>
<tr><th>Git Revision</th><td> Priv-v1.12</td></tr>
<tr><th>Git URL</th><td><a href=https://github.com/riscv/riscv-isa-manual.git>https://github.com/riscv/riscv-isa-manual.git</a></td></tr>
<tr><th>Source</th><td>src/m.tex</td></tr>
<tr><th>Conversion Date</th><td>2023/10/11</td></tr>
<tr><th>License</th><td><a href=https://creativecommons.org/licenses/by/4.0/>CC-by-4.0</a></td></tr>
</table>


<h1 id="m-standard-extension-for-integer-multiplication-and-division-version-2.0"><span class="header-section-number">8</span> “M” Standard Extension for Integer Multiplication and
Division, Version 2.0</h1>
<p>This chapter describes the standard integer multiplication and
division instruction extension, which is named “M” and contains
instructions that multiply or divide values held in two integer
registers.</p>
<div class=commentary>
<p>We separate integer multiply and divide out from the base to simplify
low-end implementations, or for applications where integer multiply
and divide operations are either infrequent or better handled in
attached accelerators.</p>
</div>
<h2 id="multiplication-operations"><span class="header-section-number">8.1</span> Multiplication Operations</h2>
<p><img src="m_00.svg" alt="image" /></p>
<p>MUL performs an XLEN-bit<span class="math inline">×</span>XLEN-bit multiplication
of <span><em>rs1</em></span> by <span><em>rs2</em></span> and places the
lower XLEN bits in the destination register. MULH, MULHU, and MULHSU
perform the same multiplication but return the upper XLEN bits of the
full 2<span class="math inline">×</span>XLEN-bit product, for signed<span class="math inline">×</span>signed,
unsigned<span class="math inline">×</span>unsigned, and <span>signed</span><span><em>rs1</em></span><span class="math inline">×</span><span>unsigned</span><span><em>rs2</em></span> multiplication,
respectively. If both the high and low bits of the same product are
required, then the recommended code sequence is: MULH[[S]U] <span><em>rdh,
rs1, rs2</em></span>; MUL <span><em>rdl, rs1, rs2</em></span> (source register specifiers must
be in same order and <span><em>rdh</em></span> cannot be the same as <span><em>rs1</em></span> or <span>
<em>rs2</em></span>). Microarchitectures can then fuse these into a single
multiply operation instead of performing two separate multiplies.</p>
<div class=commentary>
<p>MULHSU is used in multi-word signed multiplication to multiply the
most-significant word of the multiplicand (which contains the sign bit)
with the less-significant words of the multiplier (which are unsigned).</p>
</div>
<p>MULW is an RV64 instruction that multiplies the lower 32 bits of the source
registers, placing the sign-extension of the lower 32 bits of the result
into the destination register.</p>
<div class=commentary>
<p>In RV64, MUL can be used to obtain the upper 32 bits of the 64-bit product,
but signed arguments must be proper 32-bit signed values, whereas unsigned
arguments must have their upper 32 bits clear. If the
arguments are not known to be sign- or zero-extended, an alternative is to
shift both arguments left by 32 bits, then use MULH[[S]U].</p>
</div>
<h2 id="division-operations"><span class="header-section-number">8.2</span> Division Operations</h2>
<p><img src="m_01.svg" alt="image" /></p>
<p>DIV and DIVU perform an XLEN bits by XLEN bits signed and unsigned integer
division of <span><em>rs1</em></span> by <span><em>rs2</em></span>, rounding towards zero.
REM and REMU provide the remainder of the corresponding division operation.
For REM, the sign of the result equals the sign of the dividend.</p>
<div class=commentary>
<p>For both signed and unsigned division, it holds that
<span><span class="math inline">dividend = divisor × quotient + remainder</span></span> .</p>
</div>
<p>If both the quotient and remainder
are required from the same division, the recommended code sequence is:
DIV[U] <span><em>rdq, rs1, rs2</em></span>; REM[U] <span><em>rdr, rs1, rs2</em></span> (<span><em>rdq</em></span>
cannot be the same as <span><em>rs1</em></span> or <span><em>rs2</em></span>). Microarchitectures can
then fuse these into a single divide operation instead of performing
two separate divides.</p>
<p>DIVW and DIVUW are RV64 instructions that divide the
lower 32 bits of <span><em>rs1</em></span> by the lower 32 bits of <span><em>rs2</em></span>, treating
them as signed and unsigned integers respectively, placing the 32-bit
quotient in <span><em>rd</em></span>, sign-extended to 64 bits. REMW and REMUW
are RV64 instructions that provide the corresponding
signed and unsigned remainder operations respectively. Both REMW and
REMUW always sign-extend the 32-bit result to 64 bits, including on a
divide by zero.</p>
<p>The semantics for division by zero and division overflow are summarized in
Table <a href="m.html#tab:divby0" data-reference-type="ref" data-reference="tab:divby0">[tab:divby0]</a>. The quotient of division by zero has all bits set, and
the remainder of division by zero equals the dividend. Signed division overflow
occurs only when the most-negative integer is divided by <span class="math inline"> − 1</span>. The quotient of
a signed division with overflow is equal to the dividend, and the remainder is
zero. Unsigned division overflow cannot occur.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Condition</th>
<th style="text-align: center;">Dividend</th>
<th style="text-align: center;">Divisor</th>
<th style="text-align: center;">DIVU[W]</th>
<th style="text-align: center;">REMU[W]</th>
<th style="text-align: center;">DIV[W]</th>
<th style="text-align: center;">REM[W]</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Division by zero</td>
<td style="text-align: center;"><span class="math inline"><em>x</em></span></td>
<td style="text-align: center;">0</td>
<td style="text-align: center;"><span class="math inline">2<sup><em>L</em></sup> − 1</span></td>
<td style="text-align: center;"><span class="math inline"><em>x</em></span></td>
<td style="text-align: center;"><span class="math inline"> − 1</span></td>
<td style="text-align: center;"><span class="math inline"><em>x</em></span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Overflow (signed only)</td>
<td style="text-align: center;"><span class="math inline"> − 2<sup><em>L</em> − 1</sup></span></td>
<td style="text-align: center;"><span class="math inline"> − 1</span></td>
<td style="text-align: center;">–</td>
<td style="text-align: center;">–</td>
<td style="text-align: center;"><span class="math inline"> − 2<sup><em>L</em> − 1</sup></span></td>
<td style="text-align: center;">0</td>
</tr>
</tbody>
</table>
<div class=commentary>
<p>We considered raising exceptions on integer divide by zero, with these
exceptions causing a trap in most execution environments. However,
this would be the only arithmetic trap in the standard ISA
(floating-point exceptions set flags and write default values, but do
not cause traps) and would require language implementors to interact
with the execution environment’s trap handlers for this case.
Further, where language standards mandate that a divide-by-zero
exception must cause an immediate control flow change, only a single
branch instruction needs to be added to each divide operation, and
this branch instruction can be inserted after the divide and should
normally be very predictably not taken, adding little runtime
overhead.</p>
<p>The value of all bits set is returned for both unsigned and signed
divide by zero to simplify the divider circuitry. The value of all 1s
is both the natural value to return for unsigned divide, representing
the largest unsigned number, and also the natural result for simple
unsigned divider implementations. Signed division is often
implemented using an unsigned division circuit and specifying the same
overflow result simplifies the hardware.</p>
</div>
<h2 id="zmmul-extension-version-0.1"><span class="header-section-number">8.3</span> Zmmul Extension, Version 0.1</h2>
<p>The Zmmul extension implements the multiplication subset of the M extension.
It adds all of the instructions defined in Section <a href="m.html#multiplication-operations" data-reference-type="ref" data-reference="multiplication-operations">1.1</a>,
namely: MUL, MULH, MULHU, MULHSU, and (for RV64 only) MULW.
The encodings are identical to those of the corresponding M-extension instructions.</p>
<div class=commentary>
<p>The Zmmul extension enables low-cost implementations that require
multiplication operations but not division.
For many microcontroller applications, division operations are too
infrequent to justify the cost of divider hardware.
By contrast, multiplication operations are more frequent, making the cost of
multiplier hardware more justifiable.
Simple FPGA soft cores particularly benefit from eliminating division but
retaining multiplication, since many FPGAs provide hardwired multipliers
but require dividers be implemented in soft logic.</p>
</div>

</body>
</html>
