<html>
<head>
<title>RISC-V Instruction Set Manual, Volume I: RISC-V User-Level ISA</title>
</head>
<body>

<table>
<tr><th colspan=2>Metadata Table</th></tr>
<tr><th>Manual Type</th><td> user</td></tr>
<tr><th>Spec Revision</th><td> 20191214-</td></tr>
<tr><th>Spec Release Date</th><td> December 2019</td></tr>
<tr><th>Git Revision</th><td> Priv-v1.12</td></tr>
<tr><th>Git URL</th><td><a href=https://github.com/riscv/riscv-isa-manual.git>https://github.com/riscv/riscv-isa-manual.git</a></td></tr>
<tr><th>Source</th><td>src/rv32e.tex</td></tr>
<tr><th>Conversion Date</th><td>2023/09/28</td></tr>
<tr><th>License</th><td><a href=https://creativecommons.org/licenses/by/4.0/>CC-by-4.0</a></td></tr>
</table>


<h1 id="rv32e"><span class="header-section-number">5</span> RV32E Base Integer Instruction Set, Version 1.9</h1>
<p>This chapter describes a draft proposal for the RV32E base integer
instruction set, which is a reduced version of RV32I designed for
embedded systems. The only change is to reduce the number of integer
registers to 16. This chapter only outlines the differences between
RV32E and RV32I, and so should be read after Chapter <a href="rv32.html#rv32" data-reference-type="ref" data-reference="rv32">[rv32]</a>.</p>
<div class=commentary>
<p>RV32E was designed to provide an even smaller base core for embedded
microcontrollers. Although we had mentioned this possibility in
version 2.0 of this document, we initially resisted defining this
subset. However, given the demand for the smallest possible 32-bit
microcontroller, and in the interests of preempting fragmentation in
this space, we have now defined RV32E as a fourth standard base ISA in
addition to RV32I, RV64I, and RV128I. There is also interest in
defining an RV64E to reduce context state for highly threaded 64-bit
processors.</p>
</div>
<h2 id="rv32e-programmers-model"><span class="header-section-number">5.1</span> RV32E Programmers’ Model</h2>
<p>RV32E reduces the integer register count to 16 general-purpose
registers, (<span>x0</span>–<span>x15</span>), where <span>x0</span> is a dedicated zero
register.</p>
<div class=commentary>
<p>We have found that in the small RV32I core designs, the upper 16
registers consume around one quarter of the total area of the core
excluding memories, thus their removal saves around 25% core area
with a corresponding core power reduction.</p>
</div>
<div class=commentary>
<p>This change requires a different calling convention and ABI. In
particular, RV32E is only used with a soft-float calling convention.
A new embedded ABI is under consideration that would work across RV32E
and RV32I.</p>
</div>
<h2 id="rv32e-instruction-set"><span class="header-section-number">5.2</span> RV32E Instruction Set</h2>
<p>RV32E uses the same instruction-set encoding as RV32I, except that
only registers <span>x0</span>–<span>x15</span> are provided. Any future standard
extensions will not make use of the instruction bits freed up by the
reduced register-specifier fields and so these are designated for
custom extensions.</p>
<div class=commentary>
<p>RV32E can be combined with all current standard extensions. Defining the F, D,
and Q extensions as having a 16-entry floating point register file when
combined with RV32E was considered but decided against. To support
systems with reduced floating-point register state, we intend to
define a “Zfinx” extension that makes floating-point computations use the
integer registers, removing the floating-point loads, stores, and moves between
floating point and integer registers.</p>
</div>

</body>
</html>
