<html>
<head>
<title>RISC-V Instruction Set Manual, Volume I: RISC-V User-Level ISA</title>
</head>
<body>

<table>
<tr><th colspan=2>Metadata Table</th></tr>
<tr><th>Manual Type</th><td> user</td></tr>
<tr><th>Spec Revision</th><td> 20191214-</td></tr>
<tr><th>Spec Release Date</th><td> December 2019</td></tr>
<tr><th>Git Revision</th><td> Priv-v1.12</td></tr>
<tr><th>Git URL</th><td><a href=https://github.com/riscv/riscv-isa-manual.git>https://github.com/riscv/riscv-isa-manual.git</a></td></tr>
<tr><th>Source</th><td>src/zfinx.tex</td></tr>
<tr><th>Conversion Date</th><td>2023/09/28</td></tr>
<tr><th>License</th><td><a href=https://creativecommons.org/licenses/by/4.0/>CC-by-4.0</a></td></tr>
</table>


<h1 id="sec:zfinx"><span class="header-section-number">23</span> “Zfinx”, “Zdinx”, “Zhinx”, “Zhinxmin”: Standard Extensions for Floating-Point in Integer Registers, Version 1.0.0-rc</h1>
<p>This chapter is in the Frozen state. Change is extremely unlikely. A high threshold will be used,
and a change will only occur because of some truly critical issue being identified during the
public review cycle. Any other desired or needed changes can be the subject of a follow-on
new extension. For more info see: http://riscv.org/spec-state.</p>
<p>This chapter defines the “Zfinx” extension (pronounced “z-f-in-x”)
that provides instructions similar to those in the standard
floating-point F extension for single-precision floating-point
instructions but which operate on the <span>x</span> registers instead of the
<span>f</span> registers. This chapter also defines the “Zdinx”,
“Zhinx”, and “Zhinxmin” extensions that provide similar
instructions for other floating-point precisions.</p>
<div class=commentary>
<p>The F extension uses separate <span>f</span> registers for floating-point
computation, to reduce register pressure and simplify the provision of
register-file ports for wide superscalars.
However, the additional <span>128</span><span>B</span> of architectural state increases the
minimal implementation cost.
By eliminating the <span>f</span> registers, the Zfinx extension substantially
reduces the cost of simple RISC-V implementations with floating-point
instruction-set support.
Zfinx also reduces context-switch cost.</p>
<p>In general, software that assumes the presence of the F extension
is incompatible with software that assumes the presence of the Zfinx
extension, and vice versa.</p>
</div>
<p>The Zfinx extension adds all of the instructions that the F extension
adds, <span><em>except</em></span> for the transfer instructions FLW, FSW, FMV.W.X,
FMV.X.W, C.FLW[SP], and C.FSW[SP].</p>
<div class=commentary>
<p>Zfinx software uses integer loads and stores to transfer floating-point values
from and to memory.
Transfers between registers use either integer arithmetic or floating-point
sign-injection instructions.</p>
</div>
<p>The Zfinx variants of these F-extension instructions have the same semantics,
except that whenever such an instruction would have accessed an <span>f</span>
register, it instead accesses the <span>x</span> register with the same number.</p>
<h2 id="processing-of-narrower-values"><span class="header-section-number">23.1</span> Processing of Narrower Values</h2>
<p>Floating-point operands of width <span><span><em>w</em></span> <span class="math inline">&lt;</span> XLEN bits</span> occupy bits
<span><span><em>w</em></span>-1:0</span> of an <span>x</span> register.
Floating-point operations on <span><em>w</em></span>-bit operands ignore operand bits
<span>XLEN-1:<span><em>w</em></span></span> .</p>
<p>Floating-point operations that produce <span><span><em>w</em></span> <span class="math inline">&lt;</span> XLEN-bit</span> results
fill bits <span>XLEN-1:<span><em>w</em></span></span> with copies of bit <span><span><em>w</em></span>-1</span> (the
sign bit).</p>
<div class=commentary>
<p>The NaN-boxing scheme employed in the <span>f</span> registers was designed to
efficiently support recoded floating-point formats.
Recoding is less practical for Zfinx, though, since the same registers
hold both floating-point and integer operands.
Hence, the need for NaN boxing is diminished.</p>
<p>Sign-extending 32-bit floating-point numbers when held in RV64 <span>x</span>
registers matches the existing RV64 calling conventions, which require all
32-bit types to be sign-extended when passed or returned in <span>x</span> registers.
To keep the architecture more regular, we extend this pattern to 16-bit
floating-point numbers in both RV32 and RV64.</p>
</div>
<h2 id="zdinx"><span class="header-section-number">23.2</span> Zdinx</h2>
<p>The Zdinx extension provides analogous double-precision floating-point
instructions.
The Zdinx extension requires the Zfinx extension.</p>
<p>The Zdinx extension adds all of the instructions that the D extension
adds, <span><em>except</em></span> for the transfer instructions FLD, FSD, FMV.D.X,
FMV.X.D, C.FLD[SP], and C.FSD[SP].</p>
<p>The Zdinx variants of these D-extension instructions have the same semantics,
except that whenever such an instruction would have accessed an <span>f</span>
register, it instead accesses the <span>x</span> register with the same number.</p>
<h2 id="processing-of-wider-values"><span class="header-section-number">23.3</span> Processing of Wider Values</h2>
<p>Double-precision operands in RV32Zdinx
are held in aligned <span>x</span>-register pairs, i.e.,
register numbers must be even.
Use of misaligned (odd-numbered) registers for double-width floating-point
operands is <span><em>reserved</em></span>.</p>
<p>Regardless of endianness, the lower-numbered register holds the low-order
bits, and the higher-numbered register holds the high-order bits: e.g., bits
31:0 of a double-precision operand in RV32Zdinx might be held in register
<span>x14</span>, with bits 63:32 of that operand held in <span>x15</span>.</p>
<p>When a double-width floating-point result is written to <span>x0</span>, the entire
write takes no effect: e.g., for RV32Zdinx, writing a double-precision result
to <span>x0</span> does not cause <span>x1</span> to be written.</p>
<p>When <span>x0</span> is used as a double-width floating-point operand, the entire
operand is zero—i.e., <span>x1</span> is not accessed.</p>
<div class=commentary>
<p>Load-pair and store-pair instructions are not provided, so transferring
double-precision operands in RV32Zdinx from or to memory requires
two loads or stores.
Register moves need only a single FSGNJ.D instruction, however.</p>
</div>
<h2 id="zhinx"><span class="header-section-number">23.4</span> Zhinx</h2>
<p>The Zhinx extension provides analogous half-precision floating-point
instructions.
The Zhinx extension requires the Zfinx extension.</p>
<p>The Zhinx extension adds all of the instructions that the Zfh extension
adds, <span><em>except</em></span> for the transfer instructions FLH, FSH, FMV.H.X,
and FMV.X.H.</p>
<p>The Zhinx variants of these Zfh-extension instructions have the same semantics,
except that whenever such an instruction would have accessed an <span>f</span>
register, it instead accesses the <span>x</span> register with the same number.</p>
<h2 id="zhinxmin"><span class="header-section-number">23.5</span> Zhinxmin</h2>
<p>The Zhinxmin extension provides minimal support for 16-bit half-precision
floating-point instructions that operate on the <span>x</span> registers.
The Zhinxmin extension requires the Zfinx extension.</p>
<p>The Zhinxmin extension includes the following instructions from the Zhinx
extension: FCVT.S.H and FCVT.H.S.
If the Zdinx extension is present, the FCVT.D.H and FCVT.H.D instructions are
also included.</p>
<div class=commentary>
<p>In the future, an RV64Zqinx quad-precision extension could be defined analogously
to RV32Zdinx.
An RV32Zqinx extension could also be defined but would require
quad-register groups.</p>
</div>
<h2 id="privileged-architecture-implications"><span class="header-section-number">23.6</span> Privileged Architecture Implications</h2>
<p>In the standard privileged architecture defined in Volume II, the
<span>mstatus</span> field FS is hardwired to 0 if the Zfinx extension is
implemented, and FS no longer affects the trapping behavior of
floating-point instructions or <span>fcsr</span> accesses.</p>
<p>The <span>misa</span> bits F, D, and Q are hardwired to 0 when the Zfinx
extension is implemented.</p>
<div class=commentary>
<p>A future discoverability mechanism might be used to probe the existence
of the Zfinx, Zhinx, and Zdinx extensions.</p>
</div>

</body>
</html>
