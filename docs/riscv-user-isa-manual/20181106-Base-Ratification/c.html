<html>
<head>
<link rel="stylesheet" href="../../assets/docs.css">
<title>RISC-V Instruction Set Manual, Volume I: RISC-V User-Level ISA</title>
</head>
<body>

<table>
<tr><th colspan=2>Metadata Table</th></tr>
<tr><th>Manual Type</th><td> user</td></tr>
<tr><th>Spec Revision</th><td> 20181106-Base-Ratification</td></tr>
<tr><th>Spec Release Date</th><td> </td></tr>
<tr><th>Git Revision</th><td> 20181106-Base-Ratification</td></tr>
<tr><th>Git URL</th><td><a href=https://github.com/riscv/riscv-isa-manual.git>https://github.com/riscv/riscv-isa-manual.git</a></td></tr>
<tr><th>Source</th><td>src/c.tex</td></tr>
<tr><th>Conversion Date</th><td>2023/11/12</td></tr>
<tr><th>License</th><td><a href=https://creativecommons.org/licenses/by/4.0/>CC-by-4.0</a></td></tr>
</table>


<section id="compressed" data-number="1">
<h1 data-number="17"><span class="header-section-number">17</span> “C” Standard Extension for Compressed Instructions, Version
2.0</h1>
<p>This chapter describes the current proposal for the RISC-V
standard compressed instruction-set extension, named “C”, which
reduces static and dynamic code size by adding short 16-bit
instruction encodings for common operations. The C extension can be
added to any of the base ISAs (RV32, RV64, RV128), and we use the
generic term “RVC” to cover any of these. Typically, 50%–60% of
the RISC-V instructions in a program can be replaced with RVC
instructions, resulting in a 25%–30% code-size reduction.</p>
<section id="overview" data-number="1.1">
<h2 data-number="17.1"><span class="header-section-number">17.1</span> Overview</h2>
<p>RVC uses a simple compression scheme that offers shorter 16-bit
versions of common 32-bit RISC-V instructions when:</p>
<p>the immediate or address offset is small, or</p>
<p>one of the registers is the zero register (<span><code>x0</code></span>), the
ABI link register (<span><code>x1</code></span>), or the ABI stack pointer (<span><code> x2</code></span>), or</p>
<p>the destination register and the first source register are
identical, or</p>
<p>the registers used are the 8 most popular ones.</p>
<p>The C extension is compatible with all other standard instruction
extensions. The C extension allows 16-bit instructions to be freely
intermixed with 32-bit instructions, with the latter now able to start
on any 16-bit boundary, i.e., IALIGN=16. With the addition of the C
extension, no instructions can raise instruction-address-misaligned
exceptions.</p>
<div class=commentary>
<p>Removing the 32-bit alignment constraint on the original 32-bit
instructions allows significantly greater code density.</p>
</div>
<p>The compressed instruction encodings are mostly common across RV32C,
RV64C, and RV128C, but as shown in Table <a href="rvc-opcode-map.html#rvcopcodemap" data-reference-type="ref" data-reference="rvcopcodemap">[rvcopcodemap]</a>, a few
opcodes are used for different purposes depending on base ISA width.
For example, the wider address-space RV64C and RV128C variants require
additional opcodes to compress loads and stores of 64-bit integer
values, while RV32C uses the same opcodes to compress loads and stores
of single-precision floating-point values. Similarly, RV128C requires
additional opcodes to capture loads and stores of 128-bit integer
values, while these same opcodes are used for loads and stores of
double-precision floating-point values in RV32C and RV64C. If the C
extension is implemented, the appropriate compressed floating-point
load and store instructions must be provided whenever the relevant
standard floating-point extension (F and/or D) is also implemented.
In addition, RV32C includes a compressed jump and link instruction to
compress short-range subroutine calls, where the same opcode is used
to compress ADDIW for RV64C and RV128C.</p>
<div class=commentary>
<p>Double-precision loads and stores are a significant fraction of static
and dynamic instructions, hence the motivation to include them in the
RV32C and RV64C encoding.</p>
<p>Although single-precision loads and stores are not a significant
source of static or dynamic compression for benchmarks compiled for
the currently supported ABIs, for microcontrollers that only provide
hardware single-precision floating-point units and have an ABI that
only supports single-precision floating-point numbers, the
single-precision loads and stores will be used at least as frequently
as double-precision loads and stores in the measured benchmarks.
Hence, the motivation to provide compressed support for these in
RV32C.</p>
<p>Short-range subroutine calls are more likely in small binaries for
microcontrollers, hence the motivation to include these in RV32C.</p>
<p>Although reusing opcodes for different purposes for different base
register widths adds some complexity to documentation, the impact on
implementation complexity is small even for designs that support
multiple base ISA register widths. The compressed floating-point load
and store variants use the same instruction format with the same
register specifiers as the wider integer loads and stores.</p>
</div>
<p>RVC was designed under the constraint that each RVC instruction
expands into a single 32-bit instruction in either the base ISA
(RV32I/E, RV64I, or RV128I) or the F and D standard extensions where
present. Adopting this constraint has two main benefits:</p>
<p>Hardware designs can simply expand RVC instructions during
decode, simplifying verification and minimizing modifications to
existing microarchitectures.</p>
<p>Compilers can be unaware of the RVC extension and leave code
compression to the assembler and linker, although a
compression-aware compiler will generally be able to produce better
results.</p>
<div class=commentary>
<p>We felt the multiple complexity reductions of a simple one-one mapping
between C and base IFD instructions far outweighed the potential gains
of a slightly denser encoding that added additional instructions only
supported in the C extension, or that allowed encoding of multiple IFD
instructions in one C instruction.</p>
</div>
<p>It is important to note that the C extension is not designed to be a
stand-alone ISA, and is meant to be used alongside a base ISA.</p>
<div class=commentary>
<p>Variable-length instruction sets have long been used to improve code
density. For example, the IBM Stretch <span class="citation" data-cites="stretch"><a href="#ref-stretch">[stretch]</a></span>, developed in
the late 1950s, had an ISA with 32-bit and 64-bit instructions, where
some of the 32-bit instructions were compressed versions of the full
64-bit instructions. Stretch also employed the concept of limiting
the set of registers that were addressable in some of the shorter
instruction formats, with short branch instructions that could only
refer to one of the index registers. The later IBM 360
architecture <span class="citation" data-cites="ibm360"><a href="#ref-ibm360">[ibm360]</a></span> supported a simple variable-length
instruction encoding with 16-bit, 32-bit, or 48-bit instruction
formats.</p>
<p>In 1963, CDC introduced the Cray-designed CDC 6600 <span class="citation" data-cites="cdc6600"><a href="#ref-cdc6600">[cdc6600]</a></span>, a
precursor to RISC architectures, that introduced a register-rich
load-store architecture with instructions of two lengths, 15-bits and
30-bits. The later Cray-1 design used a very similar instruction
format, with 16-bit and 32-bit instruction lengths.</p>
<p>The initial RISC ISAs from the 1980s all picked performance over code
size, which was reasonable for a workstation environment, but not for
embedded systems. Hence, both ARM and MIPS subsequently made versions
of the ISAs that offered smaller code size by offering an alternative
16-bit wide instruction set instead of the standard 32-bit wide
instructions. The compressed RISC ISAs reduced code size relative to
their starting points by about 25–30%, yielding code that was
significantly <em>smaller</em> than 80x86. This result surprised some,
as their intuition was that the variable-length CISC ISA should be
smaller than RISC ISAs that offered only 16-bit and 32-bit formats.</p>
<p>Since the original RISC ISAs did not leave sufficient opcode space
free to include these unplanned compressed instructions, they were
instead developed as complete new ISAs. This meant compilers needed
different code generators for the separate compressed ISAs. The first
compressed RISC ISA extensions (e.g., ARM Thumb and MIPS16) used only
a fixed 16-bit instruction size, which gave good reductions in static
code size but caused an increase in dynamic instruction count, which
led to lower performance compared to the original fixed-width 32-bit
instruction size. This led to the development of a second generation
of compressed RISC ISA designs with mixed 16-bit and 32-bit
instruction lengths (e.g., ARM Thumb2, microMIPS, PowerPC VLE), so
that performance was similar to pure 32-bit instructions but with
significant code size savings. Unfortunately, these different
generations of compressed ISAs are incompatible with each other and
with the original uncompressed ISA, leading to significant complexity
in documentation, implementations, and software tools support.</p>
<p>Of the commonly used 64-bit ISAs, only PowerPC and microMIPS currently
supports a compressed instruction format. It is surprising that the
most popular 64-bit ISA for mobile platforms (ARM v8) does not include
a compressed instruction format given that static code size and
dynamic instruction fetch bandwidth are important metrics. Although
static code size is not a major concern in larger systems, instruction
fetch bandwidth can be a major bottleneck in servers running
commercial workloads, which often have a large instruction working
set.</p>
<p>Benefiting from 25 years of hindsight, RISC-V was designed to support
compressed instructions from the outset, leaving enough opcode
space for RVC to be added as a simple extension on top of the base ISA
(along with many other extensions). The philosophy of RVC is to
reduce code size for embedded applications <em>and</em> to improve
performance and energy-efficiency for all applications due to fewer
misses in the instruction cache. Waterman shows that RVC fetches
25%-30% fewer instruction bits, which reduces instruction cache
misses by 20%-25%, or roughly the same performance impact as
doubling the instruction cache size <span class="citation" data-cites="waterman-ms"><a href="#ref-waterman-ms">[waterman-ms]</a></span>.</p>
</div>
</section>
<section id="compressed-instruction-formats" data-number="1.2">
<h2 data-number="17.2"><span class="header-section-number">17.2</span> Compressed Instruction Formats</h2>
<p>Table <a href="c.html#rvc-formats" data-reference-type="ref" data-reference="rvc-formats">1.1</a> shows the nine compressed instruction
formats. CR, CI, and CSS can use any of the 32 RVI registers, but CIW,
CL, CS, CA, and CB are limited to just 8 of them. Table <a href="c.html#registers" data-reference-type="ref" data-reference="registers">[registers]</a>
lists these popular registers, which correspond to registers <span><code>x8</code></span>
to <span><code>x15</code></span>. Note that there is a
separate version of load and store instructions that use the stack
pointer as the base address register, since saving to and restoring
from the stack are so prevalent, and that they use the CI and CSS
formats to allow access to all 32 data registers. CIW supplies an
8-bit immediate for the ADDI4SPN instruction.</p>
<div class=commentary>
<p>The RISC-V ABI was changed to make the frequently used registers map
to registers <span><code>x8</code></span>–<span><code>x15</code></span>. This simplifies the decompression
decoder by having a contiguous naturally aligned set of register
numbers, and is also compatible with the RV32E subset base
specification, which only has 16 integer registers.</p>
</div>
<p>Compressed register-based floating-point loads and stores also use the
CL and CS formats respectively, with the eight registers mapping to
<span><code>f8</code></span> to <span><code>f15</code></span>.</p>
<div class=commentary>
<p>The standard RISC-V calling convention maps the most frequently used
floating-point registers to registers <span><code>f8</code></span> to <span><code>f15</code></span>, which
allows the same register decompression decoding as for integer
register numbers.</p>
</div>
<p>The formats were designed to keep bits for the two register source
specifiers in the same place in all instructions, while the
destination register field can move. When the full 5-bit destination
register specifier is present, it is in the same place as in the
32-bit RISC-V encoding. Where immediates are
sign-extended, the sign-extension is always from bit 12. Immediate
fields have been scrambled, as in the base specification, to reduce
the number of immediate muxes required.</p>
<div class=commentary>
<p>The immediate fields are scrambled in the instruction formats instead
of in sequential order so that as many bits as possible are in the
same position in every instruction, thereby simplifying
implementations. For example, immediate bits 17—10 are always sourced from
the same instruction bit positions. Five other immediate bits (5, 4,
3, 1, and 0) have just two source instruction bits, while four (9, 7,
6, and 2) have three sources and one (8) has four sources.</p>
</div>
<p>For many RVC instructions, zero-valued immediates are disallowed and
<span><code>x0</code></span> is not a valid 5-bit register specifier. These restrictions
free up encoding space for other instructions requiring fewer operand
bits.</p>
<figure>
<img src="c_00.svg" id="rvc-formats" alt="" /><figcaption>Compressed 16-bit RVC instruction formats.</figcaption>
</figure>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">RVC Register Number</td>
<td style="text-align: center;">000</td>
<td style="text-align: center;">001</td>
<td style="text-align: center;">010</td>
<td style="text-align: center;">011</td>
<td style="text-align: center;">100</td>
<td style="text-align: center;">101</td>
<td style="text-align: center;">110</td>
<td style="text-align: center;">111</td>
</tr>
<tr class="even">
<td style="text-align: left;">Integer Register Number</td>
<td style="text-align: center;"><span><code>x8</code></span></td>
<td style="text-align: center;"><span><code>x9</code></span></td>
<td style="text-align: center;"><span><code>x10</code></span></td>
<td style="text-align: center;"><span><code>x11</code></span></td>
<td style="text-align: center;"><span><code>x12</code></span></td>
<td style="text-align: center;"><span><code>x13</code></span></td>
<td style="text-align: center;"><span><code>x14</code></span></td>
<td style="text-align: center;"><span><code>x15</code></span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Integer Register ABI Name</td>
<td style="text-align: center;"><span><code>s0</code></span></td>
<td style="text-align: center;"><span><code>s1</code></span></td>
<td style="text-align: center;"><span><code>a0</code></span></td>
<td style="text-align: center;"><span><code>a1</code></span></td>
<td style="text-align: center;"><span><code>a2</code></span></td>
<td style="text-align: center;"><span><code>a3</code></span></td>
<td style="text-align: center;"><span><code>a4</code></span></td>
<td style="text-align: center;"><span><code>a5</code></span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Floating-Point Register Number</td>
<td style="text-align: center;"><span><code>f8</code></span></td>
<td style="text-align: center;"><span><code>f9</code></span></td>
<td style="text-align: center;"><span><code>f10</code></span></td>
<td style="text-align: center;"><span><code>f11</code></span></td>
<td style="text-align: center;"><span><code>f12</code></span></td>
<td style="text-align: center;"><span><code>f13</code></span></td>
<td style="text-align: center;"><span><code>f14</code></span></td>
<td style="text-align: center;"><span><code>f15</code></span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Floating-Point Register ABI Name</td>
<td style="text-align: center;"><span><code>fs0</code></span></td>
<td style="text-align: center;"><span><code>fs1</code></span></td>
<td style="text-align: center;"><span><code>fa0</code></span></td>
<td style="text-align: center;"><span><code>fa1</code></span></td>
<td style="text-align: center;"><span><code>fa2</code></span></td>
<td style="text-align: center;"><span><code>fa3</code></span></td>
<td style="text-align: center;"><span><code>fa4</code></span></td>
<td style="text-align: center;"><span><code>fa5</code></span></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
</section>
<section id="load-and-store-instructions" data-number="1.3">
<h2 data-number="17.3"><span class="header-section-number">17.3</span> Load and Store Instructions</h2>
<p>To increase the reach of 16-bit instructions, data-transfer
instructions use zero-extended immediates that are scaled by the size
of the data in bytes: <span class="math inline">×</span>4 for words, <span class="math inline">×</span>8 for double words,
and <span class="math inline">×</span>16 for quad words.</p>
<p>RVC provides two variants of loads and stores. One uses the ABI stack
pointer, <span><code>x2</code></span>, as the base address and can target any data register. The
other can reference one of 8 base address registers and one of 8 data
registers.</p>
<section id="stack-pointer-based-loads-and-stores" class="unnumbered" data-number="">
<h3 class="unnumbered" data-number="16">Stack-Pointer-Based Loads and Stores</h3>
<p><img src="c_01.svg" alt="image" /></p>
<p>These instructions use the CI format.</p>
<p>C.LWSP loads a 32-bit value from memory into register <span><em>rd</em></span>. It computes
an effective address by adding the <span><em>zero</em></span>-extended offset, scaled by 4, to
the stack pointer, <span><code>x2</code></span>. It expands to <span><code>lw rd, offset[7:2](x2)</code></span>.
C.LWSP is only valid when <span class="math inline"><em>rd</em> ≠ <code>x0</code></span>.</p>
<p>C.LDSP is an RV64C/RV128C-only instruction that loads a 64-bit value from memory into
register <span><em>rd</em></span>. It computes its effective address by adding the
zero-extended offset, scaled by 8, to the stack pointer, <span><code>x2</code></span>.
It expands to <span><code>ld rd, offset[8:3](x2)</code></span>.
C.LDSP is only valid when <span class="math inline"><em>rd</em> ≠ <code>x0</code></span>.</p>
<p>C.LQSP is an RV128C-only instruction that loads a 128-bit value from memory
into register <span><em>rd</em></span>. It computes its effective address by adding the
zero-extended offset, scaled by 16, to the stack pointer, <span><code>x2</code></span>.
It expands to <span><code>lq rd, offset[9:4](x2)</code></span>.
C.LQSP is only valid when <span class="math inline"><em>rd</em> ≠ <code>x0</code></span>.</p>
<p>C.FLWSP is an RV32FC-only instruction that loads a single-precision
floating-point value from memory into floating-point register <span><em>rd</em></span>. It
computes its effective address by adding the <span><em>zero</em></span>-extended offset,
scaled by 4, to the stack pointer, <span><code>x2</code></span>. It expands to <span><code>flw rd, offset[7:2](x2)</code></span>.</p>
<p>C.FLDSP is an RV32DC/RV64DC-only instruction that loads a double-precision
floating-point value from memory into floating-point register <span><em>rd</em></span>. It
computes its effective address by adding the <span><em>zero</em></span>-extended offset,
scaled by 8, to the stack pointer, <span><code>x2</code></span>. It expands to <span><code>fld rd, offset[8:3](x2)</code></span>.</p>
<p><img src="c_02.svg" alt="image" /></p>
<p>These instructions use the CSS format.</p>
<p>C.SWSP stores a 32-bit value in register <span><em>rs2</em></span> to memory. It computes
an effective address by adding the <span><em>zero</em></span>-extended offset, scaled by 4, to
the stack pointer, <span><code>x2</code></span>.
It expands to <span><code>sw rs2, offset[7:2](x2)</code></span>.</p>
<p>C.SDSP is an RV64C/RV128C-only instruction that stores a 64-bit value in register
<span><em>rs2</em></span> to memory. It computes an effective address by adding the <span>
<em>zero</em></span>-extended offset, scaled by 8, to the stack pointer, <span><code>x2</code></span>.
It expands to <span><code>sd rs2, offset[8:3](x2)</code></span>.</p>
<p>C.SQSP is an RV128C-only instruction that stores a 128-bit value in register
<span><em>rs2</em></span> to memory. It computes an effective address by adding the <span>
<em>zero</em></span>-extended offset, scaled by 16, to the stack pointer, <span><code>x2</code></span>.
It expands to <span><code>sq rs2, offset[9:4](x2)</code></span>.</p>
<p>C.FSWSP is an RV32FC-only instruction that stores a single-precision
floating-point value in floating-point register <span><em>rs2</em></span> to memory. It
computes an effective address by adding the <span><em>zero</em></span>-extended offset, scaled
by 4, to the stack pointer, <span><code>x2</code></span>. It expands to <span><code>fsw rs2, offset[7:2](x2)</code></span>.</p>
<p>C.FSDSP is an RV32DC/RV64DC-only instruction that stores a double-precision
floating-point value in floating-point register <span><em>rs2</em></span> to memory. It
computes an effective address by adding the <span><em>zero</em></span>-extended offset, scaled
by 8, to the stack pointer, <span><code>x2</code></span>. It expands to <span><code>fsd rs2, offset[8:3](x2)</code></span>.</p>
<div class=commentary>
<p>Register save/restore code at function entry/exit represents a
significant portion of static code size. The stack-pointer-based
compressed loads and stores in RVC are effective at reducing the
save/restore static code size by a factor of 2 while improving
performance by reducing dynamic instruction bandwidth.</p>
<p>A common mechanism used in other ISAs to further reduce
save/restore code size is load-multiple and store-multiple
instructions. We considered adopting these for RISC-V but noted the
following drawbacks to these instructions:</p>
<ul>
<li><p>These instructions complicate processor implementations.</p></li>
<li><p>For virtual memory systems, some data accesses could be
resident in physical memory and some could not, which requires a
new restart mechanism for partially executed instructions.</p></li>
<li><p>Unlike the rest of the RVC instructions, there is no IFD
equivalent to Load Multiple and Store Multiple.</p></li>
<li><p>Unlike the rest of the RVC instructions, the compiler would
have to be aware of these instructions to both generate the
instructions and to allocate registers in an order to maximize
the chances of the them being saved and stored, since they would
be saved and restored in sequential order.</p></li>
<li><p>Simple microarchitectural implementations will constrain how
other instructions can be scheduled around the load and store
multiple instructions, leading to a potential performance loss.</p></li>
<li><p>The desire for sequential register allocation might conflict with
the featured registers selected for the CIW, CL, CS, CA, and CB formats.</p></li>
</ul>
<p>Furthermore, much of the gains can be realized in software by replacing
prologue and epilogue code with subroutine calls to common
prologue and epilogue code, a technique described in
Section 5.6 of <span class="citation" data-cites="waterman-phd"><a href="#ref-waterman-phd">[waterman-phd]</a></span>.</p>
<p>While reasonable architects might come to different conclusions, we
decided to omit load and store multiple and instead use the
software-only approach of calling save/restore millicode routines to
attain the greatest code size reduction.</p>
</div>
</section>
<section id="register-based-loads-and-stores" class="unnumbered" data-number="">
<h3 class="unnumbered" data-number="16">Register-Based Loads and Stores</h3>
<p><img src="c_03.svg" alt="image" /></p>
<p>These instructions use the CL format.</p>
<p>C.LW loads a 32-bit value from memory into register <span><em>rd<span class="math inline">′</span></em></span>. It computes
an effective address by adding the <span><em>zero</em></span>-extended offset, scaled by 4, to
the base address in register <span><em>rs1<span class="math inline">′</span></em></span>.
It expands to <span><code>lw rd', offset[6:2](rs1')</code></span>.</p>
<p>C.LD is an RV64C/RV128C-only instruction that loads a 64-bit value from memory into
register <span><em>rd<span class="math inline">′</span></em></span>. It computes an effective address by adding the <span>
<em>zero</em></span>-extended offset, scaled by 8, to the base address in register <span>
<em>rs1<span class="math inline">′</span></em></span>.
It expands to <span><code>ld rd', offset[7:3](rs1')</code></span>.</p>
<p>C.LQ is an RV128C-only instruction that loads a 128-bit value from memory into
register <span><em>rd<span class="math inline">′</span></em></span>. It computes an effective address by adding the <span>
<em>zero</em></span>-extended offset, scaled by 16, to the base address in register <span>
<em>rs1<span class="math inline">′</span></em></span>.
It expands to <span><code>lq rd', offset[8:4](rs1')</code></span>.</p>
<p>C.FLW is an RV32FC-only instruction that loads a single-precision
floating-point value from memory into floating-point register <span><em>rd<span class="math inline">′</span></em></span>. It
computes an effective address by adding the <span><em>zero</em></span>-extended offset, scaled
by 4, to the base address in register <span><em>rs1<span class="math inline">′</span></em></span>. It expands to <span><code>flw rd', offset[6:2](rs1')</code></span>.</p>
<p>C.FLD is an RV32DC/RV64DC-only instruction that loads a double-precision
floating-point value from memory into floating-point register <span><em>rd<span class="math inline">′</span></em></span>. It
computes an effective address by adding the <span><em>zero</em></span>-extended offset, scaled
by 8, to the base address in register <span><em>rs1<span class="math inline">′</span></em></span>. It expands to <span><code>fld rd', offset[7:3](rs1')</code></span>.</p>
<p><img src="c_04.svg" alt="image" /></p>
<p>These instructions use the CS format.</p>
<p>C.SW stores a 32-bit value in register <span><em>rs2<span class="math inline">′</span></em></span> to memory. It computes an
effective address by adding the <span><em>zero</em></span>-extended offset, scaled by 4, to
the base address in register <span><em>rs1<span class="math inline">′</span></em></span>.
It expands to <span><code>sw rs2', offset[6:2](rs1')</code></span>.</p>
<p>C.SD is an RV64C/RV128C-only instruction that stores a 64-bit value in
register <span><em>rs2<span class="math inline">′</span></em></span> to memory. It computes an effective address by adding
the <span><em>zero</em></span>-extended offset, scaled by 8, to the base address in register
<span><em>rs1<span class="math inline">′</span></em></span>.
It expands to <span><code>sd rs2', offset[7:3](rs1')</code></span>.</p>
<p>C.SQ is an RV128C-only instruction that stores a 128-bit value in register
<span><em>rs2<span class="math inline">′</span></em></span> to memory. It computes an effective address by adding the <span>
<em>zero</em></span>-extended offset, scaled by 16, to the base address in register <span>
<em>rs1<span class="math inline">′</span></em></span>.
It expands to <span><code>sq rs2', offset[8:4](rs1')</code></span>.</p>
<p>C.FSW is an RV32FC-only instruction that stores a single-precision
floating-point value in floating-point register <span><em>rs2<span class="math inline">′</span></em></span> to memory. It
computes an effective address by adding the <span><em>zero</em></span>-extended offset, scaled
by 4, to the base address in register <span><em>rs1<span class="math inline">′</span></em></span>. It expands to <span><code>fsw rs2', offset[6:2](rs1')</code></span>.</p>
<p>C.FSD is an RV32DC/RV64DC-only instruction that stores a double-precision
floating-point value in floating-point register <span><em>rs2<span class="math inline">′</span></em></span> to memory. It
computes an effective address by adding the <span><em>zero</em></span>-extended offset, scaled
by 8, to the base address in register <span><em>rs1<span class="math inline">′</span></em></span>. It expands to <span><code>fsd rs2', offset[7:3](rs1')</code></span>.</p>
</section>
</section>
<section id="control-transfer-instructions" data-number="1.4">
<h2 data-number="17.4"><span class="header-section-number">17.4</span> Control Transfer Instructions</h2>
<p>RVC provides unconditional jump instructions and conditional branch
instructions. As with base RVI instructions, the offsets of all RVC
control transfer instruction are in multiples of 2 bytes.</p>
<p><img src="c_05.svg" alt="image" /></p>
<p>These instructions use the CJ format.</p>
<p>C.J performs an unconditional control transfer. The offset is sign-extended and
added to the <span><code>pc</code></span> to form the jump target address. C.J can therefore target
a <span class="math inline">±</span><span>2</span> <span>KiB</span> range. C.J expands to <span><code>jal x0, offset[11:1]</code></span>.</p>
<p>C.JAL is an RV32C-only instruction that performs the same operation as C.J,
but additionally writes the address of the instruction following the jump
(<span><code>pc</code></span>+2) to the link register, <span><code>x1</code></span>. C.JAL expands to <span><code>jal x1, offset[11:1]</code></span>.</p>
<p><img src="c_06.svg" alt="image" /></p>
<p>These instructions use the CR format.</p>
<p>C.JR (jump register) performs an unconditional control transfer to
the address in register <span><em>rs1</em></span>. C.JR expands to <span><code>jalr x0, 0(rs1)</code></span>.</p>
<p>C.JALR (jump and link register) performs the same operation as C.JR,
but additionally writes the address of the instruction following the
jump (<span><code>pc</code></span>+2) to the link register, <span><code>x1</code></span>. C.JALR expands to
<span><code>jalr x1, 0(rs1)</code></span>.</p>
<div class=commentary>
<p>Strictly speaking, C.JALR does not expand exactly to a base RVI
instruction as the value added to the PC to form the link address is 2
rather than 4 as in the base ISA, but supporting both offsets of 2 and
4 bytes is only a very minor change to the base microarchitecture.</p>
</div>
<p><img src="c_07.svg" alt="image" /></p>
<p>These instructions use the CB format.</p>
<p>C.BEQZ performs conditional control transfers. The offset is sign-extended
and added to the <span><code>pc</code></span> to form the branch target address. It can
therefore target a <span class="math inline">±</span><span>256</span> <span>B</span> range. C.BEQZ takes the branch if the
value in register <span><em>rs1<span class="math inline">′</span></em></span> is zero. It expands to <span><code>beq rs1', x0, offset[8:1]</code></span>.</p>
<p>C.BNEZ is defined analogously, but it takes the branch if <span><em>rs1<span class="math inline">′</span></em></span> contains
a nonzero value. It expands to <span><code>bne rs1', x0, offset[8:1]</code></span>.</p>
</section>
<section id="integer-computational-instructions" data-number="1.5">
<h2 data-number="17.5"><span class="header-section-number">17.5</span> Integer Computational Instructions</h2>
<p>RVC provides several instructions for integer arithmetic and constant generation.</p>
<section id="integer-constant-generation-instructions" class="unnumbered" data-number="">
<h3 class="unnumbered" data-number="16">Integer Constant-Generation Instructions</h3>
<p>The two constant-generation instructions both use the CI instruction
format and can target any integer register.</p>
<p><img src="c_08.svg" alt="image" /></p>
<p>C.LI loads the sign-extended 6-bit immediate, <span><em>imm</em></span>, into
register <span><em>rd</em></span>. C.LI is only valid when <span><em>rd</em></span><span class="math inline">≠</span><span><code>x0</code></span>.
C.LI expands into <span><code>addi rd, x0, imm[5:0]</code></span>.</p>
<p>C.LUI loads the non-zero 6-bit immediate field into bits 17–12 of the
destination register, clears the bottom 12 bits, and sign-extends bit
17 into all higher bits of the destination. C.LUI is only valid when
<span class="math inline"><em>rd</em> ≠ {<code>x0</code>,<code>x2</code>}</span>,
and when the immediate is not equal to zero.
C.LUI expands into <span><code>lui rd, nzimm[17:12]</code></span>.</p>
</section>
<section id="integer-register-immediate-operations" class="unnumbered" data-number="">
<h3 class="unnumbered" data-number="16">Integer Register-Immediate Operations</h3>
<p>These integer register-immediate operations are encoded in the CI
format and perform operations on an integer register and
a 6-bit immediate.</p>
<p><img src="c_09.svg" alt="image" /></p>
<p>C.ADDI adds the non-zero sign-extended 6-bit immediate to the value in
register <span><em>rd</em></span> then writes the result to <span><em>rd</em></span>. C.ADDI expands
into <span><code>addi rd, rd, nzimm[5:0]</code></span>.
C.ADDI is only valid when <span><em>rd</em></span><span class="math inline">≠</span><span><code>x0</code></span>.</p>
<p>C.ADDIW is an RV64C/RV128C-only instruction that performs the same
computation but produces a 32-bit result, then sign-extends result to
64 bits. C.ADDIW expands into <span><code>addiw rd, rd, imm[5:0]</code></span>. The
immediate can be zero for C.ADDIW, where this corresponds to <span><code> sext.w rd</code></span>. C.ADDIW is only valid when <span><em>rd</em></span><span class="math inline">≠</span><span><code>x0</code></span>.</p>
<p>C.ADDI16SP shares the opcode with C.LUI, but has a destination field
of <span><code>x2</code></span>. C.ADDI16SP adds the non-zero sign-extended 6-bit immediate to
the value in the stack pointer (<span><code>sp</code></span>=<span><code>x2</code></span>), where the
immediate is scaled to represent multiples of 16 in the range
(-512,496). C.ADDI16SP is used to adjust the stack pointer in procedure
prologues and epilogues. It expands into <span><code>addi x2, x2, nzimm[9:4]</code></span>.</p>
<div class=commentary>
<p>In the standard RISC-V calling convention, the stack pointer <span><code>sp</code></span>
is always 16-byte aligned.</p>
</div>
<p><img src="c_10.svg" alt="image" /></p>
<p>C.ADDI4SPN is a CIW-format instruction that adds a <span><em>zero</em></span>-extended
non-zero immediate, scaled by 4, to the stack pointer, <span><code>x2</code></span>, and
writes the result to <span><code>rd'</code></span>. This instruction is used
to generate pointers to stack-allocated variables, and expands to
<span><code>addi rd', x2, nzuimm[9:2]</code></span>.</p>
<p><img src="c_11.svg" alt="image" /></p>
<p>C.SLLI is a CI-format instruction that performs a logical left shift
of the value in register <span><em>rd</em></span> then writes the result to <span><em>rd</em></span>.
The shift amount is encoded in the <span><em>shamt</em></span> field, where <span>
<em>shamt[5]</em></span> must be zero for RV32C. For RV32C and RV64C, the shift
amount must be non-zero. For RV128C, a shift amount of zero is used
to encode a shift of 64. C.SLLI expands into <span><code>slli rd, rd, shamt[5:0]</code></span>, except for RV128C with <span><code>shamt=0</code></span>, which expands to
<span><code>slli rd, rd, 64</code></span>.</p>
<p><img src="c_12.svg" alt="image" /></p>
<p>C.SRLI is a CB-format instruction that performs a logical right shift
of the value in register <span><em>rd<span class="math inline">′</span></em></span> then writes the result to <span><em>rd<span class="math inline">′</span></em></span>.
The shift amount is encoded in the <span><em>shamt</em></span> field, where <span>
<em>shamt[5]</em></span> must be zero for RV32C. For RV32C and RV64C, the shift
amount must be non-zero. For RV128C, a shift amount of zero is used
to encode a shift of 64. Furthermore, the shift amount is sign-extended
for RV128C, and so the legal shift amounts are 1–31, 64, and 96–127.
C.SRLI expands into <span><code>srli rd', rd', shamt[5:0]</code></span>,
except for RV128C with <span><code>shamt=0</code></span>, which expands to
<span><code>srli rd', rd', 64</code></span>.</p>
<p>C.SRAI is defined analogously to C.SRLI, but instead performs an arithmetic
right shift.
C.SRAI expands to <span><code>srai rd', rd', shamt[5:0]</code></span>.</p>
<div class=commentary>
<p>Left shifts are usually more frequent than right shifts, as left
shifts are frequently used to scale address values. Right shifts have
therefore been granted less encoding space and are placed in an
encoding quadrant where all other immediates are sign-extended. For
RV128, the decision was made to have the 6-bit shift-amount immediate
also be sign-extended. Apart from reducing the decode complexity, we
believe right-shift amounts of 96–127 will be more useful than 64–95,
to allow extraction of tags located in the high portions of 128-bit
address pointers. We note that RV128C will not be frozen at the same
point as RV32C and RV64C, to allow evaluation of typical usage of
128-bit address-space codes.</p>
</div>
<p><img src="c_13.svg" alt="image" /></p>
<p>C.ANDI is a CB-format instruction that computes the bitwise AND of
of the value in register <span><em>rd<span class="math inline">′</span></em></span> and the sign-extended 6-bit immediate,
then writes the result to <span><em>rd<span class="math inline">′</span></em></span>.
C.ANDI expands to <span><code>andi rd', rd', imm[5:0]</code></span>.</p>
</section>
<section id="integer-register-register-operations" class="unnumbered" data-number="">
<h3 class="unnumbered" data-number="16">Integer Register-Register Operations</h3>
<p><img src="c_14.svg" alt="image" /></p>
<p>These instructions use the CR format.</p>
<p>C.MV copies the value in register <span><em>rs2</em></span> into register <span><em>rd</em></span>. C.MV
expands into <span><code>add rd, x0, rs2</code></span>.</p>
<div class=commentary>
<p>C.MV expands to a different instruction than the canonical MV
pseudoinstruction, which instead uses ADDI. Implementations that handle MV
specially, e.g. using register-renaming hardware, may find it more convenient
to expand C.MV to MV instead of ADD, at slight additional hardware cost.</p>
</div>
<p>C.ADD adds the values in registers <span><em>rd</em></span> and <span><em>rs2</em></span> and writes the
result to register <span><em>rd</em></span>. C.ADD expands into <span><code>add rd, rd, rs2</code></span>.</p>
<p><img src="c_15.svg" alt="image" /></p>
<p>These instructions use the CA format.</p>
<p>C.AND computes the bitwise AND of the values in registers <span><em>rd<span class="math inline">′</span></em></span>
and <span><em>rs2<span class="math inline">′</span></em></span>, then writes the result to register <span><em>rd<span class="math inline">′</span></em></span>.
C.AND expands into <span><code>and rd', rd', rs2'</code></span>.</p>
<p>C.OR computes the bitwise OR of the values in registers <span><em>rd<span class="math inline">′</span></em></span>
and <span><em>rs2<span class="math inline">′</span></em></span>, then writes the result to register <span><em>rd<span class="math inline">′</span></em></span>.
C.OR expands into <span><code>or rd', rd', rs2'</code></span>.</p>
<p>C.XOR computes the bitwise XOR of the values in registers <span><em>rd<span class="math inline">′</span></em></span>
and <span><em>rs2<span class="math inline">′</span></em></span>, then writes the result to register <span><em>rd<span class="math inline">′</span></em></span>.
C.XOR expands into <span><code>xor rd', rd', rs2'</code></span>.</p>
<p>C.SUB subtracts the value in register <span><em>rs2<span class="math inline">′</span></em></span> from the value in
register <span><em>rd<span class="math inline">′</span></em></span>, then writes the result to register <span><em>rd<span class="math inline">′</span></em></span>.
C.SUB expands into <span><code>sub rd', rd', rs2'</code></span>.</p>
<p>C.ADDW is an RV64C/RV128C-only instruction that adds the values in
registers <span><em>rd<span class="math inline">′</span></em></span> and <span><em>rs2<span class="math inline">′</span></em></span>, then sign-extends the lower
32 bits of the sum before writing the result to register <span><em>rd<span class="math inline">′</span></em></span>.
C.ADDW expands into <span><code>addw rd', rd', rs2'</code></span>.</p>
<p>C.SUBW is an RV64C/RV128C-only instruction that subtracts the value in
register <span><em>rs2<span class="math inline">′</span></em></span> from the value in register <span><em>rd<span class="math inline">′</span></em></span>, then
sign-extends the lower 32 bits of the difference before writing the result
to register <span><em>rd<span class="math inline">′</span></em></span>. C.SUBW expands into <span><code>subw rd', rd', rs2'</code></span>.</p>
<div class=commentary>
<p>This group of six instructions do not provide large savings
individually, but do not occupy much encoding space and are
straightforward to implement, and as a group provide a worthwhile
improvement in static and dynamic compression.</p>
</div>
</section>
<section id="defined-illegal-instruction" class="unnumbered" data-number="">
<h3 class="unnumbered" data-number="16">Defined Illegal Instruction</h3>
<p><img src="c_16.svg" alt="image" /></p>
<p>A 16-bit instruction with all bits zero is permanently reserved as an
illegal instruction.
<div class=commentary>
<p>We reserve all-zero instructions to be illegal instructions to help
trap attempts to execute zero-ed or non-existent portions of the
memory space. The all-zero value should not be redefined in any
non-standard extension. Similarly, we reserve instructions with all
bits set to 1 (corresponding to very long instructions in the RISC-V
variable-length encoding scheme) as illegal to capture another common
value seen in non-existent memory regions.</p>
</div>
</section>
<section id="nop-instruction" class="unnumbered" data-number="">
<h3 class="unnumbered" data-number="16">NOP Instruction</h3>
<p><img src="c_17.svg" alt="image" /></p>
<p>C.NOP is a CI-format instruction that does not change any user-visible state,
except for advancing the <span><code>pc</code></span> and incrementing any applicable performance
counters. C.NOP expands to <span><code>nop</code></span>.</p>
</section>
<section id="breakpoint-instruction" class="unnumbered" data-number="">
<h3 class="unnumbered" data-number="16">Breakpoint Instruction</h3>
<p><img src="c_18.svg" alt="image" /></p>
<p>Debuggers can use the C.EBREAK instruction, which expands to <span><code>ebreak</code></span>,
to cause control to be transferred back to the debugging environment.
C.EBREAK shares the opcode with the C.ADD instruction, but with <span>
<em>rd</em></span> and <span><em>rs2</em></span> both zero, thus can also use the CR format.</p>
</section>
</section>
<section id="usage-of-c-instructions-in-lrsc-sequences" data-number="1.6">
<h2 data-number="17.6"><span class="header-section-number">17.6</span> Usage of C Instructions in LR/SC Sequences</h2>
<p>On implementations that support the C extension, compressed forms of
the I instructions permitted inside LR/SC sequences can be used while
retaining the guarantee of eventual success, as described in
Section <a href="a.html#lrscseq" data-reference-type="ref" data-reference="lrscseq">[lrscseq]</a>.</p>
<div class=commentary>
<p>The implication is that any implementation that claims to support both
the A and C extensions must ensure that LR/SC sequences containing
valid C instructions will eventually complete.</p>
</div>
</section>
<section id="sec:rvc-hints" data-number="1.7">
<h2 data-number="17.7"><span class="header-section-number">17.7</span> HINT Instructions</h2>
<p>A portion of the RVC encoding space is reserved for microarchitectural HINTs.
Like the HINTs in the RV32I base ISA (see Section <a href="rv32.html#sec:rv32i-hints" data-reference-type="ref" data-reference="sec:rv32i-hints">[sec:rv32i-hints]</a>),
these instructions do not modify any architectural state, except for advancing
the <span><code>pc</code></span> and any applicable performance counters. HINTs are
executed as no-ops on implementations that ignore them.</p>
<p>RVC HINTs are encoded as computational instructions that do not modify the
architectural state, either because <span><em>rd</em></span>=<span><code>x0</code></span>
(e.g. <span>C.ADD <span><em>x0</em></span>, <span><em>t0</em></span></span> ), or because <span><em>rd</em></span> is overwritten
with a copy of itself (e.g. <span>C.ADDI <span><em>t0</em></span>, 0</span> ).</p>
<div class=commentary>
<p>This HINT encoding has been chosen so that simple implementations can ignore
HINTs altogether, and instead execute a HINT as a regular computational
instruction that happens not to mutate the architectural state.</p>
</div>
<p>RVC HINTs do not necessarily expand to their RVI HINT counterparts. For
example, <span>C.ADD <span><em>x0</em></span>, <span><em>t0</em></span></span> might not encode the same HINT
as <span>ADD <span><em>x0</em></span>, <span><em>x0</em></span>, <span><em>t0</em></span></span> .</p>
<div class=commentary>
<p>The primary reason to not require an RVC HINT to expand to an RVI HINT
is that HINTs are unlikely to be compressible in the same manner as
the underlying computational instruction. Also, decoupling the RVC
and RVI HINT mappings allows the scarce RVC HINT space to be allocated
to the most popular HINTs, and in particular, to HINTs that are
amenable to macro-op fusion.</p>
</div>
<p>Table <a href="c.html#tab:rvc-hints" data-reference-type="ref" data-reference="tab:rvc-hints">1.2</a> lists all RVC HINT code points. For RV32C, 78% of
the HINT space is reserved for standard HINTs, but none are presently defined.
The remainder of the HINT space is reserved for custom HINTs: no standard
HINTs will ever be defined in this subspace.</p>
<figure>
<img src="c_19.svg" id="tab:rvc-hints" alt="" /><figcaption>RVC HINT instructions.</figcaption>
</figure>
</section>
<section id="rvc-instruction-set-listings" data-number="1.8">
<h2 data-number="17.8"><span class="header-section-number">17.8</span> RVC Instruction Set Listings</h2>
<p>Table <a href="rvc-opcode-map.html#rvcopcodemap" data-reference-type="ref" data-reference="rvcopcodemap">[rvcopcodemap]</a> shows a map of the major opcodes for RVC.
Opcodes with the lower two bits set correspond to instructions wider
than 16 bits, including those in the base ISAs. Several instructions
are only valid for certain operands; when invalid, they are marked
either <span><em>RES</em></span> to indicate that the opcode is reserved for future
standard extensions; <span><em>NSE</em></span> to indicate that the opcode is reserved
for non-standard extensions; or <span><em>HINT</em></span> to indicate that the opcode
is reserved for microarchitectural hints (see Section <a href="c.html#sec:rvc-hints" data-reference-type="ref" data-reference="sec:rvc-hints">1.7</a>).</p>
<p><a href="rvc-opcode-map.html" data-reference-type="ref" data-reference="rvc-opcode-map">[rvc-opcode-map]</a></p>
<p>Tables <a href="rvc-instr-table.html#rvc-instr-table0" data-reference-type="ref" data-reference="rvc-instr-table0">[rvc-instr-table0]</a>–<a href="rvc-instr-table.html#rvc-instr-table2" data-reference-type="ref" data-reference="rvc-instr-table2">[rvc-instr-table2]</a> list the RVC instructions.
<a href="rvc-instr-table.html" data-reference-type="ref" data-reference="rvc-instr-table">[rvc-instr-table]</a></p>
</section>
</section>

</body>
</html>
