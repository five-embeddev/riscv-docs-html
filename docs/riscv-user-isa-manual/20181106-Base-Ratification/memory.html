<html>
<head>
<title>RISC-V Instruction Set Manual, Volume I: RISC-V User-Level ISA</title>
</head>
<body>

<table>
<tr><th colspan=2>Metadata Table</th></tr>
<tr><th>Manual Type</th><td> user</td></tr>
<tr><th>Spec Revision</th><td> 20181106-Base-Ratification</td></tr>
<tr><th>Spec Release Date</th><td> </td></tr>
<tr><th>Git Revision</th><td> 20181106-Base-Ratification</td></tr>
<tr><th>Git URL</th><td><a href=https://github.com/riscv/riscv-isa-manual.git>https://github.com/riscv/riscv-isa-manual.git</a></td></tr>
<tr><th>Source</th><td>src/memory.tex</td></tr>
<tr><th>Conversion Date</th><td>2023/10/11</td></tr>
<tr><th>License</th><td><a href=https://creativecommons.org/licenses/by/4.0/>CC-by-4.0</a></td></tr>
</table>


<h1 id="sec:memorymodelexplanation">RVWMO Explanatory Material, Version 0.1</h1>
<p>This section provides more explanation for RVWMO (Chapter <a href="rvwmo.html#ch:memorymodel" data-reference-type="ref" data-reference="ch:memorymodel">[ch:memorymodel]</a>), using more informal language and concrete examples.
These are intended to clarify the meaning and intent of the axioms and preserved program order rules.
This appendix should be treated as commentary; all normative material is provided in Chapter <a href="rvwmo.html#ch:memorymodel" data-reference-type="ref" data-reference="ch:memorymodel">[ch:memorymodel]</a> and in the rest of the main body of the ISA specification.
All currently known discrepancies are listed in Section <a href="memory.html#sec:memory:discrepancies" data-reference-type="ref" data-reference="sec:memory:discrepancies">1.7</a>.
Any other discrepancies are unintentional.</p>
<h2 id="sec:whyrvwmo">Why RVWMO?</h2>
<p>Memory consistency models fall along a loose spectrum from weak to strong.
Weak memory models allow more hardware implementation flexibility and deliver arguably better performance, performance per watt, power, scalability, and hardware verification overheads than strong models, at the expense of a more complex programming model.
Strong models provide simpler programming models, but at the cost of imposing more restrictions on the kinds of (non-speculative) hardware optimizations that can be performed in the pipeline and in the memory system, and in turn imposing some cost in terms of power, area overhead, and verification burden.</p>
<p>RISC-V has chosen the RVWMO memory model, a variant of release consistency.
This places it in between the two extremes of the memory model spectrum.
The RVWMO memory model enables architects to build simple implementations, aggressive implementations, implementations embedded deeply inside a much larger system and subject to complex memory system interactions, or any number of other possibilities, all while simultaneously being strong enough to support programming language memory models at high performance.</p>
<p>To facilitate the porting of code from other architectures, some hardware implementations may choose to implement the Ztso extension, which provides stricter RVTSO ordering semantics by default.
Code written for RVWMO is automatically and inherently compatible with RVTSO, but code written assuming RVTSO is not guaranteed to run correctly on RVWMO implementations.
In fact, most RVWMO implementations will (and should) simply refuse to run RVTSO-only binaries.
Each implementation must therefore choose whether to prioritize compatibility with RVTSO code (e.g., to facilitate porting from x86) or whether to instead prioritize compatibility with other RISC-V cores implementing RVWMO.</p>
<p>Some fences and/or memory ordering annotations in code written for RVWMO may become redundant under RVTSO; the cost that the default of RVWMO imposes on Ztso implementations is the incremental overhead of fetching those fences (e.g., FENCE R,RW and FENCE RW,W) which become no-ops on that implementation.
However, these fences must remain present in the code if compatibility with non-Ztso implementations is desired.</p>
<h2 id="litmus-tests">Litmus Tests</h2>
<p>The explanations in this chapter make use of <span><em>litmus tests</em></span>, or small programs designed to test or highlight one particular aspect of a memory model.
Figure <a href="memory.html#fig:litmus:sample" data-reference-type="ref" data-reference="fig:litmus:sample">1.1</a> shows an example of a litmus test with two harts.
As a convention for this figure and for all figures that follow in this chapter, we assume that <span>s0</span>–<span>s2</span> are pre-set to the same value in all harts and that <span>s0</span> holds the address labeled <span>x</span>, <span>s1</span> holds <span>y</span>, and <span>s2</span> holds <span>z</span>, where <span>x</span>, <span>y</span>, and <span>z</span> are disjoint memory locations aligned to 8 byte boundaries.
Each figure shows the litmus test code on the left, and a visualization of one particular valid or invalid execution on the right.</p>
<figure>
<img src="memory_00.svg" alt="A sample litmus test and one forbidden execution (a0=1)." id="fig:litmus:sample" /><figcaption>A sample litmus test and one forbidden execution (<span>a0=1</span>).<span label="fig:litmus:sample"></span></figcaption>
</figure>
<p>Litmus tests are used to understand the implications of the memory model in specific concrete situations.
For example, in the litmus test of Figure <a href="memory.html#fig:litmus:sample" data-reference-type="ref" data-reference="fig:litmus:sample">1.1</a>, the final value of <span>a0</span> in the first hart can be either 2, 4, or 5, depending on the dynamic interleaving of the instruction stream from each hart at runtime.
However, in this example, the final value of <span>a0</span> in Hart 0 will never be 1 or 3; intuitively, the value 1 will no longer be visible at the time the load executes, and the value 3 will not yet be visible by the time the load executes.
We analyze this test and many others below.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Edge</th>
<th style="text-align: left;">Full Name (and explanation)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">rf</td>
<td style="text-align: left;">Reads From (from each store to the loads that return a value written by that store)</td>
</tr>
<tr class="even">
<td style="text-align: center;">co</td>
<td style="text-align: left;">Coherence (a total order on the stores to each address)</td>
</tr>
<tr class="odd">
<td style="text-align: center;">fr</td>
<td style="text-align: left;">From-Reads (from each load to co-successors of the store from which the load returned a value)</td>
</tr>
<tr class="even">
<td style="text-align: center;">ppo</td>
<td style="text-align: left;">Preserved Program Order</td>
</tr>
<tr class="odd">
<td style="text-align: center;">fence</td>
<td style="text-align: left;">Orderings enforced by a FENCE instruction</td>
</tr>
<tr class="even">
<td style="text-align: center;">addr</td>
<td style="text-align: left;">Address Dependency</td>
</tr>
<tr class="odd">
<td style="text-align: center;">ctrl</td>
<td style="text-align: left;">Control Dependency</td>
</tr>
<tr class="even">
<td style="text-align: center;">data</td>
<td style="text-align: left;">Data Dependency</td>
</tr>
</tbody>
</table>
<p>The diagram shown to the right of each litmus test shows a visual representation of the particular execution candidate being considered.
These diagrams use a notation that is common in the memory model literature for constraining the set of possible global memory orders that could produce the execution in question.
It is also the basis for the <span class="sans-serif">herd</span> models presented in Appendix <a href="memory-model-herd.html#sec:herd" data-reference-type="ref" data-reference="sec:herd">[sec:herd]</a>.
This notation is explained in Table <a href="memory.html#tab:litmus:key" data-reference-type="ref" data-reference="tab:litmus:key">[tab:litmus:key]</a>.
Of the listed relations, <span>rf</span> edges between harts, <span>co</span> edges, <span>fr</span> edges, and <span>ppo</span> edges directly constrain the global memory order (as do <span>fence</span>, <span>addr</span>, <span>data</span>, and some <span>ctrl</span> edges, via <span>ppo</span>).
Other edges (such as intra-hart <span>rf</span> edges) are informative but do not constrain the global memory order.</p>
<p>For example, in Figure <a href="memory.html#fig:litmus:sample" data-reference-type="ref" data-reference="fig:litmus:sample">1.1</a>, <span>a0=1</span> could occur only if one of the following were true:</p>
<ul>
<li><p>(b) appears before (a) in global memory order (and in the coherence order <span>co</span>). However, this violates RVWMO PPO rule <a href="#ppo:-&gt;st" data-reference-type="ref" data-reference="ppo:-&gt;st">[ppo:-&gt;st]</a>. The <span>co</span> edge from (b) to (a) highlights this contradiction.</p></li>
<li><p>(a) appears before (b) in global memory order (and in the coherence order <span>co</span>). However, in this case, the Load Value Axiom would be violated, because (a) is not the latest matching store prior to (c) in program order. The <span>fr</span> edge from (c) to (b) highlights this contradiction.</p></li>
</ul>
<p>Since neither of these scenarios satisfies the RVWMO axioms, the outcome <span>a0=1</span> is forbidden.</p>
<p>Beyond what is described in this appendix, a suite of more than seven thousand litmus tests is available at <a href="http://diy.inria.fr/cats7/riscv/">http://diy.inria.fr/cats7/riscv/</a>.</p>
<div class=commentary>
<p>In the future, we expect to adapt these memory model litmus tests for use as part of the RISC-V compliance test suite as well.</p>
</div>
<h2 id="explaining-the-rvwmo-rules">Explaining the RVWMO Rules</h2>
<p>In this section, we provide explanation and examples for all of the RVWMO rules and axioms.</p>
<h3 id="preserved-program-order-and-global-memory-order">Preserved Program Order and Global Memory Order</h3>
<p>Preserved program order represents the subset of program order that must be respected within the global memory order.
Conceptually, events from the same hart that are ordered by preserved program order must appear in that order from the perspective of other harts and/or observers.
Events from the same hart that are not ordered by preserved program order, on the other hand, may appear reordered from the perspective of other harts and/or observers.</p>
<p>Informally, the global memory order represents the order in which loads and stores perform.
The formal memory model literature has moved away from specifications built around the concept of performing, but the idea is still useful for building up informal intuition.
A load is said to have performed when its return value is determined.
A store is said to have performed not when it has executed inside the pipeline, but rather only when its value has been propagated to globally visible memory.
In this sense, the global memory order also represents the contribution of the coherence protocol and/or the rest of the memory system to interleave the (possibly reordered) memory accesses being issued by each hart into a single total order agreed upon by all harts.</p>
<p>The order in which loads perform does not always directly correspond to the relative age of the values those two loads return.
In particular, a load <span class="math inline"><em>b</em></span> may perform before another load <span class="math inline"><em>a</em></span> to the same address (i.e., <span class="math inline"><em>b</em></span> may execute before <span class="math inline"><em>a</em></span>, and <span class="math inline"><em>b</em></span> may appear before <span class="math inline"><em>a</em></span> in the global memory order), but <span class="math inline"><em>a</em></span> may nevertheless return an older value than <span class="math inline"><em>b</em></span>.
This discrepancy captures (among other things) the reordering effects of buffering placed between the core and memory.
For example, <span class="math inline"><em>b</em></span> may have returned a value from a store in the store buffer, while <span class="math inline"><em>a</em></span> may have ignored that younger store and read an older value from memory instead.
To account for this, at the time each load performs, the value it returns is determined by the load value axiom, not just strictly by determining the most recent store to the same address in the global memory order, as described below.</p>
<h3 id="sec:memory:loadvalueaxiom"></h3>
<p><img src="memory_01.svg" alt="image" /></p>
<p>Preserved program order is <span><em>not</em></span> required to respect the ordering of a store followed by a load to an overlapping address.
This complexity arises due to the ubiquity of store buffers in nearly all implementations.
Informally, the load may perform (return a value) by forwarding from the store while the store is still in the store buffer, and hence before the store itself performs (writes back to globally visible memory).
Any other hart will therefore observe the load as performing before the store.</p>
<figure>
<img src="memory_02.svg" alt="A store buffer forwarding litmus test (outcome permitted)" id="fig:litmus:storebuffer" /><figcaption>A store buffer forwarding litmus test (outcome permitted)<span label="fig:litmus:storebuffer"></span></figcaption>
</figure>
<p>Consider the litmus test of Figure <a href="memory.html#fig:litmus:storebuffer" data-reference-type="ref" data-reference="fig:litmus:storebuffer">1.2</a>.
When running this program on an implementation with store buffers, it is possible to arrive at the final outcome
<span>a0=1</span>, <span>a1=0</span>, <span>a2=1</span>, <span>a3=0</span>
as follows:</p>
<ul>
<li><p>(a) executes and enters the first hart’s private store buffer</p></li>
<li><p>(b) executes and forwards its return value 1 from (a) in the store buffer</p></li>
<li><p>(c) executes since all previous loads (i.e., (b)) have completed</p></li>
<li><p>(d) executes and reads the value 0 from memory</p></li>
<li><p>(e) executes and enters the second hart’s private store buffer</p></li>
<li><p>(f) executes and forwards its return value 1 from (e) in the store buffer</p></li>
<li><p>(g) executes since all previous loads (i.e., (f)) have completed</p></li>
<li><p>(h) executes and reads the value 0 from memory</p></li>
<li><p>(a) drains from the first hart’s store buffer to memory</p></li>
<li><p>(e) drains from the second hart’s store buffer to memory</p></li>
</ul>
<p>Therefore, the memory model must be able to account for this behavior.</p>
<p>To put it another way, suppose the definition of preserved program order did include the following hypothetical rule:
memory access <span class="math inline"><em>a</em></span> precedes memory access <span class="math inline"><em>b</em></span> in preserved program order (and hence also in the global memory order) if <span class="math inline"><em>a</em></span> precedes <span class="math inline"><em>b</em></span> in program order and <span class="math inline"><em>a</em></span> and <span class="math inline"><em>b</em></span> are accesses to the same memory location, <span class="math inline"><em>a</em></span> is a write, and <span class="math inline"><em>b</em></span> is a read. Call this “Rule X”. Then we get the following:</p>
<ul>
<li><p>(a) precedes (b): by rule X</p></li>
<li><p>(b) precedes (d): by rule <a href="rvwmo.html#ppo:fence" data-reference-type="ref" data-reference="ppo:fence">[ppo:fence]</a></p></li>
<li><p>(d) precedes (e): by the load value axiom. Otherwise, if (e) preceded (d), then (d) would be required to return the value 1. (This is a perfectly legal execution; it’s just not the one in question)</p></li>
<li><p>(e) precedes (f): by rule X</p></li>
<li><p>(f) precedes (h): by rule <a href="rvwmo.html#ppo:fence" data-reference-type="ref" data-reference="ppo:fence">[ppo:fence]</a></p></li>
<li><p>(h) precedes (a): by the load value axiom, as above.</p></li>
</ul>
<p>The global memory order must be a total order and cannot be cyclic, because a cycle would imply that every event in the cycle happens before itself, which is impossible.
Therefore, the execution proposed above would be forbidden, and hence the addition of rule X would forbid implementations with store buffer forwarding, which would clearly be undesirable.</p>
<p>Nevertheless, even if (b) precedes (a) and/or (f) precedes (e) in the global memory order, the only sensible possibility in this example is for (b) to return the value written by (a), and likewise for (f) and (e). This combination of circumstances is what leads to the second option in the definition of the load value axiom.
Even though (b) precedes (a) in the global memory order, (a) will still be visible to (b) by virtue of sitting in the store buffer at the time (b) executes.
Therefore, even if (b) precedes (a) in the global memory order, (b) should return the value written by (a) because (a) precedes (b) in program order.
Likewise for (e) and (f).</p>
<figure>
<img src="memory_03.svg" alt="The “PPOCA” store buffer forwarding litmus test (outcome permitted)" id="fig:litmus:ppoca" /><figcaption>The “PPOCA” store buffer forwarding litmus test (outcome permitted)<span label="fig:litmus:ppoca"></span></figcaption>
</figure>
<p>Another test that highlights the behavior of store buffers is shown in Figure <a href="memory.html#fig:litmus:ppoca" data-reference-type="ref" data-reference="fig:litmus:ppoca">1.3</a>.
In this example, (d) is ordered before (e) because of the control dependency, and (f) is ordered before (g) because of the address dependency.
However, (e) is <span><em>not</em></span> necessarily ordered before (f), even though (f) returns the value written by (e).
This could correspond to the following sequence of events:</p>
<ul>
<li><p>(e) executes speculatively and enters the second hart’s private store buffer (but does not drain to memory)</p></li>
<li><p>(f) executes speculatively and forwards its return value 1 from (e) in the store buffer</p></li>
<li><p>(g) executes speculatively and reads the value 0 from memory</p></li>
<li><p>(a) executes, enters the first hart’s private store buffer, and drains to memory</p></li>
<li><p>(b) executes and retires</p></li>
<li><p>(c) executes, enters the first hart’s private store buffer, and drains to memory</p></li>
<li><p>(d) executes and reads the value 1 from memory</p></li>
<li><p>(e), (f), and (g) commit, since the speculation turned out to be correct</p></li>
<li><p>(e) drains from the store buffer to memory</p></li>
</ul>
<h3 id="sec:memory:atomicityaxiom"></h3>
<p><img src="memory_04.svg" alt="image" /></p>
<p>The RISC-V architecture decouples the notion of atomicity from the notion of ordering. Unlike architectures such as TSO, RISC-V atomics under RVWMO do not impose any ordering requirements by default. Ordering semantics are only guaranteed by the PPO rules that otherwise apply.</p>
<p>RISC-V contains two types of atomics: AMOs and LR/SC pairs.
These conceptually behave differently, in the following way.
LR/SC behave as if the old value is brought up to the core, modified, and written back to memory, all while a reservation is held on that memory location.
AMOs on the other hand conceptually behave as if they are performed directly in memory.
AMOs are therefore inherently atomic, while LR/SC pairs are atomic in the slightly different sense that the memory location in question will not be modified by another hart during the time the original hart holds the reservation.</p>
<figure>
<img src="memory_05.svg" alt="In all four (independent) code snippets, the store-conditional (c) is permitted but not guaranteed to succeed" id="fig:litmus:lrsdsc" /><figcaption>In all four (independent) code snippets, the store-conditional (c) is permitted but not guaranteed to succeed<span label="fig:litmus:lrsdsc"></span></figcaption>
</figure>
<p>The atomicity axiom forbids stores from other harts from being interleaved in global memory order between an LR and the SC paired with that LR.
The atomicity axiom does not forbid loads from being interleaved between the paired operations in program order or in the global memory order, nor does it forbid stores from the same hart or stores to non-overlapping locations from appearing between the paired operations in either program order or in the global memory order.
For example, the SC instructions in Figure <a href="memory.html#fig:litmus:lrsdsc" data-reference-type="ref" data-reference="fig:litmus:lrsdsc">1.4</a> may (but are not guaranteed to) succeed.
None of those successes would violate the atomicity axiom, because the intervening non-conditional stores are from the same hart as the paired load-reserved and store-conditional instructions.
This way, a memory system that tracks memory accesses at cache line granularity (and which therefore will see the four snippets of Figure <a href="memory.html#fig:litmus:lrsdsc" data-reference-type="ref" data-reference="fig:litmus:lrsdsc">1.4</a> as identical) will not be forced to fail a store-conditional instruction that happens to (falsely) share another portion of the same cache line as the memory location being held by the reservation.</p>
<p>The atomicity axiom also technically supports cases in which the LR and SC touch different addresses and/or use different access sizes; however, use cases for such behaviors are expected to be rare in practice.
Likewise, scenarios in which stores from the same hart between an LR/SC pair actually overlap the memory location(s) referenced by the LR or SC are expected to be rare compared to scenarios where the intervening store may simply fall onto the same cache line.</p>
<h3 id="sec:memory:progress"></h3>
<p><img src="memory_06.svg" alt="image" /></p>
<p>The progress axiom ensures a minimal forward progress guarantee.
It ensures that stores from one hart will eventually be made visible to other harts in the system in a finite amount of time, and that loads from other harts will eventually be able to read those values (or successors thereof).
Without this rule, it would be legal, for example, for a spinlock to spin infinitely on a value, even with a store from another hart waiting to unlock the spinlock.</p>
<p>The progress axiom is intended not to impose any other notion of fairness, latency, or quality of service onto the harts in a RISC-V implementation.
Any stronger notions of fairness are up to the rest of the ISA and/or up to the platform and/or device to define and implement.</p>
<p>The forward progress axiom will in almost all cases be naturally satisfied by any standard cache coherence protocol.
Implementations with non-coherent caches may have to provide some other mechanism to ensure the eventual visibility of all stores (or successors thereof) to all harts.</p>
<h3 id="sec:memory:overlap">Overlapping-Address Orderings (Rules <a href="#ppo:-&gt;st" data-reference-type="ref" data-reference="ppo:-&gt;st">[ppo:-&gt;st]</a>–<a href="rvwmo.html#ppo:amoforward" data-reference-type="ref" data-reference="ppo:amoforward">[ppo:amoforward]</a>)</h3>
<p><img src="memory_07.svg" alt="image" /></p>
<p>Same-address orderings where the latter is a store are straightforward: a load or store can never be reordered with a later store to an overlapping memory location. From a microarchitecture perspective, generally speaking, it is difficult or impossible to undo a speculatively reordered store if the speculation turns out to be invalid, so such behavior is simply disallowed by the model.
Same-address orderings from a store to a later load, on the other hand, do not need to be enforced.
As discussed in Section <a href="memory.html#sec:memory:loadvalueaxiom" data-reference-type="ref" data-reference="sec:memory:loadvalueaxiom">1.3.2</a>, this reflects the observable behavior of implementations that forward values from buffered stores to later loads.</p>
<p>Same-address load-load ordering requirements are far more subtle.
The basic requirement is that a younger load must not return a value that is older than a value returned by an older load in the same hart to the same address. This is often known as “CoRR” (Coherence for Read-Read pairs), or as part of a broader “coherence” or “sequential consistency per location” requirement.
Some architectures in the past have relaxed same-address load-load ordering, but in hindsight this is generally considered to complicate the programming model too much, and so RVWMO requires CoRR ordering to be enforced.
However, because the global memory order corresponds to the order in which loads perform rather than the ordering of the values being returned, capturing CoRR requirements in terms of the global memory order requires a bit of indirection.</p>
<figure>
<img src="memory_08.svg" alt="Litmus test MP+fence.w.w+fri-rfi-addr (outcome permitted)" id="fig:litmus:frirfi" /><figcaption>Litmus test MP+fence.w.w+fri-rfi-addr (outcome permitted)<span label="fig:litmus:frirfi"></span></figcaption>
</figure>
<p>Consider the litmus test of Figure <a href="memory.html#fig:litmus:frirfi" data-reference-type="ref" data-reference="fig:litmus:frirfi">1.5</a>, which is one particular instance of the more general “fri-rfi” pattern.
The term “fri-rfi” refers to the sequence (d), (e), (f): (d) “from-reads” (i.e., reads from an earlier write than) (e) which is the same hart, and (f) reads from (e) which is in the same hart.</p>
<p>From a microarchitectural perspective, outcome <span>a0=1</span>, <span>a1=2</span>, <span>a2=0</span> is legal (as are various other less subtle outcomes). Intuitively, the following would produce the outcome in question:</p>
<ul>
<li><p>(d) stalls (for whatever reason; perhaps it’s stalled waiting for some other preceding instruction)</p></li>
<li><p>(e) executes and enters the store buffer (but does not yet drain to memory)</p></li>
<li><p>(f) executes and forwards from (e) in the store buffer</p></li>
<li><p>(g), (h), and (i) execute</p></li>
<li><p>(a) executes and drains to memory, (b) executes, and (c) executes and drains to memory</p></li>
<li><p>(d) unstalls and executes</p></li>
<li><p>(e) drains from the store buffer to memory</p></li>
</ul>
<p>This corresponds to a global memory order of (f), (i), (a), (c), (d), (e).
Note that even though (f) performs before (d), the value returned by (f) is newer than the value returned by (d).
Therefore, this execution is legal and does not violate the CoRR requirements.</p>
<p>Likewise, if two back-to-back loads return the values written by the same store, then they may also appear out-of-order in the global memory order without violating CoRR. Note that this is not the same as saying that the two loads return the same value, since two different stores may write the same value.</p>
<figure>
<img src="memory_09.svg" alt="Litmus test RSW (outcome permitted)" id="fig:litmus:rsw" /><figcaption>Litmus test RSW (outcome permitted)<span label="fig:litmus:rsw"></span></figcaption>
</figure>
<p>Consider the litmus test of Figure <a href="memory.html#fig:litmus:rsw" data-reference-type="ref" data-reference="fig:litmus:rsw">1.6</a>.
The outcome <span>a0=1</span>, <span>a1=<span class="math inline"><em>v</em></span></span>, <span>a2=<span class="math inline"><em>v</em></span></span>, <span>a3=0</span> (where <span class="math inline"><em>v</em></span> is some value written by another hart) can be observed by allowing (g) and (h) to be reordered. This might be done speculatively, and the speculation can be justified by the microarchitecture (e.g., by snooping for cache invalidations and finding none) because replaying (h) after (g) would return the value written by the same store anyway.
Hence assuming <span>a1</span> and <span>a2</span> would end up with the same value written by the same store anyway, (g) and (h) can be legally reordered.
The global memory order corresponding to this execution would be (h),(k),(a),(c),(d),(g).</p>
<p>Executions of the test in Figure <a href="memory.html#fig:litmus:rsw" data-reference-type="ref" data-reference="fig:litmus:rsw">1.6</a> in which <span>a1</span> does not equal <span>a2</span> do in fact require that (g) appears before (h) in the global memory order.
Allowing (h) to appear before (g) in the global memory order would in that case result in a violation of CoRR, because then (h) would return an older value than that returned by (g).
Therefore, PPO rule <a href="rvwmo.html#ppo:rdw" data-reference-type="ref" data-reference="ppo:rdw">[ppo:rdw]</a> forbids this CoRR violation from occurring.
As such, PPO rule <a href="rvwmo.html#ppo:rdw" data-reference-type="ref" data-reference="ppo:rdw">[ppo:rdw]</a> strikes a careful balance between enforcing CoRR in all cases while simultaneously being weak enough to permit “RSW” and “fri-rfi” patterns that commonly appear in real microarchitectures.</p>
<p>There is one more overlapping-address rule: PPO rule <a href="rvwmo.html#ppo:amoforward" data-reference-type="ref" data-reference="ppo:amoforward">[ppo:amoforward]</a> simply states that a value cannot be returned from an AMO or SC to a subsequent load until the AMO or SC has (in the case of the SC, successfully) performed globally.
This follows somewhat naturally from the conceptual view that both AMOs and SC instructions are meant to be performed atomically in memory.
However, notably, PPO rule <a href="rvwmo.html#ppo:amoforward" data-reference-type="ref" data-reference="ppo:amoforward">[ppo:amoforward]</a> states that hardware may not even non-speculatively forward the value being stored by an AMOSWAP to a subsequent load, even though for AMOSWAP that store value is not actually semantically dependent on the previous value in memory, as is the case for the other AMOs.
The same holds true even when forwarding from SC store values that are not semantically dependent on the value returned by the paired LR.</p>
<p>The three PPO rules above also apply when the memory accesses in question only overlap partially.
This can occur, for example, when accesses of different sizes are used to access the same object.
Note also that the base addresses of two overlapping memory operations need not necessarily be the same for two memory accesses to overlap.
When misaligned memory accesses are being used, the overlapping-address PPO rules apply to each of the component memory accesses independently.</p>
<h3 id="sec:mm:fence">Fences (Rule <a href="rvwmo.html#ppo:fence" data-reference-type="ref" data-reference="ppo:fence">[ppo:fence]</a>)</h3>
<p><img src="memory_10.svg" alt="image" /></p>
<p>By default, the FENCE instruction ensures that all memory accesses from instructions preceding the fence in program order (the “predecessor set”) appear earlier in the global memory order than memory accesses from instructions appearing after the fence in program order (the “successor set”).
However, fences can optionally further restrict the predecessor set and/or the successor set to a smaller set of memory accesses in order to provide some speedup.
Specifically, fences have PR, PW, SR, and SW bits which restrict the predecessor and/or successor sets.
The predecessor set includes loads (resp.stores) if and only if PR (resp.PW) is set.
Similarly, the successor set includes loads (resp.stores) if and only if SR (resp.SW) is set.</p>
<p>The FENCE encoding currently has nine non-trivial combinations of the four bits PR, PW, SR, and SW, plus one extra encoding FENCE.TSO which facilitates mapping of “acquire+release” or RVTSO semantics.
The remaining seven combinations have empty predecessor and/or successor sets and hence are no-ops.
Of the ten non-trivial options, only six are commonly used in practice:</p>
<ul>
<li><p>FENCE RW,RW</p></li>
<li><p>FENCE.TSO</p></li>
<li><p>FENCE RW,W</p></li>
<li><p>FENCE R,RW</p></li>
<li><p>FENCE R,R</p></li>
<li><p>FENCE W,W</p></li>
</ul>
<p>FENCE instructions using any other combination of PR, PW, SR, and SW are reserved. We strongly recommend that programmers stick to these six.
Other combinations may have unknown or unexpected interactions with the memory model.</p>
<p>Finally, we note that since RISC-V uses a multi-copy atomic memory model, programmers can reason about fences bits in a thread-local manner. There is no complex notion of “fence cumulativity” as found in memory models that are not multi-copy atomic.</p>
<h3 id="sec:memory:acqrel">Explicit Synchronization (Rules <a href="rvwmo.html#ppo:acquire" data-reference-type="ref" data-reference="ppo:acquire">[ppo:acquire]</a>–<a href="rvwmo.html#ppo:pair" data-reference-type="ref" data-reference="ppo:pair">[ppo:pair]</a>)</h3>
<p><img src="memory_11.svg" alt="image" /></p>
<p>An <span><em>acquire</em></span> operation, as would be used at the start of a critical section, requires all memory operations following the acquire in program order to also follow the acquire in the global memory order.
This ensures, for example, that all loads and stores inside the critical section are up to date with respect to the synchronization variable being used to protect it.
Acquire ordering can be enforced in one of two ways: with an acquire annotation, which enforces ordering with respect to just the synchronization variable itself, or with a FENCE R,RW, which enforces ordering with respect to all previous loads.</p>
<figure>
<img src="memory_12.svg" alt="A spinlock with atomics" /><figcaption>A spinlock with atomics</figcaption>
</figure>
<p><span id="fig:litmus:spinlock_atomics" label="fig:litmus:spinlock_atomics">[fig:litmus:spinlock_atomics]</span></p>
<p>Consider Figure <a href="memory.html#fig:litmus:spinlock_atomics" data-reference-type="ref" data-reference="fig:litmus:spinlock_atomics">[fig:litmus:spinlock_atomics]</a>.
Because this example uses <span><em>aq</em></span>, the loads and stores in the critical section are guaranteed to appear in the global memory order after the AMOSWAP used to acquire the lock. However, assuming <span>a0</span>, <span>a1</span>, and <span>a2</span> point to different memory locations, the loads and stores in the critical section may or may not appear after the “Arbitrary unrelated load” at the beginning of the example in the global memory order.</p>
<figure>
<img src="memory_13.svg" alt="A spinlock with fences" /><figcaption>A spinlock with fences</figcaption>
</figure>
<p><span id="fig:litmus:spinlock_fences" label="fig:litmus:spinlock_fences">[fig:litmus:spinlock_fences]</span></p>
<p>Now, consider the alternative in Figure <a href="memory.html#fig:litmus:spinlock_fences" data-reference-type="ref" data-reference="fig:litmus:spinlock_fences">[fig:litmus:spinlock_fences]</a>.
In this case, even though the AMOSWAP does not enforce ordering with an <span><em>aq</em></span> bit, the fence nevertheless enforces that the acquire AMOSWAP appears earlier in the global memory order than all loads and stores in the critical section.
Note, however, that in this case, the fence also enforces additional orderings: it also requires that the “Arbitrary unrelated load” at the start of the program appears earlier in the global memory order than the loads and stores of the critical section. (This particular fence does not, however, enforce any ordering with respect to the “Arbitrary unrelated store” at the start of the snippet.)
In this way, fence-enforced orderings are slightly coarser than orderings enforced by <span><em>.aq</em></span>.</p>
<p>Release orderings work exactly the same as acquire orderings, just in the opposite direction. Release semantics require all loads and stores preceding the release operation in program order to also precede the release operation in the global memory order.
This ensures, for example, that memory accesses in a critical section appear before the lock-releasing store in the global memory order. Just as for acquire semantics, release semantics can be enforced using release annotations or with a FENCE RW,W operation. Using the same examples, the ordering between the loads and stores in the critical section and the “Arbitrary unrelated store” at the end of the code snippet is enforced only by the FENCE RW,W in Figure <a href="memory.html#fig:litmus:spinlock_fences" data-reference-type="ref" data-reference="fig:litmus:spinlock_fences">[fig:litmus:spinlock_fences]</a>, not by the <span><em>rl</em></span> in Figure <a href="memory.html#fig:litmus:spinlock_atomics" data-reference-type="ref" data-reference="fig:litmus:spinlock_atomics">[fig:litmus:spinlock_atomics]</a>.</p>
<p>With RCpc annotations alone, store-release-to-load-acquire ordering is not enforced. This facilitates the porting of code written under the TSO and/or RCpc memory models.
To enforce store-release-to-load-acquire ordering, the code must use store-release-RCsc and load-acquire-RCsc operations so that PPO rule <a href="rvwmo.html#ppo:rcsc" data-reference-type="ref" data-reference="ppo:rcsc">[ppo:rcsc]</a> applies.
RCpc alone is sufficient for many use cases in C/C++ but is insufficient for many other use cases in C/C++, Java, and Linux, to name just a few examples; see Section <a href="memory.html#sec:memory:porting" data-reference-type="ref" data-reference="sec:memory:porting">1.5</a> for details.</p>
<p>PPO rule <a href="rvwmo.html#ppo:pair" data-reference-type="ref" data-reference="ppo:pair">[ppo:pair]</a> indicates that an SC must appear after its paired LR in the global memory order.
This will follow naturally from the common use of LR/SC to perform an atomic read-modify-write operation due to the inherent data dependency.
However, PPO rule <a href="rvwmo.html#ppo:pair" data-reference-type="ref" data-reference="ppo:pair">[ppo:pair]</a> also applies even when the value being stored does not syntactically depend on the value returned by the paired LR.</p>
<p>Lastly, we note that just as with fences, programmers need not worry about “cumulativity” when analyzing ordering annotations.</p>
<h3 id="sec:memory:dependencies">Syntactic Dependencies (Rules <a href="rvwmo.html#ppo:addr" data-reference-type="ref" data-reference="ppo:addr">[ppo:addr]</a>–<a href="rvwmo.html#ppo:ctrl" data-reference-type="ref" data-reference="ppo:ctrl">[ppo:ctrl]</a>)</h3>
<p><img src="memory_14.svg" alt="image" /></p>
<p>Dependencies from a load to a later memory operation in the same hart are respected by the RVWMO memory model.
The Alpha memory model was notable for choosing <span><em>not</em></span> to enforce the ordering of such dependencies, but most modern hardware and software memory models consider allowing dependent instructions to be reordered too confusing and counterintuitive.
Furthermore, modern code sometimes intentionally uses such dependencies as a particularly lightweight ordering enforcement mechanism.</p>
<p>The terms in Section <a href="rvwmo.html#sec:memorymodel:dependencies" data-reference-type="ref" data-reference="sec:memorymodel:dependencies">[sec:memorymodel:dependencies]</a> work as follows.
Instructions are said to carry dependencies from their source register(s) to their destination register(s) whenever the value written into each destination register is a function of the source register(s).
For most instructions, this means that the destination register(s) carry a dependency from all source register(s).
However, there are a few notable exceptions.
In the case of memory instructions, the value written into the destination register ultimately comes from the memory system rather than from the source register(s) directly, and so this breaks the chain of dependencies carried from the source register(s).
In the case of unconditional jumps, the value written into the destination register comes from the current <span>pc</span> (which is never considered a source register by the memory model), and so likewise, JALR (the only jump with a source register) does not carry a dependency from <span><em>rs1</em></span> to <span><em>rd</em></span>.</p>
<p>(a) fadd f3,f1,f2
(b) fadd f6,f4,f5
(c) csrrs a0,fflags,x0</p>
<figure>
<img src="memory_15.svg" alt="(c) has a syntactic dependency on both (a) and (b) via fflags, a destination register that both (a) and (b) implicitly accumulate into" id="fig:litmus:fflags" /><figcaption>(c) has a syntactic dependency on both (a) and (b) via <span>fflags</span>, a destination register that both (a) and (b) implicitly accumulate into<span label="fig:litmus:fflags"></span></figcaption>
</figure>
<p>The notion of accumulating into a destination register rather than writing into it reflects the behavior of CSRs such as <span>fflags</span>.
In particular, an accumulation into a register does not clobber any previous writes or accumulations into the same register.
For example, in Figure <a href="memory.html#fig:litmus:fflags" data-reference-type="ref" data-reference="fig:litmus:fflags">1.7</a>, (c) has a syntactic dependency on both (a) and (b).</p>
<p>Like other modern memory models, the RVWMO memory model uses syntactic rather than semantic dependencies.
In other words, this definition depends on the identities of the
registers being accessed by different instructions, not the actual
contents of those registers. This means that an address, control, or
data dependency must be enforced even if the calculation could seemingly
be “optimized away”.
This choice ensures that RVWMO remains compatible with code that uses these false syntactic dependencies as a lightweight ordering mechanism.</p>
<p>ld a1,0(s0)
xor a2,a1,a1
add s1,s1,a2
ld a5,0(s1)</p>
<figure>
<img src="memory_16.svg" alt="A syntactic address dependency" id="fig:litmus:address" /><figcaption>A syntactic address dependency<span label="fig:litmus:address"></span></figcaption>
</figure>
<p>For example, there is a syntactic address
dependency from the memory operation generated by the first instruction to the memory operation generated by the last instruction in
Figure <a href="memory.html#fig:litmus:address" data-reference-type="ref" data-reference="fig:litmus:address">1.8</a>, even though <span>a1</span> XOR <span>a1</span> is zero and
hence has no effect on the address accessed by the second load.</p>
<p>The benefit of using dependencies as a lightweight synchronization mechanism is that the ordering enforcement requirement is limited only to the specific two instructions in question.
Other non-dependent instructions may be freely-reordered by aggressive implementations.
One alternative would be to use a load-acquire, but this would enforce ordering for the first load with respect to <span><em>all</em></span> subsequent instructions.
Another would be to use a FENCE R,R, but this would include all previous and all subsequent loads, making this option more expensive.</p>
<p>lw x1,0(x2)
bne x1,x0,next
sw x3,0(x4)
next: sw x5,0(x6)</p>
<figure>
<img src="memory_17.svg" alt="A syntactic control dependency" id="fig:litmus:control1" /><figcaption>A syntactic control dependency<span label="fig:litmus:control1"></span></figcaption>
</figure>
<p>Control dependencies behave differently from address and data dependencies in the sense that a control dependency always extends to all instructions following the original target in program order.
Consider Figure <a href="memory.html#fig:litmus:control1" data-reference-type="ref" data-reference="fig:litmus:control1">1.9</a>: the instruction at <span>next</span> will always execute, but the memory operation generated by that last instruction nevertheless still has a control dependency from the memory operation generated by the first instruction.</p>
<p>lw x1,0(x2)
bne x1,x0,next
next: sw x3,0(x4)</p>
<figure>
<img src="memory_18.svg" alt="Another syntactic control dependency" id="fig:litmus:control2" /><figcaption>Another syntactic control dependency<span label="fig:litmus:control2"></span></figcaption>
</figure>
<p>Likewise, consider Figure <a href="memory.html#fig:litmus:control2" data-reference-type="ref" data-reference="fig:litmus:control2">1.10</a>.
Even though both branch outcomes have the same target, there is still a control dependency from the memory operation generated by the first instruction in this snippet to the memory operation generated by the last instruction.
This definition of control dependency is subtly stronger than what might be seen in other contexts (e.g., C++), but it conforms with standard definitions of control dependencies in the literature.</p>
<p>Notably, PPO rules <a href="rvwmo.html#ppo:addr" data-reference-type="ref" data-reference="ppo:addr">[ppo:addr]</a>–<a href="rvwmo.html#ppo:ctrl" data-reference-type="ref" data-reference="ppo:ctrl">[ppo:ctrl]</a> are also intentionally designed to respect dependencies that originate from the output of a successful store-conditional instruction.
Typically, an SC instruction will be followed by a conditional branch checking whether the outcome was successful; this implies that there will be a control dependency from the store operation generated by the SC instruction to any memory operations following the branch.
PPO rule <a href="rvwmo.html#ppo:ctrl" data-reference-type="ref" data-reference="ppo:ctrl">[ppo:ctrl]</a> in turn implies that any subsequent store operations will appear later in the global memory order than the store operation generated by the SC.
However, since control, address, and data dependencies are defined over memory operations, and since an unsuccessful SC does not generate a memory operation, no order is enforced between unsuccessful SC and its dependent instructions.
Moreover, since SC is defined to carry dependencies from its source registers to <span><em>rd</em></span> only when the SC is successful, an unsuccessful SC has no effect on the global memory order.</p>
<figure>
<img src="memory_19.svg" alt="A variant of the LB litmus test (outcome forbidden)" id="fig:litmus:successdeps" /><figcaption>A variant of the LB litmus test (outcome forbidden)<span label="fig:litmus:successdeps"></span></figcaption>
</figure>
<p>In addition, the choice to respect dependencies originating at store-conditional instructions ensures that certain out-of-thin-air-like behaviors will be prevented.
Consider Figure <a href="memory.html#fig:litmus:successdeps" data-reference-type="ref" data-reference="fig:litmus:successdeps">1.11</a>.
Suppose a hypothetical implementation could occasionally make some early guarantee that a store-conditional operation will succeed.
In this case, (c) could return 0 to <span>a2</span> early (before actually executing), allowing the sequence (d), (e), (f), (a), and then (b) to execute, and then (c) might execute (successfully) only at that point.
This would imply that (c) writes its own success value to <span>0(s1)</span>!
Fortunately, this situation and others like it are prevented by the fact that RVWMO respects dependencies originating at the stores generated by successful SC instructions.</p>
<p>We also note that syntactic dependencies between instructions only have any force when they take the form of a syntactic address, control, and/or data dependency.
For example: a syntactic dependency between two “F” instructions via one of the “accumulating CSRs” in Section <a href="dep-table.html#sec:source-dest-regs" data-reference-type="ref" data-reference="sec:source-dest-regs">[sec:source-dest-regs]</a> does <span><em>not</em></span> imply that the two “F” instructions must be executed in order.
Such a dependency would only serve to ultimately set up later a dependency from both “F” instructions to a later CSR instruction accessing the CSR flag in question.</p>
<h3 id="sec:memory:ppopipeline">Pipeline Dependencies (Rules <a href="rvwmo.html#ppo:addrdatarfi" data-reference-type="ref" data-reference="ppo:addrdatarfi">[ppo:addrdatarfi]</a>–<a href="rvwmo.html#ppo:addrpo" data-reference-type="ref" data-reference="ppo:addrpo">[ppo:addrpo]</a>)</h3>
<p><img src="memory_20.svg" alt="image" /></p>
<figure>
<img src="memory_21.svg" alt="Because of PPO rule [ppo:addrdatarfi] and the data dependency from (d) to (e), (d) must also precede (f) in the global memory order (outcome forbidden)" id="fig:litmus:addrdatarfi" /><figcaption>Because of PPO rule <a href="rvwmo.html#ppo:addrdatarfi" data-reference-type="ref" data-reference="ppo:addrdatarfi">[ppo:addrdatarfi]</a> and the data dependency from (d) to (e), (d) must also precede (f) in the global memory order (outcome forbidden)<span label="fig:litmus:addrdatarfi"></span></figcaption>
</figure>
<p>PPO rules <a href="rvwmo.html#ppo:addrdatarfi" data-reference-type="ref" data-reference="ppo:addrdatarfi">[ppo:addrdatarfi]</a> and <a href="rvwmo.html#ppo:addrpo" data-reference-type="ref" data-reference="ppo:addrpo">[ppo:addrpo]</a> reflect behaviors of almost all real processor pipeline implementations.
Rule <a href="rvwmo.html#ppo:addrdatarfi" data-reference-type="ref" data-reference="ppo:addrdatarfi">[ppo:addrdatarfi]</a> states that a load cannot forward from a store until the address and data for that store are known.
Consider Figure <a href="memory.html#fig:litmus:addrdatarfi" data-reference-type="ref" data-reference="fig:litmus:addrdatarfi">1.12</a>:
(f) cannot be executed until the data for (e) has been resolved, because (f) must return the value written by (e) (or by something even later in the global memory order), and the old value must not be clobbered by the writeback of (e) before (d) has had a chance to perform.
Therefore, (f) will never perform before (d) has performed.</p>
<figure>
<img src="memory_22.svg" alt="Because of the extra store between (e) and (g), (d) no longer necessarily precedes (g) (outcome permitted)" /><figcaption>Because of the extra store between (e) and (g), (d) no longer necessarily precedes (g) (outcome permitted)</figcaption>
</figure>
<p><span id="fig:litmus:addrdatarfi_no" label="fig:litmus:addrdatarfi_no">[fig:litmus:addrdatarfi_no]</span></p>
<p>If there were another store to the same address in between (e) and (f), as in Figure <a href="memory.html#fig:litmus:addrdatarfi_no" data-reference-type="ref" data-reference="fig:litmus:addrdatarfi_no">[fig:litmus:addrdatarfi_no]</a>, then (f) would no longer be dependent on the data of (e) being resolved, and hence the dependency of (f) on (d), which produces the data for (e), would be broken.</p>
<p>Rule <a href="rvwmo.html#ppo:addrpo" data-reference-type="ref" data-reference="ppo:addrpo">[ppo:addrpo]</a> makes a similar observation to the previous rule: a store cannot be performed at memory until all previous loads that might access the same address have themselves been performed.
Such a load must appear to execute before the store, but it cannot do so if the store were to overwrite the value in memory before the load had a chance to read the old value.
Likewise, a store generally cannot be performed until it is known that preceding instructions will not cause an exception due to failed address resolution, and in this sense, rule <a href="rvwmo.html#ppo:addrpo" data-reference-type="ref" data-reference="ppo:addrpo">[ppo:addrpo]</a> can be seen as somewhat of a special case of rule <a href="rvwmo.html#ppo:ctrl" data-reference-type="ref" data-reference="ppo:ctrl">[ppo:ctrl]</a>.</p>
<figure>
<img src="memory_23.svg" alt="Because of the address dependency from (d) to (e), (d) also precedes (f) (outcome forbidden)" id="fig:litmus:addrpo" /><figcaption>Because of the address dependency from (d) to (e), (d) also precedes (f) (outcome forbidden)<span label="fig:litmus:addrpo"></span></figcaption>
</figure>
<p>Consider Figure <a href="memory.html#fig:litmus:addrpo" data-reference-type="ref" data-reference="fig:litmus:addrpo">1.13</a>:
(f) cannot be executed until the address for (e) is resolved, because it may turn out that the addresses match; i.e., that <span>a1=s0</span>. Therefore, (f) cannot be sent to memory before (d) has executed and confirmed whether the addresses do indeed overlap.</p>
<h2 id="beyond-main-memory">Beyond Main Memory</h2>
<p>RVWMO does not currently attempt to formally describe how FENCE.I, SFENCE.VMA, I/O fences, and PMAs behave.
All of these behaviors will be described by future formalizations.
In the meantime, the behavior of FENCE.I is described in Section <a href="rv32.html#sec:fence" data-reference-type="ref" data-reference="sec:fence">[sec:fence]</a>, the behavior of SFENCE.VMA is described in the RISC-V Instruction Set Privileged Architecture Manual, and the behavior of I/O fences and the effects of PMAs are described below.</p>
<h3 id="coherence-and-cacheability">Coherence and Cacheability</h3>
<p>The RISC-V Privileged ISA defines Physical Memory Attributes (PMAs) which specify, among other things, whether portions of the address space are coherent and/or cacheable.
See the RISC-V Privileged ISA Specification for the complete details.
Here, we simply discuss how the various details in each PMA relate to the memory model:</p>
<ul>
<li><p>Main memory vs.I/O, and I/O memory ordering PMAs: the memory model as defined applies to main memory regions. I/O ordering is discussed below.</p></li>
<li><p>Supported access types and atomicity PMAs: the memory model is simply applied on top of whatever primitives each region supports.</p></li>
<li><p>Cacheability PMAs: the cacheability PMAs in general do not affect the memory model. Non-cacheable regions may have more restrictive behavior than cacheable regions, but the set of allowed behaviors does not change regardless. However, some platform-specific and/or device-specific cacheability settings may differ.</p></li>
<li><p>Coherence PMAs: The memory consistency model for memory regions marked as non-coherent in PMAs is currently platform-specific and/or device-specific: the load-value axiom, the atomicity axiom, and the progress axiom all may be violated with non-coherent memory. Note however that coherent memory does not require a hardware cache coherence protocol. The RISC-V Privileged ISA Specification suggests that hardware-incoherent regions of main memory are discouraged, but the memory model is compatible with hardware coherence, software coherence, implicit coherence due to read-only memory, implicit coherence due to only one agent having access, or otherwise.</p></li>
<li><p>Idempotency PMAs: Idempotency PMAs are used to specify memory regions for which loads and/or stores may have side effects, and this in turn is used by the microarchitecture to determine, e.g., whether prefetches are legal. This distinction does not affect the memory model.</p></li>
</ul>
<h3 id="io-ordering">I/O Ordering</h3>
<p>For I/O, the load value axiom and atomicity axiom in general do not apply, as both reads and writes might have device-specific side effects and may return values other than the value “written” by the most recent store to the same address.
Nevertheless, the following preserved program order rules still generally apply for accesses to I/O memory:
memory access <span class="math inline"><em>a</em></span> precedes memory access <span class="math inline"><em>b</em></span> in global memory order if <span class="math inline"><em>a</em></span> precedes <span class="math inline"><em>b</em></span> in program order and one or more of the following holds:</p>
<ol>
<li><p><span class="math inline"><em>a</em></span> precedes <span class="math inline"><em>b</em></span> in preserved program order as defined in Chapter <a href="rvwmo.html#ch:memorymodel" data-reference-type="ref" data-reference="ch:memorymodel">[ch:memorymodel]</a>, with the exception that acquire and release ordering annotations apply only from one memory operation to another memory operation and from one I/O operation to another I/O operation, but not from a memory operation to an I/O nor vice versa</p></li>
<li><p><span class="math inline"><em>a</em></span> and <span class="math inline"><em>b</em></span> are accesses to overlapping addresses in an I/O region</p></li>
<li><p><span class="math inline"><em>a</em></span> and <span class="math inline"><em>b</em></span> are accesses to the same strongly-ordered I/O region</p></li>
<li><p><span class="math inline"><em>a</em></span> and <span class="math inline"><em>b</em></span> are accesses to I/O regions, and the channel associated with the I/O region accessed by either <span class="math inline"><em>a</em></span> or <span class="math inline"><em>b</em></span> is channel 1</p></li>
<li><p><span class="math inline"><em>a</em></span> and <span class="math inline"><em>b</em></span> are accesses to I/O regions associated with the same channel (except for channel 0)</p></li>
</ol>
<p>Note that the FENCE instruction distinguishes between main memory operations and I/O operations in its predecessor and successor sets.
To enforce ordering between I/O operations and main memory operations, code must use a FENCE with PI, PO, SI, and/or SO, plus PR, PW, SR, and/or SW.
For example, to enforce ordering between a write to main memory and an I/O write to a device register, a FENCE W,O or stronger is needed.</p>
<p>sd t0, 0(a0)
fence w,o
sd a0, 0(a1)</p>
<figure>
<img src="memory_24.svg" alt="Ordering memory and I/O accesses" id="fig:litmus:wo" /><figcaption>Ordering memory and I/O accesses<span label="fig:litmus:wo"></span></figcaption>
</figure>
<p>When a fence is in fact used, implementations must assume that the device may attempt to access memory immediately after receiving the MMIO signal, and subsequent memory accesses from that device to memory must observe the effects of all accesses ordered prior to that MMIO operation.
In other words, in Figure <a href="memory.html#fig:litmus:wo" data-reference-type="ref" data-reference="fig:litmus:wo">1.14</a>, suppose <span>0(a0)</span> is in main memory and <span>0(a1)</span> is the address of a device register in I/O memory.
If the device accesses <span>0(a0)</span> upon receiving the MMIO write, then that load must conceptually appear after the first store to <span>0(a0)</span> according to the rules of the RVWMO memory model.
In some implementations, the only way to ensure this will be to require that the first store does in fact complete before the MMIO write is issued.
Other implementations may find ways to be more aggressive, while others still may not need to do anything different at all for I/O and main memory accesses.
Nevertheless, the RVWMO memory model does not distinguish between these options; it simply provides an implementation-agnostic mechanism to specify the orderings that must be enforced.</p>
<p>Many architectures include separate notions of “ordering” and “completion” fences, especially as it relates to I/O (as opposed to regular main memory).
Ordering fences simply ensure that memory operations stay in order, while completion fences ensure that predecessor accesses have all completed before any successors are made visible.
RISC-V does not explicitly distinguish between ordering and completion fences.
Instead, this distinction is simply inferred from different uses of the FENCE bits.</p>
<p>For implementations that conform to the RISC-V Unix Platform Specification, I/O devices and DMA operations are required to access memory coherently and via strongly-ordered I/O channels.
Therefore, accesses to regular main memory regions that are concurrently accessed by external devices can also use the standard synchronization mechanisms.
Implementations that do not conform to the Unix Platform Specification and/or in which devices do not access memory coherently will need to use mechanisms (which are currently platform-specific or device-specific) to enforce coherency.</p>
<p>I/O regions in the address space should be considered non-cacheable regions in the PMAs for those regions. Such regions can be considered coherent by the PMA if they are not cached by any agent.</p>
<p>The ordering guarantees in this section may not apply beyond a platform-specific boundary between the RISC-V cores and the device. In particular, I/O accesses sent across an external bus (e.g., PCIe) may be reordered before they reach their ultimate destination. Ordering must be enforced in such situations according to the platform-specific rules of those external devices and buses.</p>
<h2 id="sec:memory:porting">Code Porting and Mapping Guidelines</h2>
<figure>
<img src="memory_25.svg" alt="Mappings from TSO operations to RISC-V operations" id="tab:tsomappings" /><figcaption>Mappings from TSO operations to RISC-V operations<span label="tab:tsomappings"></span></figcaption>
</figure>
<p>Table <a href="memory.html#tab:tsomappings" data-reference-type="ref" data-reference="tab:tsomappings">1.15</a> provides a mapping from TSO memory operations onto RISC-V memory instructions.
Normal x86 loads and stores are all inherently acquire-RCpc and release-RCpc operations: TSO enforces all load-load, load-store, and store-store ordering by default.
Therefore, under RVWMO, all TSO loads must be mapped onto a load followed by FENCE R,RW, and all TSO stores must be mapped onto FENCE RW,W followed by a store.
TSO atomic read-modify-writes and x86 instructions using the LOCK prefix are fully-ordered and can be implemented either via an AMO with both <span><em>aq</em></span> and <span><em>rl</em></span> set, or via an LR with <span><em>aq</em></span> set, the arithmetic operation in question, an SC with both <span><em>aq</em></span> and <span><em>rl</em></span> set, and a conditional branch checking the success condition.
In the latter case, the <span><em>rl</em></span> annotation on the LR turns out (for non-obvious reasons) to be redundant and can be omitted.</p>
<p>Alternatives to Table <a href="memory.html#tab:tsomappings" data-reference-type="ref" data-reference="tab:tsomappings">1.15</a> are also possible.
A TSO store can be mapped onto AMOSWAP with <span><em>rl</em></span> set.
However, since RVWMO PPO Rule <a href="rvwmo.html#ppo:amoforward" data-reference-type="ref" data-reference="ppo:amoforward">[ppo:amoforward]</a> forbids forwarding of values from AMOs to subsequent loads, the use of AMOSWAP for stores may negatively affect performance.
A TSO load can be mapped using LR with <span><em>aq</em></span> set: all such LR instructions will be unpaired, but that fact in and of itself does not preclude the use of LR for loads.
However, again, this mapping may also negatively affect performance if it puts more pressure on the reservation mechanism than was originally intended.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Power Operation</th>
<th style="text-align: left;">RVWMO Mapping</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Load</td>
<td style="text-align: left;">l{b|h|w|d}</td>
</tr>
<tr class="even">
<td style="text-align: left;">Load-Reserve</td>
<td style="text-align: left;">lr.{w|d}</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Store</td>
<td style="text-align: left;">s{b|h|w|d}</td>
</tr>
<tr class="even">
<td style="text-align: left;">Store-Conditional</td>
<td style="text-align: left;">sc.{w|d}</td>
</tr>
<tr class="odd">
<td style="text-align: left;">lwsync</td>
<td style="text-align: left;">fence.tso</td>
</tr>
<tr class="even">
<td style="text-align: left;">sync</td>
<td style="text-align: left;">fence rw,rw</td>
</tr>
<tr class="odd">
<td style="text-align: left;">isync</td>
<td style="text-align: left;">fence.i; fence r,r</td>
</tr>
</tbody>
</table>
<p>Table <a href="memory.html#tab:powermappings" data-reference-type="ref" data-reference="tab:powermappings">[tab:powermappings]</a> provides a mapping from Power memory operations onto RISC-V memory instructions.
Power ISYNC maps on RISC-V to a FENCE.I followed by a FENCE R,R; the latter fence is needed because ISYNC is used to define a “control+control fence” dependency that is not present in RVWMO.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">ARM Operation</th>
<th style="text-align: left;">RVWMO Mapping</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Load</td>
<td style="text-align: left;">l{b|h|w|d}</td>
</tr>
<tr class="even">
<td style="text-align: left;">Load-Acquire</td>
<td style="text-align: left;">fence rw, rw; l{b|h|w|d}; fence r,rw</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Load-Exclusive</td>
<td style="text-align: left;">lr.{w|d}</td>
</tr>
<tr class="even">
<td style="text-align: left;">Load-Acquire-Exclusive</td>
<td style="text-align: left;">lr.{w|d}.aqrl</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Store</td>
<td style="text-align: left;">s{b|h|w|d}</td>
</tr>
<tr class="even">
<td style="text-align: left;">Store-Release</td>
<td style="text-align: left;">fence rw,w; s{b|h|w|d}</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Store-Exclusive</td>
<td style="text-align: left;">sc.{w|d}</td>
</tr>
<tr class="even">
<td style="text-align: left;">Store-Release-Exclusive</td>
<td style="text-align: left;">sc.{w|d}.rl</td>
</tr>
<tr class="odd">
<td style="text-align: left;">dmb</td>
<td style="text-align: left;">fence rw,rw</td>
</tr>
<tr class="even">
<td style="text-align: left;">dmb.ld</td>
<td style="text-align: left;">fence r,rw</td>
</tr>
<tr class="odd">
<td style="text-align: left;">dmb.st</td>
<td style="text-align: left;">fence w,w</td>
</tr>
<tr class="even">
<td style="text-align: left;">isb</td>
<td style="text-align: left;">fence.i; fence r,r</td>
</tr>
</tbody>
</table>
<p>Table <a href="memory.html#tab:armmappings" data-reference-type="ref" data-reference="tab:armmappings">[tab:armmappings]</a> provides a mapping from ARM memory operations onto RISC-V memory instructions.
Since RISC-V does not currently have plain load and store opcodes with <span><em>aq</em></span> or <span><em>rl</em></span> annotations, ARM load-acquire and store-release operations should be mapped using fences instead.
Furthermore, in order to enforce store-release-to-load-acquire ordering, there must be a FENCE RW,RW between the store-release and load-acquire; Table <a href="memory.html#tab:armmappings" data-reference-type="ref" data-reference="tab:armmappings">[tab:armmappings]</a> enforces this by always placing the fence in front of each acquire operation.
ARM load-exclusive and store-exclusive instructions can likewise map onto their RISC-V LR and SC equivalents, but instead of placing a FENCE RW,RW in front of an LR with <span><em>aq</em></span> set, we simply also set <span><em>rl</em></span> instead.
ARM ISB maps on RISC-V to FENCE.I followed by FENCE R,R similarly to how ISYNC maps for Power.</p>
<figure>
<img src="memory_26.svg" alt="Mappings from Linux memory primitives to RISC-V primitives. Other constructs (such as spinlocks) should follow accordingly. Platforms or devices with non-coherent DMA may need additional synchronization (such as cache flush or invalidate mechanisms); currently any such extra synchronization will be device-specific." id="tab:linuxmappings" /><figcaption>Mappings from Linux memory primitives to RISC-V primitives. Other constructs (such as spinlocks) should follow accordingly. Platforms or devices with non-coherent DMA may need additional synchronization (such as cache flush or invalidate mechanisms); currently any such extra synchronization will be device-specific.<span label="tab:linuxmappings"></span></figcaption>
</figure>
<p>Table <a href="memory.html#tab:linuxmappings" data-reference-type="ref" data-reference="tab:linuxmappings">1.16</a> provides a mapping of Linux memory ordering macros onto RISC-V memory instructions.
The Linux fences <span>dma_rmb()</span> and <span>dma_wmb()</span> map onto FENCE R,R and FENCE W,W, respectively, since the RISC-V Unix Platform requires coherent DMA, but would be mapped onto FENCE RI,RI and FENCE WO,WO, respectively, on a platform with non-coherent DMA.
Platforms with non-coherent DMA may also require a mechanism by which cache lines can be flushed and/or invalidated.
Such mechanisms will be device-specific and/or standardized in a future extension to the ISA.</p>
<p>The Linux mappings for release operations may seem stronger than necessary, but these mappings are needed to cover some cases in which Linux requires stronger orderings than the more intuitive mappings would provide.
In particular, as of the time this text is being written, Linux is actively debating whether to require load-load, load-store, and store-store orderings between accesses in one critical section and accesses in a subsequent critical section in the same hart and protected by the same synchronization object.
Not all combinations of FENCE RW,W/FENCE R,RW mappings with <span><em>aq</em></span>/<span><em>rl</em></span> mappings combine to provide such orderings.
There are a few ways around this problem, including:</p>
<ol>
<li><p>Always use FENCE RW,W/FENCE R,RW, and never use <span><em>aq</em></span>/<span><em>rl</em></span>. This suffices but is undesirable, as it defeats the purpose of the <span><em>aq</em></span>/<span><em>rl</em></span> modifiers.</p></li>
<li><p>Always use <span><em>aq</em></span>/<span><em>rl</em></span>, and never use FENCE RW,W/FENCE R,RW. This does not currently work due to the lack of load and store opcodes with <span><em>aq</em></span> and <span><em>rl</em></span> modifiers.</p></li>
<li><p>Strengthen the mappings of release operations such that they would enforce sufficient orderings in the presence of either type of acquire mapping. This is the currently-recommended solution, and the one shown in Table <a href="memory.html#tab:linuxmappings" data-reference-type="ref" data-reference="tab:linuxmappings">1.16</a>.</p></li>
</ol>
<figure>
<img src="memory_27.svg" alt="Orderings between critical sections in Linux" /><figcaption>Orderings between critical sections in Linux</figcaption>
</figure>
<p><span id="fig:litmus:lkmm_ll" label="fig:litmus:lkmm_ll">[fig:litmus:lkmm_ll]</span></p>
<p>For example, the critical section ordering rule currently being debated by the Linux community would require (a) to be ordered before (e) in Figure <a href="memory.html#fig:litmus:lkmm_ll" data-reference-type="ref" data-reference="fig:litmus:lkmm_ll">[fig:litmus:lkmm_ll]</a>.
If that will indeed be required, then it would be insufficient for (b) to map as FENCE RW,W.
That said, these mappings are subject to change as the Linux Kernel Memory Model evolves.</p>
<figure>
<img src="memory_28.svg" alt="Mappings from C/C++ primitives to RISC-V primitives." id="tab:c11mappings" /><figcaption>Mappings from C/C++ primitives to RISC-V primitives.<span label="tab:c11mappings"></span></figcaption>
</figure>
<figure>
<img src="memory_29.svg" alt="Hypothetical mappings from C/C++ primitives to RISC-V primitives, if native load-acquire and store-release opcodes are introduced." /><figcaption>Hypothetical mappings from C/C++ primitives to RISC-V primitives, if native load-acquire and store-release opcodes are introduced.</figcaption>
</figure>
<p><span id="tab:c11mappings_hypothetical" label="tab:c11mappings_hypothetical">[tab:c11mappings_hypothetical]</span></p>
<p>Table <a href="memory.html#tab:c11mappings" data-reference-type="ref" data-reference="tab:c11mappings">1.17</a> provides a mapping of C11/C++11 atomic operations onto RISC-V memory instructions.
If load and store opcodes with <span><em>aq</em></span> and <span><em>rl</em></span> modifiers are introduced, then the mappings in Table <a href="memory.html#tab:c11mappings_hypothetical" data-reference-type="ref" data-reference="tab:c11mappings_hypothetical">[tab:c11mappings_hypothetical]</a> will suffice.
Note however that the two mappings only interoperate correctly if <span>atomic_&lt;op&gt;(memory_order_seq_cst)</span> is mapped using an LR that has both <span><em>aq</em></span> and <span><em>rl</em></span> set.</p>
<p>Any AMO can be emulated by an LR/SC pair, but care must be taken to ensure that any PPO orderings that originate from the LR are also made to originate from the SC, and that any PPO orderings that terminate at the SC are also made to terminate at the LR.
For example, the LR must also be made to respect any data dependencies that the AMO has, given that load operations do not otherwise have any notion of a data dependency.
Likewise, the effect a FENCE R,R elsewhere in the same hart must also be made to apply to the SC, which would not otherwise respect that fence.
The emulator may achieve this effect by simply mapping AMOs onto <span>lr.aq; &lt;op&gt;; sc.aqrl</span>, matching the mapping used elsewhere for fully-ordered atomics.</p>
<h2 id="implementation-guidelines">Implementation Guidelines</h2>
<p>The RVWMO and RVTSO memory models by no means preclude microarchitectures from employing sophisticated speculation techniques or other forms of optimization in order to deliver higher performance.
The models also do not impose any requirement to use any one particular cache hierarchy, nor even to use a cache coherence protocol at all.
Instead, these models only specify the behaviors that can be exposed to software.
Microarchitectures are free to use any pipeline design, any coherent or non-coherent cache hierarchy, any on-chip interconnect, etc., as long as the design only admits executions that satisfy the memory model rules.
That said, to help people understand the actual implementations of the memory model, in this section we provide some guidelines on how architects and programmers should interpret the models’ rules.</p>
<p>Both RVWMO and RVTSO are multi-copy atomic (or “other-multi-copy-atomic”): any store value that is visible to a hart other than the one that originally issued it must also be conceptually visible to all other harts in the system.
In other words, harts may forward from their own previous stores before those stores have become globally visible to all harts, but no early inter-hart forwarding is permitted.
Multi-copy atomicity may be enforced in a number of ways.
It might hold inherently due to the physical design of the caches and store buffers, it may be enforced via a single-writer/multiple-reader cache coherence protocol, or it might hold due to some other mechanism.</p>
<p>Although multi-copy atomicity does impose some restrictions on the microarchitecture, it is one of the key properties keeping the memory model from becoming extremely complicated.
For example, a hart may not legally forward a value from a neighbor hart’s private store buffer (unless of course it is done in such a way that no new illegal behaviors become architecturally visible).
Nor may a cache coherence protocol forward a value from one hart to another until the coherence protocol has invalidated all older copies from other caches.
Of course, microarchitectures may (and high-performance implementations likely will) violate these rules under the covers through speculation or other optimizations, as long as any non-compliant behaviors are not exposed to the programmer.</p>
<p>As a rough guideline for interpreting the PPO rules in RVWMO, we expect the following from the software perspective:</p>
<ul>
<li><p>programmers will use PPO rules <a href="#ppo:-&gt;st" data-reference-type="ref" data-reference="ppo:-&gt;st">[ppo:-&gt;st]</a> and <a href="rvwmo.html#ppo:fence" data-reference-type="ref" data-reference="ppo:fence">[ppo:fence]</a>–<a href="rvwmo.html#ppo:pair" data-reference-type="ref" data-reference="ppo:pair">[ppo:pair]</a> regularly and actively.</p></li>
<li><p>expert programmers will use PPO rules <a href="rvwmo.html#ppo:addr" data-reference-type="ref" data-reference="ppo:addr">[ppo:addr]</a>–<a href="rvwmo.html#ppo:ctrl" data-reference-type="ref" data-reference="ppo:ctrl">[ppo:ctrl]</a> to speed up critical paths of important data structures.</p></li>
<li><p>even expert programmers will rarely if ever use PPO rules <a href="rvwmo.html#ppo:rdw" data-reference-type="ref" data-reference="ppo:rdw">[ppo:rdw]</a>–<a href="rvwmo.html#ppo:amoforward" data-reference-type="ref" data-reference="ppo:amoforward">[ppo:amoforward]</a> and <a href="rvwmo.html#ppo:addrdatarfi" data-reference-type="ref" data-reference="ppo:addrdatarfi">[ppo:addrdatarfi]</a>–<a href="rvwmo.html#ppo:addrpo" data-reference-type="ref" data-reference="ppo:addrpo">[ppo:addrpo]</a> directly. These are included to facilitate common microarchitectural optimizations (rule <a href="#ppo:rdw" data-reference-type="ref" data-reference="ppo:rdw">[ppo:rdw]</a>) and the operational formal modeling approach (rules <a href="#ppo:amoforward" data-reference-type="ref" data-reference="ppo:amoforward">[ppo:amoforward]</a> and <a href="#ppo:addrdatarfi" data-reference-type="ref" data-reference="ppo:addrdatarfi">[ppo:addrdatarfi]</a>–<a href="#ppo:addrpo" data-reference-type="ref" data-reference="ppo:addrpo">[ppo:addrpo]</a>) described in Section <a href="memory-model-operational.html#sec:operational" data-reference-type="ref" data-reference="sec:operational">[sec:operational]</a>. They also facilitate the process of porting code from other architectures that have similar rules.</p></li>
</ul>
<p>We also expect the following from the hardware perspective:</p>
<ul>
<li><p>PPO rules <a href="#ppo:-&gt;st" data-reference-type="ref" data-reference="ppo:-&gt;st">[ppo:-&gt;st]</a> and <a href="rvwmo.html#ppo:amoforward" data-reference-type="ref" data-reference="ppo:amoforward">[ppo:amoforward]</a>–<a href="rvwmo.html#ppo:release" data-reference-type="ref" data-reference="ppo:release">[ppo:release]</a> reflect well-understood rules that should pose few surprises to architects.</p></li>
<li><p>PPO rule <a href="rvwmo.html#ppo:rdw" data-reference-type="ref" data-reference="ppo:rdw">[ppo:rdw]</a> reflects a natural and common hardware optimization, but one that is very subtle and hence is worth double checking carefully.</p></li>
<li><p>PPO rule <a href="rvwmo.html#ppo:rcsc" data-reference-type="ref" data-reference="ppo:rcsc">[ppo:rcsc]</a> may not be immediately obvious to architects, but it is a standard memory model requirement</p></li>
<li><p>The load value axiom, the atomicity axiom, and PPO rules <a href="rvwmo.html#ppo:pair" data-reference-type="ref" data-reference="ppo:pair">[ppo:pair]</a>–<a href="rvwmo.html#ppo:addrpo" data-reference-type="ref" data-reference="ppo:addrpo">[ppo:addrpo]</a> reflect rules that most hardware implementations will enforce naturally, unless they contain extreme optimizations. Of course, implementations should make sure to double check these rules nevertheless. Hardware must also ensure that syntactic dependencies are not “optimized away”.</p></li>
</ul>
<p>Architectures are free to implement any of the memory model rules as conservatively as they choose. For example, a hardware implementation may choose to do any or all of the following:</p>
<ul>
<li><p>interpret all fences as if they were FENCE RW,RW (or FENCE IORW,IORW, if I/O is involved), regardless of the bits actually set</p></li>
<li><p>implement all fences with PW and SR as if they were FENCE RW,RW (or FENCE IORW,IORW, if I/O is involved), as PW with SR is the most expensive of the four possible main memory ordering components anyway</p></li>
<li><p>emulate <span><em>aq</em></span> and <span><em>rl</em></span> as described in Section <a href="memory.html#sec:memory:porting" data-reference-type="ref" data-reference="sec:memory:porting">1.5</a></p></li>
<li><p>enforcing all same-address load-load ordering, even in the presence of patterns such as “fri-rfi” and “RSW”</p></li>
<li><p>forbid any forwarding of a value from a store in the store buffer to a subsequent AMO or LR to the same address</p></li>
<li><p>forbid any forwarding of a value from an AMO or SC in the store buffer to a subsequent load to the same address</p></li>
<li><p>implement TSO on all memory accesses, and ignore any main memory fences that do not include PW and SR ordering (e.g., as Ztso implementations will do)</p></li>
<li><p>implement all atomics to be RCsc or even fully-ordered, regardless of annotation</p></li>
</ul>
<p>Architectures that implement RVTSO can safely do the following:</p>
<ul>
<li><p>Ignore all fences that do not have both PW and SR (unless the fence also orders I/O)</p></li>
<li><p>Ignore all PPO rules except for rules <a href="rvwmo.html#ppo:fence" data-reference-type="ref" data-reference="ppo:fence">[ppo:fence]</a> through <a href="rvwmo.html#ppo:rcsc" data-reference-type="ref" data-reference="ppo:rcsc">[ppo:rcsc]</a>, since the rest are redundant with other PPO rules under RVTSO assumptions</p></li>
</ul>
<p>Other general notes:</p>
<ul>
<li><p>Silent stores (i.e., stores that write the same value that already exists at a memory location) behave like any other store from a memory model point of view. Likewise, AMOs which do not actually change the value in memory (e.g., an AMOMAX for which the value in <span><em>rs2</em></span> is smaller than the value currently in memory) are still semantically considered store operations. Microarchitectures that attempt to implement silent stores must take care to ensure that the memory model is still obeyed, particularly in cases such as RSW (Section <a href="memory.html#sec:memory:overlap" data-reference-type="ref" data-reference="sec:memory:overlap">1.3.5</a>) which tend to be incompatible with silent stores.</p></li>
<li><p>Writes may be merged (i.e., two consecutive writes to the same address may be merged) or subsumed (i.e., the earlier of two back-to-back writes to the same address may be elided) as long as the resulting behavior does not otherwise violate the memory model semantics.</p></li>
</ul>
<p>The question of write subsumption can be understood from the following example:</p>
<figure>
<img src="memory_30.svg" alt="Write subsumption litmus test, allowed execution." id="fig:litmus:subsumption" /><figcaption>Write subsumption litmus test, allowed execution.<span label="fig:litmus:subsumption"></span></figcaption>
</figure>
<p>As written, if the load  (d) reads value <span class="math inline">1</span>, then (a) must precede (f) in the global memory order:</p>
<ul>
<li><p>(a) precedes (c) in the global memory order because of rule 2</p></li>
<li><p>(c) precedes (d) in the global memory order because of the Load Value axiom</p></li>
<li><p>(d) precedes (e) in the global memory order because of rule 7</p></li>
<li><p>(e) precedes (f) in the global memory order because of rule 1</p></li>
</ul>
<p>In other words the final value of the memory location whose address is in <span>s0</span> must be <span class="math inline">2</span> (the value written by the store (f)) and cannot be <span class="math inline">3</span> (the value written by the store (a)).</p>
<p>A very aggressive microarchitecture might erroneously decide to discard (e), as (f) supersedes it, and this may in turn lead the microarchitecture to break the now-eliminated dependency between (d) and (f) (and hence also between (a) and (f)).
This would violate the memory model rules, and hence it is forbidden.
Write subsumption may in other cases be legal, if for example there were no data dependency between (d) and (e).</p>
<h3 id="possible-future-extensions">Possible Future Extensions</h3>
<p>We expect that any or all of the following possible future extensions would be compatible with the RVWMO memory model:</p>
<ul>
<li><p>‘V’ vector ISA extensions</p></li>
<li><p>A transactional memory subset of the ‘T’ ISA extension</p></li>
<li><p>‘J’ JIT extension</p></li>
<li><p>Native encodings for load and store opcodes with <span><em>aq</em></span> and <span><em>rl</em></span> set</p></li>
<li><p>Fences limited to certain addresses</p></li>
<li><p>Cache writeback/flush/invalidate/etc.instructions</p></li>
</ul>
<h2 id="sec:memory:discrepancies">Known Issues</h2>
<h3 id="sec:memory:discrepancies:mixedrsw">Mixed-size RSW</h3>
<figure>
<img src="memory_31.svg" alt="Mixed-size discrepancy (permitted by axiomatic models, forbidden by operational model)" id="fig:litmus:discrepancy:rsw1" /><figcaption>Mixed-size discrepancy (permitted by axiomatic models, forbidden by operational model)<span label="fig:litmus:discrepancy:rsw1"></span></figcaption>
</figure>
<figure>
<img src="memory_32.svg" alt="Mixed-size discrepancy (permitted by axiomatic models, forbidden by operational model)" id="fig:litmus:discrepancy:rsw2" /><figcaption>Mixed-size discrepancy (permitted by axiomatic models, forbidden by operational model)<span label="fig:litmus:discrepancy:rsw2"></span></figcaption>
</figure>
<figure>
<img src="memory_33.svg" alt="Mixed-size discrepancy (permitted by axiomatic models, forbidden by operational model)" id="fig:litmus:discrepancy:rsw3" /><figcaption>Mixed-size discrepancy (permitted by axiomatic models, forbidden by operational model)<span label="fig:litmus:discrepancy:rsw3"></span></figcaption>
</figure>
<p>There is a known discrepancy between the operational and axiomatic specifications within the family of mixed-size RSW variants shown in Figures <a href="memory.html#fig:litmus:discrepancy:rsw1" data-reference-type="ref" data-reference="fig:litmus:discrepancy:rsw1">1.19</a>–<a href="memory.html#fig:litmus:discrepancy:rsw3" data-reference-type="ref" data-reference="fig:litmus:discrepancy:rsw3">1.21</a>.
To address this, we may choose to add something like the following new PPO rule:
Memory operation <span class="math inline"><em>a</em></span> precedes memory operation <span class="math inline"><em>b</em></span> in preserved program order (and hence also in the global memory order) if <span class="math inline"><em>a</em></span> precedes <span class="math inline"><em>b</em></span> in program order, <span class="math inline"><em>a</em></span> and <span class="math inline"><em>b</em></span> both access regular main memory (rather than I/O regions), <span class="math inline"><em>a</em></span> is a load, <span class="math inline"><em>b</em></span> is a store, there is a load <span class="math inline"><em>m</em></span> between <span class="math inline"><em>a</em></span> and <span class="math inline"><em>b</em></span>, there is a byte <span class="math inline"><em>x</em></span> that both <span class="math inline"><em>a</em></span> and <span class="math inline"><em>m</em></span> read, there is no store between <span class="math inline"><em>a</em></span> and <span class="math inline"><em>m</em></span> that writes to <span class="math inline"><em>x</em></span>, and <span class="math inline"><em>m</em></span> precedes <span class="math inline"><em>b</em></span> in PPO.
In other words, in <span>herd</span> syntax, we may choose to add “<span>(po-loc &amp; rsw);ppo;[W]</span>” to PPO.
Many implementations will already enforce this ordering naturally.
As such, even though this rule is not official, we recommend that implementers enforce it nevertheless in order to ensure forwards compatibility with the possible future addition of this rule to RVWMO.</p>
<h1 id="formal-memory-model-specifications-version-0.1">Formal Memory Model Specifications, Version 0.1</h1>
<p>To facilitate formal analysis of RVWMO, this chapter presents a set of formalizations using different tools and modeling approaches. Any discrepancies are unintended; the expectation is that the models describe exactly the same sets of legal behaviors.</p>
<p>This appendix should be treated as commentary; all normative material is provided in Chapter <a href="rvwmo.html#ch:memorymodel" data-reference-type="ref" data-reference="ch:memorymodel">[ch:memorymodel]</a> and in the rest of the main body of the ISA specification.
All currently known discrepancies are listed in Section <a href="memory.html#sec:memory:discrepancies" data-reference-type="ref" data-reference="sec:memory:discrepancies">1.7</a>.
Any other discrepancies are unintentional.</p>
<p><a href="memory-model-alloy.html" data-reference-type="ref" data-reference="memory-model-alloy.tex">[memory-model-alloy.tex]</a></p>
<p><a href="memory-model-herd.html" data-reference-type="ref" data-reference="memory-model-herd.tex">[memory-model-herd.tex]</a></p>
<p><a href="memory-model-operational.html" data-reference-type="ref" data-reference="memory-model-operational.tex">[memory-model-operational.tex]</a></p>

</body>
</html>
