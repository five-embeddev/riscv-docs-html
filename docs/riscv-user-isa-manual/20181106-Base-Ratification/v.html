<html>
<head>
<title>RISC-V Instruction Set Manual, Volume I: RISC-V User-Level ISA</title>
</head>
<body>

<table>
<tr><th colspan=2>Metadata Table</th></tr>
<tr><th>Manual Type</th><td> user</td></tr>
<tr><th>Spec Revision</th><td> 20181106-Base-Ratification</td></tr>
<tr><th>Spec Release Date</th><td> </td></tr>
<tr><th>Git Revision</th><td> 20181106-Base-Ratification</td></tr>
<tr><th>Git URL</th><td><a href=https://github.com/riscv/riscv-isa-manual.git>https://github.com/riscv/riscv-isa-manual.git</a></td></tr>
<tr><th>Source</th><td>src/v.tex</td></tr>
<tr><th>Conversion Date</th><td>2023/09/28</td></tr>
<tr><th>License</th><td><a href=https://creativecommons.org/licenses/by/4.0/>CC-by-4.0</a></td></tr>
</table>


<h1 id="sec:bits"><span class="header-section-number">21</span> “V” Standard Extension for Vector Operations, Version 0.4-DRAFT</h1>
<p><span><strong>This version is out-of-date with respect to the current working
group draft, which is now hosted on <span>https://github.com/riscv/riscv-v-spec</span>.</strong></span></p>
<p>This chapter presents a proposal for the RISC-V base vector
instruction-set extension. The base vector extension is intended to
provide general support for data-parallel execution within the 32-bit
instruction encoding space, with later vector extensions supporting
richer functionality for certain domains.</p>
<div class=commentary>
<p>The vector extension is based on the style of vector register
architecture introduced by Seymour Cray in the 1970s, as opposed to
the earlier packed SIMD approach, introduced with the Lincoln Labs
TX-2 in 1957 and now adopted by most other commercial instruction
sets.</p>
</div>
<p>The base vector extension defines the components that must be included
when the “V” bit is set in the <span>misa</span> register, and consequently
those that will be assumed to exist by software written for an ABI
specifying V.</p>
<div class=commentary>
<p>This draft version of the chapter includes additional specifications
of proposed extensions to the base vector extension to explain some
of the encoding choices made for the base.</p>
</div>
<p>The vector extension supports a configurable vector unit, to enable
implementations to tradeoff the number of active architectural vector
registers and supported element widths against available maximum
vector length. The vector extension is designed to allow the same
binary code to work efficiently across a variety of hardware
implementations varying in physical vector storage capacity and
datapath spatial and/or temporal parallelism.</p>
<div class=commentary>
<p>The vector instruction set contains many features developed in earlier
research projects, including the Berkeley T0 <span class="citation" data-cites=""></span> and VIRAM <span class="citation" data-cites="VIRAM"><a href="#ref-VIRAM">[VIRAM]</a></span>
vector microprocessors, the MIT Scale vector-thread processor <span class="citation" data-cites=""></span>,
and the Berkeley Maven <span class="citation" data-cites=""></span> and Hwacha <span class="citation" data-cites=""></span> projects.</p>
</div>
<h2 id="vector-unit-state"><span class="header-section-number">21.1</span> Vector Unit State</h2>
<p>The additional vector unit architectural state includes 32 vector
registers (<span>v0</span>–<span>v31</span>), and an XLEN-bit WARL vector length
CSR, <span>vl</span>. Each vector register <span>v</span><span class="math inline"><em>n</em></span> has an associated
16-bit configuration field <span>vtype</span><span class="math inline"><em>n</em></span> described below. A 6-bit
global maximum element width register <span>vmaxew</span> defines the maximum
number of bits of storage in every element of every active vector
register.</p>
<div class=commentary>
<p>Future vector extensions using wider instruction encodings can
support more architectural vector registers. For example, 256
architectural vector registers in a 64-bit instruction encoding.</p>
</div>
<div class=commentary>
<p>Future 2D shape extensions add two more vector length registers,
<span>vm</span> and <span>vn</span>.</p>
</div>
<p>There is also a 3-bit fixed-point rounding mode CSR <span>vxrm</span>, and a
single-bit fixed-point saturation status CSR <span>vxsat</span>. The <span>
vcs</span> CSR alias provides combined access to the <span>vl</span>, <span>vxrm</span>,
<span>vxsat</span> fields to reduce context switch time. The <span>vcs</span>
register also includes a configuration mode field to support future
extended configuration modes.</p>
<p>CUSTOMTAGBEGINDISCUSSION</p>
<p>The components of vcs might not need separate CSR addresses,
depending on how they’re accessed via other non-CSR instructions.</p>
<p>CUSTOMTAGENDDISCUSSION</p>
<h2 id="vector-unit-type-configuration-register-vtypen"><span class="header-section-number">21.2</span> Vector Unit Type Configuration Register (<span>vtype</span><span class="math inline"><em>n</em></span>)</h2>
<p>The vector unit must be configured before use. Each architectural
vector register, <span>v</span><span class="math inline"><em>n</em></span>, is configured via 16 bits of vector type
configuration state <span>vtype</span><span class="math inline"><em>n</em></span>, which can be accessed via vector
configuration (<span>vcfg</span>) CSRs and other rapid vector configuration
instructions as described below. The vector register type
configuration encodes the overall organization, or <span><em>shape</em></span>, of the
elements in each vector register (e.g., scalar versus 1-D vector), as
well as the bitwidth and numeric representation of each element. As
shown in Figure <a href="v.html#fig:vtype" data-reference-type="ref" data-reference="fig:vtype">1.1</a>, the 16-bit <span>vtype</span><span class="math inline"><em>n</em></span> encoding is
divided into a 5-bit current shape field <span>vshape</span><span class="math inline"><em>n</em></span>, a 5-bit
representation field <span>verep</span><span class="math inline"><em>n</em></span>, and a 6-bit element bit-width
field <span>vew</span><span class="math inline"><em>n</em></span>  held in the <span>vcfg</span><span class="math inline"><em>x</em></span> CSRs. The combination
of an element numeric representation and an element bitwidth is called
an element <span><em>format</em></span>. Each vector register can also be disabled to
free physical vector storage for other architectural vector registers.</p>
<figure>
<img src="tmp.20181106-Base-Ratification//v_00.svg" alt="Location of subfields within a single vtypen field." id="fig:vtype" /><figcaption>Location of subfields within a single <span>vtype</span><span class="math inline"><em>n</em></span> field.<span label="fig:vtype"></span></figcaption>
</figure>
<div class=commentary>
<p>It was also common in earlier vector machines to support multiple
precisions within the vector datapath. In particular, the CDC
STAR-100 <span class="citation" data-cites="cdcstar100"><a href="#ref-cdcstar100">[cdcstar100]</a></span> supported single-precision and
double-precision floating-point operations and also bit, byte, and
nibble operations in the vector unit; TI ASC <span class="citation" data-cites="tiasc"><a href="#ref-tiasc">[tiasc]</a></span> designs
supported dividing 64-bit vector lanes into two 32-bit lanes for
double throughput.</p>
</div>
<h2 id="shape-encoding"><span class="header-section-number">21.3</span> Shape Encoding</h2>
<p>The 5-bit shape field describes the structure of the elements within
the vector register. In the base vector extension, the shape can be
set to either scalar or vector.</p>
<figure>
<img src="tmp.20181106-Base-Ratification//v_01.svg" alt="Base vector encoding of vshapen field." id="tab:vshape" /><figcaption>Base vector encoding of <span>vshape</span><span class="math inline"><em>n</em></span> field.<span label="tab:vshape"></span></figcaption>
</figure>
<div class=commentary>
<p>For the base vector ISA, only a single bit is required in each <span>
vshape</span> field to select between scalar and 1-D vector elements
with the other bits hardwired to zero.</p>
</div>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"><span>vshape</span></th>
<th style="text-align: left;">Shape</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">00000</td>
<td style="text-align: left;">scalar</td>
</tr>
<tr class="even">
<td style="text-align: center;">00001</td>
<td style="text-align: left;"><span><em>Reserved</em></span></td>
</tr>
<tr class="odd">
<td style="text-align: center;">0001x</td>
<td style="text-align: left;"><span><em>Reserved</em></span></td>
</tr>
<tr class="even">
<td style="text-align: center;">00100</td>
<td style="text-align: left;">1-D vector <span>vl</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;">01000</td>
<td style="text-align: left;">1-D vector <span>vm</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">01100</td>
<td style="text-align: left;">1-D vector <span>vn</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;">00101</td>
<td style="text-align: left;">2-D matrix <span>vl</span> x <span>vl</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">00110</td>
<td style="text-align: left;">2-D matrix <span>vl</span> x <span>vm</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;">00111</td>
<td style="text-align: left;">2-D matrix <span>vl</span> x <span>vn</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">01001</td>
<td style="text-align: left;">2-D matrix <span>vm</span> x <span>vl</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;">01010</td>
<td style="text-align: left;">2-D matrix <span>vm</span> x <span>vm</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">01011</td>
<td style="text-align: left;">2-D matrix <span>vm</span> x <span>vn</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;">01101</td>
<td style="text-align: left;">2-D matrix <span>vn</span> x <span>vl</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">01110</td>
<td style="text-align: left;">2-D matrix <span>vn</span> x <span>vm</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;">01111</td>
<td style="text-align: left;">2-D matrix <span>vn</span> x <span>vn</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">1xxxx</td>
<td style="text-align: left;"><span><em>Reserved</em></span>/<span><em>Custom</em></span></td>
</tr>
</tbody>
</table>
<div class=commentary>
<p>A sketch of the proposed encodings for the 2D shape extension is
shown in the Table.</p>
</div>
<h2 id="representation-encoding"><span class="header-section-number">21.4</span> Representation Encoding</h2>
<p>The 5-bit <span>verep</span><span class="math inline"><em>n</em></span> register sets the numeric representation of
each element of the vector register. In the base vector
extension, the representation can be set to unsigned integer,
two’s-complement signed integer, or floating-point. The
floating-point representations follow the IEEE 754 standards.</p>
<figure>
<img src="tmp.20181106-Base-Ratification//v_02.svg" alt="Base vector representation encoding." id="tab:verep" /><figcaption>Base vector representation encoding.<span label="tab:verep"></span></figcaption>
</figure>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"><span>verep</span></th>
<th style="text-align: left;">Representation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">00000</td>
<td style="text-align: left;">Unsigned integer</td>
</tr>
<tr class="even">
<td style="text-align: center;">00001</td>
<td style="text-align: left;">Two’s-complement signed integer</td>
</tr>
<tr class="odd">
<td style="text-align: center;">00010</td>
<td style="text-align: left;"><span><em>Reserved (unsigned floating-point)</em></span></td>
</tr>
<tr class="even">
<td style="text-align: center;">00011</td>
<td style="text-align: left;">IEEE-754 floating-point</td>
</tr>
<tr class="odd">
<td style="text-align: center;">001x0</td>
<td style="text-align: left;"><span><em>Reserved</em></span></td>
</tr>
<tr class="even">
<td style="text-align: center;">00101</td>
<td style="text-align: left;">Complex signed integer</td>
</tr>
<tr class="odd">
<td style="text-align: center;">00111</td>
<td style="text-align: left;">Complex floating-point</td>
</tr>
<tr class="even">
<td style="text-align: center;">01000</td>
<td style="text-align: left;">Prime Galois field - integer representation</td>
</tr>
<tr class="odd">
<td style="text-align: center;">01001</td>
<td style="text-align: left;">Prime Galois field - Montgomery representation</td>
</tr>
<tr class="even">
<td style="text-align: center;">01100</td>
<td style="text-align: left;">Binary extension Galois field - polynomial basis</td>
</tr>
<tr class="odd">
<td style="text-align: center;">01101</td>
<td style="text-align: left;">Binary extension Galois field - normal basis</td>
</tr>
<tr class="even">
<td style="text-align: center;">01010</td>
<td style="text-align: left;">UNORM</td>
</tr>
<tr class="odd">
<td style="text-align: center;">01011</td>
<td style="text-align: left;">SNORM</td>
</tr>
<tr class="even">
<td style="text-align: center;">01110</td>
<td style="text-align: left;"><span><em>Reserved</em></span></td>
</tr>
<tr class="odd">
<td style="text-align: center;">01111</td>
<td style="text-align: left;"><span><em>Reserved (complex SNORM?)</em></span></td>
</tr>
<tr class="even">
<td style="text-align: center;">10xxx</td>
<td style="text-align: left;">Custom representations</td>
</tr>
<tr class="odd">
<td style="text-align: center;">11xxx</td>
<td style="text-align: left;"><span><em>Reserved</em></span></td>
</tr>
</tbody>
</table>
<div class=commentary>
<p>The complex representations split the element width given in <span>
vew</span><span class="math inline"><em>n</em></span> into two equal-sized real and imaginary fields, so an
element width of 64 bits can hold a single complex value with a
32-bit real and a 32-bit imaginary component.</p>
</div>
<h2 id="element-bitwidth"><span class="header-section-number">21.5</span> Element Bitwidth</h2>
<p>Each vector register, <span>v</span><span class="math inline"><em>n</em></span>, has a 6-bit element width
register, <span>vew</span><span class="math inline"><em>n</em></span>, to specify the number of bits for each element
of the current type in the vector register.</p>
<p>The largest element width supported is
termed ELEN, and is defined to be the larger of the supported integer
and floating-point type widths:
<br /><span class="math display">$${\em ELEN}  = max({\em XLEN} , {\em FLEN} )$$</span><br />
For the base vector ISA, the bit width can be set at any power of two
between 8 and ELEN.</p>
<figure>
<img src="tmp.20181106-Base-Ratification//v_03.svg" alt="Base vector ISA encoding of vector element width ( vewn) register fields." id="tab:basevew" /><figcaption>Base vector ISA encoding of vector element width (<span>
vew</span><span class="math inline"><em>n</em></span>) register fields.<span label="tab:basevew"></span></figcaption>
</figure>
<figure>
<img src="tmp.20181106-Base-Ratification//v_04.svg" alt="Proposed extended encoding of vector element width ( vewn) register fields. Every bit width between 1 and 16 can be supported. Bit widths in steps of 2 between 16 to 32 (i.e., 16, 18, 20, ...). Bit widths in steps of 4 between 32 to 64 (i.e., 32, 36, 40, ...). Bit widths in steps of 8 between 64 and 128 (i.e., 64, 72, 80,...). For bit widths greater than 128, all powers-of-two up to 16384 and all widths 1.5\times greater are supported (128, 384, 512, 768,...). " id="tab:extvew" /><figcaption>Proposed extended encoding of vector element width (<span>
vew</span><span class="math inline"><em>n</em></span>) register fields. Every bit width between 1 and 16 can
be supported. Bit widths in steps of 2 between 16 to 32 (i.e.,
16, 18, 20, ...). Bit widths in steps of 4 between 32 to 64
(i.e., 32, 36, 40, ...). Bit widths in steps of 8 between 64 and
128 (i.e., 64, 72, 80,...). For bit widths greater than 128, all
powers-of-two up to 16384 and all widths 1.5<span class="math inline">×</span> greater are
supported (128, 384, 512, 768,...). <span label="tab:extvew"></span></figcaption>
</figure>
<div class=commentary>
<p>The extended bit-width encoding is designed to minimize the number
of state bits required to support useful subsets of widths. For
example, an RV32 system only needs two bits of state per <span>
vew</span><span class="math inline"><em>n</em></span> field to represent <span><em>disabled</em></span>, 8, 16, and 32. An
RV32 system with 3 bits of state can represent <span><em>disabled</em></span>, 4,
8, 12, 16, 24, 32, and 48. An RV64 system with 4 bits of state
can represent <span><em>disabled</em></span>, 4, 8, 12, 16, 24, 32, 48, 64, 96,
128, 256, 512, 1024.</p>
</div>
<h2 id="base-vector-extension-supported-types"><span class="header-section-number">21.6</span> Base Vector Extension Supported Types</h2>
<p>The types supported by the base V extension depend upon the base
scalar ISA and supported extensions. When the base V extension is
added to a base scalar ISA, it must support the vector data element
types implied by the supported scalar types as defined by
Table <a href="v.html#tab:velemtypes" data-reference-type="ref" data-reference="tab:velemtypes">1.6</a>.</p>
<figure>
<img src="tmp.20181106-Base-Ratification//v_05.svg" alt="Supported data element formats depending on base integer ISA and supported floating-point extensions. Ix indicates a signed integer of x bits, Ux indicates an unsigned integer of x bits, and Fx indicates an IEEE floating-point number of x bits." id="tab:velemtypes" /><figcaption>Supported data element formats depending on base integer ISA
and supported floating-point extensions. I<span class="math inline"><em>x</em></span> indicates a signed
integer of <span class="math inline"><em>x</em></span> bits, U<span class="math inline"><em>x</em></span> indicates an unsigned integer of <span class="math inline"><em>x</em></span> bits,
and F<span class="math inline"><em>x</em></span> indicates an IEEE floating-point number of <span class="math inline"><em>x</em></span> bits.<span label="tab:velemtypes"></span></figcaption>
</figure>
<div class=commentary>
<p>Future vector extensions might expand the set of supported
datatypes, including custom application-specific datatypes.</p>
</div>
<h2 id="maximum-vector-element-width-vmaxew"><span class="header-section-number">21.7</span> Maximum Vector Element Width (<span>vmaxew</span>)</h2>
<p>The global <span>vmaxew</span> field is used to support more complex vector
runtime environments where the types to be held in each register of a
single configuration may vary dynamically, and may not even be known
at compile time due to separate compilation.</p>
<p>The global maximum element width register <span>vmaxew</span> defines the
maximum number of bits of storage in every element of every active
architectural register, or if zero, defers to the per-vector-register
width field.</p>
<div class=commentary>
<p>The VIRAM processor had a virtual processor width
register similar to <span>vmaxew</span> <span class="citation" data-cites="VIRAM"><a href="#ref-VIRAM">[VIRAM]</a></span>.</p>
</div>
<p>If <span>vmaxew</span> is zero, then the per-element vector element widths
<span>vew</span><span class="math inline"><em>n</em></span> determine the minimum storage required for each element
of the associated vector register <span>v</span><span class="math inline"><em>n</em></span>.</p>
<p>If <span>vmaxew</span> is non-zero, it sets the largest element width that
can be supported in any vector register element in the current
configuration.</p>
<h2 id="vector-configuration-registers-vcfg0vcfg15"><span class="header-section-number">21.8</span> Vector Configuration Registers (<span>vcfg0</span>–<span>vcfg15</span>)</h2>
<p>The vector type configuration requires 512 bits of state (32 vector
registers each with 16-bit <span>vtype</span><span class="math inline"><em>n</em></span> field) that can be accessed
via the <span>vcfg CSRs</span>.</p>
<p>RV128 uses four vector configuration CSRs: <span>vcfg0</span> holds
configuration data for <span>v0</span>–<span>v7</span> with bits <span class="math inline">16<em>n</em></span> to <span class="math inline">16<em>n</em> + 15</span>
holding <span>vtype</span><span class="math inline"><em>n</em></span>, while <span>vcfg4</span>, <span>vcfg8</span> and <span>
vcfg12</span> similarly holds configuration data for <span>v8</span>–<span>v15</span>,
<span>v16</span>–<span>v23</span>, and <span>v24</span>–<span>v31</span> respectively.</p>
<p>In RV64, the <span>vcfg2</span> CSR provides access to the upper 64 bits of <span>
vcfg0</span> and <span>vcfg6</span> provides access to the upper 64 bits of
<span>vcfg4</span>. In RV32, the <span>vcfg1</span>, <span>vcfg3</span>, <span>vcfg5</span>
and <span>vcfg7</span> CSRs provides access to the upper bits of <span>
vcfg0</span>, <span>vcfg2</span>, <span>vcfg4</span> and <span>vcfg6</span> respectively.</p>
<p>Any CSR write to a <span>vcfg</span><span class="math inline"><em>x</em></span> register zeros all <span>vcfg</span><span class="math inline"><em>y</em></span>
registers, for <span class="math inline"><em>y</em> &gt; <em>x</em></span>. As a result configuration data should be
written from the <span>vcfg0</span> CSR upwards.</p>
<div class=commentary>
<p>Zeroing higher-numbered <span>vcfg</span><span class="math inline"><em>y</em></span> registers allows more rapid
reconfiguration of the vector register file via CSR writes, and
provides backward-compatibility for extensions that increase the
number of possible architectural vector registers. This choice does
prevent the use of CSRRW instructions to swap the configuration
context; an entire old configuration must be read out before a new
configuration is written in.</p>
</div>
<p>Additional instructions are provided to support more rapid changes to
the vector unit configuration as described below.</p>
<h2 id="legal-vector-unit-configurations"><span class="header-section-number">21.9</span> Legal Vector Unit Configurations</h2>
<p>To simplify hardware configuration calculations and to reduce software
context-switch complexity, vector unit configurations are constrained
to have non-disabled architectural vector registers numbered
contiguously starting at <span>v0</span>. An exception will be raised if an
instruction tries to change <span>vtype</span><span class="math inline"><em>n</em></span> in a way that violates this
constraint.</p>
<div class=commentary>
<p>During a software vector-context save, the software handler can stop
searching for active architectural registers after encountering the
first disabled vector register. Hardware to calculate physical
register allocation is also simplified with this constraint.</p>
</div>
<h2 id="vector-unit-csrs"><span class="header-section-number">21.10</span> Vector Unit CSRs</h2>
<figure>
<img src="tmp.20181106-Base-Ratification//v_06.svg" alt="Vector extension CSRs." id="tab:vcsrs" /><figcaption>Vector extension CSRs.<span label="tab:vcsrs"></span></figcaption>
</figure>
<h2 id="maximum-vector-length-mvl"><span class="header-section-number">21.11</span> Maximum Vector Length (MVL)</h2>
<p>The implementation determines an available <span><em>maximum vector length</em></span>
(MVL) dependent on the current vector type configuration held in <span>
vcfg</span><span class="math inline"><em>x</em></span> and <span>vmaxew</span>. The available MVL depends on the
configuration setting and on the implementation’s microarchitecture,
but MVL must always have the same value for the same configuration
parameters on a given hart.</p>
<div class=commentary>
<p>Several earlier vector machines had the ability to configure
physical vector register storage into a larger number of short
vectors or a shorter number of long vectors. In particular the
Fujitsu VP series <span class="citation" data-cites="vp200"><a href="#ref-vp200">[vp200]</a></span> supported combining power-of-2 base
vector registers into longer vector registers.</p>
<p>The Scale <span class="citation" data-cites=""></span>, Maven <span class="citation" data-cites=""></span>, and Hwacha <span class="citation" data-cites=""></span> processors also
support configuration-dependent MVL.</p>
</div>
<div class=commentary>
<p>Previously, the specification imposed a minimum vector length (4) on
all configurations to allow stripmining code to be removed for short
vector lengths. With the expanded scope of the vector unit types,
this would be too onerous to support, and so the requirement is removed.</p>
</div>
<p>CUSTOMTAGBEGINDISCUSSION</p>
<p>A separate mechanism for supporting fixed vector lengths should be
designed, possibly as part of an optional extension.</p>
<p>CUSTOMTAGENDDISCUSSION</p>
<p>Any change to the vector configuration that might change MVL cause the
entire vector unit state to be zeroed. Any write to the global <span>
vmaxew</span> causes the entire vector unit state to be zeroed, even if
the value in <span>vmaxew</span> is unchanged.</p>
<p>If <span>vmaxew</span> is non-zero, any write to an individual <span>vew</span><span class="math inline"><em>n</em></span>
register that would set the width greater than <span>vmaxew</span> raises an
illegal instruction exception and leaves the vector unit state
unchanged.</p>
<p>If <span>vmaxew</span> is non-zero, any write to an individual <span>vew</span><span class="math inline"><em>n</em></span>
field with a value less than or equal to the value in <span>vmaxew</span>
only zeros the associated vector register <span>v</span><span class="math inline"><em>n</em></span> and leaves other
vector unit state unchanged. The vector register data is zeroed even
if <span>vew</span><span class="math inline"><em>n</em></span> would be unchanged by the write.</p>
<p>If <span>vmaxew</span> is zero, then any write to an individual <span>vew</span><span class="math inline"><em>n</em></span>
register zeros the associated <span>v</span><span class="math inline"><em>n</em></span> vector register. In addition,
any write that changes the value in <span>vew</span><span class="math inline"><em>n</em></span>, zeros the entire vector
unit state.</p>
<div class=commentary>
<p>The state is zeroed to hide implementation-dependent bit mappings
and to provide additional security when context swapping. Zero is
also a convenient initial value for some loops.</p>
<p>In-order implementations will probably use a flag bit per register to
mux in 0 instead of garbage values on each source until it is
overwritten. For in-order machines, vector lengths less than MVL
complicate this zeroing, but these cases can be handled by adding a
zero bit per element or element group. Machines with vector
register renaming can just initialize the rename table to point
entries at a physical zero register.</p>
</div>
<p>Each vector register can be reconfigured dynamically to hold different
formats without zeroing the entire vector unit state provided that: if
<span>vmaxew</span> is zero, the bit-width of the new format is the same as
the current <span>vew</span>; or if <span>vmaxew</span> is non-zero, the format does
not require more than <span>vmaxew</span> bits. Any change to a vector
register’s format zeros the affected vector register.</p>
<p>If a vector register is disabled, then any vector instruction
that attempts to access that vector register will raise an
illegal instruction exception. Attempting to write any <span>
vmaxew</span><span class="math inline"><em>n</em></span> with an unsupported value will raise an illegal
instruction exception.</p>
<div class=commentary>
<p>Vector registers have both a maximum element width and a
current element data type to allow the same vector register to
be changed to different types during execution provided the
maximum width is not exceeded. This reduces register pressure and
helps support vector function calls, where the caller does not know
the types needed by the callee, as described below.</p>
</div>
<div class=commentary>
<p>The set of supported types might be greatly increased with future
extensions. For example (and not limited to), new scalar types in
new number systems, a complex type with real and imaginary
components, a key-value type, or an application-specific structure
type with multiple constituent fields. Auxiliary type
configuration state might be required in these cases.</p>
</div>
<p>Attempting to write an unsupported type or a type that requires more
than the current <span>vmaxew</span> width to a <span>vetype</span> field will raise
an illegal instruction exception.</p>
<div class=commentary>
<p>Implementations must still raise an exception for a <span>vetype</span><span class="math inline"><em>n</em></span>
setting that is greater than the architectural <span>vmaxew</span><span class="math inline"><em>n</em></span> width,
even if they internally implement a larger physical <span>vmaxew</span><span class="math inline"><em>n</em></span>
that could accommodate the <span>vetype</span><span class="math inline"><em>n</em></span> request.</p>
</div>
<p>CUSTOMTAGBEGINDISCUSSION</p>
<p>We can either have 1) implementations raise exceptions whenever
illegal values are written to <span>vmaxew</span> and <span>vetype</span> fields
(current design), 2) raise exceptions at use if config holds illegal
values, 3) make the fields WARL so silently reduce to supported types
with no exceptions. Option 2 could complicate vector unit context
switch code by having more cases to check, while Option 3 could make
debugging more difficult by allowing code to run with reduced
precision or incorrect types.</p>
<p>CUSTOMTAGENDDISCUSSION</p>
<div class=commentary>
<p>Three broad classes of implementation can be distinguished by how they
handle <span>vmaxew</span> settings.</p>
<p>The simplest is <span><em>max-width-per-implementation</em></span> (MWPI), where the
vector unit is organized in fixed ELEN-width physical lanes, and
changes to <span>vmaxew</span> settings simply cause portions of the
physical registers and datapath to be disabled for operations narrower
than ELEN bits.</p>
<p>The next most complex implementation, <span>
<em>max-width-per-configuration</em></span> (MWPC), uses the maximum width across
all <span>vmaxew</span> settings in a dynamic configuration to divide the
physical register storage and datapaths. For example, a MWPC machine
with ELEN=64 might subdivide physical lanes into 32-bit datapaths if
no <span>vmaxew</span> setting is greater than 32. Operations on
sub-32-bit quantities would disable appropriate portions of the
physical registers and functional units in each 32-bit lane. Several
early vector supercomputers, including the CDC
Star-100 <span class="citation" data-cites="cdcstart100"><a href="#ref-cdcstart100">[cdcstart100]</a></span>, provided a similar facility to divide
64-bit physical vector lanes into narrower 32-bit lanes.</p>
<p>The most complex implementations are <span><em>max-width-per-register</em></span>
(MWPR), which reduce wasted space in the physical register files by
packing elements in each vector register according to the individual
<span>vmaxew</span> settings and which within one configuration can
execute instructions with narrower datatypes at higher rates than for
wider datatypes. The Berkeley Hwacha vector
engine <span class="citation" data-cites="hwachatr mixedprecision"><a href="#ref-hwachatr">[hwachatr mixedprecision]</a></span> is an example microarchitecture
with this property.</p>
</div>
<p><span><strong>Following Sections are out-of-date.</strong></span></p>
<h2 id="vector-instruction-formats"><span class="header-section-number">21.12</span> Vector Instruction Formats</h2>
<div class=commentary>
<p>The instruction encoding is a work in progress.</p>
<p>An important design goal was that the base vector extension fit
within a few major opcodes of the 32-bit encoding. It is envisioned
that future vector extensions will use 48-bit or 64-bit encodings to
increase both the opcode space and the set of architectural
registers. The 64-bit vector encoding would support 256
architectural vector registers and orthogonal specification of a
predicate register in each instruction.</p>
</div>
<p>Vector arithmetic and vector memory instructions are encoded in new
variants of the R-format, shown in Figure <a href="v.html#fig:vinstformats" data-reference-type="ref" data-reference="fig:vinstformats">1.8</a>.
Both new formats use one bit to hold a <span><em>vp</em></span> field, which usually
controls the predicate register in use, either <span>vp0</span> or <span>vp1</span>.
The VR4 form is used for fused multiply-add instructions. The
existing RISC-V instruction formats are used for other vector-related
instructions, such as the vector configuration instructions.</p>
<figure>
<img src="tmp.20181106-Base-Ratification//v_07.svg" alt="New V extension instruction formats. " id="fig:vinstformats" /><figcaption>New V extension instruction formats. <span label="fig:vinstformats"></span></figcaption>
</figure>
<p>Most vector instructions are available in both vector-vector and
vector-scalar variants. Vector-vector instructions take the first
operand from the vector register specified by <span><em>rs1</em></span> and the second
operand from the vector register specified by <span><em>rs2</em></span>.</p>
<p>For vector-scalar operations, the <span><em>rs1</em></span> field specifies the scalar
register to be accessed. For most vector-scalar instructions, the
type of the vector operand specified by <span><em>rs2</em></span> indicates whether
the integer or floating-point scalar register file is accessed using
the <span><em>rs1</em></span> register specifier.</p>
<p>Some non-commutative vector-scalar instructions (such as sub) are
provided in two forms, with the scalar value used as the second
operand.</p>
<div class=commentary>
<p>The <span><em>rs1</em></span> field is used to provide the scalar operand because in
the base encoding, whenever an instruction has a single scalar
source operand, it is encoded in the <span>rs1</span> field.</p>
</div>
<h2 id="polymorphic-vector-instructions"><span class="header-section-number">21.13</span> Polymorphic Vector Instructions</h2>
<p>The vector extension uses a polymorphic instruction encoding where the
opcode is combined with the types of the source and destination
registers to determine the operation to be performed. For example, an
ADD opcode will perform a 32-bit integer vector-vector add if both
vector source operands and the vector destination register are 32-bit
integers, but will perform a 16-bit floating-point vector-vector
operation if both vector source operands and the vector destination
are 16-bit floats.</p>
<p>The polymorphic encoding also naturally supports operations with mixed
precisions on the input and output, and also supports extending the
instruction set with new types without necessarily increasing the
opcode space.</p>
<p>Not all combinations of source and destination argument types need be
supported. The base vector extension mandates only that
implementations provide a subset of combinations of types on inputs
and outputs. Table <a href="v.html#tab:vtypemix" data-reference-type="ref" data-reference="tab:vtypemix">1.9</a> shows the general rules for
integer and floating-point instructions, but the detailed instruction
listing should be consulted for accurate information.</p>
<figure>
<img src="tmp.20181106-Base-Ratification//v_08.svg" alt="General rules for supported types per instruction in base vector extension. X represents the number of bits in an integer type and F represents the number of bits in a floating-point type. Individual instruction types will provide more detailed listings. Note that the type of a scalar floating-point operand can never be different from that of the vector in Src2, hence the Src1=2F case is missing from vector-scalar operations." id="tab:vtypemix" /><figcaption>General rules for supported types per instruction in base
vector extension. X represents the number of bits in an integer
type and F represents the number of bits in a floating-point type.
Individual instruction types will provide more detailed listings.
Note that the type of a scalar floating-point operand can never be
different from that of the vector in Src2, hence the Src1=2F case
is missing from vector-scalar operations.<span label="tab:vtypemix"></span></figcaption>
</figure>
<p>A general rule in the base vector instruction set is that the
destination precision is never less than any source operand, except
for explicit type-conversion instructions. Another general rule is
that the input operands can only be the same width or half the width
of the destination operand except for the scalar operand in integer
vector-scalar instructions, which is always XLEN wide. Also, src2 is
never larger than src1 or src3.</p>
<p>Integer computations of mixed-precision values always aligns values by
their LSB, and sign or zero-extends any smaller value according to its
type. The result is truncated to fit in the destination type. Note a
scalar integer value is already XLEN bits wide, and as wide as any
possible integer vector value.</p>
<p>Floating-point computations on mixed-precision values acts as if the
calculations are performed exactly then rounded once to the
destination format.</p>
<h2 id="rapid-configuration-instructions"><span class="header-section-number">21.14</span> Rapid Configuration Instructions</h2>
<p>It can take several CSR instructions to set up the <span>vcfg</span> and
<span>vnp</span> CSRs for a given configuration. Specialized configuration
instructions are provided to quickly set up common configurations in
the <span>vcfg</span> and <span>vnp</span> CSRs.</p>
<p>The <span>vsetdcfg</span> instruction takes a scalar register value encoded as
shown in Figure <a href="v.html#fig:vcfg" data-reference-type="ref" data-reference="fig:vcfg">1.10</a>, and returns the corresponding MVL in
the destination register. The <span>vsetdcfg</span> and <span>vsetdcfgi</span>
instructions also clear the <span>vnp</span> register, so no predicate
registers are allocated.</p>
<p>CUSTOMTAGBEGINDISCUSSION</p>
<p>For now, only a 32-bit value supporting up to three different vector
data types is supported by the <span>vsetdcfg</span> instruction. RV64 and
RV128 could support larger number of types, though it’s not clear if
the hardware cost (area, latency) to support a larger number of
different types is justified.</p>
<p>CUSTOMTAGENDDISCUSSION</p>
<figure>
<img src="tmp.20181106-Base-Ratification//v_09.svg" alt="Format of the vsetdcfg value. The value contains three pairs of a 5-bit type and a 5-bit number of registers to create of that type. A value of 0 for the number of a type indicates that 32 registers should be allocated. A value of 0 for the type indicates this pair should be skipped. The types must be of monotonically increasing size from type0 to type2. " id="fig:vcfg" /><figcaption>Format of the <span>vsetdcfg</span> value. The value contains
three pairs of a 5-bit type and a 5-bit number of registers
to create of that type. A value of 0 for the number of a type
indicates that 32 registers should be allocated. A value of 0 for
the type indicates this pair should be skipped. The types must be
of monotonically increasing size from type0 to type2. <span label="fig:vcfg"></span></figcaption>
</figure>
<p>The <span>vsetdcfg</span> value specifies how many vector registers of each
datatype are allocated, and is divided into a 2-bit mode field and
pairs of 5-bit fields for each data type in the configuration.</p>
<p>The 2-bit mode field indicates the configuration mode of the vector
unit and is zero for the base vector extension.</p>
<div class=commentary>
<p>The standard vector extension operating mode configures the vector
unit into some number of vector registers, each with some number of
elements of types supported by the scalar unit.</p>
<p>At least one alternative mode is planned, where the vector unit is
configured as some number of registers each holding a single large
element, e.g., 256 bits. This would be the base for cryptographic
operations, or other coprocessors that operated on large structures.</p>
<p>Other modes can be used to reconfigure the vector unit register file
and functional units for other domain-specific purposes.</p>
</div>
<p>Each datatype pair contains a 5-bit <span>type</span><span class="math inline"><em>x</em></span> value encoded as a
<span>vetype</span><span class="math inline"><em>n</em></span> value, and a 5-bit <span>ntype</span><span class="math inline"><em>x</em></span> for the number of
registers to allocate for that type. If the <span>type0</span> field is
non-zero, the <span>vsetdcfg</span> instruction will configure the first <span>
ntype0</span> vector data registers to have <span>vetype</span><span class="math inline"><em>n</em></span> values of <span>
type0</span> with <span>vmaxew</span><span class="math inline"><em>n</em></span> values set accordingly as shown in
Table <a href="#tab:vetype" data-reference-type="ref" data-reference="tab:vetype">[tab:vetype]</a>. If the <span>type0</span> value is 0, the datatype
pair is skipped. If the <span>type1</span> field is non-zero, then the next
<span>ntype1</span> vector registers are configured to be of the type given
in <span>type1</span>. Similarly for the <span>type2</span> pair.</p>
<p>A value of zero in a <span>type</span><span class="math inline"><em>x</em></span> field indicates this datatype pair
should be ignored. A value of zero in a <span>ntype</span><span class="math inline"><em>x</em></span> field
indicates 32 registers should be allocated for the corresponding type.</p>
<div class=commentary>
<p>Zero values are skipped to simplify setting a configuration with two
different data types, where a single LUI instruction can set the upper
20 bits leaving the low bits zero.</p>
<p>A single 12-bit immediate value is sufficient to create a
configuration with some number of vector registers with a single given
datatype.</p>
<p>A compressed C.LI with a zero-extended 5-bit immediate can create a
configuration with 32 vector registers of a given datatype.</p>
</div>
<p>A corresponding <span>vsetdcfgi</span> instruction takes a 12-bit immediate
value to set the configuration instead of a scalar value, but
otherwise is identical to the <span>vsetcfgd</span> instruction.</p>
<p>CUSTOMTAGBEGINDISCUSSION</p>
<p>It is not clear how many immediate bits will be made available for the
<span>vsetdcfgi</span> instruction. If encoding space is available for both
12 immediate bits and a source register specifier, then <span>
vsetdcgfi</span> can be defined to read the source register, OR in the
bits in the immediate, then create a configuration. In this case,
there is no need for a separate <span>vsetdcfg</span> instruction.</p>
<p>CUSTOMTAGENDDISCUSSION</p>
<p>The configuration value given must result in a legal configuration or
else an illegal instruction exception will be raised.</p>
<p>If a zero argument is given to <span>vsetdcfg</span> the vector unit will be
disabled and the value 0 will be returned for MVL. This instruction
(<span>vsetdcfg x0, x0</span>) is given the assembly pseudo-code <span>
vdisable</span>.</p>
<p>Separate <span>vsetpcfg</span> and <span>vsetpcfgi</span> instructions are provided
that write the source value to the <span>vnp</span> register and return the
new MVL. These writes also clear the vector data registers, set all
bits in the allocated predicate registers, and set <span>vl</span>=MVL. A
<span>vsetpcfg</span> or <span>vsetpcfgi</span> instruction can be used after a <span>
vsetdcfg</span> to complete a reconfiguration of the vector unit.</p>
<p>CUSTOMTAGBEGINDISCUSSION</p>
<p>If <span>vnp</span> is made accessible as a separate CSR, the <span>setpcfg</span>
and <span>setpcfgi</span> instructions are less useful. The only advantage
over a CSR instruction is that they return MVL, which is rarely
needed, and which can be obtained via that <span>setvl</span> instruction.</p>
<p>CUSTOMTAGENDDISCUSSION</p>
<h2 id="vector-type-change-instructions"><span class="header-section-number">21.15</span> Vector-Type-Change Instructions</h2>
<p>To quickly change the individual types of a vector register, <span>
vetyperw</span> and <span>vetyperwi</span> instructions are provided to change
the type of the specified vector data register to the given scalar
register value or 5-bit immediate value respectively, while returning
the previous type in the destination scalar register.</p>
<p>A vector convert instruction, described below, can simultaneously
convert a source vector register into a new type, and set that type in
the destination vector register.</p>
<h2 id="vector-length"><span class="header-section-number">21.16</span> Vector Length</h2>
<p>The active vector length is held in the XLEN-bit WARL vector length
CSR <span>vl</span>, which can only hold values between 0 and MVL inclusive.
Any writes to the configuration registers (<span>vcfg</span><span class="math inline"><em>x</em></span> or <span>
vnp</span>) cause <span>vl</span> to be initialized with MVL. Changes to <span>
vetype</span><span class="math inline"><em>n</em></span> via vector-type-change instructions do not affect <span>
vl</span>.</p>
<p>The active vector length is usually set via the <span>setvl</span>
instruction. The source argument to the <span>setvl</span> is the requested
application vector length (AVL) as an unsigned XLEN-bit integer. The
<span>setvl</span> instruction calculates the value to assign to <span>vl</span>
according to Table <a href="v.html#tab:vlcalc" data-reference-type="ref" data-reference="tab:vlcalc">[tab:vlcalc]</a>. The result of this calculation
is also returned as the result of the <span>setvl</span> instruction.</p>
<div class=commentary>
<p>Earlier drafts encoded <span>setvl</span> using a modified CSRRW instruction
whereas it is now encoded as a separate new instruction.</p>
</div>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">AVL Value</th>
<th style="text-align: center;"><span>vl</span> setting</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">AVL <span class="math inline">≥</span> 2 MVL</td>
<td style="text-align: center;">MVL</td>
</tr>
<tr class="even">
<td style="text-align: center;">2 MVL <span class="math inline">&gt;</span> AVL <span class="math inline">&gt;</span> MVL</td>
<td style="text-align: center;"><span class="math inline">⌈</span>AVL<span class="math inline">/2⌉</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;">MVL <span class="math inline">≥</span> AVL</td>
<td style="text-align: center;">AVL</td>
</tr>
</tbody>
</table>
<div class=commentary>
<p>The rules for setting the <span>vl</span> register help keep vector
pipelines full over the last two iterations of a stripmined loop.
This version of the rules guarantees monotonically decreasing vector
lengths.
Similar rules were previously used in Cray-designed machines <span class="citation" data-cites="crayx1asm"><a href="#ref-crayx1asm">[crayx1asm]</a></span>.</p>
</div>
<p>CUSTOMTAGBEGINDISCUSSION</p>
<p>There are multiple possible rules for setting VL, and we could give
implementations freedom to use different VL setting rules.</p>
<p>CUSTOMTAGENDDISCUSSION</p>
<div class=commentary>
<p>The idea of having implementation-defined vector length dates back
to at least the IBM 3090 Vector Facility <span class="citation" data-cites="ibm370varch"><a href="#ref-ibm370varch">[ibm370varch]</a></span>, which
used a special “Load Vector Count and Update” (VLVCU) instruction
to control stripmine loops. The <span>setvl</span> instruction included
here is based on the simpler <span>setvlr</span> instruction introduced by
Asanović <span class="citation" data-cites="krstephd"><a href="#ref-krstephd">[krstephd]</a></span>.</p>
</div>
<p>The <span>setvl</span> instruction is typically used at the start of every
iteration of a stripmined loop to set the number of vector elements to
operate on in the following loop iteration. The current MVL can be
obtained from a vector configuration instruction, or by performing a
<span>setvl</span> with a source argument that has all bits set (largest
unsigned integer).</p>
<p>When <span>vl</span> is less than MVL, vector instructions will set all
elements in the range [<span>vl</span>:MAXVL-1] in the destination vector
data register or destination vector predicate register to zero.</p>
<div class=commentary>
<p>Requiring zeroing of elements past the current active vector length
simplifies the design of units with renamed vector data registers.
If the specification left destination elements unchanged, renaming
implementations would have to copy the tail of the old destination
register to the newly allocated destination register.
Alternatively, specifying the tail to be undefined will expose
implementation differences and possibly cause a security hole.</p>
<p>Implementations that do not support renaming, will have to zero the
tail of a vector, but this can reuse the mechanism that is already
required to initialize all vector data registers to zero on
reconfiguration, for example, by having a zero bit on each element
or element group.</p>
</div>
<p>No element operations are performed for any vector instruction when
<span>vl</span>=0.</p>
<div class=commentary>
<p>Two possible choices are to 1) require destination registers to be
completely zeroed when <span>vl</span>=0, or 2) no changes to the
destination registers. Option 2 is currently chosen as this will
prevents unnecessary work in some implementations, and option 1 does
not provide a clear advantage beyond seeming more consistent with
<span>vl</span>&gt;0 case.</p>
</div>
<figure>
<img src="tmp.20181106-Base-Ratification//v_10.svg" alt="Example vector-vector add loop." id="fig:vvadd" /><figcaption>Example vector-vector add loop.<span label="fig:vvadd"></span></figcaption>
</figure>
<h2 id="predicated-execution"><span class="header-section-number">21.17</span> Predicated Execution</h2>
<div class=commentary>
<p>The 32-bit base encoding does not leave room for a fully orthogonal
predicate register specifier. A single bit is dedicated to the
predicate register specification, and is used to select between two
active predicate registers, <span>vp0</span> or <span>vp1</span>. An alternative
scheme would have used the bit to select between <span>vp0</span> and
unpredicated (all elements active). However, given the ease of
setting all predicate bits in a vector predicate register with a
single predicate instruction, the current scheme provides more
flexibility.</p>
<p>When there are no vector predicate registers enabled, <span>vp0</span>
returns all set bits when read. So, the assembler convention is to
assume <span>vp0</span> as the predicate register when no predicate
register is explicitly given. The assembler can support a strict
operands option to require the vector predicate register is
explicitly specified.</p>
</div>
<p>At element positions where the selected predicate register bit is
zero, the corresponding vector element operation has no effect (does
not change architectural state or generate exceptions), except to
write a zero to the element position in the destination vector
register.</p>
<p>CUSTOMTAGBEGINDISCUSSION</p>
<p>The previous proposal (undisturb) left the destination vector
unchanged at element positions where the predicate bit is false,
whereas the current plan-of-record (zero) writes zero to the
destination where the predicate bit is false.</p>
<p>The advantage of the undisturb option is that it can require fewer
instructions and fewer architectural registers for many common code
sequences. For in-order machines without register renaming, the
undisturb operation simply disables writes to the destination
elements, except for vector registers that have not been written
since configuration time. Typically an extra zero bit per vector
register or element group will be added to represent a zeroed
register instead of actually zeroing state at configuration time.
For predicated undisturb writes to these uninitialized registers,
the predicated false elements must be explicitly written with zeros
on each element group and the zero bit is then cleared down.
However, in a machine with vector register renaming, undisturb does
imply an additional read of the original destination register to
write the value into the new physical destination register when the
predicate is false. This additional read port will often be cheaper
than in a scalar machine as vector machines often time-multiplex
read ports, and the additional read can be skipped when the
predicate registers are disabled (<span>vnp</span>=0) or when the source is
known to be zero after configuration, but still adds complexity to a
design.</p>
<p>The advantage of the zero option is that a machine with vector
register renaming does not need to read the original destination
vector register and so a read port is saved. The disadvantage of
the zero option is that more instructions and architectural
registers are required for common code sequences, and simpler
microarchitectures without register renaming are penalized by
requiring longer code sequences and greater register pressure. In
particular, vector merge instructions are required to collect
results from two divergent control paths, and each vector merge has
to read two vector values and write a vector result. Whether the
zero option saves total register file traffic in an register-renamed
microarchitecture depends on the ratio of a) internal temporary
writes, to b) writes creating values that are live out of each basic
block, and also to the frequency of control flow merges.</p>
<p>Overall, the zero option removes significant complexity from the
renamed machines while reducing efficiency somewhat for the
non-renamed machines, and is the current plan-of-record.</p>
<p>CUSTOMTAGENDDISCUSSION</p>
<h2 id="vector-loadstore-instructions"><span class="header-section-number">21.18</span> Vector Load/Store Instructions</h2>
<p>Three vector load/store addressing modes are supported, unit-stride,
constant stride, and indexed (scatter/gather). Each addressing mode
has a 7-bit unsigned immediate offset that is scaled by the element
type.</p>
<p>The unit-stride address mode takes a scalar base byte address, adds
the scaled immediate, then generates a contiguous set of element
addresses for loads or stores.</p>
<div class=commentary>
<p>The primary use of immediates in unit-stride loads is to generate
overlapping unit-stride loads for convolution operations.</p>
</div>
<p>The constant-stride address mode takes a scalar base byte address, a
stride value encoded in bytes, and adds a scaled immediate value.</p>
<div class=commentary>
<p>The stride value is in bytes to allow a single stride register to be
used to support operations on arrays-of-structures, where not all
elements in each structure have the same size. The immediate value
is still scaled by element size to increase reach, given that
element types will be naturally aligned.</p>
</div>
<p>The indexed address mode takes a scalar base byte address and a vector
of byte offsets. The scalar base address and the immediate value are
added to element of the offset vector to give a vector of addresses
used in a scatter/gather.</p>
<p>Indexed stores are provided in three types. Unordered, ordered, and
reverse-ordered. The unordered indexed stores might update the same
memory location from two different elements in an unspecified order.
The ordered stores always update memory locations in increasing vector
element order. The reverse-ordered stores always update memory
locations in decreasing memory order.</p>
<div class=commentary>
<p>The reverse-ordered stores support vectorization of software memory
disambiguation techniques. A reverse-ordered store of element id
into a hash table indexed by a hash on a store access address,
followed by a read of the hash table using a load access address and
a comparison against the original element id, will indicate if
there’s a potential RAW hazard with an earlier loop iteration.</p>
</div>
<p>CUSTOMTAGBEGINDISCUSSION</p>
<p>Not clear if there is sufficient realizable improvement for
supporting unordered stores over ordered stores.</p>
<p>CUSTOMTAGENDDISCUSSION</p>
<p>Vector loads/stores have a simple memory model, where each vector
load/store is observed to complete sequentially in program order only
the local hart, i.e., a vector load on a hart will observe all earlier
vector stores on the same hart, and no later vector stores.</p>
<p>Vector loads are available in a length-speculative form that writes
predicate register <span>vp1</span> in addition to the destination vector
data register. These instructions raise an illegal instruction
exception if <span>vp1</span> is not configured. For elements that do not
generate a permissions fault, the length-speculative vector loads
operate as normally except to also clear the bit in <span>vp1</span>. If an
element encounters a permission fault, a zero is written to the
destination vector register element and the <span>vp1</span> bit is set to a
1. Implementations may treat elements past the first faulting element
as also causing a fault even if they might not cause a permissions
fault when accessed alone.</p>
<p>Once software determines the active vector length, it should check if
any loads within the active vector length caused a fault, and in this
case, generate a non-length-speculative load to trigger reporting of
the error.</p>
<div class=commentary>
<p>Length-speculative vector loads are required to vectorize while
loops, with data-dependent exits (e.g. strlen).</p>
<p>The only faults ignored by the length-speculative vector loads are
ones that would have resulted in a permissions violation. Page
faults and other virtualization-related faults should be handled
invisibly to the user thread by the execution environment.</p>
<p>A malicious program can use length-speculative vector loads to probe
accessible address space without fear of a fatal fault.</p>
</div>
<h2 id="vector-register-gather"><span class="header-section-number">21.19</span> Vector Register Gather</h2>
<p>A vector register gather produces a new result data vector by gathering
elements from one source data vector at the element locations
specified by a second source index vector. Data source and
destination vector types must agree. The index vector can have any
integer type. Legal element indices can range from 0 to current
MAXVL. Indices out of this range raise an illegal instruction
exception.</p>
<pre><code>  # vindices holds values from 0..MAXVL
  vrgather  vdest, vsrc, vindices</code></pre>
<h2 id="vector-slide"><span class="header-section-number">21.20</span> Vector Slide</h2>
<p>Reductions (and convolutions) are supported via a vector slide
instruction that takes elements starting from the middle of one vector
and places these at the beginning of a second vector register. This
supports a recursive-halving reduction approach for any binary
associative operator.</p>
<div class=commentary>
<p>A similar vector register extract instruction was added to the Cray
C90 after memory latency grew too large for the memory-memory
reductions used in earlier Crays.</p>
<p>The vector unit microarchitecture can be optimized for the
power-of-2 sized element offsets used for reductions.</p>
</div>
<h2 id="fixed-point-support"><span class="header-section-number">21.21</span> Fixed-Point Support</h2>
<p>Clip instruction supports scaling, rounding, and clipping to
destination type. Rounding set by CSR fixed-point rounding mode
(truncate, jam, round-up, round-nearest-even). Clipping set by CSR
clip mode (wrap, saturate).</p>
<p>Add with average, rounding set by rounding mode.</p>
<p>Multiply with same size source and destination types, with some result
scaling values (+1, 0, -1, -8?) and rounding and clipping according to
CSR mode.</p>
<p>Accumulate with carry into predicate register to support larger
precise dot-products.</p>
<h2 id="optional-transcendental-support"><span class="header-section-number">21.22</span> Optional Transcendental Support</h2>
<h2 id="instruction-set-encoding"><span class="header-section-number">21.23</span> Instruction-Set Encoding</h2>
<p><span><strong>[ NOTE: This section is out of date. ]</strong></span></p>
<p>On the next two pages is a proposed instruction-set encoding.</p>
<p><a href="#v-instr-table" data-reference-type="ref" data-reference="v-instr-table">[v-instr-table]</a></p>

</body>
</html>
