<html>
<head>
<link rel="stylesheet" href="../../assets/docs.css">
<title>RISC-V Instruction Set Manual, Volume I: RISC-V User-Level ISA</title>
</head>
<body>

<table>
<tr><th colspan=2>Metadata Table</th></tr>
<tr><th>Manual Type</th><td> user</td></tr>
<tr><th>Spec Revision</th><td> </td></tr>
<tr><th>Spec Release Date</th><td> </td></tr>
<tr><th>Git Revision</th><td> riscv-isa-release-1239329-2023-05-23-96-g1ee25e1</td></tr>
<tr><th>Git URL</th><td><a href=https://github.com/riscv/riscv-isa-manual.git>https://github.com/riscv/riscv-isa-manual.git</a></td></tr>
<tr><th>Source</th><td>src/zfinx.adoc</td></tr>
<tr><th>Conversion Date</th><td>2023/11/12</td></tr>
<tr><th>License</th><td><a href=https://creativecommons.org/licenses/by/4.0/>CC-by-4.0</a></td></tr>
</table>

<div class="sect1">
<h2 id="sec:zfinx">1. "Zfinx", "Zdinx", "Zhinx", "Zhinxmin": Standard Extensions for Floating-Point in Integer Registers, Version 1.0</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This chapter defines the "Zfinx" extension (pronounced "z-f-in-x")
that provides instructions similar to those in the standard
floating-point F extension for single-precision floating-point
instructions but which operate on the <code>x</code> registers instead of the <code>f</code>
registers. This chapter also defines the "Zdinx", "Zhinx", and
"Zhinxmin" extensions that provide similar instructions for other
floating-point precisions.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The F extension uses separate <code>f</code> registers for floating-point
computation, to reduce register pressure and simplify the provision of
register-file ports for wide superscalars. However, the additional of
architectural state increases the minimal implementation cost. By
eliminating the <code>f</code> registers, the Zfinx extension substantially reduces
the cost of simple RISC-V implementations with floating-point
instruction-set support. Zfinx also reduces context-switch cost.</p>
</div>
<div class="paragraph">
<p>In general, software that assumes the presence of the F extension is
incompatible with software that assumes the presence of the Zfinx
extension, and vice versa.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The Zfinx extension adds all of the instructions that the F extension
adds, <em>except</em> for the transfer instructions FLW, FSW, FMV.W.X, FMV.X.W,
C.FLW[SP], and C.FSW[SP].</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Zfinx software uses integer loads and stores to transfer floating-point
values from and to memory. Transfers between registers use either
integer arithmetic or floating-point sign-injection instructions.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The Zfinx variants of these F-extension instructions have the same
semantics, except that whenever such an instruction would have accessed
an <code>f</code> register, it instead accesses the <code>x</code> register with the same
number.</p>
</div>
<div class="paragraph">
<p>The Zfinx extension depends on the "Zicsr" extension for control and status register access.</p>
</div>
<div class="sect2">
<h3 id="_processing_of_narrower_values">1.1. Processing of Narrower Values</h3>
<div class="paragraph">
<p>Floating-point operands of width <em>w</em> \(&lt;\) XLEN bits occupy
bits <em>w</em>-1:0 of an <code>x</code> register. Floating-point operations on <em>w</em>-bit
operands ignore operand bits XLEN-1: <em>w</em>.</p>
</div>
<div class="paragraph">
<p>Floating-point operations that produce <em>w</em> \(&lt;\) XLEN-bit
results fill bits XLEN-1: <em>w</em> with copies of bit <em>w</em>-1 (the sign bit).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The NaN-boxing scheme employed in the <code>f</code> registers was designed to
efficiently support recoded floating-point formats. Recoding is less
practical for Zfinx, though, since the same registers hold both
floating-point and integer operands. Hence, the need for NaN boxing is
diminished.</p>
</div>
<div class="paragraph">
<p>Sign-extending 32-bit floating-point numbers when held in RV64 <code>x</code>
registers is compatible with the existing RV64 calling conventions, which leave bits 63-32 undefined when passing a 32-bit floating point value in <code>x</code> registers. To keep the architecture more regular, we extend this pattern to 16-bit floating-point numbers in both RV32 and RV64.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_zdinx">1.2. Zdinx</h3>
<div class="paragraph">
<p>The Zdinx extension provides analogous double-precision floating-point
instructions. The Zdinx extension requires the Zfinx extension.</p>
</div>
<div class="paragraph">
<p>The Zdinx extension adds all of the instructions that the D extension
adds, <em>except</em> for the transfer instructions FLD, FSD, FMV.D.X, FMV.X.D,
C.FLD[SP], and C.FSD[SP].</p>
</div>
<div class="paragraph">
<p>The Zdinx variants of these D-extension instructions have the same
semantics, except that whenever such an instruction would have accessed
an <code>f</code> register, it instead accesses the <code>x</code> register with the same
number.</p>
</div>
</div>
<div class="sect2">
<h3 id="_processing_of_wider_values">1.3. Processing of Wider Values</h3>
<div class="paragraph">
<p>Double-precision operands in RV32Zdinx are held in aligned <code>x</code>-register
pairs, i.e., register numbers must be even. Use of misaligned
(odd-numbered) registers for double-width floating-point operands is
<em>reserved</em>.</p>
</div>
<div class="paragraph">
<p>Regardless of endianness, the lower-numbered register holds the
low-order bits, and the higher-numbered register holds the high-order
bits: e.g., bits 31:0 of a double-precision operand in RV32Zdinx might
be held in register <code>x14</code>, with bits 63:32 of that operand held in
<code>x15</code>.</p>
</div>
<div class="paragraph">
<p>When a double-width floating-point result is written to <code>x0</code>, the entire
write takes no effect: e.g., for RV32Zdinx, writing a double-precision
result to <code>x0</code> does not cause <code>x1</code> to be written.</p>
</div>
<div class="paragraph">
<p>When <code>x0</code> is used as a double-width floating-point operand, the entire
operand is zeroâ€”i.e., <code>x1</code> is not accessed.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Load-pair and store-pair instructions are not provided, so transferring
double-precision operands in RV32Zdinx from or to memory requires two
loads or stores. Register moves need only a single FSGNJ.D instruction,
however.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_zhinx">1.4. Zhinx</h3>
<div class="paragraph">
<p>The Zhinx extension provides analogous half-precision floating-point
instructions. The Zhinx extension requires the Zfinx extension.</p>
</div>
<div class="paragraph">
<p>The Zhinx extension adds all of the instructions that the Zfh extension
adds, <em>except</em> for the transfer instructions FLH, FSH, FMV.H.X, and
FMV.X.H.</p>
</div>
<div class="paragraph">
<p>The Zhinx variants of these Zfh-extension instructions have the same
semantics, except that whenever such an instruction would have accessed
an <code>f</code> register, it instead accesses the <code>x</code> register with the same
number.</p>
</div>
</div>
<div class="sect2">
<h3 id="_zhinxmin">1.5. Zhinxmin</h3>
<div class="paragraph">
<p>The Zhinxmin extension provides minimal support for 16-bit
half-precision floating-point instructions that operate on the <code>x</code>
registers. The Zhinxmin extension requires the Zfinx extension.</p>
</div>
<div class="paragraph">
<p>The Zhinxmin extension includes the following instructions from the
Zhinx extension: FCVT.S.H and FCVT.H.S. If the Zdinx extension is
present, the FCVT.D.H and FCVT.H.D instructions are also included.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>In the future, an RV64Zqinx quad-precision extension could be defined
analogously to RV32Zdinx. An RV32Zqinx extension could also be defined
but would require quad-register groups.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_privileged_architecture_implications">1.6. Privileged Architecture Implications</h3>
<div class="paragraph">
<p>In the standard privileged architecture defined in Volume II, the
<code>mstatus</code> field FS is hardwired to 0 if the Zfinx extension is
implemented, and FS no longer affects the trapping behavior of
floating-point instructions or <code>fcsr</code> accesses.</p>
</div>
<div class="paragraph">
<p>The <code>misa</code> bits F, D, and Q are hardwired to 0 when the Zfinx extension
is implemented.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>A future discoverability mechanism might be used to probe the existence
of the Zfinx, Zhinx, and Zdinx extensions.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>

</body>
</html>