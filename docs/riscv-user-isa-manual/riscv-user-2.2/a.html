<html>
<head>
<title>RISC-V Instruction Set Manual, Volume I: RISC-V User-Level ISA</title>
</head>
<body>

<table>
<tr><th colspan=2>Metadata Table</th></tr>
<tr><th>Manual Type</th><td> user</td></tr>
<tr><th>Spec Revision</th><td> </td></tr>
<tr><th>Spec Release Date</th><td> </td></tr>
<tr><th>Git Revision</th><td> riscv-priv-1.10</td></tr>
<tr><th>Git URL</th><td><a href=https://github.com/riscv/riscv-isa-manual.git>https://github.com/riscv/riscv-isa-manual.git</a></td></tr>
<tr><th>Source</th><td>src/a.tex</td></tr>
<tr><th>Conversion Date</th><td>2023/10/11</td></tr>
<tr><th>License</th><td><a href=https://creativecommons.org/licenses/by/4.0/>CC-by-4.0</a></td></tr>
</table>


<h1 id="atomics"><span class="header-section-number">9</span> “A” Standard Extension for Atomic Instructions, Version 2.0</h1>
<div class=commentary>
<p>This section is somewhat out of date as the RISC-V memory model is
currently under revision to ensure it can efficiently support current
programming language memory models. The revised base memory model
will contain further ordering constraints, including at least that
loads to the same address from the same hart cannot be reordered, and
that syntactic data dependencies between instructions are respected.</p>
</div>
<p>The standard atomic instruction extension is denoted by instruction
subset name “A”, and contains instructions that atomically
read-modify-write memory to support synchronization between multiple
RISC-V harts running in the same memory space. The two forms of
atomic instruction provided are load-reserved/store-conditional
instructions and atomic fetch-and-op memory instructions. Both types
of atomic instruction support various memory consistency orderings
including unordered, acquire, release, and sequentially consistent
semantics. These instructions allow RISC-V to support the RCsc memory
consistency model <span class="citation" data-cites="Gharachorloo90memoryconsistency"><a href="#ref-Gharachorloo90memoryconsistency">[Gharachorloo90memoryconsistency]</a></span>.</p>
<div class=commentary>
<p>After much debate, the language community and architecture community
appear to have finally settled on release consistency as the standard
memory consistency model and so the RISC-V atomic support is built
around this model.</p>
</div>
<h2 id="specifying-ordering-of-atomic-instructions"><span class="header-section-number">9.1</span> Specifying Ordering of Atomic Instructions</h2>
<p>The base RISC-V ISA has a relaxed memory model, with the FENCE
instruction used to impose additional ordering constraints. The
address space is divided by the execution environment into memory and
I/O domains, and the FENCE instruction provides options to order
accesses to one or both of these two address domains.</p>
<p>To provide more efficient support for release
consistency <span class="citation" data-cites="Gharachorloo90memoryconsistency"><a href="#ref-Gharachorloo90memoryconsistency">[Gharachorloo90memoryconsistency]</a></span>, each atomic
instruction has two bits, <span><em>aq</em></span> and <span><em>rl</em></span>, used to specify
additional memory ordering constraints as viewed by other RISC-V
harts. The bits order accesses to one of the two address domains,
memory or I/O, depending on which address domain the atomic
instruction is accessing. No ordering constraint is implied to
accesses to the other domain, and a FENCE instruction should be used
to order across both domains.</p>
<p>If both bits are clear, no additional ordering constraints are imposed
on the atomic memory operation. If only the <span><em>aq</em></span> bit is set, the
atomic memory operation is treated as an <span><em>acquire</em></span> access, i.e.,
no following memory operations on this RISC-V hart can be observed
to take place before the acquire memory operation. If only the <span>
<em>rl</em></span> bit is set, the atomic memory operation is treated as a <span>
<em>release</em></span> access, i.e., the release memory operation can not be
observed to take place before any earlier memory operations on this
RISC-V hart. If both the <span><em>aq</em></span> and <span><em>rl</em></span> bits are set, the
atomic memory operation is <span><em>sequentially consistent</em></span> and cannot be
observed to happen before any earlier memory operations or after any
later memory operations in the same RISC-V hart, and can only be
observed by any other hart in the same global order of all
sequentially consistent atomic memory operations to the same address
domain.</p>
<div class=commentary>
<p>Theoretically, the definition of the <span><em>aq</em></span> and <span><em>rl</em></span> bits allows
for implementations without global store atomicity. When both <span>
<em>aq</em></span> and <span><em>rl</em></span> bits are set, however, we require full sequential
consistency for the atomic operation which implies global store
atomicity in addition to both acquire and release semantics. In
practice, hardware systems are usually implemented with global store
atomicity, embodied in local processor ordering rules together with
single-writer cache coherence protocols.</p>
</div>
<h2 id="load-reservedstore-conditional-instructions"><span class="header-section-number">9.2</span> Load-Reserved/Store-Conditional Instructions</h2>
<p><img src="a_00.svg" alt="image" /></p>
<p>Complex atomic memory operations on a single memory word are performed
with the load-reserved (LR) and store-conditional (SC) instructions.
LR loads a word from the address in <span><em>rs1</em></span>, places the
sign-extended value in <span><em>rd</em></span>, and registers a reservation on the
memory address. SC writes a word in <span><em>rs2</em></span> to the address in <span>
<em>rs1</em></span>, provided a valid reservation still exists on that address. SC
writes zero to <span><em>rd</em></span> on success or a nonzero code on failure.</p>
<div class=commentary>
<p>Both compare-and-swap (CAS) and LR/SC can be used to build lock-free
data structures. After extensive discussion, we opted for LR/SC for
several reasons: 1) CAS suffers from the ABA problem, which LR/SC
avoids because it monitors all accesses to the address rather than
only checking for changes in the data value; 2) CAS would also require
a new integer instruction format to support three source operands
(address, compare value, swap value) as well as a different memory
system message format, which would complicate microarchitectures; 3)
Furthermore, to avoid the ABA problem, other systems provide a
double-wide CAS (DW-CAS) to allow a counter to be tested and
incremented along with a data word. This requires reading five
registers and writing two in one instruction, and also a new larger
memory system message type, further complicating implementations; 4)
LR/SC provides a more efficient implementation of many primitives as
it only requires one load as opposed to two with CAS (one load before
the CAS instruction to obtain a value for speculative computation,
then a second load as part of the CAS instruction to check if value is
unchanged before updating).</p>
<p>The main disadvantage of LR/SC over CAS is livelock, which we avoid
with an architected guarantee of eventual forward progress as
described below. Another concern is whether the influence of the
current x86 architecture, with its DW-CAS, will complicate porting of
synchronization libraries and other software that assumes DW-CAS is
the basic machine primitive. A possible mitigating factor is the
recent addition of transactional memory instructions to x86, which
might cause a move away from DW-CAS.</p>
</div>
<p>The failure code with value 1 is reserved to encode an unspecified
failure. Other failure codes are reserved at this time, and portable
software should only assume the failure code will be non-zero. LR and
SC operate on naturally-aligned 64-bit (RV64 only) or 32-bit words in
memory. Misaligned addresses will generate misaligned address
exceptions.</p>
<div class=commentary>
<p>We reserve a failure code of 1 to mean “unspecified” so that simple
implementations may return this value using the existing mux required
for the SLT/SLTU instructions. More specific failure codes might be
defined in future versions or extensions to the ISA.</p>
</div>
<p><span id="lrscseq" label="lrscseq">[lrscseq]</span></p>
<p>In the standard A extension, certain constrained LR/SC sequences are
guaranteed to succeed eventually. The static code for the LR/SC
sequence plus the code to retry the sequence in case of failure must
comprise at most 16 integer instructions placed sequentially in
memory. For the sequence to be guaranteed to eventually succeed, the
dynamic code executed between the LR and SC instructions can only
contain other instructions from the base “I” subset, excluding
loads, stores, backward jumps or taken backward branches, FENCE,
FENCE.I, and SYSTEM instructions. The code to retry a failing LR/SC
sequence can contain backward jumps and/or branches to repeat the
LR/SC sequence, but otherwise has the same constraints. The SC must
be to the same address as the latest LR executed. LR/SC sequences
that do not meet these constraints might complete on some attempts on
some implementations, but there is no guarantee of eventual success.</p>
<div class=commentary>
<p>One advantage of CAS is that it guarantees that some hart eventually
makes progress, whereas an LR/SC atomic sequence could livelock
indefinitely on some systems. To avoid this concern, we added an
architectural guarantee of forward progress to LR/SC atomic sequences.
The restrictions on LR/SC sequence contents allows an implementation
to capture a cache line on the LR and complete the LR/SC sequence by
holding off remote cache interventions for a bounded short
time. Interrupts and TLB misses might cause the reservation to be
lost, but eventually the atomic sequence can complete. We restricted
the length of LR/SC sequences to fit within 64 contiguous instruction
bytes in the base ISA to avoid undue restrictions on instruction cache
and TLB size and associativity. Similarly, we disallowed other loads
and stores within the sequences to avoid restrictions on data cache
associativity. The restrictions on branches and jumps limits the time
that can be spent in the sequence. Floating-point operations and
integer multiply/divide were disallowed to simplify the operating
system’s emulation of these instructions on implementations lacking
appropriate hardware support.</p>
</div>
<p>An implementation can reserve an arbitrary subset of the memory space
on each LR and multiple LR reservations might be active simultaneously
for a single hart. An SC can succeed if no accesses from other harts
to the address can be observed to have occurred between the SC and
the last LR in this hart to reserve the address. Note this LR might
have had a different address argument, but reserved the SC’s address
as part of the memory subset. Following this model, in systems with
memory translation, an SC is allowed to succeed if the earlier LR
reserved the same location using an alias with a different virtual
address, but is also allowed to fail if the virtual address is
different. The SC must fail if there is an observable memory access
from another hart to the address, or if there is an intervening
context switch on this hart, or if in the meantime the hart executed a
privileged exception-return instruction.</p>
<div class=commentary>
<p>The specification explicitly allows implementations to support more
powerful implementations with wider guarantees, provided they do not
void the atomicity guarantees for the constrained sequences.</p>
</div>
<p>LR/SC can be used to construct lock-free data structures. An example
using LR/SC to implement a compare-and-swap function is shown in
Figure <a href="a.html#cas" data-reference-type="ref" data-reference="cas">1.1</a>. If inlined, compare-and-swap functionality need
only take three instructions.</p>
<figure>
<img src="a_01.svg" alt="Sample code for compare-and-swap function using LR/SC." id="cas" /><figcaption>Sample code for compare-and-swap function using LR/SC.<span label="cas"></span></figcaption>
</figure>
<p>An SC instruction can never be observed by another RISC-V hart
before the immediately preceding LR. Due to the atomic nature of the
LR/SC sequence, no memory operations from any hart can be observed
to have occurred between the LR and a successful SC. The LR/SC
sequence can be given acquire semantics by setting the <span><em>aq</em></span> bit on
the SC instruction. The LR/SC sequence can be given release semantics
by setting the <span><em>rl</em></span> bit on the LR instruction. Setting both <span>
<em>aq</em></span> and <span><em>rl</em></span> bits on the LR instruction, and setting the <span>
<em>aq</em></span> bit on the SC instruction makes the LR/SC sequence sequentially
consistent with respect to other sequentially consistent atomic
operations.</p>
<p>If neither bit is set on both LR and SC, the LR/SC sequence can be
observed to occur before or after surrounding memory operations from
the same RISC-V hart. This can be appropriate when the LR/SC
sequence is used to implement a parallel reduction operation.</p>
<div class=commentary>
<p>In general, a multi-word atomic primitive is desirable but there is
still considerable debate about what form this should take, and
guaranteeing forward progress adds complexity to a system. Our
current thoughts are to include a small limited-capacity transactional
memory buffer along the lines of the original transactional memory
proposals as an optional standard extension “T”.</p>
</div>
<h2 id="atomic-memory-operations"><span class="header-section-number">9.3</span> Atomic Memory Operations</h2>
<p><img src="a_02.svg" alt="image" /></p>
<p>The atomic memory operation (AMO) instructions perform
read-modify-write operations for multiprocessor synchronization and
are encoded with an R-type instruction format. These AMO instructions
atomically load a data value from the address in <span><em>rs1</em></span>, place the
value into register <span><em>rd</em></span>, apply a binary operator to the loaded
value and the original value in <span><em>rs2</em></span>, then store the result back
to the address in <span><em>rs1</em></span>. AMOs can either operate on 64-bit (RV64
only) or 32-bit words in memory. For RV64, 32-bit AMOs always
sign-extend the value placed in <span><em>rd</em></span>. The address held in <span>
<em>rs1</em></span> must be naturally aligned to the size of the operand (i.e.,
eight-byte aligned for 64-bit words and four-byte aligned for 32-bit
words). If the address is not naturally aligned, a misaligned address
exception will be generated.</p>
<p>The operations supported are swap, integer add, logical AND, logical
OR, logical XOR, and signed and unsigned integer maximum and minimum.
Without ordering constraints, these AMOs can be used to implement
parallel reduction operations, where typically the return value would
be discarded by writing to <span>x0</span>.</p>
<div class=commentary>
<p>We provided fetch-and-op style atomic primitives as they scale to
highly parallel systems better than LR/SC or CAS. A simple
microarchitecture can implement AMOs using the LR/SC primitives. More
complex implementations might also implement AMOs at memory
controllers, and can optimize away fetching the original value when
the destination is <span>x0</span>.</p>
<p>The set of AMOs was chosen to support the C11/C++11 atomic memory
operations efficiently, and also to support parallel reductions in
memory. Another use of AMOs is to provide atomic updates to
memory-mapped device registers (e..g, setting, clearing, or toggling
bits) in the I/O space.</p>
</div>
<p>To help implement multiprocessor synchronization, the AMOs optionally
provide release consistency semantics. If the <span><em>aq</em></span> bit is set,
then no later memory operations in this RISC-V hart can be observed
to take place before the AMO.
Conversely, if the <span><em>rl</em></span> bit is set, then other
RISC-V harts will not observe the AMO before memory accesses
preceding the AMO in this RISC-V hart.</p>
<div class=commentary>
<p>The AMOs were designed to implement the C11 and C++11 memory models
efficiently. Although the FENCE R, RW instruction suffices to
implement the <span><em>acquire</em></span> operation and FENCE RW, W suffices to
implement <span><em>release</em></span>, both imply additional unnecessary ordering as
compared to AMOs with the corresponding <span><em>aq</em></span> or <span><em>rl</em></span> bit set.</p>
</div>
<p>An example code sequence for a critical section guarded by a
test-and-set spinlock is shown in Figure <a href="a.html#critical" data-reference-type="ref" data-reference="critical">1.2</a>. Note the
first AMO is marked <span><em>aq</em></span> to order the lock acquisition before the
critical section, and the second AMO is marked <span><em>rl</em></span> to order
the critical section before the lock relinquishment.</p>
<figure>
<img src="a_03.svg" alt="Sample code for mutual exclusion. a0 contains the address of the lock." id="critical" /><figcaption>Sample code for mutual exclusion. <span>a0</span> contains the address of the lock.<span label="critical"></span></figcaption>
</figure>
<div class=commentary>
<p>We recommend the use of the AMO Swap idiom shown above for both lock
acquire and release to simplify the implementation of speculative lock
elision <span class="citation" data-cites="Rajwar:2001:SLE"><a href="#ref-Rajwar:2001:SLE">[Rajwar:2001:SLE]</a></span>.</p>
<p>At the risk of complicating the implementation of atomic operations,
microarchitectures can elide the store within the acquire swap if the
lock value matches the swap value, to avoid dirtying a cache line held
in a shared or exclusive clean state. The effect is similar to a
test-and-test-and-set lock but with shorter code paths.</p>
</div>
<p>The instructions in the “A” extension can also be used to provide
sequentially consistent loads and stores. A sequentially consistent load can
be implemented as an LR with both <span><em>aq</em></span> and <span><em>rl</em></span> set. A sequentially
consistent store can be implemented as an AMOSWAP that writes the old value to
x0 and has both <span><em>aq</em></span> and <span><em>rl</em></span> set.</p>

</body>
</html>
