<html>
<head>
<title>RISC-V Instruction Set Manual, Volume I: RISC-V User-Level ISA</title>
</head>
<body>

<table>
<tr><th colspan=2>Metadata Table</th></tr>
<tr><th>Manual Type</th><td> user</td></tr>
<tr><th>Spec Revision</th><td> </td></tr>
<tr><th>Spec Release Date</th><td> </td></tr>
<tr><th>Git Revision</th><td> riscv-priv-1.10</td></tr>
<tr><th>Git URL</th><td><a href=https://github.com/riscv/riscv-isa-manual.git>https://github.com/riscv/riscv-isa-manual.git</a></td></tr>
<tr><th>Source</th><td>src/rv64.tex</td></tr>
<tr><th>Conversion Date</th><td>2023/09/28</td></tr>
<tr><th>License</th><td><a href=https://creativecommons.org/licenses/by/4.0/>CC-by-4.0</a></td></tr>
</table>


<h1 id="rv64"><span class="header-section-number">6</span> RV64I Base Integer Instruction Set, Version 2.0</h1>
<p>This chapter describes the RV64I base integer instruction set, which
builds upon the RV32I variant described in Chapter <a href="rv32.html#rv32" data-reference-type="ref" data-reference="rv32">[rv32]</a>. This
chapter presents only the differences with RV32I, so should be read in
conjunction with the earlier chapter.</p>
<h2 id="register-state"><span class="header-section-number">6.1</span> Register State</h2>
<p>RV64I widens the integer registers and supported user address space to
64 bits (XLEN=64 in Figure <a href="rv32.html#gprs" data-reference-type="ref" data-reference="gprs">[gprs]</a>).</p>
<h2 id="integer-computational-instructions"><span class="header-section-number">6.2</span> Integer Computational Instructions</h2>
<p>Additional instruction variants are provided to manipulate 32-bit
values in RV64I, indicated by a ‘W’ suffix to the opcode. These
“*W” instructions ignore the upper 32 bits of their inputs and
always produce 32-bit signed values, i.e. bits XLEN-1 through 31 are
equal. They cause an illegal instruction exception in RV32I.</p>
<div class=commentary>
<p>The compiler and calling convention maintain an invariant that all 32-bit
values are held in a sign-extended format in 64-bit registers. Even 32-bit
unsigned integers extend bit 31 into bits 63 through 32. Consequently,
conversion between unsigned and signed 32-bit integers is a no-op,
as is conversion from a signed 32-bit integer to a signed 64-bit
integer. Existing 64-bit wide SLTU and unsigned branch compares still operate
correctly on unsigned 32-bit integers under this invariant. Similarly,
existing 64-bit wide logical operations on 32-bit sign-extended integers
preserve the sign-extension property. A few new instructions
(ADD[I]W/SUBW/SxxW) are required for addition and shifts to ensure reasonable
performance for 32-bit values.</p>
</div>
<h4 id="integer-register-immediate-instructions" class="unnumbered">Integer Register-Immediate Instructions</h4>
<p><img src="rv64_00.svg" alt="image" /></p>
<p>ADDIW is an RV64I-only instruction that adds the sign-extended 12-bit
immediate to register <span><em>rs1</em></span> and produces the proper sign-extension
of a 32-bit result in <span><em>rd</em></span>. Overflows are ignored and the result
is the low 32 bits of the result sign-extended to 64 bits. Note,
ADDIW <span><em>rd, rs1, 0</em></span> writes the sign-extension of the lower 32 bits
of register <span><em>rs1</em></span> into register <span><em>rd</em></span> (assembler pseudo-op
SEXT.W).</p>
<p><img src="rv64_01.svg" alt="image" /></p>
<p>Shifts by a constant are encoded as a specialization of the I-type
format using the same instruction opcode as RV32I. The operand to be
shifted is in <span><em>rs1</em></span>, and the shift amount is encoded in the lower
6 bits of the I-immediate field for RV64I. The right shift type is
encoded in bit 30. SLLI is a logical left shift (zeros are shifted
into the lower bits); SRLI is a logical right shift (zeros are shifted
into the upper bits); and SRAI is an arithmetic right shift (the
original sign bit is copied into the vacated upper bits). For RV32I,
SLLI, SRLI, and SRAI generate an illegal instruction exception if
<span class="math inline"><em>i</em><em>m</em><em>m</em>[5] ≠ 0</span>.</p>
<p>SLLIW, SRLIW, and SRAIW are RV64I-only instructions that are
analogously defined but operate on 32-bit values and produce
signed 32-bit results. SLLIW, SRLIW, and SRAIW generate an illegal
instruction exception if <span class="math inline"><em>i</em><em>m</em><em>m</em>[5] ≠ 0</span>.</p>
<p><img src="rv64_02.svg" alt="image" /></p>
<p>LUI (load upper immediate) uses the same opcode as RV32I. LUI places
the 20-bit U-immediate into bits 31–12 of register <span><em>rd</em></span> and
places zero in the lowest 12 bits. The 32-bit result is
sign-extended to 64 bits.</p>
<p>AUIPC (add upper immediate to <span>pc</span>) uses the same opcode as RV32I.
AUIPC (add upper immediate to <span>pc</span>) is used to build <span>
pc</span>-relative addresses and uses the U-type format. AUIPC appends 12
low-order zero bits to the 20-bit U-immediate, sign-extends the result
to 64 bits, then adds it to the <span>pc</span> and places the result in
register <span><em>rd</em></span>.</p>
<h4 id="integer-register-register-operations" class="unnumbered">Integer Register-Register Operations</h4>
<p><img src="rv64_03.svg" alt="image" /></p>
<p>ADDW and SUBW are RV64I-only instructions that are defined analogously
to ADD and SUB but operate on 32-bit values and produce signed 32-bit
results. Overflows are ignored, and the low 32-bits of the result is
sign-extended to 64-bits and written to the destination register.</p>
<p>SLL, SRL, and SRA perform logical left, logical right, and arithmetic
right shifts on the value in register <span><em>rs1</em></span> by the shift amount
held in register <span><em>rs2</em></span>. In RV64I, only the low 6 bits of <span>
<em>rs2</em></span> are considered for the shift amount.</p>
<p>SLLW, SRLW, and SRAW are RV64I-only instructions that are analogously
defined but operate on 32-bit values and produce signed 32-bit
results. The shift amount is given by <span><em>rs2[4:0]</em></span>.</p>
<h2 id="load-and-store-instructions"><span class="header-section-number">6.3</span> Load and Store Instructions</h2>
<p>RV64I extends the address space to 64 bits. The execution environment
will define what portions of the address space are legal to access.</p>
<p><img src="rv64_04.svg" alt="image" /></p>
<p><img src="rv64_05.svg" alt="image" /></p>
<p>The LD instruction loads a 64-bit value from memory into register <span>
<em>rd</em></span> for RV64I.</p>
<p>The LW instruction loads a 32-bit value from memory and sign-extends
this to 64 bits before storing it in register <span><em>rd</em></span> for RV64I. The
LWU instruction, on the other hand, zero-extends the 32-bit value from
memory for RV64I. LH and LHU are defined analogously for 16-bit
values, as are LB and LBU for 8-bit values. The SD, SW, SH, and SB
instructions store 64-bit, 32-bit, 16-bit, and 8-bit values from the
low bits of register <span><em>rs2</em></span> to memory respectively.</p>
<h2 id="system-instructions"><span class="header-section-number">6.4</span> System Instructions</h2>
<p>In RV64I, the CSR instructions can manipulate 64-bit CSRs. In particular, the
RDCYCLE, RDTIME, and RDINSTRET pseudo-instructions read the full 64 bits of
the <span>cycle</span>, <span>time</span>, and <span>instret</span> counters. Hence, the RDCYCLEH,
RDTIMEH, and RDINSTRETH instructions are not necessary and are illegal in
RV64I.</p>

</body>
</html>
