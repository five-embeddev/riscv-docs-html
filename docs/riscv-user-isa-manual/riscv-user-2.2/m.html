<html>
<head>
<title>RISC-V Instruction Set Manual, Volume I: RISC-V User-Level ISA</title>
</head>
<body>

<table>
<tr><th colspan=2>Metadata Table</th></tr>
<tr><th>Manual Type</th><td> user</td></tr>
<tr><th>Spec Revision</th><td> </td></tr>
<tr><th>Spec Release Date</th><td> </td></tr>
<tr><th>Git Revision</th><td> riscv-priv-1.10</td></tr>
<tr><th>Git URL</th><td><a href=https://github.com/riscv/riscv-isa-manual.git>https://github.com/riscv/riscv-isa-manual.git</a></td></tr>
<tr><th>Source</th><td>src/m.tex</td></tr>
<tr><th>Conversion Date</th><td>2023/09/28</td></tr>
<tr><th>License</th><td><a href=https://creativecommons.org/licenses/by/4.0/>CC-by-4.0</a></td></tr>
</table>


<h1 id="m-standard-extension-for-integer-multiplication-and-division-version-2.0"><span class="header-section-number">8</span> “M” Standard Extension for Integer Multiplication and
Division, Version 2.0</h1>
<p>This chapter describes the standard integer multiplication and
division instruction extension, which is named “M” and contains
instructions that multiply or divide values held in two integer
registers.</p>
<div class=commentary>
<p>We separate integer multiply and divide out from the base to simplify
low-end implementations, or for applications where integer multiply
and divide operations are either infrequent or better handled in
attached accelerators.</p>
</div>
<h2 id="multiplication-operations"><span class="header-section-number">8.1</span> Multiplication Operations</h2>
<p><img src="tmp.riscv-user-2.2//m_00.svg" alt="image" /></p>
<p>MUL performs an XLEN-bit<span class="math inline">×</span>XLEN-bit multiplication and places the
lower XLEN bits in the destination register. MULH, MULHU, and MULHSU
perform the same multiplication but return the upper XLEN bits of the
full 2<span class="math inline">×</span>XLEN-bit product, for signed<span class="math inline">×</span>signed,
unsigned<span class="math inline">×</span>unsigned, and signed<span class="math inline">×</span>unsigned multiplication
respectively. If both the high and low bits of the same product are
required, then the recommended code sequence is: MULH[[S]U] <span><em>rdh,
rs1, rs2</em></span>; MUL <span><em>rdl, rs1, rs2</em></span> (source register specifiers must
be in same order and <span><em>rdh</em></span> cannot be the same as <span><em>rs1</em></span> or <span>
<em>rs2</em></span>). Microarchitectures can then fuse these into a single
multiply operation instead of performing two separate multiplies.</p>
<p>MULW is only valid for RV64, and multiplies the lower
32 bits of the source registers, placing the sign-extension of the
lower 32 bits of the result into the destination register. MUL can be
used to obtain the upper 32 bits of the 64-bit product, but signed
arguments must be proper 32-bit signed values, whereas unsigned
arguments must have their upper 32 bits clear.</p>
<h2 id="division-operations"><span class="header-section-number">8.2</span> Division Operations</h2>
<p><img src="tmp.riscv-user-2.2//m_01.svg" alt="image" /></p>
<p>DIV and DIVU perform signed and unsigned integer division of XLEN
bits by XLEN bits. REM and REMU provide the remainder of the
corresponding division operation. If both the quotient and remainder
are required from the same division, the recommended code sequence is:
DIV[U] <span><em>rdq, rs1, rs2</em></span>; REM[U] <span><em>rdr, rs1, rs2</em></span> (<span><em>rdq</em></span>
cannot be the same as <span><em>rs1</em></span> or <span><em>rs2</em></span>). Microarchitectures can
then fuse these into a single divide operation instead of performing
two separate divides.</p>
<p>The semantics for division by zero and division overflow are
summarized in Table <a href="m.html#tab:divby0" data-reference-type="ref" data-reference="tab:divby0">[tab:divby0]</a>. The quotient of division by
zero has all bits set, i.e. <span class="math inline">2<sup><em>X</em><em>L</em><em>E</em><em>N</em></sup> − 1</span> for unsigned division or <span class="math inline"> − 1</span>
for signed division. The remainder of division by zero equals the
dividend. Signed division overflow occurs only when the most-negative
integer, <span class="math inline"> − 2<sup><em>X</em><em>L</em><em>E</em><em>N</em> − 1</sup></span>, is divided by <span class="math inline"> − 1</span>. The quotient of signed
division overflow is equal to the dividend, and the remainder is zero.
Unsigned division overflow cannot occur.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Condition</th>
<th style="text-align: center;">Dividend</th>
<th style="text-align: center;">Divisor</th>
<th style="text-align: center;">DIVU</th>
<th style="text-align: center;">REMU</th>
<th style="text-align: center;">DIV</th>
<th style="text-align: center;">REM</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Division by zero</td>
<td style="text-align: center;"><span class="math inline"><em>x</em></span></td>
<td style="text-align: center;">0</td>
<td style="text-align: center;"><span class="math inline">2<sup><em>X</em><em>L</em><em>E</em><em>N</em></sup> − 1</span></td>
<td style="text-align: center;"><span class="math inline"><em>x</em></span></td>
<td style="text-align: center;"><span class="math inline"> − 1</span></td>
<td style="text-align: center;"><span class="math inline"><em>x</em></span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Overflow (signed only)</td>
<td style="text-align: center;"><span class="math inline"> − 2<sup><em>X</em><em>L</em><em>E</em><em>N</em> − 1</sup></span></td>
<td style="text-align: center;"><span class="math inline"> − 1</span></td>
<td style="text-align: center;">–</td>
<td style="text-align: center;">–</td>
<td style="text-align: center;"><span class="math inline"> − 2<sup><em>X</em><em>L</em><em>E</em><em>N</em> − 1</sup></span></td>
<td style="text-align: center;">0</td>
</tr>
</tbody>
</table>
<div class=commentary>
<p>We considered raising exceptions on integer divide by zero, with these
exceptions causing a trap in most execution environments. However,
this would be the only arithmetic trap in the standard ISA
(floating-point exceptions set flags and write default values, but do
not cause traps) and would require language implementors to interact
with the execution environment’s trap handlers for this case.
Further, where language standards mandate that a divide-by-zero
exception must cause an immediate control flow change, only a single
branch instruction needs to be added to each divide operation, and
this branch instruction can be inserted after the divide and should
normally be very predictably not taken, adding little runtime
overhead.</p>
<p>The value of all bits set is returned for both unsigned and signed
divide by zero to simplify the divider circuitry. The value of all 1s
is both the natural value to return for unsigned divide, representing
the largest unsigned number, and also the natural result for simple
unsigned divider implementations. Signed division is often
implemented using an unsigned division circuit and specifying the same
overflow result simplifies the hardware.</p>
</div>
<p>DIVW and DIVUW instructions are only valid for RV64, and divide the
lower 32 bits of <span><em>rs1</em></span> by the lower 32 bits of <span><em>rs2</em></span>, treating
them as signed and unsigned integers respectively, placing the 32-bit
quotient in <span><em>rd</em></span>, sign-extended to 64 bits. REMW and REMUW
instructions are only valid for RV64, and provide the corresponding
signed and unsigned remainder operations respectively. Both REMW and
REMUW always sign-extend the 32-bit result to 64 bits, including on a
divide by zero.</p>

</body>
</html>
