<html>
<head>
<link rel="stylesheet" href="../../assets/docs.css">
<title>RISC-V Instruction Set Manual, Volume I: RISC-V User-Level ISA</title>
</head>
<body>

<table>
<tr><th colspan=2>Metadata Table</th></tr>
<tr><th>Manual Type</th><td> user</td></tr>
<tr><th>Spec Revision</th><td> 20190305-Base-Ratification</td></tr>
<tr><th>Spec Release Date</th><td> March 2019</td></tr>
<tr><th>Git Revision</th><td> IMFDQC-Ratification-20190305</td></tr>
<tr><th>Git URL</th><td><a href=https://github.com/riscv/riscv-isa-manual.git>https://github.com/riscv/riscv-isa-manual.git</a></td></tr>
<tr><th>Source</th><td>src/rv64.tex</td></tr>
<tr><th>Conversion Date</th><td>2023/11/12</td></tr>
<tr><th>License</th><td><a href=https://creativecommons.org/licenses/by/4.0/>CC-by-4.0</a></td></tr>
</table>


<section id="rv64" data-number="1">
<h1 data-number="6"><span class="header-section-number">6</span> RV64I Base Integer Instruction Set, Version 2.1</h1>
<p>This chapter describes the RV64I base integer instruction set, which
builds upon the RV32I variant described in Chapter <a href="rv32.html#rv32" data-reference-type="ref" data-reference="rv32">[rv32]</a>. This
chapter presents only the differences with RV32I, so should be read in
conjunction with the earlier chapter.</p>
<section id="register-state" data-number="1.1">
<h2 data-number="6.1"><span class="header-section-number">6.1</span> Register State</h2>
<p>RV64I widens the integer registers and supported user address space to
64 bits (XLEN=64 in Figure <a href="rv32.html#gprs" data-reference-type="ref" data-reference="gprs">[gprs]</a>).</p>
</section>
<section id="integer-computational-instructions" data-number="1.2">
<h2 data-number="6.2"><span class="header-section-number">6.2</span> Integer Computational Instructions</h2>
<p>Most integer computational instructions operate on XLEN-bit values.
Additional instruction variants are provided to manipulate 32-bit
values in RV64I, indicated by a ‘W’ suffix to the opcode. These
“*W” instructions ignore the upper 32 bits of their inputs and
always produce 32-bit signed values, i.e. bits XLEN-1 through 31 are
equal.</p>
<div class=commentary>
<p>The compiler and calling convention maintain an invariant that all 32-bit
values are held in a sign-extended format in 64-bit registers. Even 32-bit
unsigned integers extend bit 31 into bits 63 through 32. Consequently,
conversion between unsigned and signed 32-bit integers is a no-op,
as is conversion from a signed 32-bit integer to a signed 64-bit
integer. Existing 64-bit wide SLTU and unsigned branch compares still operate
correctly on unsigned 32-bit integers under this invariant. Similarly,
existing 64-bit wide logical operations on 32-bit sign-extended integers
preserve the sign-extension property. A few new instructions
(ADD[I]W/SUBW/SxxW) are required for addition and shifts to ensure reasonable
performance for 32-bit values.</p>
</div>
<section id="integer-register-immediate-instructions" class="unnumbered" data-number="">
<h4 class="unnumbered" data-number="5">Integer Register-Immediate Instructions</h4>
<p><img src="rv64_00.svg" alt="image" /></p>
<p>ADDIW is an RV64I instruction that adds the sign-extended 12-bit
immediate to register <span><em>rs1</em></span> and produces the proper sign-extension
of a 32-bit result in <span><em>rd</em></span>. Overflows are ignored and the result
is the low 32 bits of the result sign-extended to 64 bits. Note,
ADDIW <span><em>rd, rs1, 0</em></span> writes the sign-extension of the lower 32 bits
of register <span><em>rs1</em></span> into register <span><em>rd</em></span> (assembler pseudoinstruction
SEXT.W).</p>
<p><img src="rv64_01.svg" alt="image" /></p>
<p>Shifts by a constant are encoded as a specialization of the I-type
format using the same instruction opcode as RV32I. The operand to be
shifted is in <span><em>rs1</em></span>, and the shift amount is encoded in the lower
6 bits of the I-immediate field for RV64I. The right shift type is
encoded in bit 30. SLLI is a logical left shift (zeros are shifted
into the lower bits); SRLI is a logical right shift (zeros are shifted
into the upper bits); and SRAI is an arithmetic right shift (the
original sign bit is copied into the vacated upper bits).</p>
<p>SLLIW, SRLIW, and SRAIW are RV64I-only instructions that are
analogously defined but operate on 32-bit values and produce
signed 32-bit results. SLLIW, SRLIW, and SRAIW encodings
with <span class="math inline"><em>i</em><em>m</em><em>m</em>[5] ≠ 0</span> are reserved.</p>
<div class=commentary>
<p>Previously, SLLIW, SRLIW, and SRAIW with imm[5]=0 were defined to
cause illegal instruction exceptions, whereas now they are marked as
reserved. This is a backwards-compatible change.</p>
</div>
<p><img src="rv64_02.svg" alt="image" /></p>
<p>LUI (load upper immediate) uses the same opcode as RV32I. LUI places
the 20-bit U-immediate into bits 31–12 of register <span><em>rd</em></span> and
places zero in the lowest 12 bits. The 32-bit result is
sign-extended to 64 bits.</p>
<p>AUIPC (add upper immediate to <span><code>pc</code></span>) uses the same opcode as RV32I.
AUIPC (add upper immediate to <span><code>pc</code></span>) is used to build <span><code> pc</code></span>-relative addresses and uses the U-type format. AUIPC appends 12
low-order zero bits to the 20-bit U-immediate, sign-extends the result
to 64 bits, then adds it to the <span><code>pc</code></span> and places the result in
register <span><em>rd</em></span>.</p>
</section>
<section id="integer-register-register-operations" class="unnumbered" data-number="">
<h4 class="unnumbered" data-number="5">Integer Register-Register Operations</h4>
<p><img src="rv64_03.svg" alt="image" /></p>
<p>ADDW and SUBW are RV64I-only instructions that are defined analogously
to ADD and SUB but operate on 32-bit values and produce signed 32-bit
results. Overflows are ignored, and the low 32-bits of the result is
sign-extended to 64-bits and written to the destination register.</p>
<p>SLL, SRL, and SRA perform logical left, logical right, and arithmetic
right shifts on the value in register <span><em>rs1</em></span> by the shift amount
held in register <span><em>rs2</em></span>. In RV64I, only the low 6 bits of <span>
<em>rs2</em></span> are considered for the shift amount.</p>
<p>SLLW, SRLW, and SRAW are RV64I-only instructions that are analogously
defined but operate on 32-bit values and produce signed 32-bit
results. The shift amount is given by <span><em>rs2[4:0]</em></span>.</p>
</section>
</section>
<section id="load-and-store-instructions" data-number="1.3">
<h2 data-number="6.3"><span class="header-section-number">6.3</span> Load and Store Instructions</h2>
<p>RV64I extends the address space to 64 bits. The execution environment
will define what portions of the address space are legal to access.</p>
<p><img src="rv64_04.svg" alt="image" /></p>
<p><img src="rv64_05.svg" alt="image" /></p>
<p>The LD instruction loads a 64-bit value from memory into register <span>
<em>rd</em></span> for RV64I.</p>
<p>The LW instruction loads a 32-bit value from memory and sign-extends
this to 64 bits before storing it in register <span><em>rd</em></span> for RV64I. The
LWU instruction, on the other hand, zero-extends the 32-bit value from
memory for RV64I. LH and LHU are defined analogously for 16-bit
values, as are LB and LBU for 8-bit values. The SD, SW, SH, and SB
instructions store 64-bit, 32-bit, 16-bit, and 8-bit values from the
low bits of register <span><em>rs2</em></span> to memory respectively.</p>
</section>
<section id="sec:rv64i-hints" data-number="1.4">
<h2 data-number="6.4"><span class="header-section-number">6.4</span> HINT Instructions</h2>
<p>All instructions that are microarchitectural HINTs in RV32I (see
Section <a href="rv32.html#sec:rv32i-hints" data-reference-type="ref" data-reference="sec:rv32i-hints">[sec:rv32i-hints]</a>) are also HINTs in RV64I. The
additional computational instructions in RV64I expand both the standard and
custom HINT encoding spaces.</p>
<p>Table <a href="rv64.html#tab:rv64i-hints" data-reference-type="ref" data-reference="tab:rv64i-hints">1.1</a> lists all RV64I HINT code points. 91% of the HINT
space is reserved for standard HINTs, but none are presently defined. The
remainder of the HINT space is reserved for custom HINTs: no standard HINTs
will ever be defined in this subspace.</p>
<figure>
<img src="rv64_06.svg" id="tab:rv64i-hints" alt="" /><figcaption>RV64I HINT instructions.</figcaption>
</figure>
</section>
</section>

</body>
</html>
