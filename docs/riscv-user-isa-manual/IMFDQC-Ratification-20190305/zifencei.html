<html>
<head>
<title>RISC-V Instruction Set Manual, Volume I: RISC-V User-Level ISA</title>
</head>
<body>

<table>
<tr><th colspan=2>Metadata Table</th></tr>
<tr><th>Manual Type</th><td> user</td></tr>
<tr><th>Spec Revision</th><td> 20190305-Base-Ratification</td></tr>
<tr><th>Spec Release Date</th><td> March 2019</td></tr>
<tr><th>Git Revision</th><td> IMFDQC-Ratification-20190305</td></tr>
<tr><th>Git URL</th><td><a href=https://github.com/riscv/riscv-isa-manual.git>https://github.com/riscv/riscv-isa-manual.git</a></td></tr>
<tr><th>Source</th><td>src/zifencei.tex</td></tr>
<tr><th>Conversion Date</th><td>2023/10/11</td></tr>
<tr><th>License</th><td><a href=https://creativecommons.org/licenses/by/4.0/>CC-by-4.0</a></td></tr>
</table>


<h1 id="chap:zifencei"><span class="header-section-number">3</span> “Zifencei” Instruction-Fetch Fence, Version 2.0</h1>
<p>This chapter defines the “Zifencei” extension, which includes the
FENCE.I instruction that provides explicit synchronization between
writes to instruction memory and instruction fetches on the same hart.
Currently, this instruction is the only standard mechanism to ensure
an instruction modified by a store on a hart will be visible to a
subsequent instruction fetch on the same hart.</p>
<div class=commentary>
<p>We considered but did not include a “store instruction word”
instruction (as in MAJC <span class="citation" data-cites="majc"><a href="#ref-majc">[majc]</a></span>). JIT compilers may generate a
large trace of instructions before a single FENCE.I, and amortize any
instruction cache snooping/invalidation overhead by writing translated
instructions to memory regions that are known not to reside in the
I-cache.</p>
</div>
<div class=commentary>
<p>The FENCE.I instruction was designed to support a wide variety of
implementations. A simple implementation can flush the local
instruction cache and the instruction pipeline when the FENCE.I is
executed. A more complex implementation might snoop the instruction
(data) cache on every data (instruction) cache miss, or use an
inclusive unified private L2 cache to invalidate lines from the
primary instruction cache when they are being written by a local store
instruction. If instruction and data caches are kept coherent in this
way, or if the memory system consists of only uncached RAMs, then just
the fetch pipeline needs to be flushed at a FENCE.I.</p>
<p>The FENCE.I instruction was previously part of the base I instruction
set. Two main issues are driving moving this out of the mandatory
base, although at time of writing it is still the only standard method
for maintaining instruction-fetch coherence.</p>
<p>First, it has been recognized that on some systems, FENCE.I will be
expensive to implement and alternate mechanisms are being discussed in
the memory model task group. In particular, for designs that have an
incoherent instruction cache and an incoherent data cache, or where
the instruction cache refill does not snoop a coherent data cache,
both caches must be completely flushed when a FENCE.I instruction is
encountered. This problem is exacerbated when there are multiple
levels of I and D cache in front of a unified cache or outer memory
system.</p>
<p>Second, the instruction is not powerful enough to make available at
user level in a Unix-like operating system environment. The FENCE.I
only synchronizes the local hart, and the OS can reschedule the user
hart to a different physical hart after the FENCE.I. This would
require the OS to execute an additional FENCE.I as part of every
context migration. For this reason, the standard Linux ABI has
removed FENCE.I from user-level and now requires a system call to
maintain instruction-fetch coherence, which allows the OS to minimize
the number of FENCE.I executions required on current systems and
provides forward-compatibility with future improved instruction-fetch
coherence mechanisms.</p>
<p>Future approaches to instruction-fetch coherence under discussion
include providing more restricted versions of FENCE.I that only target
a given address specified in <span><em>rs1</em></span>, and/or allowing software to use an
ABI that relies on machine-mode cache-maintenance operations.</p>
</div>
<p><img src="zifencei_00.svg" alt="image" /></p>
<p>The FENCE.I instruction is used to synchronize the instruction and
data streams. RISC-V does not guarantee that stores to instruction
memory will be made visible to instruction fetches on the same RISC-V
hart until a FENCE.I instruction is executed. A FENCE.I instruction
only ensures that a subsequent instruction fetch on a RISC-V hart
will see any previous data stores already visible to the same RISC-V
hart. FENCE.I does <span><em>not</em></span> ensure that other RISC-V harts’
instruction fetches will observe the local hart’s stores in a
multiprocessor system. To make a store to instruction memory visible
to all RISC-V harts, the writing hart has to execute a data FENCE
before requesting that all remote RISC-V harts execute a FENCE.I.</p>
<p>The unused fields in the FENCE.I instruction, <span><em>imm[11:0]</em></span>, <span><em>rs1</em></span>, and
<span><em>rd</em></span>, are reserved for finer-grain fences in future extensions. For
forward compatibility, base implementations shall ignore these fields, and
standard software shall zero these fields.</p>
<div class=commentary>
<p>Because FENCE.I only orders stores with a hart’s own instruction
fetches, application code should only rely upon FENCE.I if the
application thread will not be migrated to a different hart. The EEI
can provide mechanisms for efficient multiprocessor instruction-stream
synchronization.</p>
</div>

</body>
</html>
