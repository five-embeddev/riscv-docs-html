<html>
<head>
<link rel="stylesheet" href="../../assets/docs.css">
<title>RISC-V Instruction Set Manual, Volume I: RISC-V User-Level ISA</title>
</head>
<body>

<table>
<tr><th colspan=2>Metadata Table</th></tr>
<tr><th>Manual Type</th><td> user</td></tr>
<tr><th>Spec Revision</th><td> 20190305-Base-Ratification</td></tr>
<tr><th>Spec Release Date</th><td> March 2019</td></tr>
<tr><th>Git Revision</th><td> IMFDQC-Ratification-20190305</td></tr>
<tr><th>Git URL</th><td><a href=https://github.com/riscv/riscv-isa-manual.git>https://github.com/riscv/riscv-isa-manual.git</a></td></tr>
<tr><th>Source</th><td>src/csr.tex</td></tr>
<tr><th>Conversion Date</th><td>2023/11/12</td></tr>
<tr><th>License</th><td><a href=https://creativecommons.org/licenses/by/4.0/>CC-by-4.0</a></td></tr>
</table>


<section id="csrinsts" data-number="1">
<h1 data-number="10"><span class="header-section-number">10</span> “Zicsr”, Control and Status Register (CSR) Instructions, Version 2.0</h1>
<p>RISC-V defines a separate address space of 4096 Control and Status
registers associated with each hart. This chapter defines the full
set of CSR instructions that operate on these CSRs.</p>
<div class=commentary>
<p>While CSRs are primarily used by the privileged architecture, there
are several uses in unprivileged code including for counters and
timers, and for floating-point status.</p>
<p>The counters and timers are no longer considered mandatory parts of
the standard base ISAs, and so the CSR instructions required to
access them have been moved out of the base ISA chapter into this
separate chapter.</p>
</div>
<section id="csr-instructions" data-number="1.1">
<h2 data-number="10.1"><span class="header-section-number">10.1</span> CSR Instructions</h2>
<p>All CSR instructions atomically read-modify-write a single CSR, whose
CSR specifier is encoded in the 12-bit <span><em>csr</em></span> field of the
instruction held in bits 31–20. The immediate forms use a 5-bit
zero-extended immediate encoded in the <span><em>rs1</em></span> field.</p>
<p><img src="csr_00.svg" alt="image" /></p>
<p>The CSRRW (Atomic Read/Write CSR) instruction atomically swaps values
in the CSRs and integer registers. CSRRW reads the old value of the
CSR, zero-extends the value to XLEN bits, then writes it to integer
register <span><em>rd</em></span>. The initial value in <span><em>rs1</em></span> is written to the
CSR. If <span><em>rd</em></span>=<span><code>x0</code></span>, then the instruction shall not read the CSR
and shall not cause any of the side effects that might occur on a CSR
read.</p>
<p>The CSRRS (Atomic Read and Set Bits in CSR) instruction reads the
value of the CSR, zero-extends the value to XLEN bits, and writes it
to integer register <span><em>rd</em></span>. The initial value in integer register
<span><em>rs1</em></span> is treated as a bit mask that specifies bit positions to be
set in the CSR. Any bit that is high in <span><em>rs1</em></span> will cause the
corresponding bit to be set in the CSR, if that CSR bit is writable.
Other bits in the CSR are unaffected (though CSRs might have side
effects when written).</p>
<p>The CSRRC (Atomic Read and Clear Bits in CSR) instruction reads the
value of the CSR, zero-extends the value to XLEN bits, and writes it
to integer register <span><em>rd</em></span>. The initial value in integer register
<span><em>rs1</em></span> is treated as a bit mask that specifies bit positions to be
cleared in the CSR. Any bit that is high in <span><em>rs1</em></span> will cause the
corresponding bit to be cleared in the CSR, if that CSR bit is
writable. Other bits in the CSR are unaffected.</p>
<p>For both CSRRS and CSRRC, if <span><em>rs1</em></span>=<span><code>x0</code></span>, then the instruction
will not write to the CSR at all, and so shall not cause any of the
side effects that might otherwise occur on a CSR write, such as
raising illegal instruction exceptions on accesses to read-only CSRs.
Both CSRRS and CSRRC always read the addressed CSR and cause any read
side effects regardless of <span><em>rs1</em></span> and <span><em>rd</em></span> fields. Note that
if <span><em>rs1</em></span> specifies a register holding a zero value other than <span><code> x0</code></span>, the instruction will still attempt to write the unmodified
value back to the CSR and will cause any attendant side effects. A
CSRRW with <span><em>rs1</em></span>=<span><code>x0</code></span> will attempt to write zero to the
destination CSR.</p>
<p>The CSRRWI, CSRRSI, and CSRRCI variants are similar to CSRRW, CSRRS,
and CSRRC respectively, except they update the CSR using an XLEN-bit
value obtained by zero-extending a 5-bit unsigned immediate (uimm[4:0]) field
encoded in the <span><em>rs1</em></span> field instead of a value from an integer
register. For CSRRSI and CSRRCI, if the uimm[4:0] field is zero, then
these instructions will not write to the CSR, and shall not cause any
of the side effects that might otherwise occur on a CSR write. For
CSRRWI, if <span><em>rd</em></span>=<span><code>x0</code></span>, then the instruction shall not read the
CSR and shall not cause any of the side effects that might occur on a
CSR read. Both CSRRSI and CSRRCI will always read the CSR and cause
any read side effects regardless of <span><em>rd</em></span> and <span><em>rs1</em></span> fields.</p>
<figure>
<img src="csr_01.svg" id="tab:csrsideeffects" alt="" /><figcaption>Table showing whether a CSR instruction reads or writes a
given CSR. The CSRRS and CSRRC instructions have same behavior so
are shown as CSRR<span>S/C</span> in Table.</figcaption>
</figure>
<p>Table <a href="csr.html#tab:csrsideeffects" data-reference-type="ref" data-reference="tab:csrsideeffects">1.1</a> summarizes the behavior of the CSR
instructions with respect to whether they read and/or write the CSR.</p>
<div class=commentary>
<p>The CSRs defined so far do not have any architectural side effects on reads
beyond raising illegal instruction exceptions on disallowed accesses.
Custom extensions might add CSRs with side effects on reads.</p>
</div>
<p>Some CSRs, such as the instructions-retired counter, <span><code>instret</code></span>,
may be modified as side effects of instruction execution. In these
cases, if a CSR access instruction reads a CSR, it reads the value
prior to the execution of the instruction. If a CSR access
instruction writes such a CSR, the write is done instead of the
increment. In particular, a value written to <span><code>instret</code></span> by one
instruction will be the value read by the following instruction.</p>
<p>The assembler pseudoinstruction to read a CSR, CSRR <span><em>rd, csr</em></span>, is
encoded as CSRRS <span><em>rd, csr, x0</em></span>. The assembler pseudoinstruction
to write a CSR, CSRW <span><em>csr, rs1</em></span>, is encoded as CSRRW <span><em>x0, csr,
rs1</em></span>, while CSRWI <span><em>csr, uimm</em></span>, is encoded as CSRRWI <span><em>x0,
csr, uimm</em></span>.</p>
<p>Further assembler pseudoinstructions are defined to set and clear
bits in the CSR when the old value is not required: CSRS/CSRC <span>
<em>csr, rs1</em></span>; CSRSI/CSRCI <span><em>csr, uimm</em></span>.</p>
</section>
</section>

</body>
</html>
