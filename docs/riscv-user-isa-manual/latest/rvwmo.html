<html>
<head>
<title>RISC-V Instruction Set Manual, Volume I: RISC-V User-Level ISA</title>
</head>
<body>

<table>
<tr><th colspan=2>Metadata Table</th></tr>
<tr><th>Manual Type</th><td> user</td></tr>
<tr><th>Spec Revision</th><td> 20191214-</td></tr>
<tr><th>Spec Release Date</th><td> December 2019</td></tr>
<tr><th>Git Revision</th><td> Priv-v1.12</td></tr>
<tr><th>Git URL</th><td><a href=https://github.com/riscv/riscv-isa-manual.git>https://github.com/riscv/riscv-isa-manual.git</a></td></tr>
<tr><th>Source</th><td>src/rvwmo.tex</td></tr>
<tr><th>Conversion Date</th><td>2023/07/31</td></tr>
<tr><th>License</th><td><a href=https://creativecommons.org/licenses/by/4.0/>CC-by-4.0</a></td></tr>
</table>


<h1 id="ch:memorymodel"><span class="header-section-number">16</span> RVWMO Memory Consistency Model, Version 2.0</h1>
<p>This chapter defines the RISC-V memory consistency model.
A memory consistency model is a set of rules specifying the values that can be returned by loads of memory.
RISC-V uses a memory model called “RVWMO” (RISC-V Weak Memory Ordering) which is designed to provide flexibility for architects to build high-performance scalable designs while simultaneously supporting a tractable programming model.</p>
<p>Under RVWMO, code running on a single hart appears to execute in order from the perspective of other memory instructions in the same hart, but memory instructions from another hart may observe the memory instructions from the first hart being executed in a different order.
Therefore, multithreaded code may require explicit synchronization to guarantee ordering between memory instructions from different harts.
The base RISC-V ISA provides a FENCE instruction for this purpose, described in Section <a href="rv32.html#sec:fence" data-reference-type="ref" data-reference="sec:fence">[sec:fence]</a>, while the atomics extension “A” additionally defines load-reserved/store-conditional and atomic read-modify-write instructions.</p>
<p>The standard ISA extension for misaligned atomics “Zam” (Chapter <a href="zam.html#sec:zam" data-reference-type="ref" data-reference="sec:zam">[sec:zam]</a>) and the standard ISA extension for total store ordering “Ztso” (Chapter <a href="ztso.html#sec:ztso" data-reference-type="ref" data-reference="sec:ztso">[sec:ztso]</a>) augment RVWMO with additional rules specific to those extensions.</p>
<p>The appendices to this specification provide both axiomatic and operational formalizations of the memory consistency model as well as additional explanatory material.</p>
<div class=commentary>
<p>This chapter defines the memory model for regular main memory operations. The interaction of the memory model with I/O memory, instruction fetches, FENCE.I, page table walks, and SFENCE.VMA is not (yet) formalized. Some or all of the above may be formalized in a future revision of this specification. The RV128 base ISA and future ISA extensions such as the “V” vector and “J” JIT extensions will need to be incorporated into a future revision as well.</p>
<p>Memory consistency models supporting overlapping memory accesses of different widths simultaneously remain an active area of academic research and are not yet fully understood. The specifics of how memory accesses of different sizes interact under RVWMO are specified to the best of our current abilities, but they are subject to revision should new issues be uncovered.</p>
</div>
<h2 id="sec:rvwmo"><span class="header-section-number">16.1</span> Definition of the RVWMO Memory Model</h2>
<p>The RVWMO memory model is defined in terms of the <span><em>global memory order</em></span>, a total ordering of the memory operations produced by all harts.
In general, a multithreaded program has many different possible executions, with each execution having its own corresponding global memory order.</p>
<p>The global memory order is defined over the primitive load and store operations generated by memory instructions.
It is then subject to the constraints defined in the rest of this chapter.
Any execution satisfying all of the memory model constraints is a legal execution (as far as the memory model is concerned).</p>
<h3 id="sec:rvwmo:primitives" class="unnumbered">Memory Model Primitives</h3>
<p>The <span><em>program order</em></span> over memory operations reflects the order in which the instructions that generate each load and store are logically laid out in that hart’s dynamic instruction stream; i.e., the order in which a simple in-order processor would execute the instructions of that hart.</p>
<p>Memory-accessing instructions give rise to <span><em>memory operations</em></span>.
A memory operation can be either a <span><em>load operation</em></span>, a <span><em>store operation</em></span>, or both simultaneously.
All memory operations are single-copy atomic: they can never be observed in a partially complete state.</p>
<p>Among instructions in RV32GC and RV64GC, each aligned memory instruction gives rise to exactly one memory operation, with two exceptions.
First, an unsuccessful SC instruction does not give rise to any memory operations.
Second, FLD and FSD instructions may each give rise to multiple memory operations if XLEN<span class="math inline">&lt;</span>64, as stated in Section <a href="d.html#fld_fsd" data-reference-type="ref" data-reference="fld_fsd">[fld_fsd]</a> and clarified below.
An aligned AMO gives rise to a single memory operation that is both a load operation and a store operation simultaneously.</p>
<div class=commentary>
<p>Instructions in the RV128 base instruction set and in future ISA extensions such as V (vector) and P (SIMD) may give rise to multiple memory operations. However, the memory model for these extensions has not yet been formalized.</p>
</div>
<p>A misaligned load or store instruction may be decomposed into a set of component memory operations of any granularity.
An FLD or FSD instruction for which XLEN<span class="math inline">&lt;</span>64 may also be decomposed into a set of component memory operations of any granularity.
The memory operations generated by such instructions are not ordered with respect to each other in program order, but they are ordered normally with respect to the memory operations generated by preceding and subsequent instructions in program order.
The atomics extension “A” does not require execution environments to support misaligned atomic instructions at all; however, if misaligned atomics are supported via the “Zam” extension, LRs, SCs, and AMOs may be decomposed subject to the constraints of the atomicity axiom for misaligned atomics, which is defined in Chapter <a href="zam.html#sec:zam" data-reference-type="ref" data-reference="sec:zam">[sec:zam]</a>.</p>
<div class=commentary>
<p>The decomposition of misaligned memory operations down to byte granularity facilitates emulation on implementations that do not natively support misaligned accesses.
Such implementations might, for example, simply iterate over the bytes of a misaligned access one by one.</p>
</div>
<p>An LR instruction and an SC instruction are said to be <span><em>paired</em></span> if the LR precedes the SC in program order and if there are no other LR or SC instructions in between; the corresponding memory operations are said to be paired as well (except in case of a failed SC, where no store operation is generated).
The complete list of conditions determining whether an SC must succeed, may succeed, or must fail is defined in Section <a href="a.html#sec:lrsc" data-reference-type="ref" data-reference="sec:lrsc">[sec:lrsc]</a>.</p>
<p>Load and store operations may also carry one or more ordering annotations from the following set: “acquire-RCpc”, “acquire-RCsc”, “release-RCpc”, and “release-RCsc”.
An AMO or LR instruction with <span><em>aq</em></span> set has an “acquire-RCsc” annotation.
An AMO or SC instruction with <span><em>rl</em></span> set has a “release-RCsc” annotation.
An AMO, LR, or SC instruction with both <span><em>aq</em></span> and <span><em>rl</em></span> set has both “acquire-RCsc” and “release-RCsc” annotations.</p>
<p>For convenience, we use the term “acquire annotation” to refer to an acquire-RCpc annotation or an acquire-RCsc annotation.
Likewise, a “release annotation” refers to a release-RCpc annotation or a release-RCsc annotation.
An “RCpc annotation” refers to an acquire-RCpc annotation or a release-RCpc annotation.
An “RCsc annotation” refers to an acquire-RCsc annotation or a release-RCsc annotation.</p>
<div class=commentary>
<p>In the memory model literature, the term “RCpc” stands for release consistency with processor-consistent synchronization operations, and the term “RCsc” stands for release consistency with sequentially consistent synchronization operations <span class="citation" data-cites="Gharachorloo90memoryconsistency"><a href="#ref-Gharachorloo90memoryconsistency">[Gharachorloo90memoryconsistency]</a></span>.</p>
<p>While there are many different definitions for acquire and release annotations in the literature, in the context of RVWMO these terms are concisely and completely defined by Preserved Program Order rules <a href="rvwmo.html#ppo:acquire" data-reference-type="ref" data-reference="ppo:acquire">[ppo:acquire]</a>–<a href="rvwmo.html#ppo:rcsc" data-reference-type="ref" data-reference="ppo:rcsc">[ppo:rcsc]</a>.</p>
<p>“RCpc” annotations are currently only used when implicitly assigned to every memory access per the standard extension “Ztso” (Chapter <a href="ztso.html#sec:ztso" data-reference-type="ref" data-reference="sec:ztso">[sec:ztso]</a>). Furthermore, although the ISA does not currently contain native load-acquire or store-release instructions, nor RCpc variants thereof, the RVWMO model itself is designed to be forwards-compatible with the potential addition of any or all of the above into the ISA in a future extension.</p>
</div>
<h3 id="sec:memorymodel:dependencies" class="unnumbered">Syntactic Dependencies</h3>
<p>The definition of the RVWMO memory model depends in part on the notion of a syntactic dependency, defined as follows.</p>
<p>In the context of defining dependencies, a “register” refers either to an entire general-purpose register, some portion of a CSR, or an entire CSR. The granularity at which dependencies are tracked through CSRs is specific to each CSR and is defined in Section <a href="dep-table.html#sec:csr-granularity" data-reference-type="ref" data-reference="sec:csr-granularity">[sec:csr-granularity]</a>.</p>
<p>Syntactic dependencies are defined in terms of instructions’ <span><em>source registers</em></span>, instructions’ <span><em>destination registers</em></span>, and the way instructions <span><em>carry a dependency</em></span> from their source registers to their destination registers.
This section provides a general definition of all of these terms; however, Section <a href="dep-table.html#sec:source-dest-regs" data-reference-type="ref" data-reference="sec:source-dest-regs">[sec:source-dest-regs]</a> provides a complete listing of the specifics for each instruction.</p>
<p>In general, a register <span class="math inline"><em>r</em></span> other than <span>x0</span> is a <span><em>source register</em></span> for an instruction <span class="math inline"><em>i</em></span> if any of the following hold:</p>
<ul>
<li><p>In the opcode of <span class="math inline"><em>i</em></span>, <span><em>rs1</em></span>, <span><em>rs2</em></span>, or <span><em>rs3</em></span> is set to <span class="math inline"><em>r</em></span></p></li>
<li><p><span class="math inline"><em>i</em></span> is a CSR instruction, and in the opcode of <span class="math inline"><em>i</em></span>, <span><em>csr</em></span> is set to <span class="math inline"><em>r</em></span>, unless <span class="math inline"><em>i</em></span> is CSRRW or CSRRWI and <span><em>rd</em></span> is set to <span>x0</span></p></li>
<li><p><span class="math inline"><em>r</em></span> is a CSR and an implicit source register for <span class="math inline"><em>i</em></span>, as defined in Section <a href="dep-table.html#sec:source-dest-regs" data-reference-type="ref" data-reference="sec:source-dest-regs">[sec:source-dest-regs]</a></p></li>
<li><p><span class="math inline"><em>r</em></span> is a CSR that aliases with another source register for <span class="math inline"><em>i</em></span></p></li>
</ul>
<p>Memory instructions also further specify which source registers are <span><em>address source registers</em></span> and which are <span><em>data source registers</em></span>.</p>
<p>In general, a register <span class="math inline"><em>r</em></span> other than <span>x0</span> is a <span><em>destination register</em></span> for an instruction <span class="math inline"><em>i</em></span> if any of the following hold:</p>
<ul>
<li><p>In the opcode of <span class="math inline"><em>i</em></span>, <span><em>rd</em></span> is set to <span class="math inline"><em>r</em></span></p></li>
<li><p><span class="math inline"><em>i</em></span> is a CSR instruction, and in the opcode of <span class="math inline"><em>i</em></span>, <span><em>csr</em></span> is set to <span class="math inline"><em>r</em></span>, unless <span class="math inline"><em>i</em></span> is CSRRS or CSRRC and <span><em>rs1</em></span> is set to <span>x0</span> or <span class="math inline"><em>i</em></span> is CSRRSI or CSRRCI and uimm[4:0] is set to zero.</p></li>
<li><p><span class="math inline"><em>r</em></span> is a CSR and an implicit destination register for <span class="math inline"><em>i</em></span>, as defined in Section <a href="dep-table.html#sec:source-dest-regs" data-reference-type="ref" data-reference="sec:source-dest-regs">[sec:source-dest-regs]</a></p></li>
<li><p><span class="math inline"><em>r</em></span> is a CSR that aliases with another destination register for <span class="math inline"><em>i</em></span></p></li>
</ul>
<p>Most non-memory instructions <span><em>carry a dependency</em></span> from each of their source registers to each of their destination registers.
However, there are exceptions to this rule; see Section <a href="dep-table.html#sec:source-dest-regs" data-reference-type="ref" data-reference="sec:source-dest-regs">[sec:source-dest-regs]</a></p>
<p>Instruction <span class="math inline"><em>j</em></span> has a <span><em>syntactic dependency</em></span> on instruction <span class="math inline"><em>i</em></span> via destination register <span class="math inline"><em>s</em></span> of <span class="math inline"><em>i</em></span> and source register <span class="math inline"><em>r</em></span> of <span class="math inline"><em>j</em></span> if either of the following hold:</p>
<ul>
<li><p><span class="math inline"><em>s</em></span> is the same as <span class="math inline"><em>r</em></span>, and no instruction program-ordered between <span class="math inline"><em>i</em></span> and <span class="math inline"><em>j</em></span> has <span class="math inline"><em>r</em></span> as a destination register</p></li>
<li><p>There is an instruction <span class="math inline"><em>m</em></span> program-ordered between <span class="math inline"><em>i</em></span> and <span class="math inline"><em>j</em></span> such that all of the following hold:</p>
<ol>
<li><p><span class="math inline"><em>j</em></span> has a syntactic dependency on <span class="math inline"><em>m</em></span> via destination register <span class="math inline"><em>q</em></span> and source register <span class="math inline"><em>r</em></span></p></li>
<li><p><span class="math inline"><em>m</em></span> has a syntactic dependency on <span class="math inline"><em>i</em></span> via destination register <span class="math inline"><em>s</em></span> and source register <span class="math inline"><em>p</em></span></p></li>
<li><p><span class="math inline"><em>m</em></span> carries a dependency from <span class="math inline"><em>p</em></span> to <span class="math inline"><em>q</em></span></p></li>
</ol></li>
</ul>
<p>Finally, in the definitions that follow, let <span class="math inline"><em>a</em></span> and <span class="math inline"><em>b</em></span> be two memory operations, and let <span class="math inline"><em>i</em></span> and <span class="math inline"><em>j</em></span> be the instructions that generate <span class="math inline"><em>a</em></span> and <span class="math inline"><em>b</em></span>, respectively.</p>
<p><span class="math inline"><em>b</em></span> has a <span><em>syntactic address dependency</em></span> on <span class="math inline"><em>a</em></span> if <span class="math inline"><em>r</em></span> is an address source register for <span class="math inline"><em>j</em></span> and <span class="math inline"><em>j</em></span> has a syntactic dependency on <span class="math inline"><em>i</em></span> via source register <span class="math inline"><em>r</em></span></p>
<p><span class="math inline"><em>b</em></span> has a <span><em>syntactic data dependency</em></span> on <span class="math inline"><em>a</em></span> if <span class="math inline"><em>b</em></span> is a store operation, <span class="math inline"><em>r</em></span> is a data source register for <span class="math inline"><em>j</em></span>, and <span class="math inline"><em>j</em></span> has a syntactic dependency on <span class="math inline"><em>i</em></span> via source register <span class="math inline"><em>r</em></span></p>
<p><span class="math inline"><em>b</em></span> has a <span><em>syntactic control dependency</em></span> on <span class="math inline"><em>a</em></span> if there is an instruction <span class="math inline"><em>m</em></span> program-ordered between <span class="math inline"><em>i</em></span> and <span class="math inline"><em>j</em></span> such that <span class="math inline"><em>m</em></span> is a branch or indirect jump and <span class="math inline"><em>m</em></span> has a syntactic dependency on <span class="math inline"><em>i</em></span>.</p>
<div class=commentary>
<p>Generally speaking, non-AMO load instructions do not have data source registers, and unconditional non-AMO store instructions do not have destination registers. However, a successful SC instruction is considered to have the register specified in <span><em>rd</em></span> as a destination register, and hence it is possible for an instruction to have a syntactic dependency on a successful SC instruction that precedes it in program order.</p>
</div>
<h3 id="preserved-program-order" class="unnumbered">Preserved Program Order</h3>
<p>The global memory order for any given execution of a program respects some but not all of each hart’s program order.
The subset of program order that must be respected by the global memory order is known as <span><em>preserved program order</em></span>.</p>
<p>The complete definition of preserved program order is as follows (and note that AMOs are simultaneously both loads and stores):
memory operation <span class="math inline"><em>a</em></span> precedes memory operation <span class="math inline"><em>b</em></span> in preserved program order (and hence also in the global memory order) if <span class="math inline"><em>a</em></span> precedes <span class="math inline"><em>b</em></span> in program order, <span class="math inline"><em>a</em></span> and <span class="math inline"><em>b</em></span> both access regular main memory (rather than I/O regions), and any of the following hold:</p>
<ul>
<li><p>Overlapping-Address Orderings:</p>
<ol>
<li><p><span id="ppo:-&gt;st" label="ppo:-&gt;st">[ppo:-&gt;st]</span> <span class="math inline"><em>b</em></span> is a store, and <span class="math inline"><em>a</em></span> and <span class="math inline"><em>b</em></span> access overlapping memory addresses</p></li>
<li><p><span id="ppo:rdw" label="ppo:rdw">[ppo:rdw]</span> <span class="math inline"><em>a</em></span> and <span class="math inline"><em>b</em></span> are loads, <span class="math inline"><em>x</em></span> is a byte read by both <span class="math inline"><em>a</em></span> and <span class="math inline"><em>b</em></span>, there is no store to <span class="math inline"><em>x</em></span> between <span class="math inline"><em>a</em></span> and <span class="math inline"><em>b</em></span> in program order, and <span class="math inline"><em>a</em></span> and <span class="math inline"><em>b</em></span> return values for <span class="math inline"><em>x</em></span> written by different memory operations</p></li>
<li><p><span id="ppo:amoforward" label="ppo:amoforward">[ppo:amoforward]</span> <span class="math inline"><em>a</em></span> is generated by an AMO or SC instruction, <span class="math inline"><em>b</em></span> is a load, and <span class="math inline"><em>b</em></span> returns a value written by <span class="math inline"><em>a</em></span></p></li>
</ol></li>
<li><p>Explicit Synchronization</p>
<ol>
<li><p><span id="ppo:fence" label="ppo:fence">[ppo:fence]</span> There is a FENCE instruction that orders <span class="math inline"><em>a</em></span> before <span class="math inline"><em>b</em></span></p></li>
<li><p><span id="ppo:acquire" label="ppo:acquire">[ppo:acquire]</span> <span class="math inline"><em>a</em></span> has an acquire annotation</p></li>
<li><p><span id="ppo:release" label="ppo:release">[ppo:release]</span> <span class="math inline"><em>b</em></span> has a release annotation</p></li>
<li><p><span id="ppo:rcsc" label="ppo:rcsc">[ppo:rcsc]</span> <span class="math inline"><em>a</em></span> and <span class="math inline"><em>b</em></span> both have RCsc annotations</p></li>
<li><p><span id="ppo:pair" label="ppo:pair">[ppo:pair]</span> <span class="math inline"><em>a</em></span> is paired with <span class="math inline"><em>b</em></span></p></li>
</ol></li>
<li><p>Syntactic Dependencies</p>
<ol>
<li><p><span id="ppo:addr" label="ppo:addr">[ppo:addr]</span> <span class="math inline"><em>b</em></span> has a syntactic address dependency on <span class="math inline"><em>a</em></span></p></li>
<li><p><span id="ppo:data" label="ppo:data">[ppo:data]</span> <span class="math inline"><em>b</em></span> has a syntactic data dependency on <span class="math inline"><em>a</em></span></p></li>
<li><p><span id="ppo:ctrl" label="ppo:ctrl">[ppo:ctrl]</span> <span class="math inline"><em>b</em></span> is a store, and <span class="math inline"><em>b</em></span> has a syntactic control dependency on <span class="math inline"><em>a</em></span></p></li>
</ol></li>
<li><p>Pipeline Dependencies</p>
<ol>
<li><p><span id="ppo:addrdatarfi" label="ppo:addrdatarfi">[ppo:addrdatarfi]</span> <span class="math inline"><em>b</em></span> is a load, and there exists some store <span class="math inline"><em>m</em></span> between <span class="math inline"><em>a</em></span> and <span class="math inline"><em>b</em></span> in program order such that <span class="math inline"><em>m</em></span> has an address or data dependency on <span class="math inline"><em>a</em></span>, and <span class="math inline"><em>b</em></span> returns a value written by <span class="math inline"><em>m</em></span></p></li>
<li><p><span id="ppo:addrpo" label="ppo:addrpo">[ppo:addrpo]</span> <span class="math inline"><em>b</em></span> is a store, and there exists some instruction <span class="math inline"><em>m</em></span> between <span class="math inline"><em>a</em></span> and <span class="math inline"><em>b</em></span> in program order such that <span class="math inline"><em>m</em></span> has an address dependency on <span class="math inline"><em>a</em></span></p></li>
</ol></li>
</ul>
<h3 id="memory-model-axioms" class="unnumbered">Memory Model Axioms</h3>
<p>An execution of a RISC-V program obeys the RVWMO memory consistency model only if there exists a global memory order conforming to preserved program order and satisfying the <span><em>load value axiom</em></span>, the <span><em>atomicity axiom</em></span>, and the <span><em>progress axiom</em></span>.</p>
<h5 id="rvwmo:ax:load"><span class="header-section-number">16.1.0.0.1</span> Load Value Axiom</h5>
<p>Each byte of each load <span class="math inline"><em>i</em></span> returns the value written to that byte by the store that is the latest in global memory order among the following stores:</p>
<ol>
<li><p>Stores that write that byte and that precede <span class="math inline"><em>i</em></span> in the global memory order</p></li>
<li><p>Stores that write that byte and that precede <span class="math inline"><em>i</em></span> in program order</p></li>
</ol>
<h5 id="rvwmo:ax:atom"><span class="header-section-number">16.1.0.0.2</span> Atomicity Axiom</h5>
<p>If <span class="math inline"><em>r</em></span> and <span class="math inline"><em>w</em></span> are paired load and store operations generated by aligned LR and SC instructions in a hart <span class="math inline"><em>h</em></span>, <span class="math inline"><em>s</em></span> is a store to byte <span class="math inline"><em>x</em></span>, and <span class="math inline"><em>r</em></span> returns a value written by <span class="math inline"><em>s</em></span>, then <span class="math inline"><em>s</em></span> must precede <span class="math inline"><em>w</em></span> in the global memory order, and there can be no store from a hart other than <span class="math inline"><em>h</em></span> to byte <span class="math inline"><em>x</em></span> following <span class="math inline"><em>s</em></span> and preceding <span class="math inline"><em>w</em></span> in the global memory order.</p>
<div class=commentary>
<p>The theoretically supports LR/SC pairs of different widths and to mismatched addresses, since implementations are permitted to allow SC operations to succeed in such cases. However, in practice, we expect such patterns to be rare, and their use is discouraged.</p>
</div>
<h5 id="rvwmo:ax:prog"><span class="header-section-number">16.1.0.0.3</span> Progress Axiom</h5>
<p>No memory operation may be preceded in the global memory order by an infinite sequence of other memory operations.</p>
<p><a href="dep-table.html" data-reference-type="ref" data-reference="dep-table">[dep-table]</a></p>

</body>
</html>
