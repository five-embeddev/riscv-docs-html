<html>
<head>
<link rel="stylesheet" href="../../assets/docs.css">
<title>RISC-V Instruction Set Manual, Volume I: RISC-V User-Level ISA</title>
</head>
<body>

<table>
<tr><th colspan=2>Metadata Table</th></tr>
<tr><th>Manual Type</th><td> user</td></tr>
<tr><th>Spec Revision</th><td> 20191214-</td></tr>
<tr><th>Spec Release Date</th><td> December 2019</td></tr>
<tr><th>Git Revision</th><td> isa-449cd0c</td></tr>
<tr><th>Git URL</th><td><a href=https://github.com/riscv/riscv-isa-manual.git>https://github.com/riscv/riscv-isa-manual.git</a></td></tr>
<tr><th>Source</th><td>src/zfh.tex</td></tr>
<tr><th>Conversion Date</th><td>2023/11/12</td></tr>
<tr><th>License</th><td><a href=https://creativecommons.org/licenses/by/4.0/>CC-by-4.0</a></td></tr>
</table>


<section id="zfh-and-zfhmin-standard-extensions-for-half-precision-floating-point-version-1.0" data-number="1">
<h1 data-number="15"><span class="header-section-number">15</span> “Zfh” and “Zfhmin” Standard Extensions for Half-Precision Floating-Point,
Version 1.0</h1>
<p>This chapter describes the Zfh standard extension for 16-bit half-precision
binary floating-point instructions compliant with the IEEE 754-2008 arithmetic
standard.
The Zfh extension depends on the single-precision floating-point extension, F.
The NaN-boxing scheme described in Section <a href="d.html#nanboxing" data-reference-type="ref" data-reference="nanboxing">[nanboxing]</a> is extended to
allow a half-precision value to be NaN-boxed inside a single-precision value
(which may be recursively NaN-boxed inside a double- or quad-precision value
when the D or Q extension is present).</p>
<div class=commentary>
<p>This extension primarily provides instructions that consume half-precision
operands and produce half-precision results.
However, it is also common to compute on half-precision data using higher
intermediate precision.
Although this extension provides explicit conversion instructions that suffice
to implement that pattern, future extensions might further accelerate such
computation with additional instructions that implicitly widen their
operands—e.g., half<span class="math inline">×</span>half<span class="math inline">+</span>single<span class="math inline">→</span>single—or implicitly
narrow their results—e.g., half<span class="math inline">+</span>single<span class="math inline">→</span>half.</p>
</div>
<section id="half-precision-load-and-store-instructions" data-number="1.1">
<h2 data-number="15.1"><span class="header-section-number">15.1</span> Half-Precision Load and Store Instructions</h2>
<p>New 16-bit variants of LOAD-FP and STORE-FP instructions are added,
encoded with a new value for the funct3 width field.</p>
<p><img src="zfh_00.svg" alt="image" /></p>
<p><img src="zfh_01.svg" alt="image" /></p>
<p>FLH and FSH are only guaranteed to execute atomically if the effective address
is naturally aligned.</p>
<p>FLH and FSH do not modify the bits being transferred; in particular, the
payloads of non-canonical NaNs are preserved.
FLH NaN-boxes the result written to <span><em>rd</em></span>, whereas FSH ignores all but
the lower 16 bits in <span><em>rs2</em></span>.</p>
</section>
<section id="half-precision-computational-instructions" data-number="1.2">
<h2 data-number="15.2"><span class="header-section-number">15.2</span> Half-Precision Computational Instructions</h2>
<p>A new supported format is added to the format field of most
instructions, as shown in Table <a href="zfh.html#tab:fpextfmth" data-reference-type="ref" data-reference="tab:fpextfmth">[tab:fpextfmth]</a>.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"><span><em>fmt</em></span> field</th>
<th style="text-align: center;">Mnemonic</th>
<th style="text-align: left;">Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">00</td>
<td style="text-align: center;">S</td>
<td style="text-align: left;">32-bit single-precision</td>
</tr>
<tr class="even">
<td style="text-align: center;">01</td>
<td style="text-align: center;">D</td>
<td style="text-align: left;">64-bit double-precision</td>
</tr>
<tr class="odd">
<td style="text-align: center;">10</td>
<td style="text-align: center;">H</td>
<td style="text-align: left;">16-bit half-precision</td>
</tr>
<tr class="even">
<td style="text-align: center;">11</td>
<td style="text-align: center;">Q</td>
<td style="text-align: left;">128-bit quad-precision</td>
</tr>
</tbody>
</table>
<p>The half-precision floating-point computational instructions are
defined analogously to their single-precision counterparts, but operate on
half-precision operands and produce half-precision results.</p>
<p><img src="zfh_02.svg" alt="image" /></p>
<p><img src="zfh_03.svg" alt="image" /></p>
</section>
<section id="half-precision-conversion-and-move-instructions" data-number="1.3">
<h2 data-number="15.3"><span class="header-section-number">15.3</span> Half-Precision Conversion and Move Instructions</h2>
<p>New floating-point-to-integer and integer-to-floating-point conversion
instructions are added. These instructions are defined analogously to the
single-precision-to-integer and integer-to-single-precision conversion
instructions. FCVT.W.H or FCVT.L.H converts a half-precision floating-point
number to a signed 32-bit or 64-bit integer, respectively. FCVT.H.W or
FCVT.H.L converts a 32-bit or 64-bit signed integer, respectively, into a
half-precision floating-point number. FCVT.WU.H, FCVT.LU.H, FCVT.H.WU, and
FCVT.H.LU variants convert to or from unsigned integer values. FCVT.L[U].H and
FCVT.H.L[U] are RV64-only instructions.</p>
<p><img src="zfh_04.svg" alt="image" /></p>
<p>New floating-point-to-floating-point conversion instructions are added. These
instructions are defined analogously to the double-precision
floating-point-to-floating-point conversion instructions.
FCVT.S.H or FCVT.H.S converts a half-precision floating-point number to
a single-precision floating-point number, or vice-versa, respectively.
If the D extension is present, FCVT.D.H or FCVT.H.D converts a half-precision
floating-point number to a double-precision floating-point number, or
vice-versa, respectively.
If the Q extension is present, FCVT.Q.H or FCVT.H.Q converts a half-precision
floating-point number to a quad-precision floating-point number, or
vice-versa, respectively.</p>
<p><img src="zfh_05.svg" alt="image" /></p>
<p>Floating-point to floating-point sign-injection instructions, FSGNJ.H,
FSGNJN.H, and FSGNJX.H are defined analogously to the single-precision
sign-injection instruction.</p>
<p><img src="zfh_06.svg" alt="image" /></p>
<p>Instructions are provided to move bit patterns between the floating-point and
integer registers.
FMV.X.H moves the half-precision value in floating-point register <span><em>rs1</em></span> to
a representation in IEEE 754-2008 standard encoding in integer register <span>
<em>rd</em></span>, filling the upper XLEN-16 bits with copies of the floating-point number’s
sign bit.</p>
<p>FMV.H.X moves the half-precision value encoded in IEEE 754-2008 standard
encoding from the lower 16 bits of integer register <span><em>rs1</em></span> to the
floating-point register <span><em>rd</em></span>, NaN-boxing the result.</p>
<p>FMV.X.H and FMV.H.X do not modify the bits being transferred; in particular,
the payloads of non-canonical NaNs are preserved.</p>
<p><img src="zfh_07.svg" alt="image" /></p>
</section>
<section id="half-precision-floating-point-compare-instructions" data-number="1.4">
<h2 data-number="15.4"><span class="header-section-number">15.4</span> Half-Precision Floating-Point Compare Instructions</h2>
<p>The half-precision floating-point compare instructions are
defined analogously to their single-precision counterparts, but operate on
half-precision operands.</p>
<p><img src="zfh_08.svg" alt="image" /></p>
</section>
<section id="half-precision-floating-point-classify-instruction" data-number="1.5">
<h2 data-number="15.5"><span class="header-section-number">15.5</span> Half-Precision Floating-Point Classify Instruction</h2>
<p>The half-precision floating-point classify instruction, FCLASS.H, is
defined analogously to its single-precision counterpart, but operates on
half-precision operands.</p>
<p><img src="zfh_09.svg" alt="image" /></p>
</section>
<section id="zfhmin-standard-extension-for-minimal-half-precision-floating-point" data-number="1.6">
<h2 data-number="15.6"><span class="header-section-number">15.6</span> “Zfhmin” Standard Extension for Minimal Half-Precision Floating-Point</h2>
<p>This section describes the Zfhmin standard extension, which provides minimal
support for 16-bit half-precision binary floating-point instructions.
The Zfhmin extension is a subset of the Zfh extension, consisting only
of data transfer and conversion instructions.
Like Zfh, the Zfhmin extension depends on the single-precision floating-point
extension, F.
The expectation is that Zfhmin software primarily uses the half-precision
format for storage, performing most computation in higher precision.</p>
<p>The Zfhmin extension includes the following instructions from the Zfh
extension: FLH, FSH, FMV.X.H, FMV.H.X, FCVT.S.H, and FCVT.H.S.
If the D extension is present, the FCVT.D.H and FCVT.H.D instructions are
also included.
If the Q extension is present, the FCVT.Q.H and FCVT.H.Q instructions are
additionally included.</p>
<div class=commentary>
<p>Zfhmin does not include the FSGNJ.H instruction, because it suffices to
instead use the FSGNJ.S instruction to move half-precision values between
floating-point registers.</p>
</div>
<div class=commentary>
<p>Half-precision addition, subtraction, multiplication, division, and
square-root operations can be faithfully emulated by converting the
half-precision operands to single-precision, performing the operation
using single-precision arithmetic, then converting back to
half-precision <span class="citation" data-cites="roux:hal-01091186"><a href="#ref-roux:hal-01091186">[roux:hal-01091186]</a></span>.
Performing half-precision fused multiply-addition using this method incurs
a 1-ulp error on some inputs for the RNE and RMM rounding modes.</p>
<p>Conversion from 8- or 16-bit integers to half-precision can be emulated by
first converting to single-precision, then converting to half-precision.
Conversion from 32-bit integer can be emulated by first converting to
double-precision.
If the D extension is not present and a 1-ulp error under RNE or RMM is
tolerable, 32-bit integers can be first converted to single-precision instead.
The same remark applies to conversions from 64-bit integers without the Q
extension.</p>
</div>
</section>
</section>

</body>
</html>
