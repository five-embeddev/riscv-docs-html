<html>
<head>
<link rel="stylesheet" href="../../assets/docs.css">
<title>RISC-V Instruction Set Manual, Volume I: RISC-V User-Level ISA</title>
</head>
<body>

<table>
<tr><th colspan=2>Metadata Table</th></tr>
<tr><th>Manual Type</th><td> user</td></tr>
<tr><th>Spec Revision</th><td> 20191214-</td></tr>
<tr><th>Spec Release Date</th><td> December 2019</td></tr>
<tr><th>Git Revision</th><td> isa-449cd0c</td></tr>
<tr><th>Git URL</th><td><a href=https://github.com/riscv/riscv-isa-manual.git>https://github.com/riscv/riscv-isa-manual.git</a></td></tr>
<tr><th>Source</th><td>src/zfinx.tex</td></tr>
<tr><th>Conversion Date</th><td>2023/11/12</td></tr>
<tr><th>License</th><td><a href=https://creativecommons.org/licenses/by/4.0/>CC-by-4.0</a></td></tr>
</table>


<section id="sec:zfinx" data-number="1">
<h1 data-number="23"><span class="header-section-number">23</span> “Zfinx”, “Zdinx”, “Zhinx”, “Zhinxmin”: Standard Extensions for Floating-Point in Integer Registers, Version 1.0</h1>
<p>This chapter defines the “Zfinx” extension (pronounced “z-f-in-x”)
that provides instructions similar to those in the standard
floating-point F extension for single-precision floating-point
instructions but which operate on the <span><code>x</code></span> registers instead of the
<span><code>f</code></span> registers. This chapter also defines the “Zdinx”,
“Zhinx”, and “Zhinxmin” extensions that provide similar
instructions for other floating-point precisions.</p>
<div class=commentary>
<p>The F extension uses separate <span><code>f</code></span> registers for floating-point
computation, to reduce register pressure and simplify the provision of
register-file ports for wide superscalars.
However, the additional <span>128</span> <span>B</span> of architectural state increases the
minimal implementation cost.
By eliminating the <span><code>f</code></span> registers, the Zfinx extension substantially
reduces the cost of simple RISC-V implementations with floating-point
instruction-set support.
Zfinx also reduces context-switch cost.</p>
<p>In general, software that assumes the presence of the F extension
is incompatible with software that assumes the presence of the Zfinx
extension, and vice versa.</p>
</div>
<p>The Zfinx extension adds all of the instructions that the F extension
adds, <span><em>except</em></span> for the transfer instructions FLW, FSW, FMV.W.X,
FMV.X.W, C.FLW[SP], and C.FSW[SP].</p>
<div class=commentary>
<p>Zfinx software uses integer loads and stores to transfer floating-point values
from and to memory.
Transfers between registers use either integer arithmetic or floating-point
sign-injection instructions.</p>
</div>
<p>The Zfinx variants of these F-extension instructions have the same semantics,
except that whenever such an instruction would have accessed an <span><code>f</code></span>
register, it instead accesses the <span><code>x</code></span> register with the same number.</p>
<section id="processing-of-narrower-values" data-number="1.1">
<h2 data-number="23.1"><span class="header-section-number">23.1</span> Processing of Narrower Values</h2>
<p>Floating-point operands of width <span><span><em>w</em></span> <span class="math inline">&lt;</span> XLEN bits</span> occupy bits
<span><span><em>w</em></span>-1:0</span> of an <span><code>x</code></span> register.
Floating-point operations on <span><em>w</em></span>-bit operands ignore operand bits
<span>XLEN-1:<span><em>w</em></span></span> .</p>
<p>Floating-point operations that produce <span><span><em>w</em></span> <span class="math inline">&lt;</span> XLEN-bit</span> results
fill bits <span>XLEN-1:<span><em>w</em></span></span> with copies of bit <span><span><em>w</em></span>-1</span> (the
sign bit).</p>
<div class=commentary>
<p>The NaN-boxing scheme employed in the <span><code>f</code></span> registers was designed to
efficiently support recoded floating-point formats.
Recoding is less practical for Zfinx, though, since the same registers
hold both floating-point and integer operands.
Hence, the need for NaN boxing is diminished.</p>
<p>Sign-extending 32-bit floating-point numbers when held in RV64 <span><code>x</code></span>
registers is compatible with the existing RV64 calling conventions, which
leave bits 63-32 undefined when passing a 32-bit floating point value in
<span><code>x</code></span> registers. To keep the architecture more regular, we extend this
pattern to 16-bit floating-point numbers in both RV32 and RV64.</p>
</div>
</section>
<section id="zdinx" data-number="1.2">
<h2 data-number="23.2"><span class="header-section-number">23.2</span> Zdinx</h2>
<p>The Zdinx extension provides analogous double-precision floating-point
instructions.
The Zdinx extension requires the Zfinx extension.</p>
<p>The Zdinx extension adds all of the instructions that the D extension
adds, <span><em>except</em></span> for the transfer instructions FLD, FSD, FMV.D.X,
FMV.X.D, C.FLD[SP], and C.FSD[SP].</p>
<p>The Zdinx variants of these D-extension instructions have the same semantics,
except that whenever such an instruction would have accessed an <span><code>f</code></span>
register, it instead accesses the <span><code>x</code></span> register with the same number.</p>
</section>
<section id="processing-of-wider-values" data-number="1.3">
<h2 data-number="23.3"><span class="header-section-number">23.3</span> Processing of Wider Values</h2>
<p>Double-precision operands in RV32Zdinx
are held in aligned <span><code>x</code></span>-register pairs, i.e.,
register numbers must be even.
Use of misaligned (odd-numbered) registers for double-width floating-point
operands is <span><em>reserved</em></span>.</p>
<p>Regardless of endianness, the lower-numbered register holds the low-order
bits, and the higher-numbered register holds the high-order bits: e.g., bits
31:0 of a double-precision operand in RV32Zdinx might be held in register
<span><code>x14</code></span>, with bits 63:32 of that operand held in <span><code>x15</code></span>.</p>
<p>When a double-width floating-point result is written to <span><code>x0</code></span>, the entire
write takes no effect: e.g., for RV32Zdinx, writing a double-precision result
to <span><code>x0</code></span> does not cause <span><code>x1</code></span> to be written.</p>
<p>When <span><code>x0</code></span> is used as a double-width floating-point operand, the entire
operand is zero—i.e., <span><code>x1</code></span> is not accessed.</p>
<div class=commentary>
<p>Load-pair and store-pair instructions are not provided, so transferring
double-precision operands in RV32Zdinx from or to memory requires
two loads or stores.
Register moves need only a single FSGNJ.D instruction, however.</p>
</div>
</section>
<section id="zhinx" data-number="1.4">
<h2 data-number="23.4"><span class="header-section-number">23.4</span> Zhinx</h2>
<p>The Zhinx extension provides analogous half-precision floating-point
instructions.
The Zhinx extension requires the Zfinx extension.</p>
<p>The Zhinx extension adds all of the instructions that the Zfh extension
adds, <span><em>except</em></span> for the transfer instructions FLH, FSH, FMV.H.X,
and FMV.X.H.</p>
<p>The Zhinx variants of these Zfh-extension instructions have the same semantics,
except that whenever such an instruction would have accessed an <span><code>f</code></span>
register, it instead accesses the <span><code>x</code></span> register with the same number.</p>
</section>
<section id="zhinxmin" data-number="1.5">
<h2 data-number="23.5"><span class="header-section-number">23.5</span> Zhinxmin</h2>
<p>The Zhinxmin extension provides minimal support for 16-bit half-precision
floating-point instructions that operate on the <span><code>x</code></span> registers.
The Zhinxmin extension requires the Zfinx extension.</p>
<p>The Zhinxmin extension includes the following instructions from the Zhinx
extension: FCVT.S.H and FCVT.H.S.
If the Zdinx extension is present, the FCVT.D.H and FCVT.H.D instructions are
also included.</p>
<div class=commentary>
<p>In the future, an RV64Zqinx quad-precision extension could be defined analogously
to RV32Zdinx.
An RV32Zqinx extension could also be defined but would require
quad-register groups.</p>
</div>
</section>
<section id="privileged-architecture-implications" data-number="1.6">
<h2 data-number="23.6"><span class="header-section-number">23.6</span> Privileged Architecture Implications</h2>
<p>In the standard privileged architecture defined in Volume II, the
<span><code>mstatus</code></span> field FS is hardwired to 0 if the Zfinx extension is
implemented, and FS no longer affects the trapping behavior of
floating-point instructions or <span><code>fcsr</code></span> accesses.</p>
<p>The <span><code>misa</code></span> bits F, D, and Q are hardwired to 0 when the Zfinx
extension is implemented.</p>
<div class=commentary>
<p>A future discoverability mechanism might be used to probe the existence
of the Zfinx, Zhinx, and Zdinx extensions.</p>
</div>
</section>
</section>

</body>
</html>
