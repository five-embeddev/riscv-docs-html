<html>
<head>
<link rel="stylesheet" href="../../assets/docs.css">
<title>RISC-V Instruction Set Manual, Volume I: RISC-V User-Level ISA</title>
</head>
<body>

<table>
<tr><th colspan=2>Metadata Table</th></tr>
<tr><th>Manual Type</th><td> user</td></tr>
<tr><th>Spec Revision</th><td> 20191214-</td></tr>
<tr><th>Spec Release Date</th><td> December 2019</td></tr>
<tr><th>Git Revision</th><td> isa-449cd0c</td></tr>
<tr><th>Git URL</th><td><a href=https://github.com/riscv/riscv-isa-manual.git>https://github.com/riscv/riscv-isa-manual.git</a></td></tr>
<tr><th>Source</th><td>src/rv128.tex</td></tr>
<tr><th>Conversion Date</th><td>2023/11/12</td></tr>
<tr><th>License</th><td><a href=https://creativecommons.org/licenses/by/4.0/>CC-by-4.0</a></td></tr>
</table>


<section id="rv128" data-number="1">
<h1 data-number="7"><span class="header-section-number">7</span> RV128I Base Integer Instruction Set, Version 1.7</h1>
<blockquote>
<p><span><em>“There is only one mistake that can be made in computer design that is
difficult to recover from—not having enough address bits for memory
addressing and memory management.”</em></span> Bell and Strecker, ISCA-3, 1976.</p>
</blockquote>
<p>This chapter describes RV128I, a variant of the RISC-V ISA
supporting a flat 128-bit address space. The variant is a
straightforward extrapolation of the existing RV32I and RV64I designs.</p>
<div class=commentary>
<p>The primary reason to extend integer register width is to support
larger address spaces. It is not clear when a flat address space larger
than 64 bits will be required. At the time of writing, the fastest
supercomputer in the world as measured by the Top500 benchmark had
over <span>1</span> <span>PB</span> of DRAM, and would require over 50 bits of address
space if all the DRAM resided in a single address space. Some
warehouse-scale computers already contain even larger quantities of
DRAM, and new dense solid-state non-volatile memories and fast
interconnect technologies might drive a demand for even larger memory
spaces. Exascale systems research is targeting <span>100</span> <span>PB</span>
memory systems, which occupy 57 bits of address space. At historic
rates of growth, it is possible that greater than 64 bits of address
space might be required before 2030.</p>
<p>History suggests that whenever it becomes clear that more than 64 bits
of address space is needed, architects will repeat intensive debates
about alternatives to extending the address space, including
segmentation, 96-bit address spaces, and software workarounds, until,
finally, flat 128-bit address spaces will be adopted as the simplest
and best solution.</p>
<p>We have not frozen the RV128 spec at this time, as there might be need
to evolve the design based on actual usage of 128-bit address spaces.</p>
</div>
<p>RV128I builds upon RV64I in the same way RV64I builds upon RV32I, with
integer registers extended to 128 bits (i.e., XLEN=128). Most integer
computational instructions are unchanged as they are defined to
operate on XLEN bits. The RV64I “*W” integer instructions that
operate on 32-bit values in the low bits of a register are retained
but now sign extend their results from bit 31 to bit 127. A new set of
“*D” integer instructions are added that operate on 64-bit values
held in the low bits of the 128-bit integer registers and sign extend
their results from bit 63 to bit 127. The “*D” instructions consume
two major opcodes (OP-IMM-64 and OP-64) in the standard 32-bit
encoding.</p>
<div class=commentary>
<p>To improve compatibility with RV64, in a reverse of how RV32 to RV64
was handled, we might change the decoding around to rename RV64I ADD
as a 64-bit ADDD, and add a 128-bit ADDQ in what was previously the
OP-64 major opcode (now renamed the OP-128 major opcode).</p>
</div>
<p>Shifts by an immediate (SLLI/SRLI/SRAI) are now encoded using the low
7 bits of the I-immediate, and variable shifts (SLL/SRL/SRA) use the
low 7 bits of the shift amount source register.</p>
<p>A LDU (load double unsigned) instruction is added using the existing
LOAD major opcode, along with new LQ and SQ instructions to load and
store quadword values. SQ is added to the STORE major opcode, while
LQ is added to the MISC-MEM major opcode.</p>
<p>The floating-point instruction set is unchanged, although the 128-bit
Q floating-point extension can now support FMV.X.Q and FMV.Q.X
instructions, together with additional FCVT instructions to and from
the T (128-bit) integer format.</p>
</section>

</body>
</html>
