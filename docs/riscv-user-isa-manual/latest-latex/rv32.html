<html>
<head>
<link rel="stylesheet" href="../../assets/docs.css">
<title>RISC-V Instruction Set Manual, Volume I: RISC-V User-Level ISA</title>
</head>
<body>

<table>
<tr><th colspan=2>Metadata Table</th></tr>
<tr><th>Manual Type</th><td> user</td></tr>
<tr><th>Spec Revision</th><td> 20191214-</td></tr>
<tr><th>Spec Release Date</th><td> December 2019</td></tr>
<tr><th>Git Revision</th><td> isa-449cd0c</td></tr>
<tr><th>Git URL</th><td><a href=https://github.com/riscv/riscv-isa-manual.git>https://github.com/riscv/riscv-isa-manual.git</a></td></tr>
<tr><th>Source</th><td>src/rv32.tex</td></tr>
<tr><th>Conversion Date</th><td>2023/11/12</td></tr>
<tr><th>License</th><td><a href=https://creativecommons.org/licenses/by/4.0/>CC-by-4.0</a></td></tr>
</table>


<section id="rv32" data-number="1">
<h1 data-number="2"><span class="header-section-number">2</span> RV32I Base Integer Instruction Set, Version 2.1</h1>
<p>This chapter describes the RV32I base integer instruction set.</p>
<div class=commentary>
<p>RV32I was designed to be sufficient to form a compiler target and to
support modern operating system environments. The ISA was also
designed to reduce the hardware required in a minimal implementation.
RV32I contains 40 unique instructions, though a simple implementation
might cover the ECALL/EBREAK instructions with a single SYSTEM
hardware instruction that always traps and might be able to implement
the FENCE instruction as a NOP, reducing base instruction count to 38
total. RV32I can emulate almost any other ISA extension (except the A
extension, which requires additional hardware support for atomicity).</p>
<p>In practice, a hardware implementation including the machine-mode
privileged architecture will also require the 6 CSR instructions.</p>
<p>Subsets of the base integer ISA might be useful for pedagogical
purposes, but the base has been defined such that there should be
little incentive to subset a real hardware implementation beyond
omitting support for misaligned memory accesses and treating all
SYSTEM instructions as a single trap.</p>
</div>
<div class=commentary>
<p>The standard RISC-V assembly language syntax is documented in the
Assembly Programmer’s Manual <span class="citation" data-cites="riscv-asm-manual"><a href="#ref-riscv-asm-manual">[riscv-asm-manual]</a></span>.</p>
</div>
<div class=commentary>
<p>Most of the commentary for RV32I also applies to the RV64I base.</p>
</div>
<section id="programmers-model-for-base-integer-isa" data-number="1.1">
<h2 data-number="2.1"><span class="header-section-number">2.1</span> Programmers’ Model for Base Integer ISA</h2>
<p>Figure <a href="rv32.html#gprs" data-reference-type="ref" data-reference="gprs">1.1</a> shows the unprivileged state for the base integer
ISA. For RV32I, the 32 <span><code>x</code></span> registers are each 32 bits wide, i.e.,
XLEN=32. Register <span><code>x0</code></span> is hardwired with all bits equal to 0.
General purpose registers <span><code>x1</code></span>–<span><code>x31</code></span> hold values that various
instructions interpret as a collection of Boolean values, or as two’s
complement signed binary integers or unsigned binary integers.</p>
<p>There is one additional unprivileged register: the program counter <span><code>pc</code></span>
holds the address of the current instruction.</p>
<figure>
<img src="rv32_00.svg" id="gprs" alt="" /><figcaption>RISC-V base unprivileged integer register state.</figcaption>
</figure>
<div class=commentary>
<p>There is no dedicated stack pointer or subroutine return address link
register in the Base Integer ISA; the instruction encoding allows any
<span><code>x</code></span> register to be used for these purposes. However, the standard
software calling convention uses register <span><code>x1</code></span> to hold the return
address for a call, with register <span><code>x5</code></span> available as an alternate
link register.
The standard calling convention uses register <span><code>x2</code></span> as the stack
pointer.</p>
<p>Hardware might choose to accelerate function calls and returns that
use <span><code>x1</code></span> or <span><code>x5</code></span>. See the descriptions of the JAL and JALR
instructions.</p>
<p>The optional compressed 16-bit instruction format is designed around
the assumption that <span><code>x1</code></span> is the return address register and <span><code> x2</code></span> is the stack pointer. Software using other conventions will
operate correctly but may have greater code size.</p>
</div>
<div class=commentary>
<p>The number of available architectural registers can have large impacts
on code size, performance, and energy consumption. Although 16
registers would arguably be sufficient for an integer ISA running
compiled code, it is impossible to encode a complete ISA with 16
registers in 16-bit instructions using a 3-address format. Although a
2-address format would be possible, it would increase instruction
count and lower efficiency. We wanted to avoid intermediate
instruction sizes (such as Xtensa’s 24-bit instructions) to simplify
base hardware implementations, and once a 32-bit instruction size was
adopted, it was straightforward to support 32 integer registers. A
larger number of integer registers also helps performance on
high-performance code, where there can be extensive use of loop
unrolling, software pipelining, and cache tiling.</p>
<p>For these reasons, we chose a conventional size of 32 integer
registers for RV32I. Dynamic register usage tends to be
dominated by a few frequently accessed registers, and regfile
implementations can be optimized to reduce access energy for the
frequently accessed registers <span class="citation" data-cites="jtseng:sbbci"><a href="#ref-jtseng:sbbci">[jtseng:sbbci]</a></span>. The optional
compressed 16-bit instruction format mostly only accesses 8 registers
and hence can provide a dense instruction encoding, while additional
instruction-set extensions could support a much larger register space
(either flat or hierarchical) if desired.</p>
<p>For resource-constrained embedded applications, we have defined the
RV32E subset, which only has 16 registers (Chapter <a href="rv32e.html#rv32e" data-reference-type="ref" data-reference="rv32e">[rv32e]</a>).</p>
</div>
</section>
<section id="base-instruction-formats" data-number="1.2">
<h2 data-number="2.2"><span class="header-section-number">2.2</span> Base Instruction Formats</h2>
<p>In the base RV32I ISA, there are four core instruction formats
(R/I/S/U), as shown in Figure <a href="rv32.html#fig:baseinstformats" data-reference-type="ref" data-reference="fig:baseinstformats">1.2</a>. All are a
fixed 32 bits in length.
The base ISA has IALIGN=32, meaning that instructions must be aligned on
a four-byte boundary in memory.
An instruction-address-misaligned exception is generated on a taken branch or
unconditional jump if the target address is not IALIGN-bit aligned.
This exception is reported on the branch or jump
instruction, not on the target instruction. No
instruction-address-misaligned exception is generated for a
conditional branch that is not taken.</p>
<div class=commentary>
<p>The alignment constraint for base ISA instructions is relaxed to a
two-byte boundary when instruction extensions with 16-bit lengths or
other odd multiples of 16-bit lengths are added (i.e., IALIGN=16).</p>
<p>Instruction-address-misaligned exceptions are reported on the branch
or jump that would cause instruction misalignment to help debugging,
and to simplify hardware design for systems with IALIGN=32, where these
are the only places where misalignment can occur.</p>
</div>
<p>The behavior upon decoding a reserved instruction is .
<div class=commentary>
<p>Some platforms may require that opcodes reserved for standard use raise
an illegal-instruction exception.
Other platforms may permit reserved opcode space be used for non-conforming
extensions.</p>
</div>
<figure>
<img src="rv32_01.svg" id="fig:baseinstformats" alt="" /><figcaption>RISC-V base instruction formats. Each immediate subfield is
labeled with the bit position (imm[<span><em>x</em></span> ]) in the immediate
value being produced, rather than the bit position within the
instruction’s immediate field as is usually done. </figcaption>
</figure>
<p>The RISC-V ISA keeps the source (<span><em>rs1</em></span> and <span><em>rs2</em></span>) and
destination (<span><em>rd</em></span>) registers at the same position in all formats
to simplify decoding. Except for the 5-bit immediates used in CSR
instructions (Chapter <a href="csr.html#csrinsts" data-reference-type="ref" data-reference="csrinsts">[csrinsts]</a>), immediates are always
sign-extended, and are generally packed towards the leftmost available
bits in the instruction and have been allocated to reduce hardware
complexity. In particular, the sign bit for all immediates is always
in bit 31 of the instruction to speed sign-extension circuitry.</p>
<div class=commentary>
<p>Decoding register specifiers is usually on the critical paths in
implementations, and so the instruction format was chosen to keep all
register specifiers at the same position in all formats at the expense
of having to move immediate bits across formats (a property shared
with RISC-IV aka. SPUR <span class="citation" data-cites="spur-jsscc1989"><a href="#ref-spur-jsscc1989">[spur-jsscc1989]</a></span>).</p>
<p>In practice, most immediates are either small or require all XLEN
bits. We chose an asymmetric immediate split (12 bits in regular
instructions plus a special load-upper-immediate instruction with 20
bits) to increase the opcode space available for regular instructions.</p>
<p>Immediates are sign-extended because we did not observe a benefit to
using zero-extension for some immediates as in the MIPS ISA and wanted
to keep the ISA as simple as possible.</p>
</div>
</section>
<section id="immediate-encoding-variants" data-number="1.3">
<h2 data-number="2.3"><span class="header-section-number">2.3</span> Immediate Encoding Variants</h2>
<p>There are a further two variants of the instruction formats (B/J)
based on the handling of immediates, as shown in
Figure <a href="rv32.html#fig:baseinstformatsimm" data-reference-type="ref" data-reference="fig:baseinstformatsimm">1.3</a>.</p>
<figure>
<img src="rv32_02.svg" id="fig:baseinstformatsimm" alt="" /><figcaption>RISC-V base instruction formats showing immediate variants.</figcaption>
</figure>
<p>The only difference between the S and B formats is that the 12-bit
immediate field is used to encode branch offsets in multiples of 2 in
the B format. Instead of shifting all bits in the
instruction-encoded immediate left by one in hardware as is
conventionally done, the middle bits (imm[10:1]) and sign bit stay in
fixed positions, while the lowest bit in S format (inst[7]) encodes a
high-order bit in B format.</p>
<p>Similarly, the only difference between the U and J formats is
that the 20-bit immediate is shifted left by 12 bits to form U
immediates and by 1 bit to form J immediates. The location of
instruction bits in the U and J format immediates is chosen to
maximize overlap with the other formats and with each other.</p>
<p>Figure <a href="rv32.html#fig:immtypes" data-reference-type="ref" data-reference="fig:immtypes">1.4</a> shows the immediates produced by each of the
base instruction formats, and is labeled to show which instruction
bit (inst[<span><em>y</em></span> ]) produces each bit of the immediate value.</p>
<figure>
<img src="rv32_03.svg" id="fig:immtypes" alt="" /><figcaption>Types of immediate produced by RISC-V instructions. The fields are labeled with the
instruction bits used to construct their value. Sign extension
always uses inst[31].</figcaption>
</figure>
<div class=commentary>
<p>Sign-extension is one of the most critical operations on immediates
(particularly for XLEN<span class="math inline">&gt;</span>32), and in RISC-V the sign bit for all immediates
is always held in bit 31 of the instruction to allow sign-extension to
proceed in parallel with instruction decoding.</p>
<p>Although more complex implementations might have separate adders for
branch and jump calculations and so would not benefit from keeping the
location of immediate bits constant across types of instruction, we
wanted to reduce the hardware cost of the simplest implementations.
By rotating bits in the instruction encoding of B and J immediates
instead of using dynamic hardware muxes to multiply the immediate by
2, we reduce instruction signal fanout and immediate mux costs by
around a factor of 2. The scrambled immediate encoding will add
negligible time to static or ahead-of-time compilation. For dynamic
generation of instructions, there is some small additional
overhead, but the most common short forward branches have
straightforward immediate encodings.</p>
</div>
</section>
<section id="integer-computational-instructions" data-number="1.4">
<h2 data-number="2.4"><span class="header-section-number">2.4</span> Integer Computational Instructions</h2>
<p>Most integer computational instructions operate on XLEN bits of values
held in the integer register file. Integer computational instructions
are either encoded as register-immediate operations using the I-type
format or as register-register operations using the R-type format.
The destination is register <span><em>rd</em></span> for both register-immediate and
register-register instructions. No integer computational instructions
cause arithmetic exceptions.</p>
<div class=commentary>
<p>We did not include special instruction-set support for overflow checks
on integer arithmetic operations in the base instruction set, as many
overflow checks can be cheaply implemented using RISC-V branches.
Overflow checking for unsigned addition requires only a single
additional branch instruction after the addition:
<code> add t0, t1, t2; bltu t0, t1, overflow</code>.</p>
<p>For signed addition, if one operand’s sign is known, overflow checking
requires only a single branch after the addition:
<code> addi t0, t1, +imm; blt t0, t1, overflow</code>. This covers the
common case of addition with an immediate operand.</p>
<p>For general signed addition, three additional instructions after the
addition are required, leveraging the observation that the sum should
be less than one of the operands if and only if the other operand is
negative.</p>
<pre><code>         add t0, t1, t2
         slti t3, t2, 0
         slt t4, t0, t1
         bne t3, t4, overflow</code></pre>
<p>In RV64I, checks of 32-bit signed additions can be optimized further by
comparing the results of ADD and ADDW on the operands.</p>
</div>
<section id="integer-register-immediate-instructions" class="unnumbered" data-number="">
<h4 class="unnumbered" data-number="1">Integer Register-Immediate Instructions</h4>
<p><img src="rv32_04.svg" alt="image" /></p>
<p>ADDI adds the sign-extended 12-bit immediate to register <span><em>rs1</em></span>.
Arithmetic overflow is ignored and the result is simply the low
XLEN bits of the result. ADDI <span><em>rd, rs1, 0</em></span> is used to implement the
MV <span><em>rd, rs1</em></span> assembler pseudoinstruction.</p>
<p>SLTI (set less than immediate) places the value 1 in register <span><em>rd</em></span>
if register <span><em>rs1</em></span> is less than the sign-extended immediate when
both are treated as signed numbers, else 0 is written to <span><em>rd</em></span>.
SLTIU is similar but compares the values as unsigned numbers (i.e.,
the immediate is first sign-extended to XLEN bits then treated as an
unsigned number). Note, SLTIU <span><em>rd, rs1, 1</em></span> sets <span><em>rd</em></span>
to 1 if <span><em>rs1</em></span> equals zero, otherwise sets <span><em>rd</em></span> to 0 (assembler
pseudoinstruction SEQZ <span><em>rd, rs</em></span>).</p>
<p>ANDI, ORI, XORI are logical operations that perform bitwise AND, OR,
and XOR on register <span><em>rs1</em></span> and the sign-extended 12-bit immediate
and place the result in <span><em>rd</em></span>. Note, XORI <span><em>rd, rs1, -1</em></span>
performs a bitwise logical inversion of register <span><em>rs1</em></span> (assembler
pseudoinstruction NOT <span><em>rd, rs</em></span>).</p>
<p><img src="rv32_05.svg" alt="image" /></p>
<p>Shifts by a constant are encoded as a specialization of the
I-type format. The operand to be shifted is in <span><em>rs1</em></span>, and the
shift amount is encoded in the lower 5 bits of the I-immediate field.
The right shift type is encoded in bit 30.
SLLI is a logical left shift (zeros are shifted into the lower bits);
SRLI is a logical right shift (zeros are shifted into the upper bits);
and SRAI is an arithmetic right shift (the original sign bit is copied
into the vacated upper bits).</p>
<p><img src="rv32_06.svg" alt="image" /></p>
<p>LUI (load upper immediate) is used to build 32-bit constants and uses
the U-type format. LUI places the 32-bit U-immediate value into
the destination register <span><em>rd</em></span>, filling in the lowest 12
bits with zeros.</p>
<p>AUIPC (add upper immediate to <span><code>pc</code></span>) is used to build <span><code>pc</code></span>-relative
addresses and uses the U-type format. AUIPC forms a 32-bit offset from the
U-immediate, filling in the lowest 12 bits with zeros, adds this offset
to the address of the AUIPC instruction, then places the result in register <span><em>rd</em></span>.</p>
<div class=commentary>
<p>The assembly syntax for <span><code>lui</code></span> and <span><code>auipc</code></span> does not represent the lower
12 bits of the U-immediate, which are always zero.</p>
<p>The AUIPC instruction supports two-instruction sequences to access
arbitrary offsets from the <span><code>pc</code></span> for both control-flow transfers and data
accesses. The combination of an AUIPC and the 12-bit immediate in a
JALR can transfer control to any 32-bit <span><code>pc</code></span>-relative address, while an
AUIPC plus the 12-bit immediate offset in regular load or store
instructions can access any 32-bit <span><code>pc</code></span>-relative data address.</p>
<p>The current <span><code>pc</code></span> can be obtained by setting the U-immediate to 0.
Although a JAL +4 instruction could also be used to obtain the local
<span><code>pc</code></span> (of the instruction following the JAL), it might cause pipeline
breaks in simpler microarchitectures or pollute branch-target buffer
structures in more complex microarchitectures.</p>
</div>
</section>
<section id="integer-register-register-operations" class="unnumbered" data-number="">
<h4 class="unnumbered" data-number="1">Integer Register-Register Operations</h4>
<p>RV32I defines several arithmetic R-type operations. All operations
read the <span><em>rs1</em></span> and <span><em>rs2</em></span> registers as source operands and
write the result into register <span><em>rd</em></span>. The <span><em>funct7</em></span> and <span>
<em>funct3</em></span> fields select the type of operation.</p>
<p><img src="rv32_07.svg" alt="image" /></p>
<p>ADD performs the addition of <span><em>rs1</em></span> and <span><em>rs2</em></span>. SUB performs the
subtraction of <span><em>rs2</em></span> from <span><em>rs1</em></span>. Overflows are ignored and the low XLEN
bits of results are written to the destination <span><em>rd</em></span>.
SLT and SLTU perform signed and unsigned compares
respectively, writing 1 to <span><em>rd</em></span> if <span class="math inline"><em>rs1</em>  &lt;  <em>rs2</em></span>, 0 otherwise. Note, SLTU <span><em>rd</em></span>, <span><em>x0</em></span>, <span><em>rs2</em></span> sets
<span><em>rd</em></span> to 1 if <span><em>rs2</em></span> is not equal to zero, otherwise sets <span>
<em>rd</em></span> to zero (assembler pseudoinstruction SNEZ <span><em>rd, rs</em></span>). AND, OR, and
XOR perform bitwise logical operations.</p>
<p>SLL, SRL, and SRA perform logical left, logical right, and arithmetic
right shifts on the value in register <span><em>rs1</em></span> by the shift amount
held in the lower 5 bits of register <span><em>rs2</em></span>.</p>
</section>
<section id="nop-instruction" class="unnumbered" data-number="">
<h4 class="unnumbered" data-number="1">NOP Instruction</h4>
<p><img src="rv32_08.svg" alt="image" /></p>
<p>The NOP instruction does not change any architecturally visible state, except for
advancing the <span><code>pc</code></span> and incrementing any applicable performance
counters. NOP is encoded as ADDI <span><em>x0, x0, 0</em></span>.</p>
<div class=commentary>
<p>NOPs can be used to align code segments to microarchitecturally
significant address boundaries, or to leave space for inline code
modifications. Although there are many possible ways to encode a NOP,
we define a canonical NOP encoding to allow microarchitectural
optimizations as well as for more readable disassembly output. The
other NOP encodings are made available for HINT instructions
(Section <a href="rv32.html#sec:rv32i-hints" data-reference-type="ref" data-reference="sec:rv32i-hints">1.9</a>).</p>
<p>ADDI was chosen for the NOP encoding as this is most likely to take
fewest resources to execute across a range of systems (if not
optimized away in decode). In particular, the instruction only reads
one register. Also, an ADDI functional unit is more likely to be
available in a superscalar design as adds are the most common
operation. In particular, address-generation functional units can
execute ADDI using the same hardware needed for base+offset address
calculations, while register-register ADD or logical/shift operations
require additional hardware.</p>
</div>
</section>
</section>
<section id="control-transfer-instructions" data-number="1.5">
<h2 data-number="2.5"><span class="header-section-number">2.5</span> Control Transfer Instructions</h2>
<p>RV32I provides two types of control transfer instructions:
unconditional jumps and conditional branches. Control transfer
instructions in RV32I do <span><em>not</em></span> have architecturally visible delay
slots.</p>
<p>If an instruction access-fault or instruction page-fault exception occurs
on the target of a jump or taken branch, the exception is reported on the
target instruction, not on the jump or branch instruction.</p>
<section id="unconditional-jumps" class="unnumbered" data-number="">
<h4 class="unnumbered" data-number="1">Unconditional Jumps</h4>
<p>The jump and link (JAL) instruction uses the J-type
format, where the J-immediate encodes a signed offset in multiples of
2 bytes. The offset is sign-extended and added to the address of
the jump instruction
to form the jump target address. Jumps can therefore target a
<span class="math inline">±</span><span>1</span> <span>MiB</span> range. JAL stores the address of the instruction
that follows the JAL (<span><code>pc</code></span>+4) into register <span><em>rd</em></span>. The standard
software calling convention uses <span><code>x1</code></span> as the return address
register and <span><code>x5</code></span> as an alternate link register.</p>
<div class=commentary>
<p>The alternate link register supports calling millicode routines (e.g.,
those to save and restore registers in compressed code) while
preserving the regular return address register. The register <span><code>x5</code></span>
was chosen as the alternate link register as it maps to a temporary in
the standard calling convention, and has an encoding that is only one
bit different than the regular link register.</p>
</div>
<p>Plain unconditional jumps (assembler pseudoinstruction J) are encoded as a JAL
with <span><em>rd</em></span>=<span><code>x0</code></span>.</p>
<p><img src="rv32_09.svg" alt="image" /></p>
<p>The indirect jump instruction JALR (jump and link register) uses the
I-type encoding. The target address is obtained by adding the sign-extended
12-bit I-immediate to the register <span><em>rs1</em></span>, then setting the
least-significant bit of the result to zero. The address of
the instruction following the jump (<span><code>pc</code></span>+4) is written to register
<span><em>rd</em></span>. Register <span><code>x0</code></span> can be used as the destination if the
result is not required.</p>
<p><img src="rv32_10.svg" alt="image" /></p>
<div class=commentary>
<p>The unconditional jump instructions all use <span><code>pc</code></span>-relative addressing to
help support position-independent code. The JALR instruction was
defined to enable a two-instruction sequence to jump anywhere in a
32-bit absolute address range. A LUI instruction can first load <span>
<em>rs1</em></span> with the upper 20 bits of a target address, then JALR can add
in the lower bits. Similarly, AUIPC then JALR can jump
anywhere in a 32-bit <span><code>pc</code></span>-relative address range.</p>
<p>Note that the JALR instruction does not treat the 12-bit immediate as
multiples of 2 bytes, unlike the conditional branch instructions.
This avoids one more immediate format in hardware. In
practice, most uses of JALR will have either a zero immediate or be
paired with a LUI or AUIPC, so the slight reduction in range is not
significant.</p>
<p>Clearing the least-significant bit when calculating the JALR target
address both simplifies the hardware slightly and allows the
low bit of function pointers to be used to store auxiliary
information. Although there is potentially a slight loss of error
checking in this case, in practice jumps to an incorrect instruction
address will usually quickly raise an exception.</p>
<p>When used with a base <span><em>rs1</em></span><span class="math inline">=</span><span><code>x0</code></span>, JALR can be used to implement
a single instruction subroutine call to the lowest <span>2</span> <span>KiB</span> or highest
<span>2</span> <span>KiB</span> address region from anywhere in the address space, which could
be used to implement fast calls to a small runtime library. Alternatively,
an ABI could dedicate a general-purpose register to point to a library
elsewhere in the address space.</p>
</div>
<p>The JAL and JALR instructions will generate an
instruction-address-misaligned exception if the target address is not
aligned to an IALIGN-bit boundary.</p>
<div class=commentary>
<p>Instruction-address-misaligned exceptions are not possible on machines
with IALIGN=16, such as those that support the
compressed instruction-set extension, C.</p>
</div>
<p>Return-address prediction stacks are a common feature of
high-performance instruction-fetch units, but require accurate
detection of instructions used for procedure calls and returns to be
effective. For RISC-V, hints as to the instructions’ usage are encoded
implicitly via the register numbers used. A JAL instruction should
push the return address onto a return-address stack (RAS) only when
<span><em>rd</em></span> is <span><code>x1</code></span> or <span><code>x5</code></span>. JALR instructions should push/pop a
RAS as shown in the Table <a href="rv32.html#rashints" data-reference-type="ref" data-reference="rashints">[rashints]</a>.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"><em>rd</em> is <code>x1</code>/<code>x5</code></th>
<th style="text-align: center;"><em>rs1</em> is <code>x1</code>/<code>x5</code></th>
<th style="text-align: center;"><em>rd</em><span class="math inline">=</span><em>rs1</em></th>
<th style="text-align: left;">RAS action</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">No</td>
<td style="text-align: center;">No</td>
<td style="text-align: center;">–</td>
<td style="text-align: left;">None</td>
</tr>
<tr class="even">
<td style="text-align: center;">No</td>
<td style="text-align: center;">Yes</td>
<td style="text-align: center;">–</td>
<td style="text-align: left;">Pop</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Yes</td>
<td style="text-align: center;">No</td>
<td style="text-align: center;">–</td>
<td style="text-align: left;">Push</td>
</tr>
<tr class="even">
<td style="text-align: center;">Yes</td>
<td style="text-align: center;">Yes</td>
<td style="text-align: center;">No</td>
<td style="text-align: left;">Pop, then push</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Yes</td>
<td style="text-align: center;">Yes</td>
<td style="text-align: center;">Yes</td>
<td style="text-align: left;">Push</td>
</tr>
</tbody>
</table>
<div class=commentary>
<p>Some other ISAs added explicit hint bits to their indirect-jump instructions
to guide return-address stack manipulation. We use implicit hinting tied to
register numbers and the calling convention to reduce the encoding space used
for these hints.</p>
<p>When two different link registers (<span><code>x1</code></span> and <span><code>x5</code></span>) are given as
<span><em>rs1</em></span> and <span><em>rd</em></span>, then the RAS is both popped and pushed to
support coroutines. If <span><em>rs1</em></span> and <span><em>rd</em></span> are the same link
register (either <span><code>x1</code></span> or <span><code>x5</code></span>), the RAS is only pushed to
enable macro-op fusion of the sequences:
<span><code>lui ra, imm20; jalr ra, imm12(ra)</code></span>  and  <span><code>auipc ra, imm20; jalr ra, imm12(ra)</code></span></p>
</div>
</section>
<section id="conditional-branches" class="unnumbered" data-number="">
<h4 class="unnumbered" data-number="1">Conditional Branches</h4>
<p>All branch instructions use the B-type instruction format. The
12-bit B-immediate encodes signed offsets in multiples of 2 bytes.
The offset is sign-extended and added
to the address of the branch instruction to give the target address. The
conditional branch range is <span class="math inline">±</span><span>4</span> <span>KiB</span>.</p>
<p><img src="rv32_11.svg" alt="image" /></p>
<p>Branch instructions compare two registers. BEQ and BNE take the
branch if registers <span><em>rs1</em></span> and <span><em>rs2</em></span> are equal or unequal
respectively. BLT and BLTU take the branch if <span><em>rs1</em></span> is less than
<span><em>rs2</em></span>, using signed and unsigned comparison respectively. BGE and
BGEU take the branch if <span><em>rs1</em></span> is greater than or equal to <span><em>rs2</em></span>,
using signed and unsigned comparison respectively. Note, BGT, BGTU,
BLE, and BLEU can be synthesized by reversing the operands to BLT,
BLTU, BGE, and BGEU, respectively.</p>
<div class=commentary>
<p>Signed array bounds may be checked with a single BLTU instruction, since
any negative index will compare greater than any nonnegative bound.</p>
</div>
<p>Software should be optimized such that the sequential code path is the
most common path, with less-frequently taken code paths placed out of
line. Software should also assume that backward branches will be
predicted taken and forward branches as not taken, at least the
first time they are encountered. Dynamic predictors should quickly
learn any predictable branch behavior.</p>
<p>Unlike some other architectures, the RISC-V jump (JAL with <span>
<em>rd</em></span>=<span><code>x0</code></span>) instruction should always be used for unconditional
branches instead of a conditional branch instruction with an
always-true condition. RISC-V jumps are also <span><code>pc</code></span>-relative and support
a much wider offset range than branches, and will not pollute
conditional-branch prediction tables.</p>
<div class=commentary>
<p>The conditional branches were designed to include arithmetic
comparison operations between two registers (as also done in PA-RISC,
Xtensa, and MIPS R6), rather than use condition codes (x86, ARM, SPARC,
PowerPC), or to only compare one register against zero (Alpha, MIPS),
or two registers only for equality (MIPS). This design was motivated
by the observation that a combined compare-and-branch instruction fits
into a regular pipeline, avoids additional condition code state or use
of a temporary register, and reduces static code size and dynamic
instruction fetch traffic. Another point is that comparisons against
zero require non-trivial circuit delay (especially after the move to
static logic in advanced processes) and so are almost as expensive as
arithmetic magnitude compares. Another advantage of a fused
compare-and-branch instruction is that branches are observed earlier
in the front-end instruction stream, and so can be predicted earlier.
There is perhaps an advantage to a design with condition codes in the
case where multiple branches can be taken based on the same condition
codes, but we believe this case to be relatively rare.</p>
<p>We considered but did not include static branch hints in the
instruction encoding. These can reduce the pressure on dynamic
predictors, but require more instruction encoding space and
software profiling for best results, and can result in poor
performance if production runs do not match profiling runs.</p>
<p>We considered but did not include conditional moves or predicated
instructions, which can effectively replace unpredictable short
forward branches. Conditional moves are the simpler of the two, but
are difficult to use with conditional code that might cause exceptions
(memory accesses and floating-point operations). Predication adds
additional flag state to a system, additional instructions to set and
clear flags, and additional encoding overhead on every instruction.
Both conditional move and predicated instructions add complexity to
out-of-order microarchitectures, adding an implicit third source
operand due to the need to copy the original value of the destination
architectural register into the renamed destination physical register
if the predicate is false. Also, static compile-time decisions to use
predication instead of branches can result in lower performance on
inputs not included in the compiler training set, especially given
that unpredictable branches are rare, and becoming rarer as branch
prediction techniques improve.</p>
<p>We note that various microarchitectural techniques exist to
dynamically convert unpredictable short forward branches into
internally predicated code to avoid the cost of flushing pipelines on
a branch mispredict <span class="citation" data-cites="heil-tr1996 Klauser-1998 Kim-micro2005"><a href="#ref-heil-tr1996">[heil-tr1996 Klauser-1998 Kim-micro2005]</a></span> and
have been implemented in commercial processors <span class="citation" data-cites="ibmpower7"><a href="#ref-ibmpower7">[ibmpower7]</a></span>.
The simplest techniques just reduce the penalty of recovering from a
mispredicted short forward branch by only flushing instructions in the
branch shadow instead of the entire fetch pipeline, or by fetching
instructions from both sides using wide instruction fetch or idle
instruction fetch slots. More complex techniques for out-of-order
cores add internal predicates on instructions in the branch shadow,
with the internal predicate value written by the branch instruction,
allowing the branch and following instructions to be executed
speculatively and out-of-order with respect to other code <span class="citation" data-cites="ibmpower7"><a href="#ref-ibmpower7">[ibmpower7]</a></span>.</p>
</div>
<p>The conditional branch instructions will generate an
instruction-address-misaligned exception if the target address is not
aligned to an IALIGN-bit boundary and the branch condition evaluates
to true. If the branch condition evaluates to false, the
instruction-address-misaligned exception will not be raised.</p>
<div class=commentary>
<p>Instruction-address-misaligned exceptions are not possible on machines
with IALIGN=16, such as those that support the
compressed instruction-set extension, C.</p>
</div>
</section>
</section>
<section id="sec:rv32:ldst" data-number="1.6">
<h2 data-number="2.6"><span class="header-section-number">2.6</span> Load and Store Instructions</h2>
<p>RV32I is a load-store architecture, where only load and store
instructions access memory and arithmetic instructions only operate on
CPU registers. RV32I provides a 32-bit address space that is
byte-addressed.
The EEI will define what portions of the address space are legal to access with
which instructions (e.g., some addresses might be read only, or
support word access only). Loads with a destination of <span><code>x0</code></span> must
still raise any exceptions and cause any other side effects even
though the load value is discarded.</p>
<p>The EEI will define whether the memory system is little-endian or big-endian.
In RISC-V, endianness is byte-address invariant.
<div class=commentary>
<p>In a system for which endianness is byte-address invariant, the following
property holds: if a byte is stored to memory at some address in some
endianness, then a byte-sized load from that address in any endianness returns
the stored value.</p>
<p>In a little-endian configuration, multibyte stores write the least-significant
register byte at the lowest memory byte address, followed by the other
register bytes in ascending order of their significance.
Loads similarly transfer the contents of the lesser memory byte addresses to
the less-significant register bytes.</p>
<p>In a big-endian configuration, multibyte stores write the most-significant
register byte at the lowest memory byte address, followed by the other
register bytes in descending order of their significance.
Loads similarly transfer the contents of the greater memory byte addresses to
the less-significant register bytes.</p>
</div>
<p><img src="rv32_12.svg" alt="image" /></p>
<p><img src="rv32_13.svg" alt="image" /></p>
<p>Load and store instructions transfer a value between the registers and
memory. Loads are encoded in the I-type format and stores are
S-type. The effective address is obtained by adding register
<span><em>rs1</em></span> to the sign-extended 12-bit offset. Loads copy a value
from memory to register <span><em>rd</em></span>. Stores copy the value in register
<span><em>rs2</em></span> to memory.</p>
<p>The LW instruction loads a 32-bit value from memory into <span><em>rd</em></span>. LH
loads a 16-bit value from memory, then sign-extends to 32-bits before
storing in <span><em>rd</em></span>. LHU loads a 16-bit value from memory but then
zero extends to 32-bits before storing in <span><em>rd</em></span>. LB and LBU are
defined analogously for 8-bit values. The SW, SH, and SB instructions
store 32-bit, 16-bit, and 8-bit values from the low bits of register
<span><em>rs2</em></span> to memory.</p>
<p>Regardless of EEI, loads and stores whose effective addresses are
naturally aligned shall not raise an address-misaligned exception.
Loads and stores whose effective address is not naturally aligned
to the referenced datatype (i.e., the effective address is
not divisible by the size of the access in bytes) have behavior
dependent on the EEI.</p>
<p>An EEI may guarantee that misaligned loads and stores are fully
supported, and so the software running inside the execution
environment will never experience a contained or fatal
address-misaligned trap. In this case, the misaligned loads and
stores can be handled in hardware, or via an invisible trap into the
execution environment implementation, or possibly a combination of
hardware and invisible trap depending on address.</p>
<p>An EEI may not guarantee misaligned loads and stores are handled
invisibly. In this case, loads and stores that are not naturally
aligned may either complete execution successfully or raise an
exception. The exception raised can be either an address-misaligned
exception or an access-fault exception. For a memory access that would
otherwise be able to complete except for the misalignment, an
access-fault exception can be raised instead of an address-misaligned
exception if the misaligned access should not be emulated, e.g., if
accesses to the memory region have side effects. When an EEI does not
guarantee misaligned loads and stores are handled invisibly, the EEI
must define if exceptions caused by address misalignment result in a
contained trap (allowing software running inside the execution
environment to handle the trap) or a fatal trap (terminating
execution).</p>
<div class=commentary>
<p>Misaligned accesses are occasionally required when porting legacy
code, and help performance on applications when using any form of
packed-SIMD extension or handling externally packed data structures.
Our rationale for allowing EEIs to choose to support misaligned
accesses via the regular load and store instructions is to simplify
the addition of misaligned hardware support. One option would have
been to disallow misaligned accesses in the base ISAs and then provide
some separate ISA support for misaligned accesses, either special
instructions to help software handle misaligned accesses or a new
hardware addressing mode for misaligned accesses. Special
instructions are difficult to use, complicate the ISA, and often add
new processor state (e.g., SPARC VIS align address offset register) or
complicate access to existing processor state (e.g., MIPS LWL/LWR
partial register writes). In addition, for loop-oriented packed-SIMD
code, the extra overhead when operands are misaligned motivates
software to provide multiple forms of loop depending on operand
alignment, which complicates code generation and adds to loop startup
overhead. New misaligned hardware addressing modes take considerable
space in the instruction encoding or require very simplified
addressing modes (e.g., register indirect only).</p>
</div>
<p>Even when misaligned loads and stores complete successfully, these
accesses might run extremely slowly depending on the implementation
(e.g., when implemented via an invisible trap). Furthermore, whereas
naturally aligned loads and stores are guaranteed to execute
atomically, misaligned loads and stores might not, and hence
require additional synchronization to ensure atomicity.</p>
<div class=commentary>
<p>We do not mandate atomicity for misaligned accesses so execution
environment implementations can use an invisible machine trap and
a software handler to handle some or all misaligned accesses. If
hardware misaligned support is provided, software can exploit this by
simply using regular load and store instructions. Hardware can then
automatically optimize accesses depending on whether runtime addresses
are aligned.</p>
</div>
</section>
<section id="sec:fence" data-number="1.7">
<h2 data-number="2.7"><span class="header-section-number">2.7</span> Memory Ordering Instructions</h2>
<p><img src="rv32_14.svg" alt="image" /></p>
<p>The FENCE instruction is used to order device I/O and
memory accesses as viewed by other RISC-V harts and external devices
or coprocessors. Any combination of device input (I), device output
(O), memory reads (R), and memory writes (W) may be ordered with
respect to any combination of the same. Informally, no other RISC-V
hart or external device can observe any operation in the <span>
<em>successor</em></span> set following a FENCE before any operation in the <span>
<em>predecessor</em></span> set preceding the FENCE.
Chapter <a href="rvwmo.html#ch:memorymodel" data-reference-type="ref" data-reference="ch:memorymodel">[ch:memorymodel]</a> provides a precise description of the
RISC-V memory consistency model.</p>
<p>The FENCE instruction also orders memory reads and writes made by the
hart as observed by memory reads and writes made by an external
device. However, FENCE does not order observations of events made by
an external device using any other signaling mechanism.</p>
<div class=commentary>
<p>A device might observe an access to a memory location via some
external communication mechanism, e.g., a memory-mapped control
register that drives an interrupt signal to an interrupt controller.
This communication is outside the scope of the FENCE ordering
mechanism and hence the FENCE instruction can provide no guarantee on
when a change in the interrupt signal is visible to the interrupt
controller. Specific devices might provide additional ordering
guarantees to reduce software overhead but those are outside the scope
of the RISC-V memory model.</p>
</div>
<p>The EEI will define what I/O operations are possible, and in
particular, which memory addresses when accessed by load and store instructions will be treated and
ordered as device input and device output operations respectively
rather than memory reads and writes. For example, memory-mapped I/O
devices will typically be accessed with uncached loads and stores that
are ordered using the I and O bits rather than the R and W bits.
Instruction-set extensions might also describe new I/O
instructions that will also be ordered using the I and O bits in a
FENCE.</p>
<figure>
<img src="rv32_15.svg" id="fm" alt="" /><figcaption>Fence mode encoding.</figcaption>
</figure>
<p>The fence mode field <span><em>fm</em></span> defines the semantics of the FENCE. A
FENCE with <span><em>fm</em></span>=0000 orders all memory operations in its
predecessor set before all memory operations in its successor set.</p>
<p>The FENCE.TSO instruction is encoded as a FENCE instruction
with <span><em>fm</em></span>=1000, <span><em>predecessor</em></span>=RW, and <span><em>successor</em></span>=RW.
FENCE.TSO orders all load
operations in its predecessor set before all memory operations in its
successor set, and all store operations in its predecessor set before
all store operations in its successor set. This leaves non-AMO store
operations in the FENCE.TSO’s predecessor set unordered with non-AMO
loads in its successor set.</p>
<div class=commentary>
<p>Because <span>FENCE RW,RW</span> imposes a superset of the orderings that
FENCE.TSO imposes, it is correct to ignore the <span><em>fm</em></span> field and
implement FENCE.TSO as <span>FENCE RW,RW</span> .</p>
</div>
<p>The unused fields in the FENCE instructions—<span><em>rs1</em></span> and <span><em>rd</em></span>—are
reserved for finer-grain fences in future extensions. For forward
compatibility, base implementations shall ignore these fields, and standard
software shall zero these fields. Likewise, many <span><em>fm</em></span> and
predecessor/successor set settings in Table <a href="rv32.html#fm" data-reference-type="ref" data-reference="fm">1.5</a> are also reserved
for future use. Base implementations shall treat all such reserved
configurations as normal fences with <span><em>fm</em></span>=0000, and standard
software shall use only non-reserved configurations.</p>
<div class=commentary>
<p>We chose a relaxed memory model to allow high performance from simple
machine implementations and from likely future
coprocessor or accelerator extensions. We separate out I/O ordering
from memory R/W ordering to avoid unnecessary serialization within a
device-driver hart and also to support alternative non-memory paths
to control added coprocessors or I/O devices. Simple implementations
may additionally ignore the <span><em>predecessor</em></span> and <span><em>successor</em></span>
fields and always execute a conservative fence on all operations.</p>
</div>
</section>
<section id="environment-call-and-breakpoints" data-number="1.8">
<h2 data-number="2.8"><span class="header-section-number">2.8</span> Environment Call and Breakpoints</h2>
<p>SYSTEM instructions are used to access system functionality that might
require privileged access and are encoded using the I-type instruction
format. These can be divided into two main classes: those that
atomically read-modify-write control and status registers (CSRs), and
all other potentially privileged instructions. CSR instructions are
described in Chapter <a href="csr.html#csrinsts" data-reference-type="ref" data-reference="csrinsts">[csrinsts]</a>, and the base unprivileged instructions
are described in the following section.</p>
<div class=commentary>
<p>The SYSTEM instructions are defined to allow simpler implementations
to always trap to a single software trap handler. More sophisticated
implementations might execute more of each system instruction in
hardware.</p>
</div>
<p><img src="rv32_16.svg" alt="image" /></p>
<p>These two instructions cause a precise requested trap to the
supporting execution environment.</p>
<p>The ECALL instruction is used to make a service request to the
execution environment. The EEI will define how parameters for the
service request are passed, but usually these will be in defined
locations in the integer register file.</p>
<p>The EBREAK instruction is used to return control to a debugging
environment.</p>
<div class=commentary>
<p>ECALL and EBREAK were previously named SCALL and SBREAK. The
instructions have the same functionality and encoding, but were
renamed to reflect that they can be used more generally than to call a
supervisor-level operating system or debugger.</p>
</div>
<div class=commentary>
<p>EBREAK was primarily designed to be used by a debugger to cause
execution to stop and fall back into the debugger. EBREAK is also
used by the standard gcc compiler to mark code paths that should not
be executed.</p>
<p>Another use of EBREAK is to support “semihosting”, where the
execution environment includes a debugger that can provide services
over an alternate system call interface built around the EBREAK
instruction. Because the RISC-V base ISAs do not provide more than
one EBREAK instruction, RISC-V semihosting uses a special sequence of
instructions to distinguish a semihosting EBREAK from a debugger
inserted EBREAK.</p>
<pre><code>    slli x0, x0, 0x1f   # Entry NOP
    ebreak              # Break to debugger
    srai x0, x0, 7      # NOP encoding the semihosting call number 7</code></pre>
<p>Note that these three instructions must be 32-bit-wide instructions,
i.e., they mustn’t be among the compressed 16-bit instructions
described in Chapter <a href="c.html#compressed" data-reference-type="ref" data-reference="compressed">[compressed]</a>.</p>
<p>The shift NOP instructions are still considered available for use as
HINTs.</p>
<p>Semihosting is a form of service call and would be more naturally
encoded as an ECALL using an existing ABI, but this would require
the debugger to be able to intercept ECALLs, which is a newer
addition to the debug standard. We intend to move over to using
ECALLs with a standard ABI, in which case, semihosting can share a
service ABI with an existing standard.</p>
<p>We note that ARM processors have also moved to using SVC instead of
BKPT for semihosting calls in newer designs.</p>
</div>
</section>
<section id="sec:rv32i-hints" data-number="1.9">
<h2 data-number="2.9"><span class="header-section-number">2.9</span> HINT Instructions</h2>
<p>RV32I reserves a large encoding space for HINT instructions, which are
usually used to communicate performance hints to the
microarchitecture.
Like the NOP instruction, HINTs do not change any architecturally visible
state, except for advancing the <span><code>pc</code></span> and any applicable performance
counters.
Implementations are always allowed to ignore the encoded hints.</p>
<p>Most RV32I HINTs are encoded as integer computational instructions with
<span><em>rd</em></span>=<span><code>x0</code></span>.
The other RV32I HINTs are encoded as FENCE instructions with a null
predecessor or successor set and with <span><em>fm</em></span>=0.</p>
<div class=commentary>
<p>These HINT encodings have been chosen so that simple implementations can ignore
HINTs altogether, and instead execute a HINT as a regular
instruction that happens not to mutate the architectural state. For example, ADD is
a HINT if the destination register is <span><code>x0</code></span>; the five-bit <span><em>rs1</em></span> and <span>
<em>rs2</em></span> fields encode arguments to the HINT. However, a simple implementation can
simply execute the HINT as an ADD of <span><em>rs1</em></span> and <span><em>rs2</em></span> that writes <span><code> x0</code></span>, which has no architecturally visible effect.</p>
<p>As another example, a FENCE instruction with a zero <span><em>pred</em></span> field and
a zero <span><em>fm</em></span> field is a HINT; the <span><em>succ</em></span>, <span><em>rs1</em></span>, and <span><em>rd</em></span>
fields encode the arguments to the HINT.
A simple implementation can simply execute the HINT as a FENCE that orders the
null set of prior memory accesses before whichever subsequent memory accesses
are encoded in the <span><em>succ</em></span> field.
Since the intersection of the predecessor and successor sets is null, the
instruction imposes no memory orderings, and so it has no architecturally
visible effect.</p>
</div>
<p>Table <a href="rv32.html#tab:rv32i-hints" data-reference-type="ref" data-reference="tab:rv32i-hints">1.6</a> lists all RV32I HINT code points. 91% of the HINT
space is reserved for standard HINTs. The
remainder of the HINT space is designated for custom HINTs: no standard HINTs
will ever be defined in this subspace.</p>
<div class=commentary>
<p>We anticipate
standard hints to eventually include memory-system spatial and
temporal locality hints, branch prediction hints, thread-scheduling
hints, security tags, and instrumentation flags for
simulation/emulation.</p>
</div>
<figure>
<img src="rv32_17.svg" id="tab:rv32i-hints" alt="" /><figcaption>RV32I HINT instructions.</figcaption>
</figure>
</section>
</section>

</body>
</html>
