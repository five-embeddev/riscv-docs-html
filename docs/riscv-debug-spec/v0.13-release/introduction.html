<html>
<head>
<title>RISC-V External Debug Support</title>
</head>
<body>

<table>
<tr><th colspan=2>Metadata Table</th></tr>
<tr><th>Manual Type</th><td> debug</td></tr>
<tr><th>Spec Revision</th><td> 0.13.2</td></tr>
<tr><th>Spec Release Date</th><td> 2019-03-25</td></tr>
<tr><th>Git Revision</th><td> task_group_vote-4-g4e0bb0f</td></tr>
<tr><th>Git URL</th><td><a href=https://github.com/riscv/riscv-debug-spec.git>https://github.com/riscv/riscv-debug-spec.git</a></td></tr>
<tr><th>Source</th><td>introduction.tex</td></tr>
<tr><th>Conversion Date</th><td>2023/10/11</td></tr>
<tr><th>License</th><td><a href=https://creativecommons.org/licenses/by/4.0/>CC-by-4.0</a></td></tr>
</table>


<h1 id="sec:intro"><span class="header-section-number">1</span> Introduction</h1>
<p>When a design progresses from simulation to hardware implementation, a user’s
control and understanding of the system’s current state drops dramatically.
To help bring up and debug low level software and hardware,
it is critical to have good debugging support built into the hardware.
When a robust OS is running on a core, software can handle many
debugging tasks. However, in many scenarios, hardware support is essential.</p>
<p>This document outlines a standard architecture for external debug support
on RISC-V platforms. This architecture allows a variety of implementations and
tradeoffs, which is complementary to the wide range of RISC-V implementations.
At the same time, this specification defines common interfaces to
allow debugging tools and components to target a variety of platforms based on the RISC-V ISA.</p>
<p>System designers may choose to add additional hardware debug support,
but this specification defines a standard interface for common
functionality.</p>
<h2 id="terminology"><span class="header-section-number">1.1</span> Terminology</h2>
<p>A <em>platform</em> is a single integrated circuit consisting of one or more
<em>components</em>. Some components may be RISC-V cores, while others may have a different
function. Typically they will all be connected to a single system bus.
A single RISC-V core contains one or more hardware threads, called
<em>harts</em>.</p>
<p><em>DXLEN</em> of a hart is its widest supported XLEN, ignoring the current value
of in <span>misa</span>.</p>
<h3 id="context"><span class="header-section-number">1.1.1</span> Context</h3>
<p><span>This document is written to work with:</span></p>
<p>The RISC-V Instruction Set Manual, Volume I: User-Level ISA, Document
Version 2.2 (the ISA Spec)</p>
<p>The RISC-V Instruction Set Manual, Volume II: Privileged Architecture,
Version 1.10 (the Privileged Spec)</p>
<h3 id="versions"><span class="header-section-number">1.1.2</span> Versions</h3>
<p>Version 0.13 of this document was ratified by the RISC-V Foundation’s board.
Versions 0.13.<span class="math inline"><em>x</em></span> are bug fix releases to that ratified specification.</p>
<p>Version 0.14 will be forwards and backwards compatible with Version 0.13.</p>
<h2 id="about-this-document"><span class="header-section-number">1.2</span> About This Document</h2>
<h3 id="structure"><span class="header-section-number">1.2.1</span> Structure</h3>
<p>This document contains two parts. The main part of the document is the
specification, which is given in the numbered sections. The second part
of the document is a set of appendices. The information
in the appendices is intended to clarify and provide examples, but is
not part of the actual specification.</p>
<h3 id="register-definition-format"><span class="header-section-number">1.2.2</span> Register Definition Format</h3>
<p>All register definitions in this document follow the format shown below. A
simple graphic shows which fields are in the register. The upper and lower bit
indices are shown to the top left and top right of each field. The total number
of bits in the field are shown below it.</p>
<p>After the graphic follows a table which for each field lists its name,
description, allowed accesses, and reset value. The allowed accesses are listed
in Table <a href="introduction.html#tab:access" data-reference-type="ref" data-reference="tab:access">1.1</a>. The reset value is either a constant or “Preset.”
The latter means it is an implementation-specific legal value.</p>
<p>Names of registers and their fields are hyperlinks to their definition, and are
also listed in the index on page .</p>
<p><a href="sample_registers.html" data-reference-type="ref" data-reference="sample_registers.tex">[sample_registers.tex]</a></p>
<figure>
<img src="introduction_00.svg" alt="Register Access Abbreviations" id="tab:access" /><figcaption>Register Access Abbreviations<span label="tab:access"></span></figcaption>
</figure>
<h2 id="background"><span class="header-section-number">1.3</span> Background</h2>
<p>There are several use cases for dedicated debugging hardware, both
internal to a CPU core and with an external connection.
This specification addresses the use cases listed below. Implementations
can choose not to implement every feature, which means some use cases might
not be supported.</p>
<ul>
<li><p>Debugging low-level software in the absence of an OS or other software.</p></li>
<li><p>Debugging issues in the OS itself.</p></li>
<li><p>Bootstrapping a system to test, configure, and program components before
there is any executable code path in the system.</p></li>
<li><p>Accessing hardware on a system without a working CPU.</p></li>
</ul>
<p>In addition, even without a hardware debugging interface,
architectural support in a RISC-V CPU can aid software debugging and
performance analysis by allowing hardware triggers and breakpoints.</p>
<h2 id="supported-features"><span class="header-section-number">1.4</span> Supported Features</h2>
<p>The debug interface described in this specification supports the following features:</p>
<ol>
<li><p>All hart registers (including CSRs) can be read/written.</p></li>
<li><p>Memory can be accessed either from the hart’s point of view, through
the system bus directly, or both.</p></li>
<li><p>RV32, RV64, and future RV128 are all supported.</p></li>
<li><p>Any hart in the platform can be independently debugged.</p></li>
<li><p>A debugger can discover almost<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a> everything it needs
to know itself, without user configuration.</p></li>
<li><p>Each hart can be debugged from the very first instruction executed.</p></li>
<li><p>A RISC-V hart can be halted when a software breakpoint instruction is
executed.</p></li>
<li><p>Hardware single-step can execute one instruction at a time.</p></li>
<li><p>Debug functionality is independent of the debug transport used.</p></li>
<li><p>The debugger does not need to know anything about the microarchitecture
of the harts it is debugging.</p></li>
<li><p>Arbitrary subsets of harts can be halted and resumed simultaneously.
(Optional)</p></li>
<li><p>Arbitrary instructions can be executed on
a halted hart. That means no new debug functionality is needed when a
core has additional or custom instructions or state, as
long as there exist programs
that can move that state into GPRs. (Optional)</p></li>
<li><p>Registers can be accessed without halting. (Optional)</p></li>
<li><p>A running hart can be directed to execute a short sequence
of instructions, with little overhead. (Optional)</p></li>
<li><p>A system bus master allows memory access without
involving any hart. (Optional)</p></li>
<li><p>A RISC-V hart can be halted when a trigger matches the PC,
read/write address/data, or an instruction opcode. (Optional)</p></li>
</ol>
<p>This document does not suggest a strategy or implementation for hardware test,
debugging or error detection techniqes. Scan, BIST, etc. are out of scope of
this specification, but this specification does not intend to limit their use
in RISC-V systems.</p>
<p>It is possible to debug code that uses software threads, but there is no
special debug support for it.</p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Notable exceptions include
information about the memory map and peripherals.<a href="#fnref1" class="footnote-back">↩</a></p></li>
</ol>
</section>

</body>
</html>
