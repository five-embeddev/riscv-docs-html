---
opcodes:
  add:
    opcode:
    - add
    - rd
    - rs1
    - rs2
    - 31..25=0
    - 14..12=0
    - 6..2=0x0C
    - 1..0=3
    opcode_group: i
    opcode_args: &1
    - rd
    - rs1
    - rs2
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/rv32.html"
    main_desc: rv32
    main_id: "#integer-register-register-operations"
    desc:
      rv32:
        "#integer-computational-instructions":
          text:
          - In RV64I, checks of 32-bit signed additions can be optimized further by
            comparing the results of ADD and ADDW on the operands.
        "#integer-register-register-operations":
          text:
          - ADD performs the addition of rs1 and rs2. SUB performs the subtraction
            of rs2 from rs1. Overflows are ignored and the low XLEN bits of results
            are written to the destination rd. SLT and SLTU perform signed and unsigned
            compares respectively, writing 1 to rd if rs1 < rs2, 0 otherwise. Note,
            SLTU rd, x0, rs2 sets rd to 1 if rs2 is not equal to zero, otherwise sets
            rd to zero (assembler pseudoinstruction SNEZ rd, rs). AND, OR, and XOR
            perform bitwise logical operations.
        "#nop-instruction":
          text:
          - ADDI was chosen for the NOP encoding as this is most likely to take fewest
            resources to execute across a range of systems (if not optimized away
            in decode). In particular, the instruction only reads one register. Also,
            an ADDI functional unit is more likely to be available in a superscalar
            design as adds are the most common operation. In particular, address-generation
            functional units can execute ADDI using the same hardware needed for base+offset
            address calculations, while register-register ADD or logical/shift operations
            require additional hardware.
        "#sec:rv32i-hints":
          text:
          - These HINT encodings have been chosen so that simple implementations can
            ignore HINTs altogether, and instead execute a HINT as a regular instruction
            that happens not to mutate the architectural state. For example, ADD is
            a HINT if the destination register is x0; the five-bit rs1 and rs2 fields
            encode arguments to the HINT. However, a simple implementation can simply
            execute the HINT as an ADD of rs1 and rs2 that writes x0, which has no
            architecturally visible effect.
      rv64:
        "#integer-computational-instructions":
          text:
          - The compiler and calling convention maintain an invariant that all 32-bit
            values are held in a sign-extended format in 64-bit registers. Even 32-bit
            unsigned integers extend bit 31 into bits 63 through 32. Consequently,
            conversion between unsigned and signed 32-bit integers is a no-op, as
            is conversion from a signed 32-bit integer to a signed 64-bit integer.
            Existing 64-bit wide SLTU and unsigned branch compares still operate correctly
            on unsigned 32-bit integers under this invariant. Similarly, existing
            64-bit wide logical operations on 32-bit sign-extended integers preserve
            the sign-extension property. A few new instructions (ADD[I]W/SUBW/SxxW)
            are required for addition and shifts to ensure reasonable performance
            for 32-bit values.
        "#integer-register-register-operations":
          text:
          - ADDW and SUBW are RV64I-only instructions that are defined analogously
            to ADD and SUB but operate on 32-bit values and produce signed 32-bit
            results. Overflows are ignored, and the low 32-bits of the result is sign-extended
            to 64-bits and written to the destination register.
      rv128:
        "#rv128":
          text:
          - To improve compatibility with RV64, in a reverse of how RV32 to RV64 was
            handled, we might change the decoding around to rename RV64I ADD as a
            64-bit ADDD, and add a 128-bit ADDQ in what was previously the OP-64 major
            opcode (now renamed the OP-128 major opcode).
      c:
        "#integer-register-register-operations":
          text:
          - C.MV expands to a different instruction than the canonical MV pseudoinstruction,
            which instead uses ADDI. Implementations that handle MV specially, e.g.
            using register-renaming hardware, may find it more convenient to expand
            C.MV to MV instead of ADD, at slight additional hardware cost.
    iss_code:
    - WRITE_RD(sext_xlen(RS1 + RS2));
  add.uw:
    opcode:
    - add.uw
    - rd
    - rs1
    - rs2
    - 31..25=4
    - 14..12=0
    - 6..2=0x0E
    - 1..0=3
    opcode_group: zba
    opcode_args: *1
  addi:
    opcode:
    - addi
    - rd
    - rs1
    - imm12
    - 14..12=0
    - 6..2=0x04
    - 1..0=3
    opcode_group: i
    opcode_args: &2
    - rd
    - rs1
    - imm12
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/rv32.html"
    main_desc: rv32
    main_id: "#integer-register-immediate-instructions"
    desc:
      rv32:
        "#integer-register-immediate-instructions":
          text:
          - ADDI adds the sign-extended 12-bit immediate to register rs1. Arithmetic
            overflow is ignored and the result is simply the low XLEN bits of the
            result. ADDI rd, rs1, 0 is used to implement the MV rd, rs1 assembler
            pseudoinstruction.
        "#nop-instruction":
          text:
          - The NOP instruction does not change any architecturally visible state,
            except for advancing the pc and incrementing any applicable performance
            counters. NOP is encoded as ADDI x0, x0, 0.
          - ADDI was chosen for the NOP encoding as this is most likely to take fewest
            resources to execute across a range of systems (if not optimized away
            in decode). In particular, the instruction only reads one register. Also,
            an ADDI functional unit is more likely to be available in a superscalar
            design as adds are the most common operation. In particular, address-generation
            functional units can execute ADDI using the same hardware needed for base+offset
            address calculations, while register-register ADD or logical/shift operations
            require additional hardware.
      c:
        "#integer-register-register-operations":
          text:
          - C.MV expands to a different instruction than the canonical MV pseudoinstruction,
            which instead uses ADDI. Implementations that handle MV specially, e.g.
            using register-renaming hardware, may find it more convenient to expand
            C.MV to MV instead of ADD, at slight additional hardware cost.
    iss_code:
    - WRITE_RD(sext_xlen(RS1 + insn.i_imm()));
  addiw:
    opcode:
    - addiw
    - rd
    - rs1
    - imm12
    - 14..12=0
    - 6..2=0x06
    - 1..0=3
    opcode_group: i
    opcode_args: *2
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/rv64.html"
    main_desc: rv64
    main_id: "#integer-register-immediate-instructions"
    desc:
      rv64:
        "#integer-register-immediate-instructions":
          text:
          - ADDIW is an RV64I instruction that adds the sign-extended 12-bit immediate
            to register rs1 and produces the proper sign-extension of a 32-bit result
            in rd. Overflows are ignored and the result is the low 32 bits of the
            result sign-extended to 64 bits. Note, ADDIW rd, rs1, 0 writes the sign-extension
            of the lower 32 bits of register rs1 into register rd (assembler pseudoinstruction
            SEXT.W).
      c:
        "#overview":
          text:
          - The compressed instruction encodings are mostly common across RV32C, RV64C,
            and RV128C, but as shown in Table [rvcopcodemap] , a few opcodes are used
            for different purposes depending on base ISA. For example, the wider address-space
            RV64C and RV128C variants require additional opcodes to compress loads
            and stores of 64-bit integer values, while RV32C uses the same opcodes
            to compress loads and stores of single-precision floating-point values.
            Similarly, RV128C requires additional opcodes to capture loads and stores
            of 128-bit integer values, while these same opcodes are used for loads
            and stores of double-precision floating-point values in RV32C and RV64C.
            If the C extension is implemented, the appropriate compressed floating-point
            load and store instructions must be provided whenever the relevant standard
            floating-point extension (F and/or D) is also implemented. In addition,
            RV32C includes a compressed jump and link instruction to compress short-range
            subroutine calls, where the same opcode is used to compress ADDIW for
            RV64C and RV128C.
    iss_code:
    - require_rv64;
    - WRITE_RD(sext32(insn.i_imm() + RS1));
  addw:
    opcode:
    - addw
    - rd
    - rs1
    - rs2
    - 31..25=0
    - 14..12=0
    - 6..2=0x0E
    - 1..0=3
    opcode_group: i
    opcode_args: *1
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/rv32.html"
    main_desc: rv64
    main_id: "#integer-register-register-operations"
    desc:
      rv32:
        "#integer-computational-instructions":
          text:
          - In RV64I, checks of 32-bit signed additions can be optimized further by
            comparing the results of ADD and ADDW on the operands.
      rv64:
        "#integer-register-register-operations":
          text:
          - ADDW and SUBW are RV64I-only instructions that are defined analogously
            to ADD and SUB but operate on 32-bit values and produce signed 32-bit
            results. Overflows are ignored, and the low 32-bits of the result is sign-extended
            to 64-bits and written to the destination register.
    iss_code:
    - require_rv64;
    - WRITE_RD(sext32(RS1 + RS2));
  aes32dsi:
    opcode:
    - aes32dsi
    - rd
    - rs1
    - rs2
    - bs
    - 29..25=0b10101
    - 14..12=0
    - 6..0=0x33
    opcode_group: zknd
    opcode_args: *1
    iss_code:
    - ''
    - '#include "aes_common.h"'
    - ''
    - require_rv32;
    - require_extension(EXT_ZKND);
    - ''
    - uint8_t     bs = insn.bs();
    - ''
    - uint8_t     t0 = RS2 >> (8*bs);
    - uint8_t      x = AES_DEC_SBOX[t0];
    - uint32_t     u = x;
    - ''
    - u = (u << (8*bs)) | (u >> (32-8*bs));
    - ''
    - WRITE_RD(sext_xlen(u ^ RS1));
    - ''
  aes32dsmi:
    opcode:
    - aes32dsmi
    - rd
    - rs1
    - rs2
    - bs
    - 29..25=0b10111
    - 14..12=0
    - 6..0=0x33
    opcode_group: zknd
    opcode_args: *1
    iss_code:
    - ''
    - '#include "aes_common.h"'
    - ''
    - require_rv32;
    - require_extension(EXT_ZKND);
    - ''
    - uint8_t     bs = insn.bs();
    - ''
    - uint8_t     t0 = RS2 >> (8*bs);
    - uint8_t      x = AES_DEC_SBOX[t0];
    - uint32_t     u ;
    - ''
    - u = (AES_GFMUL(x,0xb) << 24) |
    - "(AES_GFMUL(x,0xd) << 16) |"
    - "(AES_GFMUL(x,0x9) <<  8) |"
    - "(AES_GFMUL(x,0xe) <<  0) ;"
    - ''
    - u = (u << (8*bs)) | (u >> (32-8*bs));
    - ''
    - WRITE_RD(sext_xlen(u ^ RS1));
    - ''
  aes32esi:
    opcode:
    - aes32esi
    - rd
    - rs1
    - rs2
    - bs
    - 29..25=0b10001
    - 14..12=0
    - 6..0=0x33
    opcode_group: zkne
    opcode_args: *1
    iss_code:
    - ''
    - '#include "aes_common.h"'
    - ''
    - require_rv32;
    - require_extension(EXT_ZKNE);
    - ''
    - uint8_t     bs = insn.bs();
    - ''
    - uint8_t     t0 = RS2 >> (8*bs);
    - uint8_t      x = AES_ENC_SBOX[t0];
    - uint32_t     u = x;
    - ''
    - u = (u << (8*bs)) | (u >> (32-8*bs));
    - ''
    - WRITE_RD(sext_xlen(u ^ RS1));
    - ''
  aes32esmi:
    opcode:
    - aes32esmi
    - rd
    - rs1
    - rs2
    - bs
    - 29..25=0b10011
    - 14..12=0
    - 6..0=0x33
    opcode_group: zkne
    opcode_args: *1
    iss_code:
    - ''
    - '#include "aes_common.h"'
    - ''
    - require_rv32;
    - require_extension(EXT_ZKNE);
    - ''
    - uint8_t     bs = insn.bs();
    - ''
    - uint8_t     t0 = RS2 >> (8*bs);
    - uint8_t      x = AES_ENC_SBOX[t0];
    - uint32_t     u ;
    - ''
    - u = (AES_GFMUL(x,3) << 24) |
    - "(          x    << 16) |"
    - "(          x    <<  8) |"
    - "(AES_GFMUL(x,2) <<  0) ;"
    - ''
    - u = (u << (8*bs)) | (u >> (32-8*bs));
    - ''
    - WRITE_RD(sext_xlen(u ^ RS1));
    - ''
  aes64ds:
    opcode:
    - aes64ds
    - rd
    - rs1
    - rs2
    - 31..30=0
    - 29..25=0b11101
    - 14..12=0b000
    - 6..0=0x33
    opcode_group: zknd
    opcode_args: *1
    iss_code:
    - ''
    - '#include "aes_common.h"'
    - ''
    - require_rv64;
    - require_extension(EXT_ZKND);
    - ''
    - uint64_t temp = AES_INVSHIFROWS_LO(RS1,RS2);
    - ''
    - temp = (
    - "((uint64_t)AES_DEC_SBOX[(temp >>  0) & 0xFF] <<  0) |"
    - "((uint64_t)AES_DEC_SBOX[(temp >>  8) & 0xFF] <<  8) |"
    - "((uint64_t)AES_DEC_SBOX[(temp >> 16) & 0xFF] << 16) |"
    - "((uint64_t)AES_DEC_SBOX[(temp >> 24) & 0xFF] << 24) |"
    - "((uint64_t)AES_DEC_SBOX[(temp >> 32) & 0xFF] << 32) |"
    - "((uint64_t)AES_DEC_SBOX[(temp >> 40) & 0xFF] << 40) |"
    - "((uint64_t)AES_DEC_SBOX[(temp >> 48) & 0xFF] << 48) |"
    - "((uint64_t)AES_DEC_SBOX[(temp >> 56) & 0xFF] << 56)"
    - ");"
    - ''
    - WRITE_RD(temp);
    - ''
  aes64dsm:
    opcode:
    - aes64dsm
    - rd
    - rs1
    - rs2
    - 31..30=0
    - 29..25=0b11111
    - 14..12=0b000
    - 6..0=0x33
    opcode_group: zknd
    opcode_args: *1
    iss_code:
    - ''
    - '#include "aes_common.h"'
    - ''
    - require_rv64;
    - require_extension(EXT_ZKND);
    - ''
    - uint64_t temp = AES_INVSHIFROWS_LO(RS1,RS2);
    - ''
    - temp = (
    - "((uint64_t)AES_DEC_SBOX[(temp >>  0) & 0xFF] <<  0) |"
    - "((uint64_t)AES_DEC_SBOX[(temp >>  8) & 0xFF] <<  8) |"
    - "((uint64_t)AES_DEC_SBOX[(temp >> 16) & 0xFF] << 16) |"
    - "((uint64_t)AES_DEC_SBOX[(temp >> 24) & 0xFF] << 24) |"
    - "((uint64_t)AES_DEC_SBOX[(temp >> 32) & 0xFF] << 32) |"
    - "((uint64_t)AES_DEC_SBOX[(temp >> 40) & 0xFF] << 40) |"
    - "((uint64_t)AES_DEC_SBOX[(temp >> 48) & 0xFF] << 48) |"
    - "((uint64_t)AES_DEC_SBOX[(temp >> 56) & 0xFF] << 56)"
    - ");"
    - ''
    - uint32_t col_0 = temp & 0xFFFFFFFF;
    - uint32_t col_1 = temp >> 32       ;
    - ''
    - col_0 = AES_INVMIXCOLUMN(col_0);
    - col_1 = AES_INVMIXCOLUMN(col_1);
    - ''
    - uint64_t result= ((uint64_t)col_1 << 32) | col_0;
    - ''
    - WRITE_RD(result);
    - ''
  aes64es:
    opcode:
    - aes64es
    - rd
    - rs1
    - rs2
    - 31..30=0
    - 29..25=0b11001
    - 14..12=0b000
    - 6..0=0x33
    opcode_group: zkne
    opcode_args: *1
    iss_code:
    - ''
    - '#include "aes_common.h"'
    - ''
    - require_rv64;
    - require_extension(EXT_ZKNE);
    - ''
    - uint64_t temp = AES_SHIFROWS_LO(RS1,RS2);
    - ''
    - temp = (
    - "((uint64_t)AES_ENC_SBOX[(temp >>  0) & 0xFF] <<  0) |"
    - "((uint64_t)AES_ENC_SBOX[(temp >>  8) & 0xFF] <<  8) |"
    - "((uint64_t)AES_ENC_SBOX[(temp >> 16) & 0xFF] << 16) |"
    - "((uint64_t)AES_ENC_SBOX[(temp >> 24) & 0xFF] << 24) |"
    - "((uint64_t)AES_ENC_SBOX[(temp >> 32) & 0xFF] << 32) |"
    - "((uint64_t)AES_ENC_SBOX[(temp >> 40) & 0xFF] << 40) |"
    - "((uint64_t)AES_ENC_SBOX[(temp >> 48) & 0xFF] << 48) |"
    - "((uint64_t)AES_ENC_SBOX[(temp >> 56) & 0xFF] << 56)"
    - ");"
    - ''
    - WRITE_RD(temp);
    - ''
  aes64esm:
    opcode:
    - aes64esm
    - rd
    - rs1
    - rs2
    - 31..30=0
    - 29..25=0b11011
    - 14..12=0b000
    - 6..0=0x33
    opcode_group: zkne
    opcode_args: *1
    iss_code:
    - ''
    - '#include "aes_common.h"'
    - ''
    - require_rv64;
    - require_extension(EXT_ZKNE);
    - ''
    - uint64_t temp = AES_SHIFROWS_LO(RS1,RS2);
    - ''
    - temp = (
    - "((uint64_t)AES_ENC_SBOX[(temp >>  0) & 0xFF] <<  0) |"
    - "((uint64_t)AES_ENC_SBOX[(temp >>  8) & 0xFF] <<  8) |"
    - "((uint64_t)AES_ENC_SBOX[(temp >> 16) & 0xFF] << 16) |"
    - "((uint64_t)AES_ENC_SBOX[(temp >> 24) & 0xFF] << 24) |"
    - "((uint64_t)AES_ENC_SBOX[(temp >> 32) & 0xFF] << 32) |"
    - "((uint64_t)AES_ENC_SBOX[(temp >> 40) & 0xFF] << 40) |"
    - "((uint64_t)AES_ENC_SBOX[(temp >> 48) & 0xFF] << 48) |"
    - "((uint64_t)AES_ENC_SBOX[(temp >> 56) & 0xFF] << 56)"
    - ");"
    - ''
    - uint32_t col_0 = temp & 0xFFFFFFFF;
    - uint32_t col_1 = temp >> 32       ;
    - ''
    - col_0 = AES_MIXCOLUMN(col_0);
    - col_1 = AES_MIXCOLUMN(col_1);
    - ''
    - uint64_t result= ((uint64_t)col_1 << 32) | col_0;
    - ''
    - WRITE_RD(result);
    - ''
  aes64im:
    opcode:
    - aes64im
    - rd
    - rs1
    - 31..30=0
    - 29..25=0b11000
    - 24..20=0b0000
    - 14..12=0b001
    - 6..0=0x13
    opcode_group: zknd
    opcode_args: &3
    - rd
    - rs1
    iss_code:
    - ''
    - '#include "aes_common.h"'
    - ''
    - require_rv64;
    - require_extension(EXT_ZKND);
    - ''
    - uint32_t col_0 = RS1 & 0xFFFFFFFF;
    - uint32_t col_1 = RS1 >> 32       ;
    - ''
    - col_0 = AES_INVMIXCOLUMN(col_0);
    - col_1 = AES_INVMIXCOLUMN(col_1);
    - ''
    - uint64_t result= ((uint64_t)col_1 << 32) | col_0;
    - ''
    - WRITE_RD(result);
    - ''
  aes64ks1i:
    opcode:
    - aes64ks1i
    - rd
    - rs1
    - rnum
    - 31..30=0
    - 29..25=0b11000
    - 24=1
    - 14..12=0b001
    - 6..0=0x13
    opcode_group: zknd
    opcode_args: *3
    iss_code:
    - ''
    - '#include "aes_common.h"'
    - ''
    - require_rv64;
    - require_either_extension(EXT_ZKND, EXT_ZKNE);
    - ''
    - uint8_t     round_consts [10] = {
    - 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36
    - "};"
    - ''
    - uint8_t     enc_rcon          = insn.rcon() ;
    - ''
    - require(enc_rcon <= 0xA);
    - ''
    - uint32_t    temp              = (RS1 >> 32) & 0xFFFFFFFF  ;
    - uint8_t     rcon              = 0            ;
    - uint64_t    result                           ;
    - ''
    - if (enc_rcon != 0xA) {
    - temp    = (temp >> 8) | (temp << 24); // Rotate right by 8
    - rcon    = round_consts[enc_rcon];
    - "}"
    - ''
    - temp        =
    - "((uint32_t)AES_ENC_SBOX[(temp >> 24) & 0xFF] << 24) |"
    - "((uint32_t)AES_ENC_SBOX[(temp >> 16) & 0xFF] << 16) |"
    - "((uint32_t)AES_ENC_SBOX[(temp >>  8) & 0xFF] <<  8) |"
    - "((uint32_t)AES_ENC_SBOX[(temp >>  0) & 0xFF] <<  0) ;"
    - ''
    - temp       ^= rcon;
    - ''
    - result      = ((uint64_t)temp << 32) | temp;
    - ''
    - WRITE_RD(result);
    - ''
  aes64ks2:
    opcode:
    - aes64ks2
    - rd
    - rs1
    - rs2
    - 31..30=1
    - 29..25=0b11111
    - 14..12=0b000
    - 6..0=0x33
    opcode_group: zknd
    opcode_args: *1
    iss_code:
    - ''
    - '#include "aes_common.h"'
    - ''
    - require_rv64;
    - require_either_extension(EXT_ZKND, EXT_ZKNE);
    - ''
    - uint32_t    rs1_hi  =  RS1 >> 32;
    - uint32_t    rs2_lo  =  RS2      ;
    - uint32_t    rs2_hi  =  RS2 >> 32;
    - ''
    - uint32_t    r_lo    = (rs1_hi ^ rs2_lo         ) ;
    - uint32_t    r_hi    = (rs1_hi ^ rs2_lo ^ rs2_hi) ;
    - uint64_t    result  =  ((uint64_t)r_hi << 32) | r_lo ;
    - ''
    - WRITE_RD(result);
    - ''
  amoadd.d:
    opcode:
    - amoadd.d
    - rd
    - rs1
    - rs2
    - aq
    - rl
    - 31..29=0
    - 28..27=0
    - 14..12=3
    - 6..2=0x0B
    - 1..0=3
    opcode_group: a
    opcode_args: *1
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/a.html"
    main_desc: a
    main_id: "#sec:amo"
    desc:
      a:
        "#sec:amo":
          text:
          - The atomic memory operation (AMO) instructions perform read-modify-write
            operations for multiprocessor synchronization and are encoded with an
            R-type instruction format. These AMO instructions atomically load a data
            value from the address in rs1, place the value into register rd, apply
            a binary operator to the loaded value and the original value in rs2, then
            store the result back to the original address in rs1. AMOs can either
            operate on 64-bit (RV64 only) or 32-bit words in memory. For RV64, 32-bit
            AMOs always sign-extend the value placed in rd, and ignore the upper 32
            bits of the original value of rs2.
      machine:
        "#sec:mcause":
          text:
          - Note that load and load-reserved instructions generate load exceptions,
            whereas store, store-conditional, and AMO instructions generate store/AMO
            exceptions.
      hypervisor:
        "#sec:tinst-vals":
          text:
          - As enumerated in the table, a synchronous exception may write to the trap
            instruction register a standard transformation of the trapping instruction
            only for exceptions that arise from explicit memory accesses (from loads,
            stores, and AMO instructions). Accordingly, standard transformations are
            currently defined only for these memory-access instructions. If a synchronous
            trap occurs for a standard instruction for which no transformation has
            been defined, the trap instruction register shall be written with zero
            (or, under certain circumstances, with a special pseudoinstruction value).
    iss_code:
    - require_extension('A');
    - require_rv64;
    - WRITE_RD(MMU.amo<uint64_t>(RS1, [&](uint64_t lhs) { return lhs + RS2; }));
  amoadd.w:
    opcode:
    - amoadd.w
    - rd
    - rs1
    - rs2
    - aq
    - rl
    - 31..29=0
    - 28..27=0
    - 14..12=2
    - 6..2=0x0B
    - 1..0=3
    opcode_group: a
    opcode_args: *1
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/a.html"
    main_desc: a
    main_id: "#sec:amo"
    desc:
      a:
        "#sec:amo":
          text:
          - The atomic memory operation (AMO) instructions perform read-modify-write
            operations for multiprocessor synchronization and are encoded with an
            R-type instruction format. These AMO instructions atomically load a data
            value from the address in rs1, place the value into register rd, apply
            a binary operator to the loaded value and the original value in rs2, then
            store the result back to the original address in rs1. AMOs can either
            operate on 64-bit (RV64 only) or 32-bit words in memory. For RV64, 32-bit
            AMOs always sign-extend the value placed in rd, and ignore the upper 32
            bits of the original value of rs2.
      machine:
        "#sec:mcause":
          text:
          - Note that load and load-reserved instructions generate load exceptions,
            whereas store, store-conditional, and AMO instructions generate store/AMO
            exceptions.
      hypervisor:
        "#sec:tinst-vals":
          text:
          - As enumerated in the table, a synchronous exception may write to the trap
            instruction register a standard transformation of the trapping instruction
            only for exceptions that arise from explicit memory accesses (from loads,
            stores, and AMO instructions). Accordingly, standard transformations are
            currently defined only for these memory-access instructions. If a synchronous
            trap occurs for a standard instruction for which no transformation has
            been defined, the trap instruction register shall be written with zero
            (or, under certain circumstances, with a special pseudoinstruction value).
    iss_code:
    - require_extension('A');
    - WRITE_RD(sext32(MMU.amo<uint32_t>(RS1, [&](uint32_t lhs) { return lhs + RS2;
      })));
  amoand.d:
    opcode:
    - amoand.d
    - rd
    - rs1
    - rs2
    - aq
    - rl
    - 31..29=3
    - 28..27=0
    - 14..12=3
    - 6..2=0x0B
    - 1..0=3
    opcode_group: a
    opcode_args: *1
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/a.html"
    main_desc: a
    main_id: "#sec:amo"
    desc:
      a:
        "#sec:amo":
          text:
          - The atomic memory operation (AMO) instructions perform read-modify-write
            operations for multiprocessor synchronization and are encoded with an
            R-type instruction format. These AMO instructions atomically load a data
            value from the address in rs1, place the value into register rd, apply
            a binary operator to the loaded value and the original value in rs2, then
            store the result back to the original address in rs1. AMOs can either
            operate on 64-bit (RV64 only) or 32-bit words in memory. For RV64, 32-bit
            AMOs always sign-extend the value placed in rd, and ignore the upper 32
            bits of the original value of rs2.
      machine:
        "#sec:mcause":
          text:
          - Note that load and load-reserved instructions generate load exceptions,
            whereas store, store-conditional, and AMO instructions generate store/AMO
            exceptions.
      hypervisor:
        "#sec:tinst-vals":
          text:
          - As enumerated in the table, a synchronous exception may write to the trap
            instruction register a standard transformation of the trapping instruction
            only for exceptions that arise from explicit memory accesses (from loads,
            stores, and AMO instructions). Accordingly, standard transformations are
            currently defined only for these memory-access instructions. If a synchronous
            trap occurs for a standard instruction for which no transformation has
            been defined, the trap instruction register shall be written with zero
            (or, under certain circumstances, with a special pseudoinstruction value).
    iss_code:
    - require_extension('A');
    - require_rv64;
    - WRITE_RD(MMU.amo<uint64_t>(RS1, [&](uint64_t lhs) { return lhs & RS2; }));
  amoand.w:
    opcode:
    - amoand.w
    - rd
    - rs1
    - rs2
    - aq
    - rl
    - 31..29=3
    - 28..27=0
    - 14..12=2
    - 6..2=0x0B
    - 1..0=3
    opcode_group: a
    opcode_args: *1
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/a.html"
    main_desc: a
    main_id: "#sec:amo"
    desc:
      a:
        "#sec:amo":
          text:
          - The atomic memory operation (AMO) instructions perform read-modify-write
            operations for multiprocessor synchronization and are encoded with an
            R-type instruction format. These AMO instructions atomically load a data
            value from the address in rs1, place the value into register rd, apply
            a binary operator to the loaded value and the original value in rs2, then
            store the result back to the original address in rs1. AMOs can either
            operate on 64-bit (RV64 only) or 32-bit words in memory. For RV64, 32-bit
            AMOs always sign-extend the value placed in rd, and ignore the upper 32
            bits of the original value of rs2.
      machine:
        "#sec:mcause":
          text:
          - Note that load and load-reserved instructions generate load exceptions,
            whereas store, store-conditional, and AMO instructions generate store/AMO
            exceptions.
      hypervisor:
        "#sec:tinst-vals":
          text:
          - As enumerated in the table, a synchronous exception may write to the trap
            instruction register a standard transformation of the trapping instruction
            only for exceptions that arise from explicit memory accesses (from loads,
            stores, and AMO instructions). Accordingly, standard transformations are
            currently defined only for these memory-access instructions. If a synchronous
            trap occurs for a standard instruction for which no transformation has
            been defined, the trap instruction register shall be written with zero
            (or, under certain circumstances, with a special pseudoinstruction value).
    iss_code:
    - require_extension('A');
    - WRITE_RD(sext32(MMU.amo<uint32_t>(RS1, [&](uint32_t lhs) { return lhs & RS2;
      })));
  amomax.d:
    opcode:
    - amomax.d
    - rd
    - rs1
    - rs2
    - aq
    - rl
    - 31..29=5
    - 28..27=0
    - 14..12=3
    - 6..2=0x0B
    - 1..0=3
    opcode_group: a
    opcode_args: *1
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/a.html"
    main_desc: a
    main_id: "#sec:amo"
    desc:
      a:
        "#sec:amo":
          text:
          - The atomic memory operation (AMO) instructions perform read-modify-write
            operations for multiprocessor synchronization and are encoded with an
            R-type instruction format. These AMO instructions atomically load a data
            value from the address in rs1, place the value into register rd, apply
            a binary operator to the loaded value and the original value in rs2, then
            store the result back to the original address in rs1. AMOs can either
            operate on 64-bit (RV64 only) or 32-bit words in memory. For RV64, 32-bit
            AMOs always sign-extend the value placed in rd, and ignore the upper 32
            bits of the original value of rs2.
      machine:
        "#sec:mcause":
          text:
          - Note that load and load-reserved instructions generate load exceptions,
            whereas store, store-conditional, and AMO instructions generate store/AMO
            exceptions.
      hypervisor:
        "#sec:tinst-vals":
          text:
          - As enumerated in the table, a synchronous exception may write to the trap
            instruction register a standard transformation of the trapping instruction
            only for exceptions that arise from explicit memory accesses (from loads,
            stores, and AMO instructions). Accordingly, standard transformations are
            currently defined only for these memory-access instructions. If a synchronous
            trap occurs for a standard instruction for which no transformation has
            been defined, the trap instruction register shall be written with zero
            (or, under certain circumstances, with a special pseudoinstruction value).
    iss_code:
    - require_extension('A');
    - require_rv64;
    - WRITE_RD(MMU.amo<uint64_t>(RS1, [&](int64_t lhs) { return std::max(lhs, int64_t(RS2));
      }));
  amomax.w:
    opcode:
    - amomax.w
    - rd
    - rs1
    - rs2
    - aq
    - rl
    - 31..29=5
    - 28..27=0
    - 14..12=2
    - 6..2=0x0B
    - 1..0=3
    opcode_group: a
    opcode_args: *1
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/a.html"
    main_desc: a
    main_id: "#sec:amo"
    desc:
      a:
        "#sec:amo":
          text:
          - The atomic memory operation (AMO) instructions perform read-modify-write
            operations for multiprocessor synchronization and are encoded with an
            R-type instruction format. These AMO instructions atomically load a data
            value from the address in rs1, place the value into register rd, apply
            a binary operator to the loaded value and the original value in rs2, then
            store the result back to the original address in rs1. AMOs can either
            operate on 64-bit (RV64 only) or 32-bit words in memory. For RV64, 32-bit
            AMOs always sign-extend the value placed in rd, and ignore the upper 32
            bits of the original value of rs2.
      machine:
        "#sec:mcause":
          text:
          - Note that load and load-reserved instructions generate load exceptions,
            whereas store, store-conditional, and AMO instructions generate store/AMO
            exceptions.
      hypervisor:
        "#sec:tinst-vals":
          text:
          - As enumerated in the table, a synchronous exception may write to the trap
            instruction register a standard transformation of the trapping instruction
            only for exceptions that arise from explicit memory accesses (from loads,
            stores, and AMO instructions). Accordingly, standard transformations are
            currently defined only for these memory-access instructions. If a synchronous
            trap occurs for a standard instruction for which no transformation has
            been defined, the trap instruction register shall be written with zero
            (or, under certain circumstances, with a special pseudoinstruction value).
    iss_code:
    - require_extension('A');
    - WRITE_RD(sext32(MMU.amo<uint32_t>(RS1, [&](int32_t lhs) { return std::max(lhs,
      int32_t(RS2)); })));
  amomaxu.d:
    opcode:
    - amomaxu.d
    - rd
    - rs1
    - rs2
    - aq
    - rl
    - 31..29=7
    - 28..27=0
    - 14..12=3
    - 6..2=0x0B
    - 1..0=3
    opcode_group: a
    opcode_args: *1
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/a.html"
    main_desc: a
    main_id: "#sec:amo"
    desc:
      a:
        "#sec:amo":
          text:
          - The atomic memory operation (AMO) instructions perform read-modify-write
            operations for multiprocessor synchronization and are encoded with an
            R-type instruction format. These AMO instructions atomically load a data
            value from the address in rs1, place the value into register rd, apply
            a binary operator to the loaded value and the original value in rs2, then
            store the result back to the original address in rs1. AMOs can either
            operate on 64-bit (RV64 only) or 32-bit words in memory. For RV64, 32-bit
            AMOs always sign-extend the value placed in rd, and ignore the upper 32
            bits of the original value of rs2.
      machine:
        "#sec:mcause":
          text:
          - Note that load and load-reserved instructions generate load exceptions,
            whereas store, store-conditional, and AMO instructions generate store/AMO
            exceptions.
      hypervisor:
        "#sec:tinst-vals":
          text:
          - As enumerated in the table, a synchronous exception may write to the trap
            instruction register a standard transformation of the trapping instruction
            only for exceptions that arise from explicit memory accesses (from loads,
            stores, and AMO instructions). Accordingly, standard transformations are
            currently defined only for these memory-access instructions. If a synchronous
            trap occurs for a standard instruction for which no transformation has
            been defined, the trap instruction register shall be written with zero
            (or, under certain circumstances, with a special pseudoinstruction value).
    iss_code:
    - require_extension('A');
    - require_rv64;
    - WRITE_RD(MMU.amo<uint64_t>(RS1, [&](uint64_t lhs) { return std::max(lhs, RS2);
      }));
  amomaxu.w:
    opcode:
    - amomaxu.w
    - rd
    - rs1
    - rs2
    - aq
    - rl
    - 31..29=7
    - 28..27=0
    - 14..12=2
    - 6..2=0x0B
    - 1..0=3
    opcode_group: a
    opcode_args: *1
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/a.html"
    main_desc: a
    main_id: "#sec:amo"
    desc:
      a:
        "#sec:amo":
          text:
          - The atomic memory operation (AMO) instructions perform read-modify-write
            operations for multiprocessor synchronization and are encoded with an
            R-type instruction format. These AMO instructions atomically load a data
            value from the address in rs1, place the value into register rd, apply
            a binary operator to the loaded value and the original value in rs2, then
            store the result back to the original address in rs1. AMOs can either
            operate on 64-bit (RV64 only) or 32-bit words in memory. For RV64, 32-bit
            AMOs always sign-extend the value placed in rd, and ignore the upper 32
            bits of the original value of rs2.
      machine:
        "#sec:mcause":
          text:
          - Note that load and load-reserved instructions generate load exceptions,
            whereas store, store-conditional, and AMO instructions generate store/AMO
            exceptions.
      hypervisor:
        "#sec:tinst-vals":
          text:
          - As enumerated in the table, a synchronous exception may write to the trap
            instruction register a standard transformation of the trapping instruction
            only for exceptions that arise from explicit memory accesses (from loads,
            stores, and AMO instructions). Accordingly, standard transformations are
            currently defined only for these memory-access instructions. If a synchronous
            trap occurs for a standard instruction for which no transformation has
            been defined, the trap instruction register shall be written with zero
            (or, under certain circumstances, with a special pseudoinstruction value).
    iss_code:
    - require_extension('A');
    - WRITE_RD(sext32(MMU.amo<uint32_t>(RS1, [&](uint32_t lhs) { return std::max(lhs,
      uint32_t(RS2)); })));
  amomin.d:
    opcode:
    - amomin.d
    - rd
    - rs1
    - rs2
    - aq
    - rl
    - 31..29=4
    - 28..27=0
    - 14..12=3
    - 6..2=0x0B
    - 1..0=3
    opcode_group: a
    opcode_args: *1
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/a.html"
    main_desc: a
    main_id: "#sec:amo"
    desc:
      a:
        "#sec:amo":
          text:
          - The atomic memory operation (AMO) instructions perform read-modify-write
            operations for multiprocessor synchronization and are encoded with an
            R-type instruction format. These AMO instructions atomically load a data
            value from the address in rs1, place the value into register rd, apply
            a binary operator to the loaded value and the original value in rs2, then
            store the result back to the original address in rs1. AMOs can either
            operate on 64-bit (RV64 only) or 32-bit words in memory. For RV64, 32-bit
            AMOs always sign-extend the value placed in rd, and ignore the upper 32
            bits of the original value of rs2.
      machine:
        "#sec:mcause":
          text:
          - Note that load and load-reserved instructions generate load exceptions,
            whereas store, store-conditional, and AMO instructions generate store/AMO
            exceptions.
      hypervisor:
        "#sec:tinst-vals":
          text:
          - As enumerated in the table, a synchronous exception may write to the trap
            instruction register a standard transformation of the trapping instruction
            only for exceptions that arise from explicit memory accesses (from loads,
            stores, and AMO instructions). Accordingly, standard transformations are
            currently defined only for these memory-access instructions. If a synchronous
            trap occurs for a standard instruction for which no transformation has
            been defined, the trap instruction register shall be written with zero
            (or, under certain circumstances, with a special pseudoinstruction value).
    iss_code:
    - require_extension('A');
    - require_rv64;
    - WRITE_RD(MMU.amo<uint64_t>(RS1, [&](int64_t lhs) { return std::min(lhs, int64_t(RS2));
      }));
  amomin.w:
    opcode:
    - amomin.w
    - rd
    - rs1
    - rs2
    - aq
    - rl
    - 31..29=4
    - 28..27=0
    - 14..12=2
    - 6..2=0x0B
    - 1..0=3
    opcode_group: a
    opcode_args: *1
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/a.html"
    main_desc: a
    main_id: "#sec:amo"
    desc:
      a:
        "#sec:amo":
          text:
          - The atomic memory operation (AMO) instructions perform read-modify-write
            operations for multiprocessor synchronization and are encoded with an
            R-type instruction format. These AMO instructions atomically load a data
            value from the address in rs1, place the value into register rd, apply
            a binary operator to the loaded value and the original value in rs2, then
            store the result back to the original address in rs1. AMOs can either
            operate on 64-bit (RV64 only) or 32-bit words in memory. For RV64, 32-bit
            AMOs always sign-extend the value placed in rd, and ignore the upper 32
            bits of the original value of rs2.
      machine:
        "#sec:mcause":
          text:
          - Note that load and load-reserved instructions generate load exceptions,
            whereas store, store-conditional, and AMO instructions generate store/AMO
            exceptions.
      hypervisor:
        "#sec:tinst-vals":
          text:
          - As enumerated in the table, a synchronous exception may write to the trap
            instruction register a standard transformation of the trapping instruction
            only for exceptions that arise from explicit memory accesses (from loads,
            stores, and AMO instructions). Accordingly, standard transformations are
            currently defined only for these memory-access instructions. If a synchronous
            trap occurs for a standard instruction for which no transformation has
            been defined, the trap instruction register shall be written with zero
            (or, under certain circumstances, with a special pseudoinstruction value).
    iss_code:
    - require_extension('A');
    - WRITE_RD(sext32(MMU.amo<uint32_t>(RS1, [&](int32_t lhs) { return std::min(lhs,
      int32_t(RS2)); })));
  amominu.d:
    opcode:
    - amominu.d
    - rd
    - rs1
    - rs2
    - aq
    - rl
    - 31..29=6
    - 28..27=0
    - 14..12=3
    - 6..2=0x0B
    - 1..0=3
    opcode_group: a
    opcode_args: *1
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/a.html"
    main_desc: a
    main_id: "#sec:amo"
    desc:
      a:
        "#sec:amo":
          text:
          - The atomic memory operation (AMO) instructions perform read-modify-write
            operations for multiprocessor synchronization and are encoded with an
            R-type instruction format. These AMO instructions atomically load a data
            value from the address in rs1, place the value into register rd, apply
            a binary operator to the loaded value and the original value in rs2, then
            store the result back to the original address in rs1. AMOs can either
            operate on 64-bit (RV64 only) or 32-bit words in memory. For RV64, 32-bit
            AMOs always sign-extend the value placed in rd, and ignore the upper 32
            bits of the original value of rs2.
      machine:
        "#sec:mcause":
          text:
          - Note that load and load-reserved instructions generate load exceptions,
            whereas store, store-conditional, and AMO instructions generate store/AMO
            exceptions.
      hypervisor:
        "#sec:tinst-vals":
          text:
          - As enumerated in the table, a synchronous exception may write to the trap
            instruction register a standard transformation of the trapping instruction
            only for exceptions that arise from explicit memory accesses (from loads,
            stores, and AMO instructions). Accordingly, standard transformations are
            currently defined only for these memory-access instructions. If a synchronous
            trap occurs for a standard instruction for which no transformation has
            been defined, the trap instruction register shall be written with zero
            (or, under certain circumstances, with a special pseudoinstruction value).
    iss_code:
    - require_extension('A');
    - require_rv64;
    - WRITE_RD(MMU.amo<uint64_t>(RS1, [&](uint64_t lhs) { return std::min(lhs, RS2);
      }));
  amominu.w:
    opcode:
    - amominu.w
    - rd
    - rs1
    - rs2
    - aq
    - rl
    - 31..29=6
    - 28..27=0
    - 14..12=2
    - 6..2=0x0B
    - 1..0=3
    opcode_group: a
    opcode_args: *1
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/a.html"
    main_desc: a
    main_id: "#sec:amo"
    desc:
      a:
        "#sec:amo":
          text:
          - The atomic memory operation (AMO) instructions perform read-modify-write
            operations for multiprocessor synchronization and are encoded with an
            R-type instruction format. These AMO instructions atomically load a data
            value from the address in rs1, place the value into register rd, apply
            a binary operator to the loaded value and the original value in rs2, then
            store the result back to the original address in rs1. AMOs can either
            operate on 64-bit (RV64 only) or 32-bit words in memory. For RV64, 32-bit
            AMOs always sign-extend the value placed in rd, and ignore the upper 32
            bits of the original value of rs2.
      machine:
        "#sec:mcause":
          text:
          - Note that load and load-reserved instructions generate load exceptions,
            whereas store, store-conditional, and AMO instructions generate store/AMO
            exceptions.
      hypervisor:
        "#sec:tinst-vals":
          text:
          - As enumerated in the table, a synchronous exception may write to the trap
            instruction register a standard transformation of the trapping instruction
            only for exceptions that arise from explicit memory accesses (from loads,
            stores, and AMO instructions). Accordingly, standard transformations are
            currently defined only for these memory-access instructions. If a synchronous
            trap occurs for a standard instruction for which no transformation has
            been defined, the trap instruction register shall be written with zero
            (or, under certain circumstances, with a special pseudoinstruction value).
    iss_code:
    - require_extension('A');
    - WRITE_RD(sext32(MMU.amo<uint32_t>(RS1, [&](uint32_t lhs) { return std::min(lhs,
      uint32_t(RS2)); })));
  amoor.d:
    opcode:
    - amoor.d
    - rd
    - rs1
    - rs2
    - aq
    - rl
    - 31..29=2
    - 28..27=0
    - 14..12=3
    - 6..2=0x0B
    - 1..0=3
    opcode_group: a
    opcode_args: *1
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/a.html"
    main_desc: a
    main_id: "#sec:amo"
    desc:
      a:
        "#sec:amo":
          text:
          - The atomic memory operation (AMO) instructions perform read-modify-write
            operations for multiprocessor synchronization and are encoded with an
            R-type instruction format. These AMO instructions atomically load a data
            value from the address in rs1, place the value into register rd, apply
            a binary operator to the loaded value and the original value in rs2, then
            store the result back to the original address in rs1. AMOs can either
            operate on 64-bit (RV64 only) or 32-bit words in memory. For RV64, 32-bit
            AMOs always sign-extend the value placed in rd, and ignore the upper 32
            bits of the original value of rs2.
      machine:
        "#sec:mcause":
          text:
          - Note that load and load-reserved instructions generate load exceptions,
            whereas store, store-conditional, and AMO instructions generate store/AMO
            exceptions.
      hypervisor:
        "#sec:tinst-vals":
          text:
          - As enumerated in the table, a synchronous exception may write to the trap
            instruction register a standard transformation of the trapping instruction
            only for exceptions that arise from explicit memory accesses (from loads,
            stores, and AMO instructions). Accordingly, standard transformations are
            currently defined only for these memory-access instructions. If a synchronous
            trap occurs for a standard instruction for which no transformation has
            been defined, the trap instruction register shall be written with zero
            (or, under certain circumstances, with a special pseudoinstruction value).
    iss_code:
    - require_extension('A');
    - require_rv64;
    - WRITE_RD(MMU.amo<uint64_t>(RS1, [&](uint64_t lhs) { return lhs | RS2; }));
  amoor.w:
    opcode:
    - amoor.w
    - rd
    - rs1
    - rs2
    - aq
    - rl
    - 31..29=2
    - 28..27=0
    - 14..12=2
    - 6..2=0x0B
    - 1..0=3
    opcode_group: a
    opcode_args: *1
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/a.html"
    main_desc: a
    main_id: "#sec:amo"
    desc:
      a:
        "#sec:amo":
          text:
          - The atomic memory operation (AMO) instructions perform read-modify-write
            operations for multiprocessor synchronization and are encoded with an
            R-type instruction format. These AMO instructions atomically load a data
            value from the address in rs1, place the value into register rd, apply
            a binary operator to the loaded value and the original value in rs2, then
            store the result back to the original address in rs1. AMOs can either
            operate on 64-bit (RV64 only) or 32-bit words in memory. For RV64, 32-bit
            AMOs always sign-extend the value placed in rd, and ignore the upper 32
            bits of the original value of rs2.
      machine:
        "#sec:mcause":
          text:
          - Note that load and load-reserved instructions generate load exceptions,
            whereas store, store-conditional, and AMO instructions generate store/AMO
            exceptions.
      hypervisor:
        "#sec:tinst-vals":
          text:
          - As enumerated in the table, a synchronous exception may write to the trap
            instruction register a standard transformation of the trapping instruction
            only for exceptions that arise from explicit memory accesses (from loads,
            stores, and AMO instructions). Accordingly, standard transformations are
            currently defined only for these memory-access instructions. If a synchronous
            trap occurs for a standard instruction for which no transformation has
            been defined, the trap instruction register shall be written with zero
            (or, under certain circumstances, with a special pseudoinstruction value).
    iss_code:
    - require_extension('A');
    - WRITE_RD(sext32(MMU.amo<uint32_t>(RS1, [&](uint32_t lhs) { return lhs | RS2;
      })));
  amoswap.d:
    opcode:
    - amoswap.d
    - rd
    - rs1
    - rs2
    - aq
    - rl
    - 31..29=0
    - 28..27=1
    - 14..12=3
    - 6..2=0x0B
    - 1..0=3
    opcode_group: a
    opcode_args: *1
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/a.html"
    main_desc: a
    main_id: "#sec:amo"
    desc:
      a:
        "#sec:amo":
          text:
          - The atomic memory operation (AMO) instructions perform read-modify-write
            operations for multiprocessor synchronization and are encoded with an
            R-type instruction format. These AMO instructions atomically load a data
            value from the address in rs1, place the value into register rd, apply
            a binary operator to the loaded value and the original value in rs2, then
            store the result back to the original address in rs1. AMOs can either
            operate on 64-bit (RV64 only) or 32-bit words in memory. For RV64, 32-bit
            AMOs always sign-extend the value placed in rd, and ignore the upper 32
            bits of the original value of rs2.
      machine:
        "#sec:mcause":
          text:
          - Note that load and load-reserved instructions generate load exceptions,
            whereas store, store-conditional, and AMO instructions generate store/AMO
            exceptions.
      hypervisor:
        "#sec:tinst-vals":
          text:
          - As enumerated in the table, a synchronous exception may write to the trap
            instruction register a standard transformation of the trapping instruction
            only for exceptions that arise from explicit memory accesses (from loads,
            stores, and AMO instructions). Accordingly, standard transformations are
            currently defined only for these memory-access instructions. If a synchronous
            trap occurs for a standard instruction for which no transformation has
            been defined, the trap instruction register shall be written with zero
            (or, under certain circumstances, with a special pseudoinstruction value).
    iss_code:
    - require_extension('A');
    - require_rv64;
    - WRITE_RD(MMU.amo<uint64_t>(RS1, [&](uint64_t UNUSED lhs) { return RS2; }));
  amoswap.w:
    opcode:
    - amoswap.w
    - rd
    - rs1
    - rs2
    - aq
    - rl
    - 31..29=0
    - 28..27=1
    - 14..12=2
    - 6..2=0x0B
    - 1..0=3
    opcode_group: a
    opcode_args: *1
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/a.html"
    main_desc: a
    main_id: "#sec:amo"
    desc:
      a:
        "#sec:amo":
          text:
          - The atomic memory operation (AMO) instructions perform read-modify-write
            operations for multiprocessor synchronization and are encoded with an
            R-type instruction format. These AMO instructions atomically load a data
            value from the address in rs1, place the value into register rd, apply
            a binary operator to the loaded value and the original value in rs2, then
            store the result back to the original address in rs1. AMOs can either
            operate on 64-bit (RV64 only) or 32-bit words in memory. For RV64, 32-bit
            AMOs always sign-extend the value placed in rd, and ignore the upper 32
            bits of the original value of rs2.
      machine:
        "#sec:mcause":
          text:
          - Note that load and load-reserved instructions generate load exceptions,
            whereas store, store-conditional, and AMO instructions generate store/AMO
            exceptions.
      hypervisor:
        "#sec:tinst-vals":
          text:
          - As enumerated in the table, a synchronous exception may write to the trap
            instruction register a standard transformation of the trapping instruction
            only for exceptions that arise from explicit memory accesses (from loads,
            stores, and AMO instructions). Accordingly, standard transformations are
            currently defined only for these memory-access instructions. If a synchronous
            trap occurs for a standard instruction for which no transformation has
            been defined, the trap instruction register shall be written with zero
            (or, under certain circumstances, with a special pseudoinstruction value).
    iss_code:
    - require_extension('A');
    - WRITE_RD(sext32(MMU.amo<uint32_t>(RS1, [&](uint32_t UNUSED lhs) { return RS2;
      })));
  amoxor.d:
    opcode:
    - amoxor.d
    - rd
    - rs1
    - rs2
    - aq
    - rl
    - 31..29=1
    - 28..27=0
    - 14..12=3
    - 6..2=0x0B
    - 1..0=3
    opcode_group: a
    opcode_args: *1
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/a.html"
    main_desc: a
    main_id: "#sec:amo"
    desc:
      a:
        "#sec:amo":
          text:
          - The atomic memory operation (AMO) instructions perform read-modify-write
            operations for multiprocessor synchronization and are encoded with an
            R-type instruction format. These AMO instructions atomically load a data
            value from the address in rs1, place the value into register rd, apply
            a binary operator to the loaded value and the original value in rs2, then
            store the result back to the original address in rs1. AMOs can either
            operate on 64-bit (RV64 only) or 32-bit words in memory. For RV64, 32-bit
            AMOs always sign-extend the value placed in rd, and ignore the upper 32
            bits of the original value of rs2.
      machine:
        "#sec:mcause":
          text:
          - Note that load and load-reserved instructions generate load exceptions,
            whereas store, store-conditional, and AMO instructions generate store/AMO
            exceptions.
      hypervisor:
        "#sec:tinst-vals":
          text:
          - As enumerated in the table, a synchronous exception may write to the trap
            instruction register a standard transformation of the trapping instruction
            only for exceptions that arise from explicit memory accesses (from loads,
            stores, and AMO instructions). Accordingly, standard transformations are
            currently defined only for these memory-access instructions. If a synchronous
            trap occurs for a standard instruction for which no transformation has
            been defined, the trap instruction register shall be written with zero
            (or, under certain circumstances, with a special pseudoinstruction value).
    iss_code:
    - require_extension('A');
    - require_rv64;
    - WRITE_RD(MMU.amo<uint64_t>(RS1, [&](uint64_t lhs) { return lhs ^ RS2; }));
  amoxor.w:
    opcode:
    - amoxor.w
    - rd
    - rs1
    - rs2
    - aq
    - rl
    - 31..29=1
    - 28..27=0
    - 14..12=2
    - 6..2=0x0B
    - 1..0=3
    opcode_group: a
    opcode_args: *1
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/a.html"
    main_desc: a
    main_id: "#sec:amo"
    desc:
      a:
        "#sec:amo":
          text:
          - The atomic memory operation (AMO) instructions perform read-modify-write
            operations for multiprocessor synchronization and are encoded with an
            R-type instruction format. These AMO instructions atomically load a data
            value from the address in rs1, place the value into register rd, apply
            a binary operator to the loaded value and the original value in rs2, then
            store the result back to the original address in rs1. AMOs can either
            operate on 64-bit (RV64 only) or 32-bit words in memory. For RV64, 32-bit
            AMOs always sign-extend the value placed in rd, and ignore the upper 32
            bits of the original value of rs2.
      machine:
        "#sec:mcause":
          text:
          - Note that load and load-reserved instructions generate load exceptions,
            whereas store, store-conditional, and AMO instructions generate store/AMO
            exceptions.
      hypervisor:
        "#sec:tinst-vals":
          text:
          - As enumerated in the table, a synchronous exception may write to the trap
            instruction register a standard transformation of the trapping instruction
            only for exceptions that arise from explicit memory accesses (from loads,
            stores, and AMO instructions). Accordingly, standard transformations are
            currently defined only for these memory-access instructions. If a synchronous
            trap occurs for a standard instruction for which no transformation has
            been defined, the trap instruction register shall be written with zero
            (or, under certain circumstances, with a special pseudoinstruction value).
    iss_code:
    - require_extension('A');
    - WRITE_RD(sext32(MMU.amo<uint32_t>(RS1, [&](uint32_t lhs) { return lhs ^ RS2;
      })));
  and:
    opcode:
    - and
    - rd
    - rs1
    - rs2
    - 31..25=0
    - 14..12=7
    - 6..2=0x0C
    - 1..0=3
    opcode_group: i
    opcode_args: *1
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/rv32.html"
    main_desc: rv32
    main_id: "#integer-register-register-operations"
    desc:
      rv32:
        "#integer-register-immediate-instructions":
          text:
          - ANDI, ORI, XORI are logical operations that perform bitwise AND, OR, and
            XOR on register rs1 and the sign-extended 12-bit immediate and place the
            result in rd. Note, XORI rd, rs1, -1 performs a bitwise logical inversion
            of register rs1 (assembler pseudoinstruction NOT rd, rs).
        "#integer-register-register-operations":
          text:
          - ADD performs the addition of rs1 and rs2. SUB performs the subtraction
            of rs2 from rs1. Overflows are ignored and the low XLEN bits of results
            are written to the destination rd. SLT and SLTU perform signed and unsigned
            compares respectively, writing 1 to rd if rs1 < rs2, 0 otherwise. Note,
            SLTU rd, x0, rs2 sets rd to 1 if rs2 is not equal to zero, otherwise sets
            rd to zero (assembler pseudoinstruction SNEZ rd, rs). AND, OR, and XOR
            perform bitwise logical operations.
      a:
        "#sec:amo":
          text:
          - The operations supported are swap, integer add, bitwise AND, bitwise OR,
            bitwise XOR, and signed and unsigned integer maximum and minimum. Without
            ordering constraints, these AMOs can be used to implement parallel reduction
            operations, where typically the return value would be discarded by writing
            to x0.
      c:
        "#integer-register-immediate-operations":
          text:
          - C.ANDI is a CB-format instruction that computes the bitwise AND of the
            value in register rd' and the sign-extended 6-bit immediate, then writes
            the result to rd'. C.ANDI expands to andi rd', rd', imm.
        "#integer-register-register-operations":
          text:
          - C.AND computes the bitwise AND of the values in registers rd' and rs2',
            then writes the result to register rd'. C.AND expands into and rd', rd',
            rs2'.
      hypervisor:
        "#sec:hinterruptregs":
          text:
          - Bits hip.SGEIP and hie.SGEIE are the interrupt-pending and interrupt-enable
            bits for guest external interrupts at supervisor level (HS-level). SGEIP
            is read-only in hip, and is 1 if and only if the bitwise logical-AND of
            CSRs hgeip and hgeie is nonzero in any bit. (See Section 1.2.4 .)
      v:
        "#_vector_integer_compare_instructions":
          text:
          - Compares effectively AND in the mask under a mask-undisturbed policy e.g,
    iss_code:
    - WRITE_RD(RS1 & RS2);
  andi:
    opcode:
    - andi
    - rd
    - rs1
    - imm12
    - 14..12=7
    - 6..2=0x04
    - 1..0=3
    opcode_group: i
    opcode_args: *2
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/rv32.html"
    main_desc: rv32
    main_id: "#integer-register-immediate-instructions"
    desc:
      rv32:
        "#integer-register-immediate-instructions":
          text:
          - ANDI, ORI, XORI are logical operations that perform bitwise AND, OR, and
            XOR on register rs1 and the sign-extended 12-bit immediate and place the
            result in rd. Note, XORI rd, rs1, -1 performs a bitwise logical inversion
            of register rs1 (assembler pseudoinstruction NOT rd, rs).
    iss_code:
    - WRITE_RD(insn.i_imm() & RS1);
  andn:
    opcode:
    - andn
    - rd
    - rs1
    - rs2
    - 31..25=32
    - 14..12=7
    - 6..2=0x0C
    - 1..0=3
    opcode_group: zbb
    opcode_args: *1
    iss_code:
    - require_either_extension(EXT_ZBB, EXT_ZBKB);
    - WRITE_RD(RS1 & ~RS2);
  auipc:
    opcode:
    - auipc
    - rd
    - imm20
    - 6..2=0x05
    - 1..0=3
    opcode_group: i
    opcode_args: &26
    - rd
    - imm20
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/rv32.html"
    main_desc: rv32
    main_id: "#integer-register-immediate-instructions"
    desc:
      rv32:
        "#integer-register-immediate-instructions":
          text:
          - AUIPC (add upper immediate to pc) is used to build pc-relative addresses
            and uses the U-type format. AUIPC forms a 32-bit offset from the U-immediate,
            filling in the lowest 12 bits with zeros, adds this offset to the address
            of the AUIPC instruction, then places the result in register rd.
          - The AUIPC instruction supports two-instruction sequences to access arbitrary
            offsets from the PC for both control-flow transfers and data accesses.
            The combination of an AUIPC and the 12-bit immediate in a JALR can transfer
            control to any 32-bit PC-relative address, while an AUIPC plus the 12-bit
            immediate offset in regular load or store instructions can access any
            32-bit PC-relative data address.
        "#unconditional-jumps":
          text:
          - The unconditional jump instructions all use PC-relative addressing to
            help support position-independent code. The JALR instruction was defined
            to enable a two-instruction sequence to jump anywhere in a 32-bit absolute
            address range. A LUI instruction can first load rs1 with the upper 20
            bits of a target address, then JALR can add in the lower bits. Similarly,
            AUIPC then JALR can jump anywhere in a 32-bit pc-relative address range.
          - Note that the JALR instruction does not treat the 12-bit immediate as
            multiples of 2 bytes, unlike the conditional branch instructions. This
            avoids one more immediate format in hardware. In practice, most uses of
            JALR will have either a zero immediate or be paired with a LUI or AUIPC,
            so the slight reduction in range is not significant.
      rv64:
        "#integer-register-immediate-instructions":
          text:
          - AUIPC (add upper immediate to pc) uses the same opcode as RV32I. AUIPC
            is used to build pc-relative addresses and uses the U-type format. AUIPC
            forms a 32-bit offset from the U-immediate, filling in the lowest 12 bits
            with zeros, sign-extends the result to 64 bits, adds it to the address
            of the AUIPC instruction, then places the result in register rd.
          - Note that the set of address offsets that can be formed by pairing LUI
            with LD, AUIPC with JALR, etc.in RV64I is [ - 231 - 211, 231 - 211 - 1].
    iss_code:
    - WRITE_RD(sext_xlen(insn.u_imm() + pc));
  bclr:
    opcode:
    - bclr
    - rd
    - rs1
    - rs2
    - 31..25=0x24
    - 14..12=1
    - 6..2=0x0C
    - 1..0=3
    opcode_group: zbs
    opcode_args: *1
    iss_code:
    - require_extension(EXT_ZBS);
    - int shamt = RS2 & (xlen-1);
    - WRITE_RD(sext_xlen(RS1 & ~(1LL << shamt)));
  bclri:
    opcode:
    - bclri
    - rd
    - rs1
    - 31..26=0x12
    - shamtd
    - 14..12=1
    - 6..2=0x04
    - 1..0=3
    opcode_group: zbs
    opcode_args: *3
    iss_code:
    - require_extension(EXT_ZBS);
    - int shamt = SHAMT & (xlen-1);
    - WRITE_RD(sext_xlen(RS1 & ~(1LL << shamt)));
  beq:
    opcode:
    - beq
    - bimm12hi
    - rs1
    - rs2
    - bimm12lo
    - 14..12=0
    - 6..2=0x18
    - 1..0=3
    opcode_group: i
    opcode_args: &4
    - rs1
    - rs2
    - bimm12
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/rv32.html"
    main_desc: rv32
    main_id: "#conditional-branches"
    desc:
      rv32:
        "#conditional-branches":
          text:
          - Branch instructions compare two registers. BEQ and BNE take the branch
            if registers rs1 and rs2 are equal or unequal respectively. BLT and BLTU
            take the branch if rs1 is less than rs2, using signed and unsigned comparison
            respectively. BGE and BGEU take the branch if rs1 is greater than or equal
            to rs2, using signed and unsigned comparison respectively. Note, BGT,
            BGTU, BLE, and BLEU can be synthesized by reversing the operands to BLT,
            BLTU, BGE, and BGEU, respectively.
    iss_code:
    - if (RS1 == RS2)
    - set_pc(BRANCH_TARGET);
  beqz:
    opcode:
    - beqz
    - rs
    - offset
    opcode_group: psuedo
    opcode_args:
    - rs
    - offset
    psuedo_to_base:
    - beq rs, x0, offset
  bext:
    opcode:
    - bext
    - rd
    - rs1
    - rs2
    - 31..25=36
    - 14..12=5
    - 6..2=0x0C
    - 1..0=3
    opcode_group: zbs
    opcode_args: *1
    iss_code:
    - require_extension(EXT_ZBS);
    - int shamt = RS2 & (xlen-1);
    - WRITE_RD(sext_xlen(1 & (RS1 >> shamt)));
  bexti:
    opcode:
    - bexti
    - rd
    - rs1
    - 31..26=0x12
    - shamtd
    - 14..12=5
    - 6..2=0x04
    - 1..0=3
    opcode_group: zbs
    opcode_args: *3
    iss_code:
    - require_extension(EXT_ZBS);
    - int shamt = SHAMT & (xlen-1);
    - WRITE_RD(sext_xlen(1 & (RS1 >> shamt)));
  bge:
    opcode:
    - bge
    - bimm12hi
    - rs1
    - rs2
    - bimm12lo
    - 14..12=5
    - 6..2=0x18
    - 1..0=3
    opcode_group: i
    opcode_args: *4
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/rv32.html"
    main_desc: rv32
    main_id: "#conditional-branches"
    desc:
      rv32:
        "#conditional-branches":
          text:
          - Branch instructions compare two registers. BEQ and BNE take the branch
            if registers rs1 and rs2 are equal or unequal respectively. BLT and BLTU
            take the branch if rs1 is less than rs2, using signed and unsigned comparison
            respectively. BGE and BGEU take the branch if rs1 is greater than or equal
            to rs2, using signed and unsigned comparison respectively. Note, BGT,
            BGTU, BLE, and BLEU can be synthesized by reversing the operands to BLT,
            BLTU, BGE, and BGEU, respectively.
    iss_code:
    - if (sreg_t(RS1) >= sreg_t(RS2))
    - set_pc(BRANCH_TARGET);
  bgeu:
    opcode:
    - bgeu
    - bimm12hi
    - rs1
    - rs2
    - bimm12lo
    - 14..12=7
    - 6..2=0x18
    - 1..0=3
    opcode_group: i
    opcode_args: *4
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/rv32.html"
    main_desc: rv32
    main_id: "#conditional-branches"
    desc:
      rv32:
        "#conditional-branches":
          text:
          - Branch instructions compare two registers. BEQ and BNE take the branch
            if registers rs1 and rs2 are equal or unequal respectively. BLT and BLTU
            take the branch if rs1 is less than rs2, using signed and unsigned comparison
            respectively. BGE and BGEU take the branch if rs1 is greater than or equal
            to rs2, using signed and unsigned comparison respectively. Note, BGT,
            BGTU, BLE, and BLEU can be synthesized by reversing the operands to BLT,
            BLTU, BGE, and BGEU, respectively.
    iss_code:
    - if (RS1 >= RS2)
    - set_pc(BRANCH_TARGET);
  bgez:
    opcode:
    - bgez
    - rs
    - offset
    opcode_group: psuedo
    opcode_args:
    - rs
    - offset
    psuedo_to_base:
    - bge rs, x0, offset
  bgt:
    opcode:
    - bgt
    - rs
    - rt
    - offset
    opcode_group: psuedo
    opcode_args:
    - rs
    - rt
    - offset
    psuedo_to_base:
    - blt rt, rs, offset
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/rv32.html"
    main_desc: rv32
    main_id: "#conditional-branches"
    desc:
      rv32:
        "#conditional-branches":
          text:
          - Branch instructions compare two registers. BEQ and BNE take the branch
            if registers rs1 and rs2 are equal or unequal respectively. BLT and BLTU
            take the branch if rs1 is less than rs2, using signed and unsigned comparison
            respectively. BGE and BGEU take the branch if rs1 is greater than or equal
            to rs2, using signed and unsigned comparison respectively. Note, BGT,
            BGTU, BLE, and BLEU can be synthesized by reversing the operands to BLT,
            BLTU, BGE, and BGEU, respectively.
  bgtu:
    opcode:
    - bgtu
    - rs
    - rt
    - offset
    opcode_group: psuedo
    opcode_args:
    - rs
    - rt
    - offset
    psuedo_to_base:
    - bltu rt, rs, offset
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/rv32.html"
    main_desc: rv32
    main_id: "#conditional-branches"
    desc:
      rv32:
        "#conditional-branches":
          text:
          - Branch instructions compare two registers. BEQ and BNE take the branch
            if registers rs1 and rs2 are equal or unequal respectively. BLT and BLTU
            take the branch if rs1 is less than rs2, using signed and unsigned comparison
            respectively. BGE and BGEU take the branch if rs1 is greater than or equal
            to rs2, using signed and unsigned comparison respectively. Note, BGT,
            BGTU, BLE, and BLEU can be synthesized by reversing the operands to BLT,
            BLTU, BGE, and BGEU, respectively.
  bgtz:
    opcode:
    - bgtz
    - rs
    - offset
    opcode_group: psuedo
    opcode_args:
    - rs
    - offset
    psuedo_to_base:
    - blt x0, rs, offset
  binv:
    opcode:
    - binv
    - rd
    - rs1
    - rs2
    - 31..25=52
    - 14..12=1
    - 6..2=0x0C
    - 1..0=3
    opcode_group: zbs
    opcode_args: *1
    iss_code:
    - require_extension(EXT_ZBS);
    - int shamt = RS2 & (xlen-1);
    - WRITE_RD(sext_xlen(RS1 ^ (1LL << shamt)));
  binvi:
    opcode:
    - binvi
    - rd
    - rs1
    - 31..26=0x1a
    - shamtd
    - 14..12=1
    - 6..2=0x04
    - 1..0=3
    opcode_group: zbs
    opcode_args: *3
    iss_code:
    - require_extension(EXT_ZBS);
    - int shamt = SHAMT & (xlen-1);
    - WRITE_RD(sext_xlen(RS1 ^ (1LL << shamt)));
  ble:
    opcode:
    - ble
    - rs
    - rt
    - offset
    opcode_group: psuedo
    opcode_args:
    - rs
    - rt
    - offset
    psuedo_to_base:
    - bge rt, rs, offset
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/rv32.html"
    main_desc: rv32
    main_id: "#conditional-branches"
    desc:
      rv32:
        "#conditional-branches":
          text:
          - Branch instructions compare two registers. BEQ and BNE take the branch
            if registers rs1 and rs2 are equal or unequal respectively. BLT and BLTU
            take the branch if rs1 is less than rs2, using signed and unsigned comparison
            respectively. BGE and BGEU take the branch if rs1 is greater than or equal
            to rs2, using signed and unsigned comparison respectively. Note, BGT,
            BGTU, BLE, and BLEU can be synthesized by reversing the operands to BLT,
            BLTU, BGE, and BGEU, respectively.
  bleu:
    opcode:
    - bleu
    - rs
    - rt
    - offset
    opcode_group: psuedo
    opcode_args:
    - rs
    - rt
    - offset
    psuedo_to_base:
    - bgeu rt, rs, offset
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/rv32.html"
    main_desc: rv32
    main_id: "#conditional-branches"
    desc:
      rv32:
        "#conditional-branches":
          text:
          - Branch instructions compare two registers. BEQ and BNE take the branch
            if registers rs1 and rs2 are equal or unequal respectively. BLT and BLTU
            take the branch if rs1 is less than rs2, using signed and unsigned comparison
            respectively. BGE and BGEU take the branch if rs1 is greater than or equal
            to rs2, using signed and unsigned comparison respectively. Note, BGT,
            BGTU, BLE, and BLEU can be synthesized by reversing the operands to BLT,
            BLTU, BGE, and BGEU, respectively.
  blez:
    opcode:
    - blez
    - rs
    - offset
    opcode_group: psuedo
    opcode_args:
    - rs
    - offset
    psuedo_to_base:
    - bge x0, rs, offset
  blt:
    opcode:
    - blt
    - bimm12hi
    - rs1
    - rs2
    - bimm12lo
    - 14..12=4
    - 6..2=0x18
    - 1..0=3
    opcode_group: i
    opcode_args: *4
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/rv32.html"
    main_desc: rv32
    main_id: "#conditional-branches"
    desc:
      rv32:
        "#conditional-branches":
          text:
          - Branch instructions compare two registers. BEQ and BNE take the branch
            if registers rs1 and rs2 are equal or unequal respectively. BLT and BLTU
            take the branch if rs1 is less than rs2, using signed and unsigned comparison
            respectively. BGE and BGEU take the branch if rs1 is greater than or equal
            to rs2, using signed and unsigned comparison respectively. Note, BGT,
            BGTU, BLE, and BLEU can be synthesized by reversing the operands to BLT,
            BLTU, BGE, and BGEU, respectively.
    iss_code:
    - if (sreg_t(RS1) < sreg_t(RS2))
    - set_pc(BRANCH_TARGET);
  bltu:
    opcode:
    - bltu
    - bimm12hi
    - rs1
    - rs2
    - bimm12lo
    - 14..12=6
    - 6..2=0x18
    - 1..0=3
    opcode_group: i
    opcode_args: *4
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/rv32.html"
    main_desc: rv32
    main_id: "#conditional-branches"
    desc:
      rv32:
        "#conditional-branches":
          text:
          - Branch instructions compare two registers. BEQ and BNE take the branch
            if registers rs1 and rs2 are equal or unequal respectively. BLT and BLTU
            take the branch if rs1 is less than rs2, using signed and unsigned comparison
            respectively. BGE and BGEU take the branch if rs1 is greater than or equal
            to rs2, using signed and unsigned comparison respectively. Note, BGT,
            BGTU, BLE, and BLEU can be synthesized by reversing the operands to BLT,
            BLTU, BGE, and BGEU, respectively.
          - Signed array bounds may be checked with a single BLTU instruction, since
            any negative index will compare greater than any nonnegative bound.
    iss_code:
    - if (RS1 < RS2)
    - set_pc(BRANCH_TARGET);
  bltz:
    opcode:
    - bltz
    - rs
    - offset
    opcode_group: psuedo
    opcode_args:
    - rs
    - offset
    psuedo_to_base:
    - blt rs, x0, offset
  bne:
    opcode:
    - bne
    - bimm12hi
    - rs1
    - rs2
    - bimm12lo
    - 14..12=1
    - 6..2=0x18
    - 1..0=3
    opcode_group: i
    opcode_args: *4
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/rv32.html"
    main_desc: rv32
    main_id: "#conditional-branches"
    desc:
      rv32:
        "#conditional-branches":
          text:
          - Branch instructions compare two registers. BEQ and BNE take the branch
            if registers rs1 and rs2 are equal or unequal respectively. BLT and BLTU
            take the branch if rs1 is less than rs2, using signed and unsigned comparison
            respectively. BGE and BGEU take the branch if rs1 is greater than or equal
            to rs2, using signed and unsigned comparison respectively. Note, BGT,
            BGTU, BLE, and BLEU can be synthesized by reversing the operands to BLT,
            BLTU, BGE, and BGEU, respectively.
    iss_code:
    - if (RS1 != RS2)
    - set_pc(BRANCH_TARGET);
  bnez:
    opcode:
    - bnez
    - rs
    - offset
    opcode_group: psuedo
    opcode_args:
    - rs
    - offset
    psuedo_to_base:
    - bne rs, x0, offset
  brev8:
    opcode:
    - brev8
    - rd
    - rs1
    - 31..20=0x687
    - 14..12=5
    - 6..2=0x4
    - 1..0=0x3
    opcode_group: zbkb
    opcode_args: *3
    pseudo_src: rv64_zbp
    pseudo_op: grevi
  bset:
    opcode:
    - bset
    - rd
    - rs1
    - rs2
    - 31..25=20
    - 14..12=1
    - 6..2=0x0C
    - 1..0=3
    opcode_group: zbs
    opcode_args: *1
    iss_code:
    - require_extension(EXT_ZBS);
    - int shamt = RS2 & (xlen-1);
    - WRITE_RD(sext_xlen(RS1 | (1LL << shamt)));
  bseti:
    opcode:
    - bseti
    - rd
    - rs1
    - 31..26=0x0a
    - shamtd
    - 14..12=1
    - 6..2=0x04
    - 1..0=3
    opcode_group: zbs
    opcode_args: *3
    iss_code:
    - require_extension(EXT_ZBS);
    - int shamt = SHAMT & (xlen-1);
    - WRITE_RD(sext_xlen(RS1 | (1LL << shamt)));
  c.add:
    opcode:
    - c.add
    - rd_rs1
    - c_rs2_n0
    - 1..0=2
    - 15..13=4
    - 12=1
    opcode_group: c
    opcode_args: &64
    - rd_rs1
    - c_rs2_n0
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/c.html"
    main_desc: c
    main_id: "#integer-register-register-operations"
    desc:
      c:
        "#integer-register-register-operations":
          text:
          - C.ADD adds the values in registers rd and rs2 and writes the result to
            register rd. C.ADD expands into add rd, rd, rs2. C.ADD is only valid when
            rs2 x0; the code points with rs2 = x0 correspond to the C.JALR and C.EBREAK
            instructions. The code points with rs2 x0 and rd = x0 are HINTs.
        "#breakpoint-instruction":
          text:
          - Debuggers can use the C.EBREAK instruction, which expands to ebreak, to
            cause control to be transferred back to the debugging environment. C.EBREAK
            shares the opcode with the C.ADD instruction, but with rd and rs2 both
            zero, thus can also use the CR format.
    iss_code:
    - require_extension(EXT_ZCA);
    - require(insn.rvc_rs2() != 0);
    - WRITE_RD(sext_xlen(RVC_RS1 + RVC_RS2));
  c.addi:
    opcode:
    - c.addi
    - rd_rs1_n0
    - c_nzimm6lo
    - c_nzimm6hi
    - 1..0=1
    - 15..13=0
    opcode_group: c
    opcode_args: &47
    - rd_rs1_n0
    - c_nzimm6
    - c_nzimm6
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/c.html"
    main_desc: c
    main_id: "#integer-register-immediate-operations"
    desc:
      c:
        "#integer-register-immediate-operations":
          text:
          - C.ADDI adds the non-zero sign-extended 6-bit immediate to the value in
            register rd then writes the result to rd. C.ADDI expands into addi rd,
            rd, nzimm. C.ADDI is only valid when rd x0 and nzimm 0. The code points
            with rd=x0 encode the C.NOP instruction; the remaining code points with
            nzimm=0 encode HINTs.
    iss_code:
    - require_extension(EXT_ZCA);
    - WRITE_RD(sext_xlen(RVC_RS1 + insn.rvc_imm()));
  c.addi16sp:
    opcode:
    - c.addi16sp
    - c_nzimm10hi
    - c_nzimm10lo
    - 1..0=1
    - 15..13=3
    - 11..7=2
    opcode_group: c
    opcode_args: &49
    - c_nzimm10
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/c.html"
    main_desc: c
    main_id: "#integer-constant-generation-instructions"
    desc:
      c:
        "#integer-constant-generation-instructions":
          text:
          - C.LUI loads the non-zero 6-bit immediate field into bits 17-12 of the
            destination register, clears the bottom 12 bits, and sign-extends bit
            17 into all higher bits of the destination. C.LUI expands into lui rd,
            nzimm. C.LUI is only valid when rd {x0,x2}, and when the immediate is
            not equal to zero. The code points with nzimm=0 are reserved; the remaining
            code points with rd=x0 are HINTs; and the remaining code points with rd=x2
            correspond to the C.ADDI16SP instruction.
        "#integer-register-immediate-operations":
          text:
          - C.ADDI16SP shares the opcode with C.LUI, but has a destination field of
            x2. C.ADDI16SP adds the non-zero sign-extended 6-bit immediate to the
            value in the stack pointer (sp=x2), where the immediate is scaled to represent
            multiples of 16 in the range (-512,496). C.ADDI16SP is used to adjust
            the stack pointer in procedure prologues and epilogues. It expands into
            addi x2, x2, nzimm. C.ADDI16SP is only valid when nzimm 0; the code point
            with nzimm=0 is reserved.
    opcode_alias: addi16sp
  c.addi4spn:
    opcode:
    - c.addi4spn
    - rd_p
    - c_nzuimm10
    - 1..0=0
    - 15..13=0
    opcode_group: c
    opcode_args: &57
    - rd_p
    - c_nzuimm10
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/c.html"
    main_desc: c
    main_id: "#integer-register-immediate-operations"
    desc:
      c:
        "#integer-register-immediate-operations":
          text:
          - C.ADDI4SPN is a CIW-format instruction that adds a zero-extended non-zero
            immediate, scaled by 4, to the stack pointer, x2, and writes the result
            to rd'. This instruction is used to generate pointers to stack-allocated
            variables, and expands to addi rd', x2, nzuimm. C.ADDI4SPN is only valid
            when nzuimm 0; the code points with nzuimm=0 are reserved.
    iss_code:
    - require_extension(EXT_ZCA);
    - require(insn.rvc_addi4spn_imm() != 0);
    - WRITE_RVC_RS2S(sext_xlen(RVC_SP + insn.rvc_addi4spn_imm()));
    opcode_alias: addi4spn
  c.addiw:
    opcode:
    - c.addiw
    - rd_rs1_n0
    - c_imm6lo
    - c_imm6hi
    - 1..0=1
    - 15..13=1
    opcode_group: c
    opcode_args: &69
    - rd_rs1_n0
    - c_imm6
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/c.html"
    main_desc: c
    main_id: "#integer-register-immediate-operations"
    desc:
      c:
        "#integer-register-immediate-operations":
          text:
          - C.ADDIW is an RV64C/RV128C-only instruction that performs the same computation
            but produces a 32-bit result, then sign-extends result to 64 bits. C.ADDIW
            expands into addiw rd, rd, imm. The immediate can be zero for C.ADDIW,
            where this corresponds to sext.w rd. C.ADDIW is only valid when rd x0;
            the code points with rd=x0 are reserved.
  c.addw:
    opcode:
    - c.addw
    - rd_rs1_p
    - rs2_p
    - 1..0=1
    - 15..13=4
    - 12..10=0b111
    - 6..5=1
    opcode_group: c
    opcode_args: &5
    - rd_rs1_p
    - rs2_p
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/c.html"
    main_desc: c
    main_id: "#integer-register-register-operations"
    desc:
      c:
        "#integer-register-register-operations":
          text:
          - C.ADDW is an RV64C/RV128C-only instruction that adds the values in registers
            rd' and rs2', then sign-extends the lower 32 bits of the sum before writing
            the result to register rd'. C.ADDW expands into addw rd', rd', rs2'.
    iss_code:
    - require_extension(EXT_ZCA);
    - require_rv64;
    - WRITE_RVC_RS1S(sext32(RVC_RS1S + RVC_RS2S));
  c.and:
    opcode:
    - c.and
    - rd_rs1_p
    - rs2_p
    - 1..0=1
    - 15..13=4
    - 12..10=0b011
    - 6..5=3
    opcode_group: c
    opcode_args: *5
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/c.html"
    main_desc: c
    main_id: "#integer-register-register-operations"
    desc:
      c:
        "#integer-register-register-operations":
          text:
          - C.AND computes the bitwise AND of the values in registers rd' and rs2',
            then writes the result to register rd'. C.AND expands into and rd', rd',
            rs2'.
    iss_code:
    - require_extension(EXT_ZCA);
    - WRITE_RVC_RS1S(RVC_RS1S & RVC_RS2S);
  c.andi:
    opcode:
    - c.andi
    - rd_rs1_p
    - c_imm6hi
    - c_imm6lo
    - 1..0=1
    - 15..13=4
    - 11..10=2
    opcode_group: c
    opcode_args: &60
    - rd_rs1_p
    - c_imm6
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/c.html"
    main_desc: c
    main_id: "#integer-register-immediate-operations"
    desc:
      c:
        "#integer-register-immediate-operations":
          text:
          - C.ANDI is a CB-format instruction that computes the bitwise AND of the
            value in register rd' and the sign-extended 6-bit immediate, then writes
            the result to rd'. C.ANDI expands to andi rd', rd', imm.
    iss_code:
    - require_extension(EXT_ZCA);
    - WRITE_RVC_RS1S(RVC_RS1S & insn.rvc_imm());
  c.beqz:
    opcode:
    - c.beqz
    - rs1_p
    - c_bimm9lo
    - c_bimm9hi
    - 1..0=1
    - 15..13=6
    opcode_group: c
    opcode_args: &6
    - rs1_p
    - c_bimm9
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/c.html"
    main_desc: c
    main_id: "#control-transfer-instructions"
    desc:
      c:
        "#control-transfer-instructions":
          text:
          - C.BEQZ performs conditional control transfers. The offset is sign-extended
            and added to the pc to form the branch target address. It can therefore
            target a 256B range. C.BEQZ takes the branch if the value in register
            rs1' is zero. It expands to beq rs1', x0, offset.
    iss_code:
    - require_extension(EXT_ZCA);
    - if (RVC_RS1S == 0)
    - set_pc(pc + insn.rvc_b_imm());
  c.bnez:
    opcode:
    - c.bnez
    - rs1_p
    - c_bimm9lo
    - c_bimm9hi
    - 1..0=1
    - 15..13=7
    opcode_group: c
    opcode_args: *6
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/c.html"
    main_desc: c
    main_id: "#control-transfer-instructions"
    desc:
      c:
        "#control-transfer-instructions":
          text:
          - C.BNEZ is defined analogously, but it takes the branch if rs1' contains
            a nonzero value. It expands to bne rs1', x0, offset.
    iss_code:
    - require_extension(EXT_ZCA);
    - if (RVC_RS1S != 0)
    - set_pc(pc + insn.rvc_b_imm());
  c.ebreak:
    opcode:
    - c.ebreak
    - 1..0=2
    - 15..13=4
    - 12=1
    - 11..2=0
    opcode_group: c
    opcode_args: &18 []
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/c.html"
    main_desc: c
    main_id: "#integer-register-register-operations"
    desc:
      c:
        "#control-transfer-instructions":
          text:
          - C.JALR (jump and link register) performs the same operation as C.JR, but
            additionally writes the address of the instruction following the jump
            (pc+2) to the link register, x1. C.JALR expands to jalr x1, 0(rs1). C.JALR
            is only valid when rs1 x0; the code point with rs1 = x0 corresponds to
            the C.EBREAK instruction.
        "#integer-register-register-operations":
          text:
          - C.ADD adds the values in registers rd and rs2 and writes the result to
            register rd. C.ADD expands into add rd, rd, rs2. C.ADD is only valid when
            rs2 x0; the code points with rs2 = x0 correspond to the C.JALR and C.EBREAK
            instructions. The code points with rs2 x0 and rd = x0 are HINTs.
        "#breakpoint-instruction":
          text:
          - Debuggers can use the C.EBREAK instruction, which expands to ebreak, to
            cause control to be transferred back to the debugging environment. C.EBREAK
            shares the opcode with the C.ADD instruction, but with rd and rs2 both
            zero, thus can also use the CR format.
      machine:
        "#environment-call-and-breakpoint":
          text:
          - As described in the "C" Standard Extension for Compressed Instructions
            in Volume I of this manual, the C.EBREAK instruction performs the same
            operation as the EBREAK instruction.
    iss_code:
    - require_extension(EXT_ZCA);
    - if (!STATE.debug_mode && (
    - "(!STATE.v && STATE.prv == PRV_M && STATE.dcsr->ebreakm) ||"
    - "(!STATE.v && STATE.prv == PRV_S && STATE.dcsr->ebreaks) ||"
    - "(!STATE.v && STATE.prv == PRV_U && STATE.dcsr->ebreaku) ||"
    - "(STATE.v && STATE.prv == PRV_S && STATE.dcsr->ebreakvs) ||"
    - "(STATE.v && STATE.prv == PRV_U && STATE.dcsr->ebreakvu))) {"
    - throw trap_debug_mode();
    - "} else {"
    - throw trap_breakpoint(STATE.v, pc);
    - "}"
  c.fld:
    opcode:
    - c.fld
    - rd_p
    - rs1_p
    - c_uimm8lo
    - c_uimm8hi
    - 1..0=0
    - 15..13=1
    opcode_group: c_d
    opcode_args: &8
    - rd_p
    - rs1_p
    - c_uimm8
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/c.html"
    main_desc: c
    main_id: "#register-based-loads-and-stores"
    desc:
      c:
        "#register-based-loads-and-stores":
          text:
          - C.FLD is an RV32DC/RV64DC-only instruction that loads a double-precision
            floating-point value from memory into floating-point register rd'. It
            computes an effective address by adding the zero-extended offset, scaled
            by 8, to the base address in register rs1'. It expands to fld rd', offset(rs1').
      zfinx:
        "#zdinx":
          text:
          - The Zdinx extension adds all of the instructions that the D extension
            adds, except for the transfer instructions FLD, FSD, FMV.D.X, FMV.X.D,
            C.FLD[SP], and C.FSD[SP].
    iss_code:
    - require_extension(EXT_ZCD);
    - require_fp;
    - WRITE_RVC_FRS2S(f64(MMU.load<uint64_t>(RVC_RS1S + insn.rvc_ld_imm())));
  c.fldsp:
    opcode:
    - c.fldsp
    - rd
    - c_uimm9sphi
    - c_uimm9splo
    - 1..0=2
    - 15..13=1
    opcode_group: c_d
    opcode_args: &50
    - rd
    - c_uimm9sp
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/c.html"
    main_desc: c
    main_id: "#stack-pointer-based-loads-and-stores"
    desc:
      c:
        "#stack-pointer-based-loads-and-stores":
          text:
          - C.FLDSP is an RV32DC/RV64DC-only instruction that loads a double-precision
            floating-point value from memory into floating-point register rd. It computes
            its effective address by adding the zero-extended offset, scaled by 8,
            to the stack pointer, x2. It expands to fld rd, offset(x2).
    iss_code:
    - require_extension(EXT_ZCD);
    - require_fp;
    - WRITE_FRD(f64(MMU.load<uint64_t>(RVC_SP + insn.rvc_ldsp_imm())));
    opcode_alias: fldsp
  c.flw:
    opcode:
    - c.flw
    - rd_p
    - rs1_p
    - c_uimm7lo
    - c_uimm7hi
    - 1..0=0
    - 15..13=3
    opcode_group: c_f
    opcode_args: &10
    - rd_p
    - rs1_p
    - c_uimm7
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/c.html"
    main_desc: c
    main_id: "#register-based-loads-and-stores"
    desc:
      c:
        "#register-based-loads-and-stores":
          text:
          - C.FLW is an RV32FC-only instruction that loads a single-precision floating-point
            value from memory into floating-point register rd'. It computes an effective
            address by adding the zero-extended offset, scaled by 4, to the base address
            in register rs1'. It expands to flw rd', offset(rs1').
      zfinx:
        "#sec:zfinx":
          text:
          - The Zfinx extension adds all of the instructions that the F extension
            adds, except for the transfer instructions FLW, FSW, FMV.W.X, FMV.X.W,
            C.FLW[SP], and C.FSW[SP].
    iss_code:
    - if (xlen == 32) {
    - require_extension(EXT_ZCF);
    - require_fp;
    - WRITE_RVC_FRS2S(f32(MMU.load<uint32_t>(RVC_RS1S + insn.rvc_lw_imm())));
    - "} else { // c.ld"
    - require_extension(EXT_ZCA);
    - WRITE_RVC_RS2S(MMU.load<int64_t>(RVC_RS1S + insn.rvc_ld_imm()));
    - "}"
  c.flwsp:
    opcode:
    - c.flwsp
    - rd
    - c_uimm8sphi
    - c_uimm8splo
    - 1..0=2
    - 15..13=3
    opcode_group: c_f
    opcode_args: &67
    - rd
    - c_uimm8sp
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/c.html"
    main_desc: c
    main_id: "#stack-pointer-based-loads-and-stores"
    desc:
      c:
        "#stack-pointer-based-loads-and-stores":
          text:
          - C.FLWSP is an RV32FC-only instruction that loads a single-precision floating-point
            value from memory into floating-point register rd. It computes its effective
            address by adding the zero-extended offset, scaled by 4, to the stack
            pointer, x2. It expands to flw rd, offset(x2).
    iss_code:
    - if (xlen == 32) {
    - require_extension(EXT_ZCF);
    - require_fp;
    - WRITE_FRD(f32(MMU.load<uint32_t>(RVC_SP + insn.rvc_lwsp_imm())));
    - "} else { // c.ldsp"
    - require_extension(EXT_ZCA);
    - require(insn.rvc_rd() != 0);
    - WRITE_RD(MMU.load<int64_t>(RVC_SP + insn.rvc_ldsp_imm()));
    - "}"
    opcode_alias: flwsp
  c.fsd:
    opcode:
    - c.fsd
    - rs1_p
    - rs2_p
    - c_uimm8lo
    - c_uimm8hi
    - 1..0=0
    - 15..13=5
    opcode_group: c_d
    opcode_args: &65
    - rs1_p
    - rs2_p
    - c_uimm8
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/c.html"
    main_desc: c
    main_id: "#register-based-loads-and-stores"
    desc:
      c:
        "#register-based-loads-and-stores":
          text:
          - C.FSD is an RV32DC/RV64DC-only instruction that stores a double-precision
            floating-point value in floating-point register rs2' to memory. It computes
            an effective address by adding the zero-extended offset, scaled by 8,
            to the base address in register rs1'. It expands to fsd rs2', offset(rs1').
      zfinx:
        "#zdinx":
          text:
          - The Zdinx extension adds all of the instructions that the D extension
            adds, except for the transfer instructions FLD, FSD, FMV.D.X, FMV.X.D,
            C.FLD[SP], and C.FSD[SP].
    iss_code:
    - require_extension(EXT_ZCD);
    - require_fp;
    - MMU.store<uint64_t>(RVC_RS1S + insn.rvc_ld_imm(), RVC_FRS2S.v[0]);
  c.fsdsp:
    opcode:
    - c.fsdsp
    - c_rs2
    - c_uimm9sp_s
    - 1..0=2
    - 15..13=5
    opcode_group: c_d
    opcode_args: &11
    - c_rs2
    - c_uimm9sp_s
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/c.html"
    main_desc: c
    main_id: "#stack-pointer-based-loads-and-stores"
    desc:
      c:
        "#stack-pointer-based-loads-and-stores":
          text:
          - C.FSDSP is an RV32DC/RV64DC-only instruction that stores a double-precision
            floating-point value in floating-point register rs2 to memory. It computes
            an effective address by adding the zero-extended offset, scaled by 8,
            to the stack pointer, x2. It expands to fsd rs2, offset(x2).
    iss_code:
    - require_extension(EXT_ZCD);
    - require_fp;
    - MMU.store<uint64_t>(RVC_SP + insn.rvc_sdsp_imm(), RVC_FRS2.v[0]);
    opcode_alias: fsdsp
  c.fsw:
    opcode:
    - c.fsw
    - rs1_p
    - rs2_p
    - c_uimm7lo
    - c_uimm7hi
    - 1..0=0
    - 15..13=7
    opcode_group: c_f
    opcode_args: &15
    - rs1_p
    - rs2_p
    - c_uimm7
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/c.html"
    main_desc: c
    main_id: "#register-based-loads-and-stores"
    desc:
      c:
        "#register-based-loads-and-stores":
          text:
          - C.FSW is an RV32FC-only instruction that stores a single-precision floating-point
            value in floating-point register rs2' to memory. It computes an effective
            address by adding the zero-extended offset, scaled by 4, to the base address
            in register rs1'. It expands to fsw rs2', offset(rs1').
      zfinx:
        "#sec:zfinx":
          text:
          - The Zfinx extension adds all of the instructions that the F extension
            adds, except for the transfer instructions FLW, FSW, FMV.W.X, FMV.X.W,
            C.FLW[SP], and C.FSW[SP].
    iss_code:
    - if (xlen == 32) {
    - require_extension(EXT_ZCF);
    - require_fp;
    - MMU.store<uint32_t>(RVC_RS1S + insn.rvc_lw_imm(), RVC_FRS2S.v[0]);
    - "} else { // c.sd"
    - require_extension(EXT_ZCA);
    - MMU.store<uint64_t>(RVC_RS1S + insn.rvc_ld_imm(), RVC_RS2S);
    - "}"
  c.fswsp:
    opcode:
    - c.fswsp
    - c_rs2
    - c_uimm8sp_s
    - 1..0=2
    - 15..13=7
    opcode_group: c_f
    opcode_args: &16
    - c_rs2
    - c_uimm8sp_s
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/c.html"
    main_desc: c
    main_id: "#stack-pointer-based-loads-and-stores"
    desc:
      c:
        "#stack-pointer-based-loads-and-stores":
          text:
          - C.FSWSP is an RV32FC-only instruction that stores a single-precision floating-point
            value in floating-point register rs2 to memory. It computes an effective
            address by adding the zero-extended offset, scaled by 4, to the stack
            pointer, x2. It expands to fsw rs2, offset(x2).
    iss_code:
    - if (xlen == 32) {
    - require_extension(EXT_ZCF);
    - require_fp;
    - MMU.store<uint32_t>(RVC_SP + insn.rvc_swsp_imm(), RVC_FRS2.v[0]);
    - "} else { // c.sdsp"
    - require_extension(EXT_ZCA);
    - MMU.store<uint64_t>(RVC_SP + insn.rvc_sdsp_imm(), RVC_RS2);
    - "}"
    opcode_alias: fswsp
  c.j:
    opcode:
    - c.j
    - c_imm12
    - 1..0=1
    - 15..13=5
    opcode_group: c
    opcode_args: &7
    - c_imm12
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/c.html"
    main_desc: c
    main_id: "#control-transfer-instructions"
    desc:
      c:
        "#control-transfer-instructions":
          text:
          - C.J performs an unconditional control transfer. The offset is sign-extended
            and added to the pc to form the jump target address. C.J can therefore
            target a 2KiB range. C.J expands to jal x0, offset.
          - C.JAL is an RV32C-only instruction that performs the same operation as
            C.J, but additionally writes the address of the instruction following
            the jump (pc+2) to the link register, x1. C.JAL expands to jal x1, offset.
    iss_code:
    - require_extension(EXT_ZCA);
    - set_pc(pc + insn.rvc_j_imm());
  c.jal:
    opcode:
    - c.jal
    - c_imm12
    - 1..0=1
    - 15..13=1
    opcode_group: c
    opcode_args: *7
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/c.html"
    main_desc: c
    main_id: "#control-transfer-instructions"
    desc:
      c:
        "#control-transfer-instructions":
          text:
          - C.JAL is an RV32C-only instruction that performs the same operation as
            C.J, but additionally writes the address of the instruction following
            the jump (pc+2) to the link register, x1. C.JAL expands to jal x1, offset.
    iss_code:
    - require_extension(EXT_ZCA);
    - if (xlen == 32) {
    - reg_t tmp = npc;
    - set_pc(pc + insn.rvc_j_imm());
    - WRITE_REG(X_RA, tmp);
    - "} else { // c.addiw"
    - require(insn.rvc_rd() != 0);
    - WRITE_RD(sext32(RVC_RS1 + insn.rvc_imm()));
    - "}"
  c.jalr:
    opcode:
    - c.jalr
    - c_rs1_n0
    - 1..0=2
    - 15..13=4
    - 12=1
    - 6..2=0
    opcode_group: c
    opcode_args: &63
    - c_rs1_n0
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/c.html"
    main_desc: c
    main_id: "#integer-register-register-operations"
    desc:
      c:
        "#control-transfer-instructions":
          text:
          - C.JALR (jump and link register) performs the same operation as C.JR, but
            additionally writes the address of the instruction following the jump
            (pc+2) to the link register, x1. C.JALR expands to jalr x1, 0(rs1). C.JALR
            is only valid when rs1 x0; the code point with rs1 = x0 corresponds to
            the C.EBREAK instruction.
          - Strictly speaking, C.JALR does not expand exactly to a base RVI instruction
            as the value added to the PC to form the link address is 2 rather than
            4 as in the base ISA, but supporting both offsets of 2 and 4 bytes is
            only a very minor change to the base microarchitecture.
        "#integer-register-register-operations":
          text:
          - C.ADD adds the values in registers rd and rs2 and writes the result to
            register rd. C.ADD expands into add rd, rd, rs2. C.ADD is only valid when
            rs2 x0; the code points with rs2 = x0 correspond to the C.JALR and C.EBREAK
            instructions. The code points with rs2 x0 and rd = x0 are HINTs.
    iss_code:
    - require_extension(EXT_ZCA);
    - require(insn.rvc_rs1() != 0);
    - reg_t tmp = npc;
    - set_pc(RVC_RS1 & ~reg_t(1));
    - WRITE_REG(X_RA, tmp);
  c.jr:
    opcode:
    - c.jr
    - rs1_n0
    - 1..0=2
    - 15..13=4
    - 12=0
    - 6..2=0
    opcode_group: c
    opcode_args: &61
    - rs1_n0
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/c.html"
    main_desc: c
    main_id: "#integer-register-register-operations"
    desc:
      c:
        "#control-transfer-instructions":
          text:
          - C.JR (jump register) performs an unconditional control transfer to the
            address in register rs1. C.JR expands to jalr x0, 0(rs1). C.JR is only
            valid when rs1 x0; the code point with rs1 = x0 is reserved.
          - C.JALR (jump and link register) performs the same operation as C.JR, but
            additionally writes the address of the instruction following the jump
            (pc+2) to the link register, x1. C.JALR expands to jalr x1, 0(rs1). C.JALR
            is only valid when rs1 x0; the code point with rs1 = x0 corresponds to
            the C.EBREAK instruction.
        "#integer-register-register-operations":
          text:
          - C.MV copies the value in register rs2 into register rd. C.MV expands into
            add rd, x0, rs2. C.MV is only valid when rs2 x0; the code points with
            rs2 = x0 correspond to the C.JR instruction. The code points with rs2
            x0 and rd = x0 are HINTs.
    iss_code:
    - require_extension(EXT_ZCA);
    - require(insn.rvc_rs1() != 0);
    - set_pc(RVC_RS1 & ~reg_t(1));
  c.lbu:
    opcode:
    - c.lbu
    - rd_p
    - rs1_p
    - c_uimm2
    - 1..0=0
    - 15..13=4
    - 12..10=0
    opcode_group: zcb
    opcode_args: &51
    - rd_p
    - rs1_p
    - c_uimm2
    iss_code:
    - require_extension(EXT_ZCB);
    - WRITE_RVC_RS2S(MMU.load<uint8_t>(RVC_RS1S + insn.rvc_lbimm()));
  c.ld:
    opcode:
    - c.ld
    - rd_p
    - rs1_p
    - c_uimm8lo
    - c_uimm8hi
    - 1..0=0
    - 15..13=3
    opcode_group: c
    opcode_args: *8
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/c.html"
    main_desc: c
    main_id: "#register-based-loads-and-stores"
    desc:
      c:
        "#register-based-loads-and-stores":
          text:
          - C.LD is an RV64C/RV128C-only instruction that loads a 64-bit value from
            memory into register rd'. It computes an effective address by adding the
            zero-extended offset, scaled by 8, to the base address in register rs1'.
            It expands to ld rd', offset(rs1').
  c.ldsp:
    opcode:
    - c.ldsp
    - rd_n0
    - c_uimm9sphi
    - c_uimm9splo
    - 1..0=2
    - 15..13=3
    opcode_group: c
    opcode_args: &71
    - rd_n0
    - c_uimm9sp
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/c.html"
    main_desc: c
    main_id: "#stack-pointer-based-loads-and-stores"
    desc:
      c:
        "#stack-pointer-based-loads-and-stores":
          text:
          - C.LDSP is an RV64C/RV128C-only instruction that loads a 64-bit value from
            memory into register rd. It computes its effective address by adding the
            zero-extended offset, scaled by 8, to the stack pointer, x2. It expands
            to ld rd, offset(x2). C.LDSP is only valid when rd x0; the code points
            with rd = x0 are reserved.
    opcode_alias: ldsp
  c.lh:
    opcode:
    - c.lh
    - rd_p
    - rs1_p
    - c_uimm1
    - 1..0=0
    - 15..13=4
    - 12..10=1
    - 6=1
    opcode_group: zcb
    opcode_args: &9
    - rd_p
    - rs1_p
    - c_uimm1
    iss_code:
    - require_extension(EXT_ZCB);
    - WRITE_RVC_RS2S(MMU.load<int16_t>(RVC_RS1S + insn.rvc_lhimm()));
  c.lhu:
    opcode:
    - c.lhu
    - rd_p
    - rs1_p
    - c_uimm1
    - 1..0=0
    - 15..13=4
    - 12..10=1
    - 6=0
    opcode_group: zcb
    opcode_args: *9
    iss_code:
    - require_extension(EXT_ZCB);
    - WRITE_RVC_RS2S(MMU.load<uint16_t>(RVC_RS1S + insn.rvc_lhimm()));
  c.li:
    opcode:
    - c.li
    - rd
    - c_imm6lo
    - c_imm6hi
    - 1..0=1
    - 15..13=2
    opcode_group: c
    opcode_args: &48
    - rd
    - c_imm6
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/c.html"
    main_desc: c
    main_id: "#integer-constant-generation-instructions"
    desc:
      c:
        "#integer-constant-generation-instructions":
          text:
          - C.LI loads the sign-extended 6-bit immediate, imm, into register rd. C.LI
            expands into addi rd, x0, imm. C.LI is only valid when rd x0; the code
            points with rd=x0 encode HINTs.
    iss_code:
    - require_extension(EXT_ZCA);
    - WRITE_RD(insn.rvc_imm());
  c.lui:
    opcode:
    - c.lui
    - rd_n2
    - c_nzimm18hi
    - c_nzimm18lo
    - 1..0=1
    - 15..13=3
    opcode_group: c
    opcode_args: &59
    - rd_n2
    - c_nzimm18
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/c.html"
    main_desc: c
    main_id: "#integer-constant-generation-instructions"
    desc:
      c:
        "#integer-constant-generation-instructions":
          text:
          - C.LUI loads the non-zero 6-bit immediate field into bits 17-12 of the
            destination register, clears the bottom 12 bits, and sign-extends bit
            17 into all higher bits of the destination. C.LUI expands into lui rd,
            nzimm. C.LUI is only valid when rd {x0,x2}, and when the immediate is
            not equal to zero. The code points with nzimm=0 are reserved; the remaining
            code points with rd=x0 are HINTs; and the remaining code points with rd=x2
            correspond to the C.ADDI16SP instruction.
        "#integer-register-immediate-operations":
          text:
          - C.ADDI16SP shares the opcode with C.LUI, but has a destination field of
            x2. C.ADDI16SP adds the non-zero sign-extended 6-bit immediate to the
            value in the stack pointer (sp=x2), where the immediate is scaled to represent
            multiples of 16 in the range (-512,496). C.ADDI16SP is used to adjust
            the stack pointer in procedure prologues and epilogues. It expands into
            addi x2, x2, nzimm. C.ADDI16SP is only valid when nzimm 0; the code point
            with nzimm=0 is reserved.
    iss_code:
    - require_extension(EXT_ZCA);
    - if (insn.rvc_rd() == 2) { // c.addi16sp
    - require(insn.rvc_addi16sp_imm() != 0);
    - WRITE_REG(X_SP, sext_xlen(RVC_SP + insn.rvc_addi16sp_imm()));
    - "} else {"
    - require(insn.rvc_imm() != 0);
    - WRITE_RD(insn.rvc_imm() << 12);
    - "}"
  c.lw:
    opcode:
    - c.lw
    - rd_p
    - rs1_p
    - c_uimm7lo
    - c_uimm7hi
    - 1..0=0
    - 15..13=2
    opcode_group: c
    opcode_args: *10
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/c.html"
    main_desc: c
    main_id: "#register-based-loads-and-stores"
    desc:
      c:
        "#register-based-loads-and-stores":
          text:
          - C.LW loads a 32-bit value from memory into register rd'. It computes an
            effective address by adding the zero-extended offset, scaled by 4, to
            the base address in register rs1'. It expands to lw rd', offset(rs1').
    iss_code:
    - require_extension(EXT_ZCA);
    - WRITE_RVC_RS2S(MMU.load<int32_t>(RVC_RS1S + insn.rvc_lw_imm()));
  c.lwsp:
    opcode:
    - c.lwsp
    - rd_n0
    - c_uimm8sphi
    - c_uimm8splo
    - 1..0=2
    - 15..13=2
    opcode_group: c
    opcode_args: &46
    - rd_n0
    - c_uimm8sp
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/c.html"
    main_desc: c
    main_id: "#stack-pointer-based-loads-and-stores"
    desc:
      c:
        "#stack-pointer-based-loads-and-stores":
          text:
          - C.LWSP loads a 32-bit value from memory into register rd. It computes
            an effective address by adding the zero-extended offset, scaled by 4,
            to the stack pointer, x2. It expands to lw rd, offset(x2). C.LWSP is only
            valid when rd x0; the code points with rd = x0 are reserved.
    iss_code:
    - require_extension(EXT_ZCA);
    - require(insn.rvc_rd() != 0);
    - WRITE_RD(MMU.load<int32_t>(RVC_SP + insn.rvc_lwsp_imm()));
    opcode_alias: lwsp
  c.mul:
    opcode:
    - c.mul
    - rd_rs1_p
    - rs2_p
    - 1..0=1
    - 15..13=4
    - 12..10=7
    - 6..5=2
    opcode_group: zcb
    opcode_args: *5
    iss_code:
    - require_extension(EXT_ZCB);
    - require_either_extension('M', EXT_ZMMUL);
    - WRITE_RVC_RS1S(sext_xlen(RVC_RS1S * RVC_RS2S));
  c.mv:
    opcode:
    - c.mv
    - rd
    - c_rs2_n0
    - 1..0=2
    - 15..13=4
    - 12=0
    opcode_group: c
    opcode_args: &62
    - rd
    - c_rs2_n0
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/c.html"
    main_desc: c
    main_id: "#integer-register-register-operations"
    desc:
      c:
        "#integer-register-register-operations":
          text:
          - C.MV copies the value in register rs2 into register rd. C.MV expands into
            add rd, x0, rs2. C.MV is only valid when rs2 x0; the code points with
            rs2 = x0 correspond to the C.JR instruction. The code points with rs2
            x0 and rd = x0 are HINTs.
          - C.MV expands to a different instruction than the canonical MV pseudoinstruction,
            which instead uses ADDI. Implementations that handle MV specially, e.g.
            using register-renaming hardware, may find it more convenient to expand
            C.MV to MV instead of ADD, at slight additional hardware cost.
    iss_code:
    - require_extension(EXT_ZCA);
    - require(insn.rvc_rs2() != 0);
    - WRITE_RD(RVC_RS2);
  c.nop:
    opcode:
    - c.nop
    - c_nzimm6hi
    - c_nzimm6lo
    - 1..0=1
    - 15..13=0
    - 11..7=0
    opcode_group: c
    opcode_args: &58
    - c_nzimm6
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/c.html"
    main_desc: c
    main_id: "#nop-instruction"
    desc:
      c:
        "#integer-register-immediate-operations":
          text:
          - C.ADDI adds the non-zero sign-extended 6-bit immediate to the value in
            register rd then writes the result to rd. C.ADDI expands into addi rd,
            rd, nzimm. C.ADDI is only valid when rd x0 and nzimm 0. The code points
            with rd=x0 encode the C.NOP instruction; the remaining code points with
            nzimm=0 encode HINTs.
        "#nop-instruction":
          text:
          - C.NOP is a CI-format instruction that does not change any user-visible
            state, except for advancing the pc and incrementing any applicable performance
            counters. C.NOP expands to nop. C.NOP is only valid when imm=0; the code
            points with imm 0 encode HINTs.
  c.not:
    opcode:
    - c.not
    - rd_rs1_p
    - 1..0=1
    - 15..13=4
    - 12..10=7
    - 6..5=3
    - 4..2=5
    opcode_group: zcb
    opcode_args: &12
    - rd_rs1_p
    iss_code:
    - require_extension(EXT_ZCB);
    - WRITE_RVC_RS1S(sext_xlen(~RVC_RS1S));
  c.or:
    opcode:
    - c.or
    - rd_rs1_p
    - rs2_p
    - 1..0=1
    - 15..13=4
    - 12..10=0b011
    - 6..5=2
    opcode_group: c
    opcode_args: *5
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/c.html"
    main_desc: c
    main_id: "#integer-register-register-operations"
    desc:
      c:
        "#integer-register-register-operations":
          text:
          - C.OR computes the bitwise OR of the values in registers rd' and rs2',
            then writes the result to register rd'. C.OR expands into or rd', rd',
            rs2'.
    iss_code:
    - require_extension(EXT_ZCA);
    - WRITE_RVC_RS1S(RVC_RS1S | RVC_RS2S);
  c.sb:
    opcode:
    - c.sb
    - rs2_p
    - rs1_p
    - c_uimm2
    - 1..0=0
    - 15..13=4
    - 12..10=2
    opcode_group: zcb
    opcode_args: &52
    - rs2_p
    - rs1_p
    - c_uimm2
    iss_code:
    - require_extension(EXT_ZCB);
    - MMU.store<uint8_t>(RVC_RS1S + insn.rvc_lbimm(), RVC_RS2S);
  c.sd:
    opcode:
    - c.sd
    - rs1_p
    - rs2_p
    - c_uimm8hi
    - c_uimm8lo
    - 1..0=0
    - 15..13=7
    opcode_group: c
    opcode_args: &68
    - rs1_p
    - rs2_p
    - c_uimm8
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/c.html"
    main_desc: c
    main_id: "#register-based-loads-and-stores"
    desc:
      c:
        "#register-based-loads-and-stores":
          text:
          - C.SD is an RV64C/RV128C-only instruction that stores a 64-bit value in
            register rs2' to memory. It computes an effective address by adding the
            zero-extended offset, scaled by 8, to the base address in register rs1'.
            It expands to sd rs2', offset(rs1').
  c.sdsp:
    opcode:
    - c.sdsp
    - c_rs2
    - c_uimm9sp_s
    - 1..0=2
    - 15..13=7
    opcode_group: c
    opcode_args: *11
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/c.html"
    main_desc: c
    main_id: "#stack-pointer-based-loads-and-stores"
    desc:
      c:
        "#stack-pointer-based-loads-and-stores":
          text:
          - C.SDSP is an RV64C/RV128C-only instruction that stores a 64-bit value
            in register rs2 to memory. It computes an effective address by adding
            the zero-extended offset, scaled by 8, to the stack pointer, x2. It expands
            to sd rs2, offset(x2).
    opcode_alias: sdsp
  c.sext.b:
    opcode:
    - c.sext.b
    - rd_rs1_p
    - 1..0=1
    - 15..13=4
    - 12..10=7
    - 6..5=3
    - 4..2=1
    opcode_group: zcb
    opcode_args: *12
    iss_code:
    - require_extension(EXT_ZCB);
    - require_extension(EXT_ZBB);
    - WRITE_RVC_RS1S((sreg_t)(int8_t)(RVC_RS1S));
  c.sext.h:
    opcode:
    - c.sext.h
    - rd_rs1_p
    - 1..0=1
    - 15..13=4
    - 12..10=7
    - 6..5=3
    - 4..2=3
    opcode_group: zcb
    opcode_args: *12
    iss_code:
    - require_extension(EXT_ZCB);
    - require_extension(EXT_ZBB);
    - WRITE_RVC_RS1S((sreg_t)(int16_t)(RVC_RS1S));
  c.sh:
    opcode:
    - c.sh
    - rs2_p
    - rs1_p
    - c_uimm1
    - 1..0=0
    - 15..13=4
    - 12..10=3
    - 6=0
    opcode_group: zcb
    opcode_args: &53
    - rs2_p
    - rs1_p
    - c_uimm1
    iss_code:
    - require_extension(EXT_ZCB);
    - MMU.store<uint16_t>(RVC_RS1S + insn.rvc_lhimm(), RVC_RS2S);
  c.slli:
    opcode:
    - c.slli
    - rd_rs1_n0
    - c_nzuimm6hi
    - c_nzuimm6lo
    - 1..0=2
    - 15..13=0
    opcode_group: c
    opcode_args: &70
    - rd_rs1_n0
    - c_nzuimm6
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/c.html"
    main_desc: c
    main_id: "#integer-register-immediate-operations"
    desc:
      c:
        "#integer-register-immediate-operations":
          text:
          - C.SLLI is a CI-format instruction that performs a logical left shift of
            the value in register rd then writes the result to rd. The shift amount
            is encoded in the shamt field. For RV128C, a shift amount of zero is used
            to encode a shift of 64. C.SLLI expands into slli rd, rd, shamt, except
            for RV128C with shamt=0, which expands to slli rd, rd, 64.
    iss_code:
    - require_extension(EXT_ZCA);
    - require(insn.rvc_zimm() < xlen);
    - WRITE_RD(sext_xlen(RVC_RS1 << insn.rvc_zimm()));
  c.slli_rv32:
    opcode:
    - c.slli_rv32
    - rd_rs1_n0
    - c_nzuimm6lo
    - 1..0=2
    - 15..12=0
    opcode_group: c
    opcode_args: &66
    - rd_rs1_n0
    - c_nzuimm6lo
    pseudo_src: rv64_c
    pseudo_op: c.slli
    main_desc: c
    main_id: "#compressed"
    desc:
      c:
        "#compressed":
          text: []
  c.srai:
    opcode:
    - c.srai
    - rd_rs1_p
    - c_nzuimm6lo
    - c_nzuimm6hi
    - 1..0=1
    - 15..13=4
    - 11..10=1
    opcode_group: c
    opcode_args: &13
    - rd_rs1_p
    - c_nzuimm6
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/c.html"
    main_desc: c
    main_id: "#integer-register-immediate-operations"
    desc:
      c:
        "#integer-register-immediate-operations":
          text:
          - C.SRAI is defined analogously to C.SRLI, but instead performs an arithmetic
            right shift. C.SRAI expands to srai rd', rd', shamt.
    iss_code:
    - require_extension(EXT_ZCA);
    - require(insn.rvc_zimm() < xlen);
    - WRITE_RVC_RS1S(sext_xlen(sext_xlen(RVC_RS1S) >> insn.rvc_zimm()));
  c.srai_rv32:
    opcode:
    - c.srai_rv32
    - rd_rs1_p
    - c_nzuimm5
    - 1..0=1
    - 15..13=4
    - 12..10=1
    opcode_group: c
    opcode_args: &14
    - rd_rs1_p
    - c_nzuimm5
    pseudo_src: rv64_c
    pseudo_op: c.srai
    main_desc: c
    main_id: "#compressed"
    desc:
      c:
        "#compressed":
          text: []
  c.srli:
    opcode:
    - c.srli
    - rd_rs1_p
    - c_nzuimm6lo
    - c_nzuimm6hi
    - 1..0=1
    - 15..13=4
    - 11..10=0
    opcode_group: c
    opcode_args: *13
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/c.html"
    main_desc: c
    main_id: "#integer-register-immediate-operations"
    desc:
      c:
        "#integer-register-immediate-operations":
          text:
          - C.SRLI is a CB-format instruction that performs a logical right shift
            of the value in register rd' then writes the result to rd'. The shift
            amount is encoded in the shamt field. For RV128C, a shift amount of zero
            is used to encode a shift of 64. Furthermore, the shift amount is sign-extended
            for RV128C, and so the legal shift amounts are 1-31, 64, and 96-127. C.SRLI
            expands into srli rd', rd', shamt, except for RV128C with shamt=0, which
            expands to srli rd', rd', 64.
          - C.SRAI is defined analogously to C.SRLI, but instead performs an arithmetic
            right shift. C.SRAI expands to srai rd', rd', shamt.
    iss_code:
    - require_extension(EXT_ZCA);
    - require(insn.rvc_zimm() < xlen);
    - WRITE_RVC_RS1S(sext_xlen(zext_xlen(RVC_RS1S) >> insn.rvc_zimm()));
  c.srli_rv32:
    opcode:
    - c.srli_rv32
    - rd_rs1_p
    - c_nzuimm5
    - 1..0=1
    - 15..13=4
    - 12..10=0
    opcode_group: c
    opcode_args: *14
    pseudo_src: rv64_c
    pseudo_op: c.srli
    main_desc: c
    main_id: "#compressed"
    desc:
      c:
        "#compressed":
          text: []
  c.sub:
    opcode:
    - c.sub
    - rd_rs1_p
    - rs2_p
    - 1..0=1
    - 15..13=4
    - 12..10=0b011
    - 6..5=0
    opcode_group: c
    opcode_args: *5
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/c.html"
    main_desc: c
    main_id: "#integer-register-register-operations"
    desc:
      c:
        "#integer-register-register-operations":
          text:
          - C.SUB subtracts the value in register rs2' from the value in register
            rd', then writes the result to register rd'. C.SUB expands into sub rd',
            rd', rs2'.
    iss_code:
    - require_extension(EXT_ZCA);
    - WRITE_RVC_RS1S(sext_xlen(RVC_RS1S - RVC_RS2S));
  c.subw:
    opcode:
    - c.subw
    - rd_rs1_p
    - rs2_p
    - 1..0=1
    - 15..13=4
    - 12..10=0b111
    - 6..5=0
    opcode_group: c
    opcode_args: *5
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/c.html"
    main_desc: c
    main_id: "#integer-register-register-operations"
    desc:
      c:
        "#integer-register-register-operations":
          text:
          - C.SUBW is an RV64C/RV128C-only instruction that subtracts the value in
            register rs2' from the value in register rd', then sign-extends the lower
            32 bits of the difference before writing the result to register rd'. C.SUBW
            expands into subw rd', rd', rs2'.
    iss_code:
    - require_extension(EXT_ZCA);
    - require_rv64;
    - WRITE_RVC_RS1S(sext32(RVC_RS1S - RVC_RS2S));
  c.sw:
    opcode:
    - c.sw
    - rs1_p
    - rs2_p
    - c_uimm7lo
    - c_uimm7hi
    - 1..0=0
    - 15..13=6
    opcode_group: c
    opcode_args: *15
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/c.html"
    main_desc: c
    main_id: "#register-based-loads-and-stores"
    desc:
      c:
        "#register-based-loads-and-stores":
          text:
          - C.SW stores a 32-bit value in register rs2' to memory. It computes an
            effective address by adding the zero-extended offset, scaled by 4, to
            the base address in register rs1'. It expands to sw rs2', offset(rs1').
    iss_code:
    - require_extension(EXT_ZCA);
    - MMU.store<uint32_t>(RVC_RS1S + insn.rvc_lw_imm(), RVC_RS2S);
  c.swsp:
    opcode:
    - c.swsp
    - c_rs2
    - c_uimm8sp_s
    - 1..0=2
    - 15..13=6
    opcode_group: c
    opcode_args: *16
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/c.html"
    main_desc: c
    main_id: "#stack-pointer-based-loads-and-stores"
    desc:
      c:
        "#stack-pointer-based-loads-and-stores":
          text:
          - C.SWSP stores a 32-bit value in register rs2 to memory. It computes an
            effective address by adding the zero-extended offset, scaled by 4, to
            the stack pointer, x2. It expands to sw rs2, offset(x2).
    iss_code:
    - require_extension(EXT_ZCA);
    - MMU.store<uint32_t>(RVC_SP + insn.rvc_swsp_imm(), RVC_RS2);
    opcode_alias: swsp
  c.xor:
    opcode:
    - c.xor
    - rd_rs1_p
    - rs2_p
    - 1..0=1
    - 15..13=4
    - 12..10=0b011
    - 6..5=1
    opcode_group: c
    opcode_args: *5
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/c.html"
    main_desc: c
    main_id: "#integer-register-register-operations"
    desc:
      c:
        "#integer-register-register-operations":
          text:
          - C.XOR computes the bitwise XOR of the values in registers rd' and rs2',
            then writes the result to register rd'. C.XOR expands into xor rd', rd',
            rs2'.
    iss_code:
    - require_extension(EXT_ZCA);
    - WRITE_RVC_RS1S(RVC_RS1S ^ RVC_RS2S);
  c.zext.b:
    opcode:
    - c.zext.b
    - rd_rs1_p
    - 1..0=1
    - 15..13=4
    - 12..10=7
    - 6..5=3
    - 4..2=0
    opcode_group: zcb
    opcode_args: *12
    iss_code:
    - require_extension(EXT_ZCB);
    - WRITE_RVC_RS1S((reg_t)(uint8_t)(RVC_RS1S));
  c.zext.h:
    opcode:
    - c.zext.h
    - rd_rs1_p
    - 1..0=1
    - 15..13=4
    - 12..10=7
    - 6..5=3
    - 4..2=2
    opcode_group: zcb
    opcode_args: *12
    iss_code:
    - require_extension(EXT_ZCB);
    - require_extension(EXT_ZBB);
    - WRITE_RVC_RS1S((reg_t)(uint16_t)(RVC_RS1S));
  c.zext.w:
    opcode:
    - c.zext.w
    - rd_rs1_p
    - 1..0=1
    - 15..13=4
    - 12..10=7
    - 6..5=3
    - 4..2=4
    opcode_group: zcb
    opcode_args: *12
    iss_code:
    - require_extension(EXT_ZCB);
    - require_extension(EXT_ZBA);
    - require_rv64;
    - WRITE_RVC_RS1S((reg_t)(uint32_t)(RVC_RS1S));
  call:
    opcode:
    - call
    - offset
    opcode_group: psuedo
    opcode_args:
    - offset
    psuedo_to_base:
    - auipc x1, offset[31:12]
    - jalr x1, x1, offset[11:0]
  cbo.clean:
    opcode:
    - cbo.clean
    - rs1
    - 31..20=1
    - 14..12=2
    - 11..7=0
    - 6..2=0x03
    - 1..0=3
    opcode_group: zicbo
    opcode_args: &17
    - rs1
  cbo.flush:
    opcode:
    - cbo.flush
    - rs1
    - 31..20=2
    - 14..12=2
    - 11..7=0
    - 6..2=0x03
    - 1..0=3
    opcode_group: zicbo
    opcode_args: *17
  cbo.inval:
    opcode:
    - cbo.inval
    - rs1
    - 31..20=0
    - 14..12=2
    - 11..7=0
    - 6..2=0x03
    - 1..0=3
    opcode_group: zicbo
    opcode_args: *17
  cbo.zero:
    opcode:
    - cbo.zero
    - rs1
    - 31..20=4
    - 14..12=2
    - 11..7=0
    - 6..2=0x03
    - 1..0=3
    opcode_group: zicbo
    opcode_args: *17
  clmul:
    opcode:
    - clmul
    - rd
    - rs1
    - rs2
    - 31..25=5
    - 14..12=1
    - 6..2=0x0C
    - 1..0=3
    opcode_group: zbc
    opcode_args: *1
    iss_code:
    - require_either_extension(EXT_ZBC, EXT_ZBKC);
    - reg_t a = zext_xlen(RS1), b = zext_xlen(RS2), x = 0;
    - for (int i = 0; i < xlen; i++)
    - if ((b >> i) & 1)
    - x ^= a << i;
    - WRITE_RD(sext_xlen(x));
  clmulh:
    opcode:
    - clmulh
    - rd
    - rs1
    - rs2
    - 31..25=5
    - 14..12=3
    - 6..2=0x0C
    - 1..0=3
    opcode_group: zbc
    opcode_args: *1
    iss_code:
    - require_either_extension(EXT_ZBC, EXT_ZBKC);
    - reg_t a = zext_xlen(RS1), b = zext_xlen(RS2), x = 0;
    - for (int i = 1; i < xlen; i++)
    - if ((b >> i) & 1)
    - x ^= a >> (xlen-i);
    - WRITE_RD(sext_xlen(x));
  clmulr:
    opcode:
    - clmulr
    - rd
    - rs1
    - rs2
    - 31..25=5
    - 14..12=2
    - 6..2=0x0C
    - 1..0=3
    opcode_group: zbc
    opcode_args: *1
    iss_code:
    - require_extension(EXT_ZBC);
    - reg_t a = zext_xlen(RS1), b = zext_xlen(RS2), x = 0;
    - for (int i = 0; i < xlen; i++)
    - if ((b >> i) & 1)
    - x ^= a >> (xlen-i-1);
    - WRITE_RD(sext_xlen(x));
  clz:
    opcode:
    - clz
    - rd
    - rs1
    - 31..20=0x600
    - 14..12=1
    - 6..2=0x04
    - 1..0=3
    opcode_group: zbb
    opcode_args: *3
    iss_code:
    - 'require_either_extension(xlen == 32 ? EXT_ZBPBO : EXT_ZBB, EXT_ZBB);'
    - reg_t x = xlen;
    - for (int i = 0; i < xlen; i++)
    - if (1 & (RS1 >> (xlen-i-1))) { x = i; break; }
    - WRITE_RD(sext_xlen(x));
  clzw:
    opcode:
    - clzw
    - rd
    - rs1
    - 31..20=0x600
    - 14..12=1
    - 6..2=0x06
    - 1..0=3
    opcode_group: zbb
    opcode_args: *3
    iss_code:
    - require_rv64;
    - require_extension(EXT_ZBB);
    - reg_t x = 32;
    - for (int i = 0; i < 32; i++)
    - if (1 & (RS1 >> (31-i))) { x = i; break; }
    - WRITE_RD(sext32(x));
  cm.jalt:
    opcode:
    - cm.jalt
    - c_index
    - 1..0=2
    - 15..13=5
    - 12..10=0
    opcode_group: zcmt
    opcode_args: *18
  cm.mva01s:
    opcode:
    - cm.mva01s
    - c_sreg1
    - c_sreg2
    - 1..0=2
    - 15..13=5
    - 12..10=3
    - 6..5=3
    opcode_group: zcmp
    opcode_args: *18
  cm.mvsa01:
    opcode:
    - cm.mvsa01
    - c_sreg1
    - c_sreg2
    - 1..0=2
    - 15..13=5
    - 12..10=3
    - 6..5=1
    opcode_group: zcmp
    opcode_args: *18
  cm.pop:
    opcode:
    - cm.pop
    - c_rlist
    - c_spimm
    - 1..0=2
    - 15..13=5
    - 12..8=0x1A
    opcode_group: zcmp
    opcode_args: &19
    - c_spimm
  cm.popret:
    opcode:
    - cm.popret
    - c_rlist
    - c_spimm
    - 1..0=2
    - 15..13=5
    - 12..8=0x1E
    opcode_group: zcmp
    opcode_args: *19
  cm.popretz:
    opcode:
    - cm.popretz
    - c_rlist
    - c_spimm
    - 1..0=2
    - 15..13=5
    - 12..8=0x1C
    opcode_group: zcmp
    opcode_args: *19
  cm.push:
    opcode:
    - cm.push
    - c_rlist
    - c_spimm
    - 1..0=2
    - 15..13=5
    - 12..8=0x18
    opcode_group: zcmp
    opcode_args: *19
  cpop:
    opcode:
    - cpop
    - rd
    - rs1
    - 31..20=0x602
    - 14..12=1
    - 6..2=0x04
    - 1..0=3
    opcode_group: zbb
    opcode_args: *3
    iss_code:
    - require_extension(EXT_ZBB);
    - reg_t x = 0;
    - for (int i = 0; i < xlen; i++)
    - if (1 & (RS1 >> i)) x++;
    - WRITE_RD(sext_xlen(x));
  cpopw:
    opcode:
    - cpopw
    - rd
    - rs1
    - 31..20=0x602
    - 14..12=1
    - 6..2=0x06
    - 1..0=3
    opcode_group: zbb
    opcode_args: *3
    iss_code:
    - require_rv64;
    - require_extension(EXT_ZBB);
    - reg_t x = 0;
    - for (int i = 0; i < 32; i++)
    - if (1 & (RS1 >> i)) x++;
    - WRITE_RD(sext32(x));
  csrc:
    opcode:
    - csrc
    - csr
    - rs
    opcode_group: psuedo
    opcode_args:
    - csr
    - rs
    psuedo_to_base:
    - csrrc x0, csr, rs
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/csr.html"
    main_desc: csr
    main_id: "#csr-instructions"
    desc:
      csr:
        "#csr-instructions":
          text:
          - 'Further assembler pseudoinstructions are defined to set and clear bits
            in the CSR when the old value is not required: CSRS/CSRC csr, rs1; CSRSI/CSRCI
            csr, uimm.'
  csrci:
    opcode:
    - csrci
    - csr
    - imm
    opcode_group: psuedo
    opcode_args:
    - csr
    - imm
    psuedo_to_base:
    - csrrci x0, csr, imm
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/csr.html"
    main_desc: csr
    main_id: "#csr-instructions"
    desc:
      csr:
        "#csr-instructions":
          text:
          - 'Further assembler pseudoinstructions are defined to set and clear bits
            in the CSR when the old value is not required: CSRS/CSRC csr, rs1; CSRSI/CSRCI
            csr, uimm.'
  csrr:
    opcode:
    - csrr
    - rd
    - csr
    opcode_group: psuedo
    opcode_args:
    - rd
    - csr
    psuedo_to_base:
    - csrrs rd, csr, x0
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/csr.html"
    main_desc: csr
    main_id: "#csr-instructions"
    desc:
      csr:
        "#csr-instructions":
          text:
          - The assembler pseudoinstruction to read a CSR, CSRR rd, csr, is encoded
            as CSRRS rd, csr, x0. The assembler pseudoinstruction to write a CSR,
            CSRW csr, rs1, is encoded as CSRRW x0, csr, rs1, while CSRWI csr, uimm,
            is encoded as CSRRWI x0, csr, uimm.
  csrrc:
    opcode:
    - csrrc
    - rd
    - rs1
    - csr
    - 14..12=3
    - 6..2=0x1C
    - 1..0=3
    opcode_group: zicsr
    opcode_args: *3
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/csr.html"
    main_desc: csr
    main_id: "#csr-instructions"
    desc:
      csr:
        "#csr-instructions":
          text:
          - The CSRRC (Atomic Read and Clear Bits in CSR) instruction reads the value
            of the CSR, zero-extends the value to XLEN bits, and writes it to integer
            register rd. The initial value in integer register rs1 is treated as a
            bit mask that specifies bit positions to be cleared in the CSR. Any bit
            that is high in rs1 will cause the corresponding bit to be cleared in
            the CSR, if that CSR bit is writable. Other bits in the CSR are not explicitly
            written.
          - For both CSRRS and CSRRC, if rs1=x0, then the instruction will not write
            to the CSR at all, and so shall not cause any of the side effects that
            might otherwise occur on a CSR write, nor raise illegal instruction exceptions
            on accesses to read-only CSRs. Both CSRRS and CSRRC always read the addressed
            CSR and cause any read side effects regardless of rs1 and rd fields. Note
            that if rs1 specifies a register holding a zero value other than x0, the
            instruction will still attempt to write the unmodified value back to the
            CSR and will cause any attendant side effects. A CSRRW with rs1=x0 will
            attempt to write zero to the destination CSR.
          - The CSRRWI, CSRRSI, and CSRRCI variants are similar to CSRRW, CSRRS, and
            CSRRC respectively, except they update the CSR using an XLEN-bit value
            obtained by zero-extending a 5-bit unsigned immediate (uimm[4:0]) field
            encoded in the rs1 field instead of a value from an integer register.
            For CSRRSI and CSRRCI, if the uimm[4:0] field is zero, then these instructions
            will not write to the CSR, and shall not cause any of the side effects
            that might otherwise occur on a CSR write, nor raise illegal instruction
            exceptions on accesses to read-only CSRs. For CSRRWI, if rd=x0, then the
            instruction shall not read the CSR and shall not cause any of the side
            effects that might occur on a CSR read. Both CSRRSI and CSRRCI will always
            read the CSR and cause any read side effects regardless of rd and rs1
            fields.
      rvwmo:
        "#sec:memorymodel:dependencies":
          text:
          - i is a CSR instruction, and in the opcode of i, csr is set to r, unless
            i is CSRRS or CSRRC and rs1 is set to x0 or i is CSRRSI or CSRRCI and
            uimm[4:0] is set to zero.
      machine:
        "#machine-interrupt-registers-mip-and-mie":
          text:
          - If supervisor mode is implemented, bits mip.SEIP and mie.SEIE are the
            interrupt-pending and interrupt-enable bits for supervisor-level external
            interrupts. SEIP is writable in mip, and may be written by M-mode software
            to indicate to S-mode that an external interrupt is pending. Additionally,
            the platform-level interrupt controller may generate supervisor-level
            external interrupts. Supervisor-level external interrupts are made pending
            based on the logical-OR of the software-writable SEIP bit and the signal
            from the external interrupt controller. When mip is read with a CSR instruction,
            the value of the SEIP bit returned in the rd destination register is the
            logical-OR of the software-writable bit and the interrupt signal from
            the interrupt controller, but the signal from the interrupt controller
            is not used to calculate the value written to SEIP. Only the software-writable
            SEIP bit participates in the read-modify-write sequence of a CSRRS or
            CSRRC instruction.
    iss_code:
    - bool write = insn.rs1() != 0;
    - int csr = validate_csr(insn.csr(), write);
    - reg_t old = p->get_csr(csr, insn, write);
    - if (write) {
    - p->put_csr(csr, old & ~RS1);
    - "}"
    - WRITE_RD(sext_xlen(old));
    - serialize();
  csrrci:
    opcode:
    - csrrci
    - rd
    - csr
    - zimm
    - 14..12=7
    - 6..2=0x1C
    - 1..0=3
    opcode_group: zicsr
    opcode_args: &20
    - rd
    - zimm
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/csr.html"
    main_desc: csr
    main_id: "#csr-instructions"
    desc:
      csr:
        "#csr-instructions":
          text:
          - The CSRRWI, CSRRSI, and CSRRCI variants are similar to CSRRW, CSRRS, and
            CSRRC respectively, except they update the CSR using an XLEN-bit value
            obtained by zero-extending a 5-bit unsigned immediate (uimm[4:0]) field
            encoded in the rs1 field instead of a value from an integer register.
            For CSRRSI and CSRRCI, if the uimm[4:0] field is zero, then these instructions
            will not write to the CSR, and shall not cause any of the side effects
            that might otherwise occur on a CSR write, nor raise illegal instruction
            exceptions on accesses to read-only CSRs. For CSRRWI, if rd=x0, then the
            instruction shall not read the CSR and shall not cause any of the side
            effects that might occur on a CSR read. Both CSRRSI and CSRRCI will always
            read the CSR and cause any read side effects regardless of rd and rs1
            fields.
      rvwmo:
        "#sec:memorymodel:dependencies":
          text:
          - i is a CSR instruction, and in the opcode of i, csr is set to r, unless
            i is CSRRS or CSRRC and rs1 is set to x0 or i is CSRRSI or CSRRCI and
            uimm[4:0] is set to zero.
    iss_code:
    - bool write = insn.rs1() != 0;
    - int csr = validate_csr(insn.csr(), write);
    - reg_t old = p->get_csr(csr, insn, write);
    - if (write) {
    - p->put_csr(csr, old & ~(reg_t)insn.rs1());
    - "}"
    - WRITE_RD(sext_xlen(old));
    - serialize();
  csrrs:
    opcode:
    - csrrs
    - rd
    - rs1
    - csr
    - 14..12=2
    - 6..2=0x1C
    - 1..0=3
    opcode_group: zicsr
    opcode_args: *3
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/csr.html"
    main_desc: csr
    main_id: "#csr-instructions"
    desc:
      csr:
        "#csr-instructions":
          text:
          - The CSRRS (Atomic Read and Set Bits in CSR) instruction reads the value
            of the CSR, zero-extends the value to XLEN bits, and writes it to integer
            register rd. The initial value in integer register rs1 is treated as a
            bit mask that specifies bit positions to be set in the CSR. Any bit that
            is high in rs1 will cause the corresponding bit to be set in the CSR,
            if that CSR bit is writable. Other bits in the CSR are not explicitly
            written.
          - For both CSRRS and CSRRC, if rs1=x0, then the instruction will not write
            to the CSR at all, and so shall not cause any of the side effects that
            might otherwise occur on a CSR write, nor raise illegal instruction exceptions
            on accesses to read-only CSRs. Both CSRRS and CSRRC always read the addressed
            CSR and cause any read side effects regardless of rs1 and rd fields. Note
            that if rs1 specifies a register holding a zero value other than x0, the
            instruction will still attempt to write the unmodified value back to the
            CSR and will cause any attendant side effects. A CSRRW with rs1=x0 will
            attempt to write zero to the destination CSR.
          - The CSRRWI, CSRRSI, and CSRRCI variants are similar to CSRRW, CSRRS, and
            CSRRC respectively, except they update the CSR using an XLEN-bit value
            obtained by zero-extending a 5-bit unsigned immediate (uimm[4:0]) field
            encoded in the rs1 field instead of a value from an integer register.
            For CSRRSI and CSRRCI, if the uimm[4:0] field is zero, then these instructions
            will not write to the CSR, and shall not cause any of the side effects
            that might otherwise occur on a CSR write, nor raise illegal instruction
            exceptions on accesses to read-only CSRs. For CSRRWI, if rd=x0, then the
            instruction shall not read the CSR and shall not cause any of the side
            effects that might occur on a CSR read. Both CSRRSI and CSRRCI will always
            read the CSR and cause any read side effects regardless of rd and rs1
            fields.
          - The assembler pseudoinstruction to read a CSR, CSRR rd, csr, is encoded
            as CSRRS rd, csr, x0. The assembler pseudoinstruction to write a CSR,
            CSRW csr, rs1, is encoded as CSRRW x0, csr, rs1, while CSRWI csr, uimm,
            is encoded as CSRRWI x0, csr, uimm.
      counters:
        "#zicntr-standard-extension-for-base-counters-and-timers":
          text:
          - RV32I provides a number of 64-bit read-only user-level counters, which
            are mapped into the 12-bit CSR address space and accessed in 32-bit pieces
            using CSRRS instructions. In RV64I, the CSR instructions can manipulate
            64-bit CSRs. In particular, the RDCYCLE, RDTIME, and RDINSTRET pseudoinstructions
            read the full 64 bits of the cycle, time, and instret counters. Hence,
            the RDCYCLEH, RDTIMEH, and RDINSTRETH instructions are RV32I-only.
      rvwmo:
        "#sec:memorymodel:dependencies":
          text:
          - i is a CSR instruction, and in the opcode of i, csr is set to r, unless
            i is CSRRS or CSRRC and rs1 is set to x0 or i is CSRRSI or CSRRCI and
            uimm[4:0] is set to zero.
      machine:
        "#machine-interrupt-registers-mip-and-mie":
          text:
          - If supervisor mode is implemented, bits mip.SEIP and mie.SEIE are the
            interrupt-pending and interrupt-enable bits for supervisor-level external
            interrupts. SEIP is writable in mip, and may be written by M-mode software
            to indicate to S-mode that an external interrupt is pending. Additionally,
            the platform-level interrupt controller may generate supervisor-level
            external interrupts. Supervisor-level external interrupts are made pending
            based on the logical-OR of the software-writable SEIP bit and the signal
            from the external interrupt controller. When mip is read with a CSR instruction,
            the value of the SEIP bit returned in the rd destination register is the
            logical-OR of the software-writable bit and the interrupt signal from
            the interrupt controller, but the signal from the interrupt controller
            is not used to calculate the value written to SEIP. Only the software-writable
            SEIP bit participates in the read-modify-write sequence of a CSRRS or
            CSRRC instruction.
    iss_code:
    - bool write = insn.rs1() != 0;
    - int csr = validate_csr(insn.csr(), write);
    - reg_t old = p->get_csr(csr, insn, write);
    - if (write) {
    - p->put_csr(csr, old | RS1);
    - "}"
    - WRITE_RD(sext_xlen(old));
    - serialize();
  csrrsi:
    opcode:
    - csrrsi
    - rd
    - csr
    - zimm
    - 14..12=6
    - 6..2=0x1C
    - 1..0=3
    opcode_group: zicsr
    opcode_args: *20
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/csr.html"
    main_desc: csr
    main_id: "#csr-instructions"
    desc:
      csr:
        "#csr-instructions":
          text:
          - The CSRRWI, CSRRSI, and CSRRCI variants are similar to CSRRW, CSRRS, and
            CSRRC respectively, except they update the CSR using an XLEN-bit value
            obtained by zero-extending a 5-bit unsigned immediate (uimm[4:0]) field
            encoded in the rs1 field instead of a value from an integer register.
            For CSRRSI and CSRRCI, if the uimm[4:0] field is zero, then these instructions
            will not write to the CSR, and shall not cause any of the side effects
            that might otherwise occur on a CSR write, nor raise illegal instruction
            exceptions on accesses to read-only CSRs. For CSRRWI, if rd=x0, then the
            instruction shall not read the CSR and shall not cause any of the side
            effects that might occur on a CSR read. Both CSRRSI and CSRRCI will always
            read the CSR and cause any read side effects regardless of rd and rs1
            fields.
      rvwmo:
        "#sec:memorymodel:dependencies":
          text:
          - i is a CSR instruction, and in the opcode of i, csr is set to r, unless
            i is CSRRS or CSRRC and rs1 is set to x0 or i is CSRRSI or CSRRCI and
            uimm[4:0] is set to zero.
    iss_code:
    - bool write = insn.rs1() != 0;
    - int csr = validate_csr(insn.csr(), write);
    - reg_t old = p->get_csr(csr, insn, write);
    - if (write) {
    - p->put_csr(csr, old | insn.rs1());
    - "}"
    - WRITE_RD(sext_xlen(old));
    - serialize();
  csrrw:
    opcode:
    - csrrw
    - rd
    - rs1
    - csr
    - 14..12=1
    - 6..2=0x1C
    - 1..0=3
    opcode_group: zicsr
    opcode_args: *3
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/csr.html"
    main_desc: csr
    main_id: "#csr-instructions"
    desc:
      csr:
        "#csr-instructions":
          text:
          - The CSRRW (Atomic Read/Write CSR) instruction atomically swaps values
            in the CSRs and integer registers. CSRRW reads the old value of the CSR,
            zero-extends the value to XLEN bits, then writes it to integer register
            rd. The initial value in rs1 is written to the CSR. If rd=x0, then the
            instruction shall not read the CSR and shall not cause any of the side
            effects that might occur on a CSR read.
          - For both CSRRS and CSRRC, if rs1=x0, then the instruction will not write
            to the CSR at all, and so shall not cause any of the side effects that
            might otherwise occur on a CSR write, nor raise illegal instruction exceptions
            on accesses to read-only CSRs. Both CSRRS and CSRRC always read the addressed
            CSR and cause any read side effects regardless of rs1 and rd fields. Note
            that if rs1 specifies a register holding a zero value other than x0, the
            instruction will still attempt to write the unmodified value back to the
            CSR and will cause any attendant side effects. A CSRRW with rs1=x0 will
            attempt to write zero to the destination CSR.
          - The CSRRWI, CSRRSI, and CSRRCI variants are similar to CSRRW, CSRRS, and
            CSRRC respectively, except they update the CSR using an XLEN-bit value
            obtained by zero-extending a 5-bit unsigned immediate (uimm[4:0]) field
            encoded in the rs1 field instead of a value from an integer register.
            For CSRRSI and CSRRCI, if the uimm[4:0] field is zero, then these instructions
            will not write to the CSR, and shall not cause any of the side effects
            that might otherwise occur on a CSR write, nor raise illegal instruction
            exceptions on accesses to read-only CSRs. For CSRRWI, if rd=x0, then the
            instruction shall not read the CSR and shall not cause any of the side
            effects that might occur on a CSR read. Both CSRRSI and CSRRCI will always
            read the CSR and cause any read side effects regardless of rd and rs1
            fields.
          - The assembler pseudoinstruction to read a CSR, CSRR rd, csr, is encoded
            as CSRRS rd, csr, x0. The assembler pseudoinstruction to write a CSR,
            CSRW csr, rs1, is encoded as CSRRW x0, csr, rs1, while CSRWI csr, uimm,
            is encoded as CSRRWI x0, csr, uimm.
      rvwmo:
        "#sec:memorymodel:dependencies":
          text:
          - i is a CSR instruction, and in the opcode of i, csr is set to r, unless
            i is CSRRW or CSRRWI and rd is set to x0
    iss_code:
    - int csr = validate_csr(insn.csr(), true);
    - reg_t old = p->get_csr(csr, insn, true);
    - p->put_csr(csr, RS1);
    - WRITE_RD(sext_xlen(old));
    - serialize();
  csrrwi:
    opcode:
    - csrrwi
    - rd
    - csr
    - zimm
    - 14..12=5
    - 6..2=0x1C
    - 1..0=3
    opcode_group: zicsr
    opcode_args: *20
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/csr.html"
    main_desc: csr
    main_id: "#csr-instructions"
    desc:
      csr:
        "#csr-instructions":
          text:
          - The CSRRWI, CSRRSI, and CSRRCI variants are similar to CSRRW, CSRRS, and
            CSRRC respectively, except they update the CSR using an XLEN-bit value
            obtained by zero-extending a 5-bit unsigned immediate (uimm[4:0]) field
            encoded in the rs1 field instead of a value from an integer register.
            For CSRRSI and CSRRCI, if the uimm[4:0] field is zero, then these instructions
            will not write to the CSR, and shall not cause any of the side effects
            that might otherwise occur on a CSR write, nor raise illegal instruction
            exceptions on accesses to read-only CSRs. For CSRRWI, if rd=x0, then the
            instruction shall not read the CSR and shall not cause any of the side
            effects that might occur on a CSR read. Both CSRRSI and CSRRCI will always
            read the CSR and cause any read side effects regardless of rd and rs1
            fields.
          - The assembler pseudoinstruction to read a CSR, CSRR rd, csr, is encoded
            as CSRRS rd, csr, x0. The assembler pseudoinstruction to write a CSR,
            CSRW csr, rs1, is encoded as CSRRW x0, csr, rs1, while CSRWI csr, uimm,
            is encoded as CSRRWI x0, csr, uimm.
      rvwmo:
        "#sec:memorymodel:dependencies":
          text:
          - i is a CSR instruction, and in the opcode of i, csr is set to r, unless
            i is CSRRW or CSRRWI and rd is set to x0
    iss_code:
    - int csr = validate_csr(insn.csr(), true);
    - reg_t old = p->get_csr(csr, insn, true);
    - p->put_csr(csr, insn.rs1());
    - WRITE_RD(sext_xlen(old));
    - serialize();
  csrs:
    opcode:
    - csrs
    - csr
    - rs
    opcode_group: psuedo
    opcode_args:
    - csr
    - rs
    psuedo_to_base:
    - csrrs x0, csr, rs
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/csr.html"
    main_desc: csr
    main_id: "#csr-instructions"
    desc:
      csr:
        "#csr-instructions":
          text:
          - 'Further assembler pseudoinstructions are defined to set and clear bits
            in the CSR when the old value is not required: CSRS/CSRC csr, rs1; CSRSI/CSRCI
            csr, uimm.'
  csrsi:
    opcode:
    - csrsi
    - csr
    - imm
    opcode_group: psuedo
    opcode_args:
    - csr
    - imm
    psuedo_to_base:
    - csrrsi x0, csr, imm
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/csr.html"
    main_desc: csr
    main_id: "#csr-instructions"
    desc:
      csr:
        "#csr-instructions":
          text:
          - 'Further assembler pseudoinstructions are defined to set and clear bits
            in the CSR when the old value is not required: CSRS/CSRC csr, rs1; CSRSI/CSRCI
            csr, uimm.'
  csrw:
    opcode:
    - csrw
    - csr
    - rs
    opcode_group: psuedo
    opcode_args:
    - csr
    - rs
    psuedo_to_base:
    - csrrw x0, csr, rs
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/csr.html"
    main_desc: csr
    main_id: "#csr-instructions"
    desc:
      csr:
        "#csr-instructions":
          text:
          - The assembler pseudoinstruction to read a CSR, CSRR rd, csr, is encoded
            as CSRRS rd, csr, x0. The assembler pseudoinstruction to write a CSR,
            CSRW csr, rs1, is encoded as CSRRW x0, csr, rs1, while CSRWI csr, uimm,
            is encoded as CSRRWI x0, csr, uimm.
  csrwi:
    opcode:
    - csrwi
    - csr
    - imm
    opcode_group: psuedo
    opcode_args:
    - csr
    - imm
    psuedo_to_base:
    - csrrwi x0, csr, imm
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/csr.html"
    main_desc: csr
    main_id: "#csr-instructions"
    desc:
      csr:
        "#csr-instructions":
          text:
          - The assembler pseudoinstruction to read a CSR, CSRR rd, csr, is encoded
            as CSRRS rd, csr, x0. The assembler pseudoinstruction to write a CSR,
            CSRW csr, rs1, is encoded as CSRRW x0, csr, rs1, while CSRWI csr, uimm,
            is encoded as CSRRWI x0, csr, uimm.
  ctz:
    opcode:
    - ctz
    - rd
    - rs1
    - 31..20=0x601
    - 14..12=1
    - 6..2=0x04
    - 1..0=3
    opcode_group: zbb
    opcode_args: *3
    iss_code:
    - require_extension(EXT_ZBB);
    - reg_t x = xlen;
    - for (int i = 0; i < xlen; i++)
    - if (1 & (RS1 >> i)) { x = i; break; }
    - WRITE_RD(sext_xlen(x));
  ctzw:
    opcode:
    - ctzw
    - rd
    - rs1
    - 31..20=0x601
    - 14..12=1
    - 6..2=0x06
    - 1..0=3
    opcode_group: zbb
    opcode_args: *3
    iss_code:
    - require_rv64;
    - require_extension(EXT_ZBB);
    - reg_t x = 32;
    - for (int i = 0; i < 32; i++)
    - if (1 & (RS1 >> i)) { x = i; break; }
    - WRITE_RD(sext32(x));
  div:
    opcode:
    - div
    - rd
    - rs1
    - rs2
    - 31..25=1
    - 14..12=4
    - 6..2=0x0C
    - 1..0=3
    opcode_group: m
    opcode_args: *1
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/m.html"
    main_desc: m
    main_id: "#division-operations"
    desc:
      m:
        "#division-operations":
          text:
          - DIV and DIVU perform an XLEN bits by XLEN bits signed and unsigned integer
            division of rs1 by rs2, rounding towards zero. REM and REMU provide the
            remainder of the corresponding division operation. For REM, the sign of
            the result equals the sign of the dividend.
          - 'If both the quotient and remainder are required from the same division,
            the recommended code sequence is: DIV[U] rdq, rs1, rs2; REM[U] rdr, rs1,
            rs2 (rdq cannot be the same as rs1 or rs2). Microarchitectures can then
            fuse these into a single divide operation instead of performing two separate
            divides.'
          - DIV[W]
    iss_code:
    - require_extension('M');
    - sreg_t lhs = sext_xlen(RS1);
    - sreg_t rhs = sext_xlen(RS2);
    - if (rhs == 0)
    - WRITE_RD(UINT64_MAX);
    - else if (lhs == INT64_MIN && rhs == -1)
    - WRITE_RD(lhs);
    - else
    - WRITE_RD(sext_xlen(lhs / rhs));
  divu:
    opcode:
    - divu
    - rd
    - rs1
    - rs2
    - 31..25=1
    - 14..12=5
    - 6..2=0x0C
    - 1..0=3
    opcode_group: m
    opcode_args: *1
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/m.html"
    main_desc: m
    main_id: "#division-operations"
    desc:
      m:
        "#division-operations":
          text:
          - DIV and DIVU perform an XLEN bits by XLEN bits signed and unsigned integer
            division of rs1 by rs2, rounding towards zero. REM and REMU provide the
            remainder of the corresponding division operation. For REM, the sign of
            the result equals the sign of the dividend.
          - DIVU[W]
    iss_code:
    - require_extension('M');
    - reg_t lhs = zext_xlen(RS1);
    - reg_t rhs = zext_xlen(RS2);
    - if (rhs == 0)
    - WRITE_RD(UINT64_MAX);
    - else
    - WRITE_RD(sext_xlen(lhs / rhs));
  divuw:
    opcode:
    - divuw
    - rd
    - rs1
    - rs2
    - 31..25=1
    - 14..12=5
    - 6..2=0x0E
    - 1..0=3
    opcode_group: m
    opcode_args: *1
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/m.html"
    main_desc: m
    main_id: "#division-operations"
    desc:
      m:
        "#division-operations":
          text:
          - DIVW and DIVUW are RV64 instructions that divide the lower 32 bits of
            rs1 by the lower 32 bits of rs2, treating them as signed and unsigned
            integers respectively, placing the 32-bit quotient in rd, sign-extended
            to 64 bits. REMW and REMUW are RV64 instructions that provide the corresponding
            signed and unsigned remainder operations respectively. Both REMW and REMUW
            always sign-extend the 32-bit result to 64 bits, including on a divide
            by zero.
    iss_code:
    - require_extension('M');
    - require_rv64;
    - reg_t lhs = zext32(RS1);
    - reg_t rhs = zext32(RS2);
    - if (rhs == 0)
    - WRITE_RD(UINT64_MAX);
    - else
    - WRITE_RD(sext32(lhs / rhs));
  divw:
    opcode:
    - divw
    - rd
    - rs1
    - rs2
    - 31..25=1
    - 14..12=4
    - 6..2=0x0E
    - 1..0=3
    opcode_group: m
    opcode_args: *1
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/m.html"
    main_desc: m
    main_id: "#division-operations"
    desc:
      m:
        "#division-operations":
          text:
          - DIVW and DIVUW are RV64 instructions that divide the lower 32 bits of
            rs1 by the lower 32 bits of rs2, treating them as signed and unsigned
            integers respectively, placing the 32-bit quotient in rd, sign-extended
            to 64 bits. REMW and REMUW are RV64 instructions that provide the corresponding
            signed and unsigned remainder operations respectively. Both REMW and REMUW
            always sign-extend the 32-bit result to 64 bits, including on a divide
            by zero.
    iss_code:
    - require_extension('M');
    - require_rv64;
    - sreg_t lhs = sext32(RS1);
    - sreg_t rhs = sext32(RS2);
    - if (rhs == 0)
    - WRITE_RD(UINT64_MAX);
    - else
    - WRITE_RD(sext32(lhs / rhs));
  dret:
    opcode:
    - dret
    - 11..7=0
    - 19..15=0
    - 31..20=0x7b2
    - 14..12=0
    - 6..2=0x1C
    - 1..0=3
    opcode_group: sdext
    opcode_args: *18
    iss_code:
    - require(STATE.debug_mode);
    - set_pc_and_serialize(STATE.dpc->read());
    - p->set_privilege(STATE.dcsr->prv, STATE.dcsr->v);
    - if (STATE.prv < PRV_M)
    - STATE.mstatus->write(STATE.mstatus->read() & ~MSTATUS_MPRV);
    - ''
    - "/* We're not in Debug Mode anymore. */"
    - STATE.debug_mode = false;
    - ''
    - if (STATE.dcsr->step)
    - STATE.single_step = STATE.STEP_STEPPING;
  ebreak:
    opcode:
    - ebreak
    - 31..20=0x001
    - 19..7=0
    - 6..2=0x1C
    - 1..0=3
    opcode_group: i
    opcode_args: *18
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/rv32.html"
    main_desc: rv32
    main_id: "#rv32"
    desc:
      rv32:
        "#rv32":
          text:
          - RV32I was designed to be sufficient to form a compiler target and to support
            modern operating system environments. The ISA was also designed to reduce
            the hardware required in a minimal implementation. RV32I contains 40 unique
            instructions, though a simple implementation might cover the ECALL/EBREAK
            instructions with a single SYSTEM hardware instruction that always traps
            and might be able to implement the FENCE instruction as a NOP, reducing
            base instruction count to 38 total. RV32I can emulate almost any other
            ISA extension (except the A extension, which requires additional hardware
            support for atomicity).
        "#environment-call-and-breakpoints":
          text:
          - The EBREAK instruction is used to return control to a debugging environment.
          - ECALL and EBREAK were previously named SCALL and SBREAK. The instructions
            have the same functionality and encoding, but were renamed to reflect
            that they can be used more generally than to call a supervisor-level operating
            system or debugger.
          - EBREAK was primarily designed to be used by a debugger to cause execution
            to stop and fall back into the debugger. EBREAK is also used by the standard
            gcc compiler to mark code paths that should not be executed.
          - Another use of EBREAK is to support "semihosting", where the execution
            environment includes a debugger that can provide services over an alternate
            system call interface built around the EBREAK instruction. Because the
            RISC-V base ISAs do not provide more than one EBREAK instruction, RISC-V
            semihosting uses a special sequence of instructions to distinguish a semihosting
            EBREAK from a debugger inserted EBREAK.
      counters:
        "#zicntr-standard-extension-for-base-counters-and-timers":
          text:
          - Instructions that cause synchronous exceptions, including ECALL and EBREAK,
            are not considered to retire and hence do not increment the instret CSR.
      machine:
        "#sec:mcause":
          text:
          - Instruction address breakpoints have the same cause value as, but different
            priority than, data address breakpoints (a.k.a. watchpoints) and environment
            break exceptions (which are raised by the EBREAK instruction).
        "#environment-call-and-breakpoint":
          text:
          - The EBREAK instruction is used by debuggers to cause control to be transferred
            back to a debugging environment. It generates a breakpoint exception and
            performs no other operation.
          - As described in the "C" Standard Extension for Compressed Instructions
            in Volume I of this manual, the C.EBREAK instruction performs the same
            operation as the EBREAK instruction.
          - ECALL and EBREAK cause the receiving privilege mode's epc register to
            be set to the address of the ECALL or EBREAK instruction itself, not the
            address of the following instruction. As ECALL and EBREAK cause synchronous
            exceptions, they are not considered to retire, and should not increment
            the minstret CSR.
    iss_code:
    - if (!STATE.debug_mode && (
    - "(!STATE.v && STATE.prv == PRV_M && STATE.dcsr->ebreakm) ||"
    - "(!STATE.v && STATE.prv == PRV_S && STATE.dcsr->ebreaks) ||"
    - "(!STATE.v && STATE.prv == PRV_U && STATE.dcsr->ebreaku) ||"
    - "(STATE.v && STATE.prv == PRV_S && STATE.dcsr->ebreakvs) ||"
    - "(STATE.v && STATE.prv == PRV_U && STATE.dcsr->ebreakvu))) {"
    - throw trap_debug_mode();
    - "} else {"
    - throw trap_breakpoint(STATE.v, pc);
    - "}"
  ecall:
    opcode:
    - ecall
    - 31..20=0x000
    - 19..7=0
    - 6..2=0x1C
    - 1..0=3
    opcode_group: i
    opcode_args: *18
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/rv32.html"
    main_desc: rv32
    main_id: "#rv32"
    desc:
      rv32:
        "#rv32":
          text:
          - RV32I was designed to be sufficient to form a compiler target and to support
            modern operating system environments. The ISA was also designed to reduce
            the hardware required in a minimal implementation. RV32I contains 40 unique
            instructions, though a simple implementation might cover the ECALL/EBREAK
            instructions with a single SYSTEM hardware instruction that always traps
            and might be able to implement the FENCE instruction as a NOP, reducing
            base instruction count to 38 total. RV32I can emulate almost any other
            ISA extension (except the A extension, which requires additional hardware
            support for atomicity).
        "#environment-call-and-breakpoints":
          text:
          - The ECALL instruction is used to make a service request to the execution
            environment. The EEI will define how parameters for the service request
            are passed, but usually these will be in defined locations in the integer
            register file.
          - ECALL and EBREAK were previously named SCALL and SBREAK. The instructions
            have the same functionality and encoding, but were renamed to reflect
            that they can be used more generally than to call a supervisor-level operating
            system or debugger.
          - Semihosting is a form of service call and would be more naturally encoded
            as an ECALL using an existing ABI, but this would require the debugger
            to be able to intercept ECALLs, which is a newer addition to the debug
            standard. We intend to move over to using ECALLs with a standard ABI,
            in which case, semihosting can share a service ABI with an existing standard.
      counters:
        "#zicntr-standard-extension-for-base-counters-and-timers":
          text:
          - Instructions that cause synchronous exceptions, including ECALL and EBREAK,
            are not considered to retire and hence do not increment the instret CSR.
      machine:
        "#environment-call-and-breakpoint":
          text:
          - The ECALL instruction is used to make a request to the supporting execution
            environment. When executed in U-mode, S-mode, or M-mode, it generates
            an environment-call-from-U-mode exception, environment-call-from-S-mode
            exception, or environment-call-from-M-mode exception, respectively, and
            performs no other operation.
          - ECALL generates a different exception for each originating privilege mode
            so that environment call exceptions can be selectively delegated. A typical
            use case for Unix-like operating systems is to delegate to S-mode the
            environment-call-from-U-mode exception but not the others.
          - ECALL and EBREAK cause the receiving privilege mode's epc register to
            be set to the address of the ECALL or EBREAK instruction itself, not the
            address of the following instruction. As ECALL and EBREAK cause synchronous
            exceptions, they are not considered to retire, and should not increment
            the minstret CSR.
    iss_code:
    - switch (STATE.prv)
    - "{"
    - 'case PRV_U: throw trap_user_ecall();'
    - 'case PRV_S:'
    - if (STATE.v)
    - throw trap_virtual_supervisor_ecall();
    - else
    - throw trap_supervisor_ecall();
    - 'case PRV_M: throw trap_machine_ecall();'
    - 'default: abort();'
    - "}"
  fabs.d:
    opcode:
    - fabs.d
    - rd
    - rs
    opcode_group: psuedo
    opcode_args:
    - rd
    - rs
    psuedo_to_base:
    - fsgnjx.d rd, rs, rs
    main_desc: d
    main_id: "#single-precision-floating-point-conversion-and-move-instructions"
    desc:
      d:
        "#single-precision-floating-point-conversion-and-move-instructions":
          text:
          - Floating-point to floating-point sign-injection instructions, FSGNJ.S,
            FSGNJN.S, and FSGNJX.S, produce a result that takes all bits except the
            sign bit from rs1. For FSGNJ, the result's sign bit is rs2's sign bit;
            for FSGNJN, the result's sign bit is the opposite of rs2's sign bit; and
            for FSGNJX, the sign bit is the XOR of the sign bits of rs1 and rs2. Sign-injection
            instructions do not set floating-point exception flags, nor do they canonicalize
            NaNs. Note, FSGNJ.S rx, ry, ry moves ry to rx (assembler pseudoinstruction
            FMV.S rx, ry); FSGNJN.S rx, ry, ry moves the negation of ry to rx (assembler
            pseudoinstruction FNEG.S rx, ry); and FSGNJX.S rx, ry, ry moves the absolute
            value of ry to rx (assembler pseudoinstruction FABS.S rx, ry).
  fabs.s:
    opcode:
    - fabs.s
    - rd
    - rs
    opcode_group: psuedo
    opcode_args:
    - rd
    - rs
    psuedo_to_base:
    - fsgnjx.s rd, rs, rs
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/f.html"
    main_desc: f
    main_id: "#single-precision-floating-point-conversion-and-move-instructions"
    desc:
      f:
        "#single-precision-floating-point-conversion-and-move-instructions":
          text:
          - Floating-point to floating-point sign-injection instructions, FSGNJ.S,
            FSGNJN.S, and FSGNJX.S, produce a result that takes all bits except the
            sign bit from rs1. For FSGNJ, the result's sign bit is rs2's sign bit;
            for FSGNJN, the result's sign bit is the opposite of rs2's sign bit; and
            for FSGNJX, the sign bit is the XOR of the sign bits of rs1 and rs2. Sign-injection
            instructions do not set floating-point exception flags, nor do they canonicalize
            NaNs. Note, FSGNJ.S rx, ry, ry moves ry to rx (assembler pseudoinstruction
            FMV.S rx, ry); FSGNJN.S rx, ry, ry moves the negation of ry to rx (assembler
            pseudoinstruction FNEG.S rx, ry); and FSGNJX.S rx, ry, ry moves the absolute
            value of ry to rx (assembler pseudoinstruction FABS.S rx, ry).
  fadd.d:
    opcode:
    - fadd.d
    - rd
    - rs1
    - rs2
    - 31..27=0x00
    - rm
    - 26..25=1
    - 6..2=0x14
    - 1..0=3
    opcode_group: d
    opcode_args: *1
    main_desc: d
    main_id: "#sec:single-float-compute"
    desc:
      d:
        "#sec:single-float-compute":
          text:
          - Floating-point arithmetic instructions with one or two source operands
            use the R-type format with the OP-FP major opcode. FADD.S and FMUL.S perform
            single-precision floating-point addition and multiplication respectively,
            between rs1 and rs2. FSUB.S performs the single-precision floating-point
            subtraction of rs2 from rs1. FDIV.S performs the single-precision floating-point
            division of rs1 by rs2. FSQRT.S computes the square root of rs1. In each
            case, the result is written to rd.
    iss_code:
    - require_either_extension('D', EXT_ZDINX);
    - require_fp;
    - softfloat_roundingMode = RM;
    - WRITE_FRD_D(f64_add(FRS1_D, FRS2_D));
    - set_fp_exceptions;
  fadd.h:
    opcode:
    - fadd.h
    - rd
    - rs1
    - rs2
    - 31..27=0x00
    - rm
    - 26..25=2
    - 6..2=0x14
    - 1..0=3
    opcode_group: zfh
    opcode_args: *1
    iss_code:
    - require_either_extension(EXT_ZFH, EXT_ZHINX);
    - require_fp;
    - softfloat_roundingMode = RM;
    - WRITE_FRD_H(f16_add(FRS1_H, FRS2_H));
    - set_fp_exceptions;
  fadd.q:
    opcode:
    - fadd.q
    - rd
    - rs1
    - rs2
    - 31..27=0x00
    - rm
    - 26..25=3
    - 6..2=0x14
    - 1..0=3
    opcode_group: q
    opcode_args: *1
    main_desc: q
    main_id: "#sec:single-float-compute"
    desc:
      q:
        "#sec:single-float-compute":
          text:
          - Floating-point arithmetic instructions with one or two source operands
            use the R-type format with the OP-FP major opcode. FADD.S and FMUL.S perform
            single-precision floating-point addition and multiplication respectively,
            between rs1 and rs2. FSUB.S performs the single-precision floating-point
            subtraction of rs2 from rs1. FDIV.S performs the single-precision floating-point
            division of rs1 by rs2. FSQRT.S computes the square root of rs1. In each
            case, the result is written to rd.
    iss_code:
    - require_extension('Q');
    - require_fp;
    - softfloat_roundingMode = RM;
    - WRITE_FRD(f128_add(f128(FRS1), f128(FRS2)));
    - set_fp_exceptions;
  fadd.s:
    opcode:
    - fadd.s
    - rd
    - rs1
    - rs2
    - 31..27=0x00
    - rm
    - 26..25=0
    - 6..2=0x14
    - 1..0=3
    opcode_group: f
    opcode_args: *1
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/f.html"
    main_desc: f
    main_id: "#sec:single-float-compute"
    desc:
      f:
        "#sec:single-float-compute":
          text:
          - Floating-point arithmetic instructions with one or two source operands
            use the R-type format with the OP-FP major opcode. FADD.S and FMUL.S perform
            single-precision floating-point addition and multiplication respectively,
            between rs1 and rs2. FSUB.S performs the single-precision floating-point
            subtraction of rs2 from rs1. FDIV.S performs the single-precision floating-point
            division of rs1 by rs2. FSQRT.S computes the square root of rs1. In each
            case, the result is written to rd.
    iss_code:
    - require_either_extension('F', EXT_ZFINX);
    - require_fp;
    - softfloat_roundingMode = RM;
    - WRITE_FRD_F(f32_add(FRS1_F, FRS2_F));
    - set_fp_exceptions;
  fclass.d:
    opcode:
    - fclass.d
    - rd
    - rs1
    - 24..20=0
    - 31..27=0x1C
    - 14..12=1
    - 26..25=1
    - 6..2=0x14
    - 1..0=3
    opcode_group: d
    opcode_args: *3
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/d.html"
    main_desc: d
    main_id: "#double-precision-floating-point-classify-instruction"
    desc:
      d:
        "#double-precision-floating-point-classify-instruction":
          text:
          - The double-precision floating-point classify instruction, FCLASS.D, is
            defined analogously to its single-precision counterpart, but operates
            on double-precision operands.
    iss_code:
    - require_either_extension('D', EXT_ZDINX);
    - require_fp;
    - WRITE_RD(f64_classify(FRS1_D));
  fclass.h:
    opcode:
    - fclass.h
    - rd
    - rs1
    - 24..20=0
    - 31..27=0x1C
    - 14..12=1
    - 26..25=2
    - 6..2=0x14
    - 1..0=3
    opcode_group: zfh
    opcode_args: *3
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/zfh.html"
    main_desc: zfh
    main_id: "#half-precision-floating-point-classify-instruction"
    desc:
      zfh:
        "#half-precision-floating-point-classify-instruction":
          text:
          - The half-precision floating-point classify instruction, FCLASS.H, is defined
            analogously to its single-precision counterpart, but operates on half-precision
            operands.
    iss_code:
    - require_either_extension(EXT_ZFH, EXT_ZHINX);
    - require_fp;
    - WRITE_RD(f16_classify(FRS1_H));
  fclass.q:
    opcode:
    - fclass.q
    - rd
    - rs1
    - 24..20=0
    - 31..27=0x1C
    - 14..12=1
    - 26..25=3
    - 6..2=0x14
    - 1..0=3
    opcode_group: q
    opcode_args: *3
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/q.html"
    main_desc: q
    main_id: "#quad-precision-floating-point-classify-instruction"
    desc:
      q:
        "#quad-precision-floating-point-classify-instruction":
          text:
          - The quad-precision floating-point classify instruction, FCLASS.Q, is defined
            analogously to its double-precision counterpart, but operates on quad-precision
            operands.
    iss_code:
    - require_extension('Q');
    - require_fp;
    - WRITE_RD(f128_classify(f128(FRS1)));
  fclass.s:
    opcode:
    - fclass.s
    - rd
    - rs1
    - 24..20=0
    - 31..27=0x1C
    - 14..12=1
    - 26..25=0
    - 6..2=0x14
    - 1..0=3
    opcode_group: f
    opcode_args: *3
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/f.html"
    main_desc: f
    main_id: "#single-precision-floating-point-classify-instruction"
    desc:
      f:
        "#single-precision-floating-point-classify-instruction":
          text:
          - The FCLASS.S instruction examines the value in floating-point register
            rs1 and writes to integer register rd a 10-bit mask that indicates the
            class of the floating-point number. The format of the mask is described
            in Table [tab:fclass] . The corresponding bit in rd will be set if the
            property is true and clear otherwise. All other bits in rd are cleared.
            Note that exactly one bit in rd will be set. FCLASS.S does not set the
            floating-point exception flags.
    iss_code:
    - require_either_extension('F', EXT_ZFINX);
    - require_fp;
    - WRITE_RD(f32_classify(FRS1_F));
  fcvt.d.h:
    opcode:
    - fcvt.d.h
    - rd
    - rs1
    - 24..20=2
    - 31..27=0x08
    - rm
    - 26..25=1
    - 6..2=0x14
    - 1..0=3
    opcode_group: d_zfh
    opcode_args: *3
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/zfh.html"
    main_desc: zfh
    main_id: "#half-precision-convert-and-move-instructions"
    desc:
      zfh:
        "#half-precision-convert-and-move-instructions":
          text:
          - New floating-point-to-floating-point conversion instructions are added.
            These instructions are defined analogously to the double-precision floating-point-to-floating-point
            conversion instructions. FCVT.S.H or FCVT.H.S converts a half-precision
            floating-point number to a single-precision floating-point number, or
            vice-versa, respectively. If the D extension is present, FCVT.D.H or FCVT.H.D
            converts a half-precision floating-point number to a double-precision
            floating-point number, or vice-versa, respectively. If the Q extension
            is present, FCVT.Q.H or FCVT.H.Q converts a half-precision floating-point
            number to a quad-precision floating-point number, or vice-versa, respectively.
        "#zfhmin-standard-extension-for-minimal-half-precision-floating-point-support":
          text:
          - 'The Zfhmin extension includes the following instructions from the Zfh
            extension: FLH, FSH, FMV.X.H, FMV.H.X, FCVT.S.H, and FCVT.H.S. If the
            D extension is present, the FCVT.D.H and FCVT.H.D instructions are also
            included. If the Q extension is present, the FCVT.Q.H and FCVT.H.Q instructions
            are additionally included.'
      zfinx:
        "#zhinxmin":
          text:
          - 'The Zhinxmin extension includes the following instructions from the Zhinx
            extension: FCVT.S.H and FCVT.H.S. If the Zdinx extension is present, the
            FCVT.D.H and FCVT.H.D instructions are also included.'
  fcvt.d.l:
    opcode:
    - fcvt.d.l
    - rd
    - rs1
    - 24..20=2
    - 31..27=0x1A
    - rm
    - 26..25=1
    - 6..2=0x14
    - 1..0=3
    opcode_group: d
    opcode_args: *3
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/d.html"
    main_desc: d
    main_id: "#double-precision-floating-point-conversion-and-move-instructions"
    desc:
      d:
        "#double-precision-floating-point-conversion-and-move-instructions":
          text:
          - Floating-point-to-integer and integer-to-floating-point conversion instructions
            are encoded in the OP-FP major opcode space. FCVT.W.D or FCVT.L.D converts
            a double-precision floating-point number in floating-point register rs1
            to a signed 32-bit or 64-bit integer, respectively, in integer register
            rd. FCVT.D.W or FCVT.D.L converts a 32-bit or 64-bit signed integer, respectively,
            in integer register rs1 into a double-precision floating-point number
            in floating-point register rd. FCVT.WU.D, FCVT.LU.D, FCVT.D.WU, and FCVT.D.LU
            variants convert to or from unsigned integer values. For RV64, FCVT.W[U].D
            sign-extends the 32-bit result. FCVT.L[U].D and FCVT.D.L[U] are RV64-only
            instructions. The range of valid inputs for FCVT.int.D and the behavior
            for invalid inputs are the same as for FCVT.int.S.
  fcvt.d.lu:
    opcode:
    - fcvt.d.lu
    - rd
    - rs1
    - 24..20=3
    - 31..27=0x1A
    - rm
    - 26..25=1
    - 6..2=0x14
    - 1..0=3
    opcode_group: d
    opcode_args: *3
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/d.html"
    main_desc: d
    main_id: "#double-precision-floating-point-conversion-and-move-instructions"
    desc:
      d:
        "#double-precision-floating-point-conversion-and-move-instructions":
          text:
          - Floating-point-to-integer and integer-to-floating-point conversion instructions
            are encoded in the OP-FP major opcode space. FCVT.W.D or FCVT.L.D converts
            a double-precision floating-point number in floating-point register rs1
            to a signed 32-bit or 64-bit integer, respectively, in integer register
            rd. FCVT.D.W or FCVT.D.L converts a 32-bit or 64-bit signed integer, respectively,
            in integer register rs1 into a double-precision floating-point number
            in floating-point register rd. FCVT.WU.D, FCVT.LU.D, FCVT.D.WU, and FCVT.D.LU
            variants convert to or from unsigned integer values. For RV64, FCVT.W[U].D
            sign-extends the 32-bit result. FCVT.L[U].D and FCVT.D.L[U] are RV64-only
            instructions. The range of valid inputs for FCVT.int.D and the behavior
            for invalid inputs are the same as for FCVT.int.S.
  fcvt.d.q:
    opcode:
    - fcvt.d.q
    - rd
    - rs1
    - 24..20=3
    - 31..27=0x08
    - rm
    - 26..25=1
    - 6..2=0x14
    - 1..0=3
    opcode_group: q
    opcode_args: *3
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/q.html"
    main_desc: q
    main_id: "#quad-precision-convert-and-move-instructions"
    desc:
      q:
        "#quad-precision-convert-and-move-instructions":
          text:
          - New floating-point-to-floating-point conversion instructions are added.
            These instructions are defined analogously to the double-precision floating-point-to-floating-point
            conversion instructions. FCVT.S.Q or FCVT.Q.S converts a quad-precision
            floating-point number to a single-precision floating-point number, or
            vice-versa, respectively. FCVT.D.Q or FCVT.Q.D converts a quad-precision
            floating-point number to a double-precision floating-point number, or
            vice-versa, respectively.
  fcvt.d.s:
    opcode:
    - fcvt.d.s
    - rd
    - rs1
    - 24..20=0
    - 31..27=0x08
    - rm
    - 26..25=1
    - 6..2=0x14
    - 1..0=3
    opcode_group: d
    opcode_args: *3
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/d.html"
    main_desc: d
    main_id: "#double-precision-floating-point-conversion-and-move-instructions"
    desc:
      d:
        "#double-precision-floating-point-conversion-and-move-instructions":
          text:
          - The double-precision to single-precision and single-precision to double-precision
            conversion instructions, FCVT.S.D and FCVT.D.S, are encoded in the OP-FP
            major opcode space and both the source and destination are floating-point
            registers. The rs2 field encodes the datatype of the source, and the fmt
            field encodes the datatype of the destination. FCVT.S.D rounds according
            to the RM field; FCVT.D.S will never round.
  fcvt.d.w:
    opcode:
    - fcvt.d.w
    - rd
    - rs1
    - 24..20=0
    - 31..27=0x1A
    - rm
    - 26..25=1
    - 6..2=0x14
    - 1..0=3
    opcode_group: d
    opcode_args: *3
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/d.html"
    main_desc: d
    main_id: "#double-precision-floating-point-conversion-and-move-instructions"
    desc:
      d:
        "#double-precision-floating-point-conversion-and-move-instructions":
          text:
          - Floating-point-to-integer and integer-to-floating-point conversion instructions
            are encoded in the OP-FP major opcode space. FCVT.W.D or FCVT.L.D converts
            a double-precision floating-point number in floating-point register rs1
            to a signed 32-bit or 64-bit integer, respectively, in integer register
            rd. FCVT.D.W or FCVT.D.L converts a 32-bit or 64-bit signed integer, respectively,
            in integer register rs1 into a double-precision floating-point number
            in floating-point register rd. FCVT.WU.D, FCVT.LU.D, FCVT.D.WU, and FCVT.D.LU
            variants convert to or from unsigned integer values. For RV64, FCVT.W[U].D
            sign-extends the 32-bit result. FCVT.L[U].D and FCVT.D.L[U] are RV64-only
            instructions. The range of valid inputs for FCVT.int.D and the behavior
            for invalid inputs are the same as for FCVT.int.S.
          - All floating-point to integer and integer to floating-point conversion
            instructions round according to the rm field. Note FCVT.D.W[U] always
            produces an exact result and is unaffected by rounding mode.
  fcvt.d.wu:
    opcode:
    - fcvt.d.wu
    - rd
    - rs1
    - 24..20=1
    - 31..27=0x1A
    - rm
    - 26..25=1
    - 6..2=0x14
    - 1..0=3
    opcode_group: d
    opcode_args: *3
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/d.html"
    main_desc: d
    main_id: "#double-precision-floating-point-conversion-and-move-instructions"
    desc:
      d:
        "#double-precision-floating-point-conversion-and-move-instructions":
          text:
          - Floating-point-to-integer and integer-to-floating-point conversion instructions
            are encoded in the OP-FP major opcode space. FCVT.W.D or FCVT.L.D converts
            a double-precision floating-point number in floating-point register rs1
            to a signed 32-bit or 64-bit integer, respectively, in integer register
            rd. FCVT.D.W or FCVT.D.L converts a 32-bit or 64-bit signed integer, respectively,
            in integer register rs1 into a double-precision floating-point number
            in floating-point register rd. FCVT.WU.D, FCVT.LU.D, FCVT.D.WU, and FCVT.D.LU
            variants convert to or from unsigned integer values. For RV64, FCVT.W[U].D
            sign-extends the 32-bit result. FCVT.L[U].D and FCVT.D.L[U] are RV64-only
            instructions. The range of valid inputs for FCVT.int.D and the behavior
            for invalid inputs are the same as for FCVT.int.S.
  fcvt.h.d:
    opcode:
    - fcvt.h.d
    - rd
    - rs1
    - 24..20=1
    - 31..27=0x08
    - rm
    - 26..25=2
    - 6..2=0x14
    - 1..0=3
    opcode_group: d_zfh
    opcode_args: *3
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/zfh.html"
    main_desc: zfh
    main_id: "#half-precision-convert-and-move-instructions"
    desc:
      zfh:
        "#half-precision-convert-and-move-instructions":
          text:
          - New floating-point-to-floating-point conversion instructions are added.
            These instructions are defined analogously to the double-precision floating-point-to-floating-point
            conversion instructions. FCVT.S.H or FCVT.H.S converts a half-precision
            floating-point number to a single-precision floating-point number, or
            vice-versa, respectively. If the D extension is present, FCVT.D.H or FCVT.H.D
            converts a half-precision floating-point number to a double-precision
            floating-point number, or vice-versa, respectively. If the Q extension
            is present, FCVT.Q.H or FCVT.H.Q converts a half-precision floating-point
            number to a quad-precision floating-point number, or vice-versa, respectively.
        "#zfhmin-standard-extension-for-minimal-half-precision-floating-point-support":
          text:
          - 'The Zfhmin extension includes the following instructions from the Zfh
            extension: FLH, FSH, FMV.X.H, FMV.H.X, FCVT.S.H, and FCVT.H.S. If the
            D extension is present, the FCVT.D.H and FCVT.H.D instructions are also
            included. If the Q extension is present, the FCVT.Q.H and FCVT.H.Q instructions
            are additionally included.'
      zfinx:
        "#zhinxmin":
          text:
          - 'The Zhinxmin extension includes the following instructions from the Zhinx
            extension: FCVT.S.H and FCVT.H.S. If the Zdinx extension is present, the
            FCVT.D.H and FCVT.H.D instructions are also included.'
  fcvt.h.l:
    opcode:
    - fcvt.h.l
    - rd
    - rs1
    - 24..20=2
    - 31..27=0x1A
    - rm
    - 26..25=2
    - 6..2=0x14
    - 1..0=3
    opcode_group: zfh
    opcode_args: *3
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/zfh.html"
    main_desc: zfh
    main_id: "#half-precision-convert-and-move-instructions"
    desc:
      zfh:
        "#half-precision-convert-and-move-instructions":
          text:
          - New floating-point-to-integer and integer-to-floating-point conversion
            instructions are added. These instructions are defined analogously to
            the single-precision-to-integer and integer-to-single-precision conversion
            instructions. FCVT.W.H or FCVT.L.H converts a half-precision floating-point
            number to a signed 32-bit or 64-bit integer, respectively. FCVT.H.W or
            FCVT.H.L converts a 32-bit or 64-bit signed integer, respectively, into
            a half-precision floating-point number. FCVT.WU.H, FCVT.LU.H, FCVT.H.WU,
            and FCVT.H.LU variants convert to or from unsigned integer values. FCVT.L[U].H
            and FCVT.H.L[U] are RV64-only instructions.
  fcvt.h.lu:
    opcode:
    - fcvt.h.lu
    - rd
    - rs1
    - 24..20=3
    - 31..27=0x1A
    - rm
    - 26..25=2
    - 6..2=0x14
    - 1..0=3
    opcode_group: zfh
    opcode_args: *3
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/zfh.html"
    main_desc: zfh
    main_id: "#half-precision-convert-and-move-instructions"
    desc:
      zfh:
        "#half-precision-convert-and-move-instructions":
          text:
          - New floating-point-to-integer and integer-to-floating-point conversion
            instructions are added. These instructions are defined analogously to
            the single-precision-to-integer and integer-to-single-precision conversion
            instructions. FCVT.W.H or FCVT.L.H converts a half-precision floating-point
            number to a signed 32-bit or 64-bit integer, respectively. FCVT.H.W or
            FCVT.H.L converts a 32-bit or 64-bit signed integer, respectively, into
            a half-precision floating-point number. FCVT.WU.H, FCVT.LU.H, FCVT.H.WU,
            and FCVT.H.LU variants convert to or from unsigned integer values. FCVT.L[U].H
            and FCVT.H.L[U] are RV64-only instructions.
  fcvt.h.q:
    opcode:
    - fcvt.h.q
    - rd
    - rs1
    - 24..20=3
    - 31..27=0x08
    - rm
    - 26..25=2
    - 6..2=0x14
    - 1..0=3
    opcode_group: q_zfh
    opcode_args: *3
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/zfh.html"
    main_desc: zfh
    main_id: "#half-precision-convert-and-move-instructions"
    desc:
      zfh:
        "#half-precision-convert-and-move-instructions":
          text:
          - New floating-point-to-floating-point conversion instructions are added.
            These instructions are defined analogously to the double-precision floating-point-to-floating-point
            conversion instructions. FCVT.S.H or FCVT.H.S converts a half-precision
            floating-point number to a single-precision floating-point number, or
            vice-versa, respectively. If the D extension is present, FCVT.D.H or FCVT.H.D
            converts a half-precision floating-point number to a double-precision
            floating-point number, or vice-versa, respectively. If the Q extension
            is present, FCVT.Q.H or FCVT.H.Q converts a half-precision floating-point
            number to a quad-precision floating-point number, or vice-versa, respectively.
        "#zfhmin-standard-extension-for-minimal-half-precision-floating-point-support":
          text:
          - 'The Zfhmin extension includes the following instructions from the Zfh
            extension: FLH, FSH, FMV.X.H, FMV.H.X, FCVT.S.H, and FCVT.H.S. If the
            D extension is present, the FCVT.D.H and FCVT.H.D instructions are also
            included. If the Q extension is present, the FCVT.Q.H and FCVT.H.Q instructions
            are additionally included.'
  fcvt.h.s:
    opcode:
    - fcvt.h.s
    - rd
    - rs1
    - 24..20=0
    - 31..27=0x08
    - rm
    - 26..25=2
    - 6..2=0x14
    - 1..0=3
    opcode_group: zfh
    opcode_args: *3
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/zfh.html"
    main_desc: zfh
    main_id: "#half-precision-convert-and-move-instructions"
    desc:
      zfh:
        "#half-precision-convert-and-move-instructions":
          text:
          - New floating-point-to-floating-point conversion instructions are added.
            These instructions are defined analogously to the double-precision floating-point-to-floating-point
            conversion instructions. FCVT.S.H or FCVT.H.S converts a half-precision
            floating-point number to a single-precision floating-point number, or
            vice-versa, respectively. If the D extension is present, FCVT.D.H or FCVT.H.D
            converts a half-precision floating-point number to a double-precision
            floating-point number, or vice-versa, respectively. If the Q extension
            is present, FCVT.Q.H or FCVT.H.Q converts a half-precision floating-point
            number to a quad-precision floating-point number, or vice-versa, respectively.
        "#zfhmin-standard-extension-for-minimal-half-precision-floating-point-support":
          text:
          - 'The Zfhmin extension includes the following instructions from the Zfh
            extension: FLH, FSH, FMV.X.H, FMV.H.X, FCVT.S.H, and FCVT.H.S. If the
            D extension is present, the FCVT.D.H and FCVT.H.D instructions are also
            included. If the Q extension is present, the FCVT.Q.H and FCVT.H.Q instructions
            are additionally included.'
      zfinx:
        "#zhinxmin":
          text:
          - 'The Zhinxmin extension includes the following instructions from the Zhinx
            extension: FCVT.S.H and FCVT.H.S. If the Zdinx extension is present, the
            FCVT.D.H and FCVT.H.D instructions are also included.'
  fcvt.h.w:
    opcode:
    - fcvt.h.w
    - rd
    - rs1
    - 24..20=0
    - 31..27=0x1A
    - rm
    - 26..25=2
    - 6..2=0x14
    - 1..0=3
    opcode_group: zfh
    opcode_args: *3
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/zfh.html"
    main_desc: zfh
    main_id: "#half-precision-convert-and-move-instructions"
    desc:
      zfh:
        "#half-precision-convert-and-move-instructions":
          text:
          - New floating-point-to-integer and integer-to-floating-point conversion
            instructions are added. These instructions are defined analogously to
            the single-precision-to-integer and integer-to-single-precision conversion
            instructions. FCVT.W.H or FCVT.L.H converts a half-precision floating-point
            number to a signed 32-bit or 64-bit integer, respectively. FCVT.H.W or
            FCVT.H.L converts a 32-bit or 64-bit signed integer, respectively, into
            a half-precision floating-point number. FCVT.WU.H, FCVT.LU.H, FCVT.H.WU,
            and FCVT.H.LU variants convert to or from unsigned integer values. FCVT.L[U].H
            and FCVT.H.L[U] are RV64-only instructions.
  fcvt.h.wu:
    opcode:
    - fcvt.h.wu
    - rd
    - rs1
    - 24..20=1
    - 31..27=0x1A
    - rm
    - 26..25=2
    - 6..2=0x14
    - 1..0=3
    opcode_group: zfh
    opcode_args: *3
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/zfh.html"
    main_desc: zfh
    main_id: "#half-precision-convert-and-move-instructions"
    desc:
      zfh:
        "#half-precision-convert-and-move-instructions":
          text:
          - New floating-point-to-integer and integer-to-floating-point conversion
            instructions are added. These instructions are defined analogously to
            the single-precision-to-integer and integer-to-single-precision conversion
            instructions. FCVT.W.H or FCVT.L.H converts a half-precision floating-point
            number to a signed 32-bit or 64-bit integer, respectively. FCVT.H.W or
            FCVT.H.L converts a 32-bit or 64-bit signed integer, respectively, into
            a half-precision floating-point number. FCVT.WU.H, FCVT.LU.H, FCVT.H.WU,
            and FCVT.H.LU variants convert to or from unsigned integer values. FCVT.L[U].H
            and FCVT.H.L[U] are RV64-only instructions.
  fcvt.l.d:
    opcode:
    - fcvt.l.d
    - rd
    - rs1
    - 24..20=2
    - 31..27=0x18
    - rm
    - 26..25=1
    - 6..2=0x14
    - 1..0=3
    opcode_group: d
    opcode_args: *3
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/d.html"
    main_desc: d
    main_id: "#double-precision-floating-point-conversion-and-move-instructions"
    desc:
      d:
        "#double-precision-floating-point-conversion-and-move-instructions":
          text:
          - Floating-point-to-integer and integer-to-floating-point conversion instructions
            are encoded in the OP-FP major opcode space. FCVT.W.D or FCVT.L.D converts
            a double-precision floating-point number in floating-point register rs1
            to a signed 32-bit or 64-bit integer, respectively, in integer register
            rd. FCVT.D.W or FCVT.D.L converts a 32-bit or 64-bit signed integer, respectively,
            in integer register rs1 into a double-precision floating-point number
            in floating-point register rd. FCVT.WU.D, FCVT.LU.D, FCVT.D.WU, and FCVT.D.LU
            variants convert to or from unsigned integer values. For RV64, FCVT.W[U].D
            sign-extends the 32-bit result. FCVT.L[U].D and FCVT.D.L[U] are RV64-only
            instructions. The range of valid inputs for FCVT.int.D and the behavior
            for invalid inputs are the same as for FCVT.int.S.
  fcvt.l.h:
    opcode:
    - fcvt.l.h
    - rd
    - rs1
    - 24..20=2
    - 31..27=0x18
    - rm
    - 26..25=2
    - 6..2=0x14
    - 1..0=3
    opcode_group: zfh
    opcode_args: *3
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/zfh.html"
    main_desc: zfh
    main_id: "#half-precision-convert-and-move-instructions"
    desc:
      zfh:
        "#half-precision-convert-and-move-instructions":
          text:
          - New floating-point-to-integer and integer-to-floating-point conversion
            instructions are added. These instructions are defined analogously to
            the single-precision-to-integer and integer-to-single-precision conversion
            instructions. FCVT.W.H or FCVT.L.H converts a half-precision floating-point
            number to a signed 32-bit or 64-bit integer, respectively. FCVT.H.W or
            FCVT.H.L converts a 32-bit or 64-bit signed integer, respectively, into
            a half-precision floating-point number. FCVT.WU.H, FCVT.LU.H, FCVT.H.WU,
            and FCVT.H.LU variants convert to or from unsigned integer values. FCVT.L[U].H
            and FCVT.H.L[U] are RV64-only instructions.
  fcvt.l.q:
    opcode:
    - fcvt.l.q
    - rd
    - rs1
    - 24..20=2
    - 31..27=0x18
    - rm
    - 26..25=3
    - 6..2=0x14
    - 1..0=3
    opcode_group: q
    opcode_args: *3
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/q.html"
    main_desc: q
    main_id: "#quad-precision-convert-and-move-instructions"
    desc:
      q:
        "#quad-precision-convert-and-move-instructions":
          text:
          - New floating-point-to-integer and integer-to-floating-point conversion
            instructions are added. These instructions are defined analogously to
            the double-precision-to-integer and integer-to-double-precision conversion
            instructions. FCVT.W.Q or FCVT.L.Q converts a quad-precision floating-point
            number to a signed 32-bit or 64-bit integer, respectively. FCVT.Q.W or
            FCVT.Q.L converts a 32-bit or 64-bit signed integer, respectively, into
            a quad-precision floating-point number. FCVT.WU.Q, FCVT.LU.Q, FCVT.Q.WU,
            and FCVT.Q.LU variants convert to or from unsigned integer values. FCVT.L[U].Q
            and FCVT.Q.L[U] are RV64-only instructions.
  fcvt.l.s:
    opcode:
    - fcvt.l.s
    - rd
    - rs1
    - 24..20=2
    - 31..27=0x18
    - rm
    - 26..25=0
    - 6..2=0x14
    - 1..0=3
    opcode_group: f
    opcode_args: *3
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/f.html"
    main_desc: f
    main_id: "#single-precision-floating-point-conversion-and-move-instructions"
    desc:
      f:
        "#single-precision-floating-point-conversion-and-move-instructions":
          text:
          - Floating-point-to-integer and integer-to-floating-point conversion instructions
            are encoded in the OP-FP major opcode space. FCVT.W.S or FCVT.L.S converts
            a floating-point number in floating-point register rs1 to a signed 32-bit
            or 64-bit integer, respectively, in integer register rd. FCVT.S.W or FCVT.S.L
            converts a 32-bit or 64-bit signed integer, respectively, in integer register
            rs1 into a floating-point number in floating-point register rd. FCVT.WU.S,
            FCVT.LU.S, FCVT.S.WU, and FCVT.S.LU variants convert to or from unsigned
            integer values. For XLEN > 32, FCVT.W[U].S sign-extends the 32-bit result
            to the destination register width. FCVT.L[U].S and FCVT.S.L[U] are RV64-only
            instructions. If the rounded result is not representable in the destination
            format, it is clipped to the nearest value and the invalid flag is set.
            Table [tab:int_conv] gives the range of valid inputs for FCVT.int.S and
            the behavior for invalid inputs.
          - FCVT.L.S
  fcvt.lu.d:
    opcode:
    - fcvt.lu.d
    - rd
    - rs1
    - 24..20=3
    - 31..27=0x18
    - rm
    - 26..25=1
    - 6..2=0x14
    - 1..0=3
    opcode_group: d
    opcode_args: *3
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/d.html"
    main_desc: d
    main_id: "#double-precision-floating-point-conversion-and-move-instructions"
    desc:
      d:
        "#double-precision-floating-point-conversion-and-move-instructions":
          text:
          - Floating-point-to-integer and integer-to-floating-point conversion instructions
            are encoded in the OP-FP major opcode space. FCVT.W.D or FCVT.L.D converts
            a double-precision floating-point number in floating-point register rs1
            to a signed 32-bit or 64-bit integer, respectively, in integer register
            rd. FCVT.D.W or FCVT.D.L converts a 32-bit or 64-bit signed integer, respectively,
            in integer register rs1 into a double-precision floating-point number
            in floating-point register rd. FCVT.WU.D, FCVT.LU.D, FCVT.D.WU, and FCVT.D.LU
            variants convert to or from unsigned integer values. For RV64, FCVT.W[U].D
            sign-extends the 32-bit result. FCVT.L[U].D and FCVT.D.L[U] are RV64-only
            instructions. The range of valid inputs for FCVT.int.D and the behavior
            for invalid inputs are the same as for FCVT.int.S.
  fcvt.lu.h:
    opcode:
    - fcvt.lu.h
    - rd
    - rs1
    - 24..20=3
    - 31..27=0x18
    - rm
    - 26..25=2
    - 6..2=0x14
    - 1..0=3
    opcode_group: zfh
    opcode_args: *3
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/zfh.html"
    main_desc: zfh
    main_id: "#half-precision-convert-and-move-instructions"
    desc:
      zfh:
        "#half-precision-convert-and-move-instructions":
          text:
          - New floating-point-to-integer and integer-to-floating-point conversion
            instructions are added. These instructions are defined analogously to
            the single-precision-to-integer and integer-to-single-precision conversion
            instructions. FCVT.W.H or FCVT.L.H converts a half-precision floating-point
            number to a signed 32-bit or 64-bit integer, respectively. FCVT.H.W or
            FCVT.H.L converts a 32-bit or 64-bit signed integer, respectively, into
            a half-precision floating-point number. FCVT.WU.H, FCVT.LU.H, FCVT.H.WU,
            and FCVT.H.LU variants convert to or from unsigned integer values. FCVT.L[U].H
            and FCVT.H.L[U] are RV64-only instructions.
  fcvt.lu.q:
    opcode:
    - fcvt.lu.q
    - rd
    - rs1
    - 24..20=3
    - 31..27=0x18
    - rm
    - 26..25=3
    - 6..2=0x14
    - 1..0=3
    opcode_group: q
    opcode_args: *3
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/q.html"
    main_desc: q
    main_id: "#quad-precision-convert-and-move-instructions"
    desc:
      q:
        "#quad-precision-convert-and-move-instructions":
          text:
          - New floating-point-to-integer and integer-to-floating-point conversion
            instructions are added. These instructions are defined analogously to
            the double-precision-to-integer and integer-to-double-precision conversion
            instructions. FCVT.W.Q or FCVT.L.Q converts a quad-precision floating-point
            number to a signed 32-bit or 64-bit integer, respectively. FCVT.Q.W or
            FCVT.Q.L converts a 32-bit or 64-bit signed integer, respectively, into
            a quad-precision floating-point number. FCVT.WU.Q, FCVT.LU.Q, FCVT.Q.WU,
            and FCVT.Q.LU variants convert to or from unsigned integer values. FCVT.L[U].Q
            and FCVT.Q.L[U] are RV64-only instructions.
  fcvt.lu.s:
    opcode:
    - fcvt.lu.s
    - rd
    - rs1
    - 24..20=3
    - 31..27=0x18
    - rm
    - 26..25=0
    - 6..2=0x14
    - 1..0=3
    opcode_group: f
    opcode_args: *3
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/f.html"
    main_desc: f
    main_id: "#single-precision-floating-point-conversion-and-move-instructions"
    desc:
      f:
        "#single-precision-floating-point-conversion-and-move-instructions":
          text:
          - Floating-point-to-integer and integer-to-floating-point conversion instructions
            are encoded in the OP-FP major opcode space. FCVT.W.S or FCVT.L.S converts
            a floating-point number in floating-point register rs1 to a signed 32-bit
            or 64-bit integer, respectively, in integer register rd. FCVT.S.W or FCVT.S.L
            converts a 32-bit or 64-bit signed integer, respectively, in integer register
            rs1 into a floating-point number in floating-point register rd. FCVT.WU.S,
            FCVT.LU.S, FCVT.S.WU, and FCVT.S.LU variants convert to or from unsigned
            integer values. For XLEN > 32, FCVT.W[U].S sign-extends the 32-bit result
            to the destination register width. FCVT.L[U].S and FCVT.S.L[U] are RV64-only
            instructions. If the rounded result is not representable in the destination
            format, it is clipped to the nearest value and the invalid flag is set.
            Table [tab:int_conv] gives the range of valid inputs for FCVT.int.S and
            the behavior for invalid inputs.
          - FCVT.LU.S
  fcvt.q.d:
    opcode:
    - fcvt.q.d
    - rd
    - rs1
    - 24..20=1
    - 31..27=0x08
    - rm
    - 26..25=3
    - 6..2=0x14
    - 1..0=3
    opcode_group: q
    opcode_args: *3
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/q.html"
    main_desc: q
    main_id: "#quad-precision-convert-and-move-instructions"
    desc:
      q:
        "#quad-precision-convert-and-move-instructions":
          text:
          - New floating-point-to-floating-point conversion instructions are added.
            These instructions are defined analogously to the double-precision floating-point-to-floating-point
            conversion instructions. FCVT.S.Q or FCVT.Q.S converts a quad-precision
            floating-point number to a single-precision floating-point number, or
            vice-versa, respectively. FCVT.D.Q or FCVT.Q.D converts a quad-precision
            floating-point number to a double-precision floating-point number, or
            vice-versa, respectively.
  fcvt.q.h:
    opcode:
    - fcvt.q.h
    - rd
    - rs1
    - 24..20=2
    - 31..27=0x08
    - rm
    - 26..25=3
    - 6..2=0x14
    - 1..0=3
    opcode_group: q_zfh
    opcode_args: *3
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/zfh.html"
    main_desc: zfh
    main_id: "#half-precision-convert-and-move-instructions"
    desc:
      zfh:
        "#half-precision-convert-and-move-instructions":
          text:
          - New floating-point-to-floating-point conversion instructions are added.
            These instructions are defined analogously to the double-precision floating-point-to-floating-point
            conversion instructions. FCVT.S.H or FCVT.H.S converts a half-precision
            floating-point number to a single-precision floating-point number, or
            vice-versa, respectively. If the D extension is present, FCVT.D.H or FCVT.H.D
            converts a half-precision floating-point number to a double-precision
            floating-point number, or vice-versa, respectively. If the Q extension
            is present, FCVT.Q.H or FCVT.H.Q converts a half-precision floating-point
            number to a quad-precision floating-point number, or vice-versa, respectively.
        "#zfhmin-standard-extension-for-minimal-half-precision-floating-point-support":
          text:
          - 'The Zfhmin extension includes the following instructions from the Zfh
            extension: FLH, FSH, FMV.X.H, FMV.H.X, FCVT.S.H, and FCVT.H.S. If the
            D extension is present, the FCVT.D.H and FCVT.H.D instructions are also
            included. If the Q extension is present, the FCVT.Q.H and FCVT.H.Q instructions
            are additionally included.'
  fcvt.q.l:
    opcode:
    - fcvt.q.l
    - rd
    - rs1
    - 24..20=2
    - 31..27=0x1A
    - rm
    - 26..25=3
    - 6..2=0x14
    - 1..0=3
    opcode_group: q
    opcode_args: *3
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/q.html"
    main_desc: q
    main_id: "#quad-precision-convert-and-move-instructions"
    desc:
      q:
        "#quad-precision-convert-and-move-instructions":
          text:
          - New floating-point-to-integer and integer-to-floating-point conversion
            instructions are added. These instructions are defined analogously to
            the double-precision-to-integer and integer-to-double-precision conversion
            instructions. FCVT.W.Q or FCVT.L.Q converts a quad-precision floating-point
            number to a signed 32-bit or 64-bit integer, respectively. FCVT.Q.W or
            FCVT.Q.L converts a 32-bit or 64-bit signed integer, respectively, into
            a quad-precision floating-point number. FCVT.WU.Q, FCVT.LU.Q, FCVT.Q.WU,
            and FCVT.Q.LU variants convert to or from unsigned integer values. FCVT.L[U].Q
            and FCVT.Q.L[U] are RV64-only instructions.
  fcvt.q.lu:
    opcode:
    - fcvt.q.lu
    - rd
    - rs1
    - 24..20=3
    - 31..27=0x1A
    - rm
    - 26..25=3
    - 6..2=0x14
    - 1..0=3
    opcode_group: q
    opcode_args: *3
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/q.html"
    main_desc: q
    main_id: "#quad-precision-convert-and-move-instructions"
    desc:
      q:
        "#quad-precision-convert-and-move-instructions":
          text:
          - New floating-point-to-integer and integer-to-floating-point conversion
            instructions are added. These instructions are defined analogously to
            the double-precision-to-integer and integer-to-double-precision conversion
            instructions. FCVT.W.Q or FCVT.L.Q converts a quad-precision floating-point
            number to a signed 32-bit or 64-bit integer, respectively. FCVT.Q.W or
            FCVT.Q.L converts a 32-bit or 64-bit signed integer, respectively, into
            a quad-precision floating-point number. FCVT.WU.Q, FCVT.LU.Q, FCVT.Q.WU,
            and FCVT.Q.LU variants convert to or from unsigned integer values. FCVT.L[U].Q
            and FCVT.Q.L[U] are RV64-only instructions.
  fcvt.q.s:
    opcode:
    - fcvt.q.s
    - rd
    - rs1
    - 24..20=0
    - 31..27=0x08
    - rm
    - 26..25=3
    - 6..2=0x14
    - 1..0=3
    opcode_group: q
    opcode_args: *3
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/q.html"
    main_desc: q
    main_id: "#quad-precision-convert-and-move-instructions"
    desc:
      q:
        "#quad-precision-convert-and-move-instructions":
          text:
          - New floating-point-to-floating-point conversion instructions are added.
            These instructions are defined analogously to the double-precision floating-point-to-floating-point
            conversion instructions. FCVT.S.Q or FCVT.Q.S converts a quad-precision
            floating-point number to a single-precision floating-point number, or
            vice-versa, respectively. FCVT.D.Q or FCVT.Q.D converts a quad-precision
            floating-point number to a double-precision floating-point number, or
            vice-versa, respectively.
  fcvt.q.w:
    opcode:
    - fcvt.q.w
    - rd
    - rs1
    - 24..20=0
    - 31..27=0x1A
    - rm
    - 26..25=3
    - 6..2=0x14
    - 1..0=3
    opcode_group: q
    opcode_args: *3
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/q.html"
    main_desc: q
    main_id: "#quad-precision-convert-and-move-instructions"
    desc:
      q:
        "#quad-precision-convert-and-move-instructions":
          text:
          - New floating-point-to-integer and integer-to-floating-point conversion
            instructions are added. These instructions are defined analogously to
            the double-precision-to-integer and integer-to-double-precision conversion
            instructions. FCVT.W.Q or FCVT.L.Q converts a quad-precision floating-point
            number to a signed 32-bit or 64-bit integer, respectively. FCVT.Q.W or
            FCVT.Q.L converts a 32-bit or 64-bit signed integer, respectively, into
            a quad-precision floating-point number. FCVT.WU.Q, FCVT.LU.Q, FCVT.Q.WU,
            and FCVT.Q.LU variants convert to or from unsigned integer values. FCVT.L[U].Q
            and FCVT.Q.L[U] are RV64-only instructions.
  fcvt.q.wu:
    opcode:
    - fcvt.q.wu
    - rd
    - rs1
    - 24..20=1
    - 31..27=0x1A
    - rm
    - 26..25=3
    - 6..2=0x14
    - 1..0=3
    opcode_group: q
    opcode_args: *3
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/q.html"
    main_desc: q
    main_id: "#quad-precision-convert-and-move-instructions"
    desc:
      q:
        "#quad-precision-convert-and-move-instructions":
          text:
          - New floating-point-to-integer and integer-to-floating-point conversion
            instructions are added. These instructions are defined analogously to
            the double-precision-to-integer and integer-to-double-precision conversion
            instructions. FCVT.W.Q or FCVT.L.Q converts a quad-precision floating-point
            number to a signed 32-bit or 64-bit integer, respectively. FCVT.Q.W or
            FCVT.Q.L converts a 32-bit or 64-bit signed integer, respectively, into
            a quad-precision floating-point number. FCVT.WU.Q, FCVT.LU.Q, FCVT.Q.WU,
            and FCVT.Q.LU variants convert to or from unsigned integer values. FCVT.L[U].Q
            and FCVT.Q.L[U] are RV64-only instructions.
  fcvt.s.d:
    opcode:
    - fcvt.s.d
    - rd
    - rs1
    - 24..20=1
    - 31..27=0x08
    - rm
    - 26..25=0
    - 6..2=0x14
    - 1..0=3
    opcode_group: d
    opcode_args: *3
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/d.html"
    main_desc: d
    main_id: "#double-precision-floating-point-conversion-and-move-instructions"
    desc:
      d:
        "#double-precision-floating-point-conversion-and-move-instructions":
          text:
          - The double-precision to single-precision and single-precision to double-precision
            conversion instructions, FCVT.S.D and FCVT.D.S, are encoded in the OP-FP
            major opcode space and both the source and destination are floating-point
            registers. The rs2 field encodes the datatype of the source, and the fmt
            field encodes the datatype of the destination. FCVT.S.D rounds according
            to the RM field; FCVT.D.S will never round.
  fcvt.s.h:
    opcode:
    - fcvt.s.h
    - rd
    - rs1
    - 24..20=2
    - 31..27=0x08
    - rm
    - 26..25=0
    - 6..2=0x14
    - 1..0=3
    opcode_group: zfh
    opcode_args: *3
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/zfh.html"
    main_desc: zfh
    main_id: "#half-precision-convert-and-move-instructions"
    desc:
      zfh:
        "#half-precision-convert-and-move-instructions":
          text:
          - New floating-point-to-floating-point conversion instructions are added.
            These instructions are defined analogously to the double-precision floating-point-to-floating-point
            conversion instructions. FCVT.S.H or FCVT.H.S converts a half-precision
            floating-point number to a single-precision floating-point number, or
            vice-versa, respectively. If the D extension is present, FCVT.D.H or FCVT.H.D
            converts a half-precision floating-point number to a double-precision
            floating-point number, or vice-versa, respectively. If the Q extension
            is present, FCVT.Q.H or FCVT.H.Q converts a half-precision floating-point
            number to a quad-precision floating-point number, or vice-versa, respectively.
        "#zfhmin-standard-extension-for-minimal-half-precision-floating-point-support":
          text:
          - 'The Zfhmin extension includes the following instructions from the Zfh
            extension: FLH, FSH, FMV.X.H, FMV.H.X, FCVT.S.H, and FCVT.H.S. If the
            D extension is present, the FCVT.D.H and FCVT.H.D instructions are also
            included. If the Q extension is present, the FCVT.Q.H and FCVT.H.Q instructions
            are additionally included.'
      zfinx:
        "#zhinxmin":
          text:
          - 'The Zhinxmin extension includes the following instructions from the Zhinx
            extension: FCVT.S.H and FCVT.H.S. If the Zdinx extension is present, the
            FCVT.D.H and FCVT.H.D instructions are also included.'
  fcvt.s.l:
    opcode:
    - fcvt.s.l
    - rd
    - rs1
    - 24..20=2
    - 31..27=0x1A
    - rm
    - 26..25=0
    - 6..2=0x14
    - 1..0=3
    opcode_group: f
    opcode_args: *3
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/f.html"
    main_desc: f
    main_id: "#single-precision-floating-point-conversion-and-move-instructions"
    desc:
      f:
        "#single-precision-floating-point-conversion-and-move-instructions":
          text:
          - Floating-point-to-integer and integer-to-floating-point conversion instructions
            are encoded in the OP-FP major opcode space. FCVT.W.S or FCVT.L.S converts
            a floating-point number in floating-point register rs1 to a signed 32-bit
            or 64-bit integer, respectively, in integer register rd. FCVT.S.W or FCVT.S.L
            converts a 32-bit or 64-bit signed integer, respectively, in integer register
            rs1 into a floating-point number in floating-point register rd. FCVT.WU.S,
            FCVT.LU.S, FCVT.S.WU, and FCVT.S.LU variants convert to or from unsigned
            integer values. For XLEN > 32, FCVT.W[U].S sign-extends the 32-bit result
            to the destination register width. FCVT.L[U].S and FCVT.S.L[U] are RV64-only
            instructions. If the rounded result is not representable in the destination
            format, it is clipped to the nearest value and the invalid flag is set.
            Table [tab:int_conv] gives the range of valid inputs for FCVT.int.S and
            the behavior for invalid inputs.
  fcvt.s.lu:
    opcode:
    - fcvt.s.lu
    - rd
    - rs1
    - 24..20=3
    - 31..27=0x1A
    - rm
    - 26..25=0
    - 6..2=0x14
    - 1..0=3
    opcode_group: f
    opcode_args: *3
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/f.html"
    main_desc: f
    main_id: "#single-precision-floating-point-conversion-and-move-instructions"
    desc:
      f:
        "#single-precision-floating-point-conversion-and-move-instructions":
          text:
          - Floating-point-to-integer and integer-to-floating-point conversion instructions
            are encoded in the OP-FP major opcode space. FCVT.W.S or FCVT.L.S converts
            a floating-point number in floating-point register rs1 to a signed 32-bit
            or 64-bit integer, respectively, in integer register rd. FCVT.S.W or FCVT.S.L
            converts a 32-bit or 64-bit signed integer, respectively, in integer register
            rs1 into a floating-point number in floating-point register rd. FCVT.WU.S,
            FCVT.LU.S, FCVT.S.WU, and FCVT.S.LU variants convert to or from unsigned
            integer values. For XLEN > 32, FCVT.W[U].S sign-extends the 32-bit result
            to the destination register width. FCVT.L[U].S and FCVT.S.L[U] are RV64-only
            instructions. If the rounded result is not representable in the destination
            format, it is clipped to the nearest value and the invalid flag is set.
            Table [tab:int_conv] gives the range of valid inputs for FCVT.int.S and
            the behavior for invalid inputs.
  fcvt.s.q:
    opcode:
    - fcvt.s.q
    - rd
    - rs1
    - 24..20=3
    - 31..27=0x08
    - rm
    - 26..25=0
    - 6..2=0x14
    - 1..0=3
    opcode_group: q
    opcode_args: *3
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/q.html"
    main_desc: q
    main_id: "#quad-precision-convert-and-move-instructions"
    desc:
      q:
        "#quad-precision-convert-and-move-instructions":
          text:
          - New floating-point-to-floating-point conversion instructions are added.
            These instructions are defined analogously to the double-precision floating-point-to-floating-point
            conversion instructions. FCVT.S.Q or FCVT.Q.S converts a quad-precision
            floating-point number to a single-precision floating-point number, or
            vice-versa, respectively. FCVT.D.Q or FCVT.Q.D converts a quad-precision
            floating-point number to a double-precision floating-point number, or
            vice-versa, respectively.
  fcvt.s.w:
    opcode:
    - fcvt.s.w
    - rd
    - rs1
    - 24..20=0
    - 31..27=0x1A
    - rm
    - 26..25=0
    - 6..2=0x14
    - 1..0=3
    opcode_group: f
    opcode_args: *3
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/f.html"
    main_desc: f
    main_id: "#single-precision-floating-point-conversion-and-move-instructions"
    desc:
      f:
        "#single-precision-floating-point-conversion-and-move-instructions":
          text:
          - Floating-point-to-integer and integer-to-floating-point conversion instructions
            are encoded in the OP-FP major opcode space. FCVT.W.S or FCVT.L.S converts
            a floating-point number in floating-point register rs1 to a signed 32-bit
            or 64-bit integer, respectively, in integer register rd. FCVT.S.W or FCVT.S.L
            converts a 32-bit or 64-bit signed integer, respectively, in integer register
            rs1 into a floating-point number in floating-point register rd. FCVT.WU.S,
            FCVT.LU.S, FCVT.S.WU, and FCVT.S.LU variants convert to or from unsigned
            integer values. For XLEN > 32, FCVT.W[U].S sign-extends the 32-bit result
            to the destination register width. FCVT.L[U].S and FCVT.S.L[U] are RV64-only
            instructions. If the rounded result is not representable in the destination
            format, it is clipped to the nearest value and the invalid flag is set.
            Table [tab:int_conv] gives the range of valid inputs for FCVT.int.S and
            the behavior for invalid inputs.
          - All floating-point to integer and integer to floating-point conversion
            instructions round according to the rm field. A floating-point register
            can be initialized to floating-point positive zero using FCVT.S.W rd,
            x0, which will never set any exception flags.
  fcvt.s.wu:
    opcode:
    - fcvt.s.wu
    - rd
    - rs1
    - 24..20=1
    - 31..27=0x1A
    - rm
    - 26..25=0
    - 6..2=0x14
    - 1..0=3
    opcode_group: f
    opcode_args: *3
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/f.html"
    main_desc: f
    main_id: "#single-precision-floating-point-conversion-and-move-instructions"
    desc:
      f:
        "#single-precision-floating-point-conversion-and-move-instructions":
          text:
          - Floating-point-to-integer and integer-to-floating-point conversion instructions
            are encoded in the OP-FP major opcode space. FCVT.W.S or FCVT.L.S converts
            a floating-point number in floating-point register rs1 to a signed 32-bit
            or 64-bit integer, respectively, in integer register rd. FCVT.S.W or FCVT.S.L
            converts a 32-bit or 64-bit signed integer, respectively, in integer register
            rs1 into a floating-point number in floating-point register rd. FCVT.WU.S,
            FCVT.LU.S, FCVT.S.WU, and FCVT.S.LU variants convert to or from unsigned
            integer values. For XLEN > 32, FCVT.W[U].S sign-extends the 32-bit result
            to the destination register width. FCVT.L[U].S and FCVT.S.L[U] are RV64-only
            instructions. If the rounded result is not representable in the destination
            format, it is clipped to the nearest value and the invalid flag is set.
            Table [tab:int_conv] gives the range of valid inputs for FCVT.int.S and
            the behavior for invalid inputs.
  fcvt.w.d:
    opcode:
    - fcvt.w.d
    - rd
    - rs1
    - 24..20=0
    - 31..27=0x18
    - rm
    - 26..25=1
    - 6..2=0x14
    - 1..0=3
    opcode_group: d
    opcode_args: *3
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/d.html"
    main_desc: d
    main_id: "#double-precision-floating-point-conversion-and-move-instructions"
    desc:
      d:
        "#double-precision-floating-point-conversion-and-move-instructions":
          text:
          - Floating-point-to-integer and integer-to-floating-point conversion instructions
            are encoded in the OP-FP major opcode space. FCVT.W.D or FCVT.L.D converts
            a double-precision floating-point number in floating-point register rs1
            to a signed 32-bit or 64-bit integer, respectively, in integer register
            rd. FCVT.D.W or FCVT.D.L converts a 32-bit or 64-bit signed integer, respectively,
            in integer register rs1 into a double-precision floating-point number
            in floating-point register rd. FCVT.WU.D, FCVT.LU.D, FCVT.D.WU, and FCVT.D.LU
            variants convert to or from unsigned integer values. For RV64, FCVT.W[U].D
            sign-extends the 32-bit result. FCVT.L[U].D and FCVT.D.L[U] are RV64-only
            instructions. The range of valid inputs for FCVT.int.D and the behavior
            for invalid inputs are the same as for FCVT.int.S.
  fcvt.w.h:
    opcode:
    - fcvt.w.h
    - rd
    - rs1
    - 24..20=0
    - 31..27=0x18
    - rm
    - 26..25=2
    - 6..2=0x14
    - 1..0=3
    opcode_group: zfh
    opcode_args: *3
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/zfh.html"
    main_desc: zfh
    main_id: "#half-precision-convert-and-move-instructions"
    desc:
      zfh:
        "#half-precision-convert-and-move-instructions":
          text:
          - New floating-point-to-integer and integer-to-floating-point conversion
            instructions are added. These instructions are defined analogously to
            the single-precision-to-integer and integer-to-single-precision conversion
            instructions. FCVT.W.H or FCVT.L.H converts a half-precision floating-point
            number to a signed 32-bit or 64-bit integer, respectively. FCVT.H.W or
            FCVT.H.L converts a 32-bit or 64-bit signed integer, respectively, into
            a half-precision floating-point number. FCVT.WU.H, FCVT.LU.H, FCVT.H.WU,
            and FCVT.H.LU variants convert to or from unsigned integer values. FCVT.L[U].H
            and FCVT.H.L[U] are RV64-only instructions.
  fcvt.w.q:
    opcode:
    - fcvt.w.q
    - rd
    - rs1
    - 24..20=0
    - 31..27=0x18
    - rm
    - 26..25=3
    - 6..2=0x14
    - 1..0=3
    opcode_group: q
    opcode_args: *3
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/q.html"
    main_desc: q
    main_id: "#quad-precision-convert-and-move-instructions"
    desc:
      q:
        "#quad-precision-convert-and-move-instructions":
          text:
          - New floating-point-to-integer and integer-to-floating-point conversion
            instructions are added. These instructions are defined analogously to
            the double-precision-to-integer and integer-to-double-precision conversion
            instructions. FCVT.W.Q or FCVT.L.Q converts a quad-precision floating-point
            number to a signed 32-bit or 64-bit integer, respectively. FCVT.Q.W or
            FCVT.Q.L converts a 32-bit or 64-bit signed integer, respectively, into
            a quad-precision floating-point number. FCVT.WU.Q, FCVT.LU.Q, FCVT.Q.WU,
            and FCVT.Q.LU variants convert to or from unsigned integer values. FCVT.L[U].Q
            and FCVT.Q.L[U] are RV64-only instructions.
  fcvt.w.s:
    opcode:
    - fcvt.w.s
    - rd
    - rs1
    - 24..20=0
    - 31..27=0x18
    - rm
    - 26..25=0
    - 6..2=0x14
    - 1..0=3
    opcode_group: f
    opcode_args: *3
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/f.html"
    main_desc: f
    main_id: "#single-precision-floating-point-conversion-and-move-instructions"
    desc:
      f:
        "#single-precision-floating-point-conversion-and-move-instructions":
          text:
          - Floating-point-to-integer and integer-to-floating-point conversion instructions
            are encoded in the OP-FP major opcode space. FCVT.W.S or FCVT.L.S converts
            a floating-point number in floating-point register rs1 to a signed 32-bit
            or 64-bit integer, respectively, in integer register rd. FCVT.S.W or FCVT.S.L
            converts a 32-bit or 64-bit signed integer, respectively, in integer register
            rs1 into a floating-point number in floating-point register rd. FCVT.WU.S,
            FCVT.LU.S, FCVT.S.WU, and FCVT.S.LU variants convert to or from unsigned
            integer values. For XLEN > 32, FCVT.W[U].S sign-extends the 32-bit result
            to the destination register width. FCVT.L[U].S and FCVT.S.L[U] are RV64-only
            instructions. If the rounded result is not representable in the destination
            format, it is clipped to the nearest value and the invalid flag is set.
            Table [tab:int_conv] gives the range of valid inputs for FCVT.int.S and
            the behavior for invalid inputs.
          - FCVT.W.S
  fcvt.wu.d:
    opcode:
    - fcvt.wu.d
    - rd
    - rs1
    - 24..20=1
    - 31..27=0x18
    - rm
    - 26..25=1
    - 6..2=0x14
    - 1..0=3
    opcode_group: d
    opcode_args: *3
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/d.html"
    main_desc: d
    main_id: "#double-precision-floating-point-conversion-and-move-instructions"
    desc:
      d:
        "#double-precision-floating-point-conversion-and-move-instructions":
          text:
          - Floating-point-to-integer and integer-to-floating-point conversion instructions
            are encoded in the OP-FP major opcode space. FCVT.W.D or FCVT.L.D converts
            a double-precision floating-point number in floating-point register rs1
            to a signed 32-bit or 64-bit integer, respectively, in integer register
            rd. FCVT.D.W or FCVT.D.L converts a 32-bit or 64-bit signed integer, respectively,
            in integer register rs1 into a double-precision floating-point number
            in floating-point register rd. FCVT.WU.D, FCVT.LU.D, FCVT.D.WU, and FCVT.D.LU
            variants convert to or from unsigned integer values. For RV64, FCVT.W[U].D
            sign-extends the 32-bit result. FCVT.L[U].D and FCVT.D.L[U] are RV64-only
            instructions. The range of valid inputs for FCVT.int.D and the behavior
            for invalid inputs are the same as for FCVT.int.S.
  fcvt.wu.h:
    opcode:
    - fcvt.wu.h
    - rd
    - rs1
    - 24..20=1
    - 31..27=0x18
    - rm
    - 26..25=2
    - 6..2=0x14
    - 1..0=3
    opcode_group: zfh
    opcode_args: *3
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/zfh.html"
    main_desc: zfh
    main_id: "#half-precision-convert-and-move-instructions"
    desc:
      zfh:
        "#half-precision-convert-and-move-instructions":
          text:
          - New floating-point-to-integer and integer-to-floating-point conversion
            instructions are added. These instructions are defined analogously to
            the single-precision-to-integer and integer-to-single-precision conversion
            instructions. FCVT.W.H or FCVT.L.H converts a half-precision floating-point
            number to a signed 32-bit or 64-bit integer, respectively. FCVT.H.W or
            FCVT.H.L converts a 32-bit or 64-bit signed integer, respectively, into
            a half-precision floating-point number. FCVT.WU.H, FCVT.LU.H, FCVT.H.WU,
            and FCVT.H.LU variants convert to or from unsigned integer values. FCVT.L[U].H
            and FCVT.H.L[U] are RV64-only instructions.
  fcvt.wu.q:
    opcode:
    - fcvt.wu.q
    - rd
    - rs1
    - 24..20=1
    - 31..27=0x18
    - rm
    - 26..25=3
    - 6..2=0x14
    - 1..0=3
    opcode_group: q
    opcode_args: *3
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/q.html"
    main_desc: q
    main_id: "#quad-precision-convert-and-move-instructions"
    desc:
      q:
        "#quad-precision-convert-and-move-instructions":
          text:
          - New floating-point-to-integer and integer-to-floating-point conversion
            instructions are added. These instructions are defined analogously to
            the double-precision-to-integer and integer-to-double-precision conversion
            instructions. FCVT.W.Q or FCVT.L.Q converts a quad-precision floating-point
            number to a signed 32-bit or 64-bit integer, respectively. FCVT.Q.W or
            FCVT.Q.L converts a 32-bit or 64-bit signed integer, respectively, into
            a quad-precision floating-point number. FCVT.WU.Q, FCVT.LU.Q, FCVT.Q.WU,
            and FCVT.Q.LU variants convert to or from unsigned integer values. FCVT.L[U].Q
            and FCVT.Q.L[U] are RV64-only instructions.
  fcvt.wu.s:
    opcode:
    - fcvt.wu.s
    - rd
    - rs1
    - 24..20=1
    - 31..27=0x18
    - rm
    - 26..25=0
    - 6..2=0x14
    - 1..0=3
    opcode_group: f
    opcode_args: *3
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/f.html"
    main_desc: f
    main_id: "#single-precision-floating-point-conversion-and-move-instructions"
    desc:
      f:
        "#single-precision-floating-point-conversion-and-move-instructions":
          text:
          - Floating-point-to-integer and integer-to-floating-point conversion instructions
            are encoded in the OP-FP major opcode space. FCVT.W.S or FCVT.L.S converts
            a floating-point number in floating-point register rs1 to a signed 32-bit
            or 64-bit integer, respectively, in integer register rd. FCVT.S.W or FCVT.S.L
            converts a 32-bit or 64-bit signed integer, respectively, in integer register
            rs1 into a floating-point number in floating-point register rd. FCVT.WU.S,
            FCVT.LU.S, FCVT.S.WU, and FCVT.S.LU variants convert to or from unsigned
            integer values. For XLEN > 32, FCVT.W[U].S sign-extends the 32-bit result
            to the destination register width. FCVT.L[U].S and FCVT.S.L[U] are RV64-only
            instructions. If the rounded result is not representable in the destination
            format, it is clipped to the nearest value and the invalid flag is set.
            Table [tab:int_conv] gives the range of valid inputs for FCVT.int.S and
            the behavior for invalid inputs.
          - FCVT.WU.S
  fdiv.d:
    opcode:
    - fdiv.d
    - rd
    - rs1
    - rs2
    - 31..27=0x03
    - rm
    - 26..25=1
    - 6..2=0x14
    - 1..0=3
    opcode_group: d
    opcode_args: *1
    main_desc: d
    main_id: "#sec:single-float-compute"
    desc:
      d:
        "#sec:single-float-compute":
          text:
          - Floating-point arithmetic instructions with one or two source operands
            use the R-type format with the OP-FP major opcode. FADD.S and FMUL.S perform
            single-precision floating-point addition and multiplication respectively,
            between rs1 and rs2. FSUB.S performs the single-precision floating-point
            subtraction of rs2 from rs1. FDIV.S performs the single-precision floating-point
            division of rs1 by rs2. FSQRT.S computes the square root of rs1. In each
            case, the result is written to rd.
    iss_code:
    - require_either_extension('D', EXT_ZDINX);
    - require_fp;
    - softfloat_roundingMode = RM;
    - WRITE_FRD_D(f64_div(FRS1_D, FRS2_D));
    - set_fp_exceptions;
  fdiv.h:
    opcode:
    - fdiv.h
    - rd
    - rs1
    - rs2
    - 31..27=0x03
    - rm
    - 26..25=2
    - 6..2=0x14
    - 1..0=3
    opcode_group: zfh
    opcode_args: *1
    iss_code:
    - require_either_extension(EXT_ZFH, EXT_ZHINX);
    - require_fp;
    - softfloat_roundingMode = RM;
    - WRITE_FRD_H(f16_div(FRS1_H, FRS2_H));
    - set_fp_exceptions;
  fdiv.q:
    opcode:
    - fdiv.q
    - rd
    - rs1
    - rs2
    - 31..27=0x03
    - rm
    - 26..25=3
    - 6..2=0x14
    - 1..0=3
    opcode_group: q
    opcode_args: *1
    main_desc: q
    main_id: "#sec:single-float-compute"
    desc:
      q:
        "#sec:single-float-compute":
          text:
          - Floating-point arithmetic instructions with one or two source operands
            use the R-type format with the OP-FP major opcode. FADD.S and FMUL.S perform
            single-precision floating-point addition and multiplication respectively,
            between rs1 and rs2. FSUB.S performs the single-precision floating-point
            subtraction of rs2 from rs1. FDIV.S performs the single-precision floating-point
            division of rs1 by rs2. FSQRT.S computes the square root of rs1. In each
            case, the result is written to rd.
    iss_code:
    - require_extension('Q');
    - require_fp;
    - softfloat_roundingMode = RM;
    - WRITE_FRD(f128_div(f128(FRS1), f128(FRS2)));
    - set_fp_exceptions;
  fdiv.s:
    opcode:
    - fdiv.s
    - rd
    - rs1
    - rs2
    - 31..27=0x03
    - rm
    - 26..25=0
    - 6..2=0x14
    - 1..0=3
    opcode_group: f
    opcode_args: *1
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/f.html"
    main_desc: f
    main_id: "#sec:single-float-compute"
    desc:
      f:
        "#sec:single-float-compute":
          text:
          - Floating-point arithmetic instructions with one or two source operands
            use the R-type format with the OP-FP major opcode. FADD.S and FMUL.S perform
            single-precision floating-point addition and multiplication respectively,
            between rs1 and rs2. FSUB.S performs the single-precision floating-point
            subtraction of rs2 from rs1. FDIV.S performs the single-precision floating-point
            division of rs1 by rs2. FSQRT.S computes the square root of rs1. In each
            case, the result is written to rd.
    iss_code:
    - require_either_extension('F', EXT_ZFINX);
    - require_fp;
    - softfloat_roundingMode = RM;
    - WRITE_FRD_F(f32_div(FRS1_F, FRS2_F));
    - set_fp_exceptions;
  fence:
    opcode:
    - fence
    - fm
    - pred
    - succ
    - rs1
    - 14..12=0
    - rd
    - 6..2=0x03
    - 1..0=3
    opcode_group: i
    opcode_args: &21
    - rs1
    - rd
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/rv32.html"
    main_desc: rv32
    main_id: "#rv32"
    desc:
      rv32:
        "#rv32":
          text:
          - RV32I was designed to be sufficient to form a compiler target and to support
            modern operating system environments. The ISA was also designed to reduce
            the hardware required in a minimal implementation. RV32I contains 40 unique
            instructions, though a simple implementation might cover the ECALL/EBREAK
            instructions with a single SYSTEM hardware instruction that always traps
            and might be able to implement the FENCE instruction as a NOP, reducing
            base instruction count to 38 total. RV32I can emulate almost any other
            ISA extension (except the A extension, which requires additional hardware
            support for atomicity).
        "#sec:fence":
          text:
          - The FENCE instruction is used to order device I/O and memory accesses
            as viewed by other RISC-V harts and external devices or coprocessors.
            Any combination of device input (I), device output (O), memory reads (R),
            and memory writes (W) may be ordered with respect to any combination of
            the same. Informally, no other RISC-V hart or external device can observe
            any operation in the successor set following a FENCE before any operation
            in the predecessor set preceding the FENCE. Chapter [ch:memorymodel] provides
            a precise description of the RISC-V memory consistency model.
          - The FENCE instruction also orders memory reads and writes made by the
            hart as observed by memory reads and writes made by an external device.
            However, FENCE does not order observations of events made by an external
            device using any other signaling mechanism.
          - A device might observe an access to a memory location via some external
            communication mechanism, e.g., a memory-mapped control register that drives
            an interrupt signal to an interrupt controller. This communication is
            outside the scope of the FENCE ordering mechanism and hence the FENCE
            instruction can provide no guarantee on when a change in the interrupt
            signal is visible to the interrupt controller. Specific devices might
            provide additional ordering guarantees to reduce software overhead but
            those are outside the scope of the RISC-V memory model.
          - The EEI will define what I/O operations are possible, and in particular,
            which memory addresses when accessed by load and store instructions will
            be treated and ordered as device input and device output operations respectively
            rather than memory reads and writes. For example, memory-mapped I/O devices
            will typically be accessed with uncached loads and stores that are ordered
            using the I and O bits rather than the R and W bits. Instruction-set extensions
            might also describe new I/O instructions that will also be ordered using
            the I and O bits in a FENCE.
          - The fence mode field fm defines the semantics of the FENCE. A FENCE with
            fm=0000 orders all memory operations in its predecessor set before all
            memory operations in its successor set.
          - The FENCE.TSO instruction is encoded as a FENCE instruction with fm=1000,
            predecessor=RW, and successor=RW. FENCE.TSO orders all load operations
            in its predecessor set before all memory operations in its successor set,
            and all store operations in its predecessor set before all store operations
            in its successor set. This leaves non-AMO store operations in the FENCE.TSO's
            predecessor set unordered with non-AMO loads in its successor set.
          - Because FENCE RW,RW imposes a superset of the orderings that FENCE.TSO
            imposes, it is correct to ignore the fm field and implement FENCE.TSO
            as FENCE RW,RW .
          - The unused fields in the FENCE instructions--rs1 and rd--are reserved
            for finer-grain fences in future extensions. For forward compatibility,
            base implementations shall ignore these fields, and standard software
            shall zero these fields. Likewise, many fm and predecessor/successor set
            settings in Table 1.5 are also reserved for future use. Base implementations
            shall treat all such reserved configurations as normal fences with fm=0000,
            and standard software shall use only non-reserved configurations.
        "#sec:rv32i-hints":
          text:
          - Most RV32I HINTs are encoded as integer computational instructions with
            rd=x0. The other RV32I HINTs are encoded as FENCE instructions with a
            null predecessor or successor set and with fm=0.
          - As another example, a FENCE instruction with a zero pred field and a zero
            fm field is a HINT; the succ, rs1, and rd fields encode the arguments
            to the HINT. A simple implementation can simply execute the HINT as a
            FENCE that orders the null set of prior memory accesses before whichever
            subsequent memory accesses are encoded in the succ field. Since the intersection
            of the predecessor and successor sets is null, the instruction imposes
            no memory orderings, and so it has no architecturally visible effect.
      zifencei:
        "#chap:zifencei":
          text:
          - This chapter defines the "Zifencei" extension, which includes the FENCE.I
            instruction that provides explicit synchronization between writes to instruction
            memory and instruction fetches on the same hart. Currently, this instruction
            is the only standard mechanism to ensure that stores visible to a hart
            will also be visible to its instruction fetches.
          - We considered but did not include a "store instruction word" instruction
            (as in MAJC [majc]). JIT compilers may generate a large trace of instructions
            before a single FENCE.I, and amortize any instruction cache snooping/invalidation
            overhead by writing translated instructions to memory regions that are
            known not to reside in the I-cache.
          - The FENCE.I instruction was designed to support a wide variety of implementations.
            A simple implementation can flush the local instruction cache and the
            instruction pipeline when the FENCE.I is executed. A more complex implementation
            might snoop the instruction (data) cache on every data (instruction) cache
            miss, or use an inclusive unified private L2 cache to invalidate lines
            from the primary instruction cache when they are being written by a local
            store instruction. If instruction and data caches are kept coherent in
            this way, or if the memory system consists of only uncached RAMs, then
            just the fetch pipeline needs to be flushed at a FENCE.I.
          - The FENCE.I instruction was previously part of the base I instruction
            set. Two main issues are driving moving this out of the mandatory base,
            although at time of writing it is still the only standard method for maintaining
            instruction-fetch coherence.
          - First, it has been recognized that on some systems, FENCE.I will be expensive
            to implement and alternate mechanisms are being discussed in the memory
            model task group. In particular, for designs that have an incoherent instruction
            cache and an incoherent data cache, or where the instruction cache refill
            does not snoop a coherent data cache, both caches must be completely flushed
            when a FENCE.I instruction is encountered. This problem is exacerbated
            when there are multiple levels of I and D cache in front of a unified
            cache or outer memory system.
          - Second, the instruction is not powerful enough to make available at user
            level in a Unix-like operating system environment. The FENCE.I only synchronizes
            the local hart, and the OS can reschedule the user hart to a different
            physical hart after the FENCE.I. This would require the OS to execute
            an additional FENCE.I as part of every context migration. For this reason,
            the standard Linux ABI has removed FENCE.I from user-level and now requires
            a system call to maintain instruction-fetch coherence, which allows the
            OS to minimize the number of FENCE.I executions required on current systems
            and provides forward-compatibility with future improved instruction-fetch
            coherence mechanisms.
          - Future approaches to instruction-fetch coherence under discussion include
            providing more restricted versions of FENCE.I that only target a given
            address specified in rs1, and/or allowing software to use an ABI that
            relies on machine-mode cache-maintenance operations.
          - The FENCE.I instruction is used to synchronize the instruction and data
            streams. RISC-V does not guarantee that stores to instruction memory will
            be made visible to instruction fetches on a RISC-V hart until that hart
            executes a FENCE.I instruction. A FENCE.I instruction ensures that a subsequent
            instruction fetch on a RISC-V hart will see any previous data stores already
            visible to the same RISC-V hart. FENCE.I does not ensure that other RISC-V
            harts' instruction fetches will observe the local hart's stores in a multiprocessor
            system. To make a store to instruction memory visible to all RISC-V harts,
            the writing hart also has to execute a data FENCE before requesting that
            all remote RISC-V harts execute a FENCE.I.
          - The unused fields in the FENCE.I instruction, imm[11:0], rs1, and rd,
            are reserved for finer-grain fences in future extensions. For forward
            compatibility, base implementations shall ignore these fields, and standard
            software shall zero these fields.
          - Because FENCE.I only orders stores with a hart's own instruction fetches,
            application code should only rely upon FENCE.I if the application thread
            will not be migrated to a different hart. The EEI can provide mechanisms
            for efficient multiprocessor instruction-stream synchronization.
      zihintpause:
        "#chap:zihintpause":
          text:
          - PAUSE is encoded as a FENCE instruction with pred=W, succ=0, fm=0, rd=x0,
            and rs1=x0.
          - PAUSE is encoded as a hint within the FENCE opcode because some implementations
            are expected to deliberately stall the PAUSE instruction until outstanding
            memory transactions have completed. Because the successor set is null,
            however, PAUSE does not mandate any particular memory ordering--hence,
            it truly is a HINT.
          - Like other FENCE instructions, PAUSE cannot be used within LR/SC sequences
            without voiding the forward-progress guarantee.
      a:
        "#specifying-ordering-of-atomic-instructions":
          text:
          - The base RISC-V ISA has a relaxed memory model, with the FENCE instruction
            used to impose additional ordering constraints. The address space is divided
            by the execution environment into memory and I/O domains, and the FENCE
            instruction provides options to order accesses to one or both of these
            two address domains.
          - To provide more efficient support for release consistency [Gharachorloo90memoryconsistency],
            each atomic instruction has two bits, aq and rl, used to specify additional
            memory ordering constraints as viewed by other RISC-V harts. The bits
            order accesses to one of the two address domains, memory or I/O, depending
            on which address domain the atomic instruction is accessing. No ordering
            constraint is implied to accesses to the other domain, and a FENCE instruction
            should be used to order across both domains.
        "#sec:lrscseq":
          text:
          - An LR/SC sequence begins with an LR instruction and ends with an SC instruction.
            The dynamic code executed between the LR and SC instructions can only
            contain instructions from the base "I" instruction set, excluding loads,
            stores, backward jumps, taken backward branches, JALR, FENCE, and SYSTEM
            instructions. If the "C" extension is supported, then compressed forms
            of the aforementioned "I" instructions are also permitted.
        "#sec:amo":
          text:
          - The AMOs were designed to implement the C11 and C++11 memory models efficiently.
            Although the FENCE R, RW instruction suffices to implement the acquire
            operation and FENCE RW, W suffices to implement release, both imply additional
            unnecessary ordering as compared to AMOs with the corresponding aq or
            rl bit set.
      csr:
        "#csr-access-ordering":
          text:
          - For the RVWMO memory consistency model (Chapter [ch:memorymodel] ), CSR
            accesses are weakly ordered by default, so other harts or devices may
            observe CSR accesses in an order different from program order. In addition,
            CSR accesses are not ordered with respect to explicit memory accesses,
            unless a CSR access modifies the execution behavior of the instruction
            that performs the explicit memory access or unless a CSR access and an
            explicit memory access are ordered by either the syntactic dependencies
            defined by the memory model or the ordering requirements defined by the
            Memory-Ordering PMAs section in Volume II of this manual. To enforce ordering
            in all other cases, software should execute a FENCE instruction between
            the relevant accesses. For the purposes of the FENCE instruction, CSR
            read accesses are classified as device input (I), and CSR write accesses
            are classified as device output (O).
          - Most CSRs (including, e.g., the fcsr) are not visible to other harts;
            their accesses can be freely reordered in the global memory order with
            respect to FENCE instructions without violating this specification.
      rvwmo:
        "#ch:memorymodel":
          text:
          - Under RVWMO, code running on a single hart appears to execute in order
            from the perspective of other memory instructions in the same hart, but
            memory instructions from another hart may observe the memory instructions
            from the first hart being executed in a different order. Therefore, multithreaded
            code may require explicit synchronization to guarantee ordering between
            memory instructions from different harts. The base RISC-V ISA provides
            a FENCE instruction for this purpose, described in Section [sec:fence]
            , while the atomics extension "A" additionally defines load-reserved/store-conditional
            and atomic read-modify-write instructions.
          - This chapter defines the memory model for regular main memory operations.
            The interaction of the memory model with I/O memory, instruction fetches,
            FENCE.I, page table walks, and SFENCE.VMA is not (yet) formalized. Some
            or all of the above may be formalized in a future revision of this specification.
            The RV128 base ISA and future ISA extensions such as the "V" vector and
            "J" JIT extensions will need to be incorporated into a future revision
            as well.
        "#preserved-program-order":
          text:
          - "[ppo:fence] There is a FENCE instruction that orders a before b"
      machine:
        "#machine-environment-configuration-registers-menvcfg-and-menvcfgh":
          text:
          - If bit FIOM (Fence of I/O implies Memory) is set to one in menvcfg, FENCE
            instructions executed in modes less privileged than M are modified so
            the requirement to order accesses to device I/O implies also the requirement
            to order main memory accesses. Table [tab:menvcfg-FIOM] details the modified
            interpretation of FENCE instruction bits PI, PO, SI, and SO for modes
            less privileged than M when FIOM=1.
        "#memory-ordering-pmas":
          text:
          - Regions of the address space are classified as either main memory or I/O
            for the purposes of ordering by the FENCE instruction and atomic-instruction
            ordering bits.
      supervisor:
        "#supervisor-environment-configuration-register-senvcfg":
          text:
          - If bit FIOM (Fence of I/O implies Memory) is set to one in senvcfg, FENCE
            instructions executed in U-mode are modified so the requirement to order
            accesses to device I/O implies also the requirement to order main memory
            accesses. Table [tab:senvcfg-FIOM] details the modified interpretation
            of FENCE instruction bits PI, PO, SI, and SO in U-mode when FIOM=1.
        "#sec:translation":
          text:
          - When a virtual page is accessed and the A bit is clear, or is written
            and the D bit is clear, the implementation sets the corresponding bit(s)
            in the PTE. The PTE update must be atomic with respect to other accesses
            to the PTE, and must atomically check that the PTE is valid and grants
            sufficient permissions. Updates of the A bit may be performed as a result
            of speculation, but updates to the D bit must be exact (i.e., not speculative),
            and observed in program order by the local hart. Furthermore, the PTE
            update must appear in the global memory order no later than the explicit
            memory access, or any subsequent explicit memory access to that virtual
            page by the local hart. The ordering on loads and stores provided by FENCE
            instructions and the acquire/release bits on atomic instructions also
            orders the PTE updates associated with those loads and stores as observed
            by remote harts.
        "#svpbmt":
          text:
          - If the underlying physical memory attribute for a page is I/O, and the
            page has PBMT=NC, then accesses to that page obey RVWMO. However, accesses
            to such pages are considered to be both I/O and main memory accesses for
            the purposes of FENCE, .aq, and .rl.
          - If the underlying physical memory attribute for a page is main memory,
            and the page has PBMT=IO, then accesses to that page obey strong channel
            0 I/O ordering rules with respect to other accesses to physical main memory
            and to other accesses to pages with PBMT=IO. However, accesses to such
            pages are considered to be both I/O and main memory accesses for the purposes
            of FENCE, .aq, and .rl.
      hypervisor:
        "#hypervisor-environment-configuration-registers-henvcfg-and-henvcfgh":
          text:
          - If bit FIOM (Fence of I/O implies Memory) is set to one in henvcfg, FENCE
            instructions executed when V=1 are modified so the requirement to order
            accesses to device I/O implies also the requirement to order main memory
            accesses. Table [tab:henvcfg-FIOM] details the modified interpretation
            of FENCE instruction bits PI, PO, SI, and SO when FIOM=1 and V=1.
    iss_code: []
  fence.i:
    opcode:
    - fence.i
    - imm12
    - rs1
    - 14..12=1
    - rd
    - 6..2=0x03
    - 1..0=3
    opcode_group: zifencei
    opcode_args: &42
    - imm12
    - rs1
    - rd
    iss_code:
    - MMU.flush_icache();
  fence.tso:
    opcode:
    - fence.tso
    - 31..28=8
    - 27..24=3
    - 23..20=3
    - rs1
    - 14..12=0
    - rd
    - 6..2=0x03
    - 1..0=3
    opcode_group: i
    opcode_args: *21
    pseudo_src: rv_i
    pseudo_op: fence
  feq.d:
    opcode:
    - feq.d
    - rd
    - rs1
    - rs2
    - 31..27=0x14
    - 14..12=2
    - 26..25=1
    - 6..2=0x14
    - 1..0=3
    opcode_group: d
    opcode_args: *1
    main_desc: d
    main_id: "#single-precision-floating-point-compare-instructions"
    desc:
      d:
        "#single-precision-floating-point-compare-instructions":
          text:
          - Floating-point compare instructions (FEQ.S, FLT.S, FLE.S) perform the
            specified comparison between floating-point registers (rs1 = rs2, rs1
            < rs2, rs1 \leq rs2) writing 1 to the integer register rd if the condition
            holds, and 0 otherwise.
          - 'FLT.S and FLE.S perform what the IEEE 754-2008 standard refers to as
            signaling comparisons: that is, they set the invalid operation exception
            flag if either input is NaN. FEQ.S performs a quiet comparison: it only
            sets the invalid operation exception flag if either input is a signaling
            NaN. For all three instructions, the result is 0 if either operand is
            NaN.'
    iss_code:
    - require_either_extension('D', EXT_ZDINX);
    - require_fp;
    - WRITE_RD(f64_eq(FRS1_D, FRS2_D));
    - set_fp_exceptions;
  feq.h:
    opcode:
    - feq.h
    - rd
    - rs1
    - rs2
    - 31..27=0x14
    - 14..12=2
    - 26..25=2
    - 6..2=0x14
    - 1..0=3
    opcode_group: zfh
    opcode_args: *1
    iss_code:
    - require_either_extension(EXT_ZFH, EXT_ZHINX);
    - require_fp;
    - WRITE_RD(f16_eq(FRS1_H, FRS2_H));
    - set_fp_exceptions;
  feq.q:
    opcode:
    - feq.q
    - rd
    - rs1
    - rs2
    - 31..27=0x14
    - 14..12=2
    - 26..25=3
    - 6..2=0x14
    - 1..0=3
    opcode_group: q
    opcode_args: *1
    main_desc: q
    main_id: "#single-precision-floating-point-compare-instructions"
    desc:
      q:
        "#single-precision-floating-point-compare-instructions":
          text:
          - Floating-point compare instructions (FEQ.S, FLT.S, FLE.S) perform the
            specified comparison between floating-point registers (rs1 = rs2, rs1
            < rs2, rs1 \leq rs2) writing 1 to the integer register rd if the condition
            holds, and 0 otherwise.
          - 'FLT.S and FLE.S perform what the IEEE 754-2008 standard refers to as
            signaling comparisons: that is, they set the invalid operation exception
            flag if either input is NaN. FEQ.S performs a quiet comparison: it only
            sets the invalid operation exception flag if either input is a signaling
            NaN. For all three instructions, the result is 0 if either operand is
            NaN.'
    iss_code:
    - require_extension('Q');
    - require_fp;
    - WRITE_RD(f128_eq(f128(FRS1), f128(FRS2)));
    - set_fp_exceptions;
  feq.s:
    opcode:
    - feq.s
    - rd
    - rs1
    - rs2
    - 31..27=0x14
    - 14..12=2
    - 26..25=0
    - 6..2=0x14
    - 1..0=3
    opcode_group: f
    opcode_args: *1
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/f.html"
    main_desc: f
    main_id: "#single-precision-floating-point-compare-instructions"
    desc:
      f:
        "#single-precision-floating-point-compare-instructions":
          text:
          - Floating-point compare instructions (FEQ.S, FLT.S, FLE.S) perform the
            specified comparison between floating-point registers (rs1 = rs2, rs1
            < rs2, rs1 \leq rs2) writing 1 to the integer register rd if the condition
            holds, and 0 otherwise.
          - 'FLT.S and FLE.S perform what the IEEE 754-2008 standard refers to as
            signaling comparisons: that is, they set the invalid operation exception
            flag if either input is NaN. FEQ.S performs a quiet comparison: it only
            sets the invalid operation exception flag if either input is a signaling
            NaN. For all three instructions, the result is 0 if either operand is
            NaN.'
    iss_code:
    - require_either_extension('F', EXT_ZFINX);
    - require_fp;
    - WRITE_RD(f32_eq(FRS1_F, FRS2_F));
    - set_fp_exceptions;
  fld:
    opcode:
    - fld
    - rd
    - rs1
    - imm12
    - 14..12=3
    - 6..2=0x01
    - 1..0=3
    opcode_group: d
    opcode_args: *2
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/d.html"
    main_desc: d
    main_id: "#fld_fsd"
    desc:
      d:
        "#fld_fsd":
          text:
          - The FLD instruction loads a double-precision floating-point value from
            memory into floating-point register rd. FSD stores a double-precision
            value from the floating-point registers to memory.
          - FLD and FSD are only guaranteed to execute atomically if the effective
            address is naturally aligned and XLEN>=64.
          - FLD and FSD do not modify the bits being transferred; in particular, the
            payloads of non-canonical NaNs are preserved.
      rvwmo:
        "#sec:rvwmo:primitives":
          text:
          - Among instructions in RV32GC and RV64GC, each aligned memory instruction
            gives rise to exactly one memory operation, with two exceptions. First,
            an unsuccessful SC instruction does not give rise to any memory operations.
            Second, FLD and FSD instructions may each give rise to multiple memory
            operations if XLEN<64, as stated in Section [fld_fsd] and clarified below.
            An aligned AMO gives rise to a single memory operation that is both a
            load operation and a store operation simultaneously.
          - A misaligned load or store instruction may be decomposed into a set of
            component memory operations of any granularity. An FLD or FSD instruction
            for which XLEN<64 may also be decomposed into a set of component memory
            operations of any granularity. The memory operations generated by such
            instructions are not ordered with respect to each other in program order,
            but they are ordered normally with respect to the memory operations generated
            by preceding and subsequent instructions in program order. The atomics
            extension "A" does not require execution environments to support misaligned
            atomic instructions at all; however, if misaligned atomics are supported
            via the "Zam" extension, LRs, SCs, and AMOs may be decomposed subject
            to the constraints of the atomicity axiom for misaligned atomics, which
            is defined in Chapter [sec:zam] .
      zfinx:
        "#zdinx":
          text:
          - The Zdinx extension adds all of the instructions that the D extension
            adds, except for the transfer instructions FLD, FSD, FMV.D.X, FMV.X.D,
            C.FLD[SP], and C.FSD[SP].
      hypervisor:
        "#sec:tinst-vals":
          text:
          - For a standard load instruction that is not a compressed instruction and
            is one of LB, LBU, LH, LHU, LW, LWU, LD, FLW, FLD, FLQ, or FLH, the transformed
            instruction has the format shown in Figure 1.46 .
          - Transformed noncompressed load instruction (LB, LBU, LH, LHU, LW, LWU,
            LD, FLW, FLD, FLQ, or FLH). Fields funct3, rd, and opcode are the same
            as the trapping load instruction.
          - In decoding the contents of mtinst or htinst, once software has determined
            that the register contains the encoding of a standard basic load (LB,
            LBU, LH, LHU, LW, LWU, LD, FLW, FLD, FLQ, or FLH) or basic store (SB,
            SH, SW, SD, FSW, FSD, FSQ, or FSH), it is not necessary to confirm also
            that the immediate offset fields (31:25, and 24:20 or 11:7) are zeros.
            The knowledge that the register's value is the encoding of a basic load/store
            is sufficient to prove that the trapping instruction is of the same kind.
      v:
        "#sec-vector-loadstore-width-encoding":
          text:
          - FLD/FSD
    iss_code:
    - require_extension('D');
    - require_fp;
    - WRITE_FRD(f64(MMU.load<uint64_t>(RS1 + insn.i_imm())));
  fle.d:
    opcode:
    - fle.d
    - rd
    - rs1
    - rs2
    - 31..27=0x14
    - 14..12=0
    - 26..25=1
    - 6..2=0x14
    - 1..0=3
    opcode_group: d
    opcode_args: *1
    main_desc: d
    main_id: "#single-precision-floating-point-compare-instructions"
    desc:
      d:
        "#single-precision-floating-point-compare-instructions":
          text:
          - Floating-point compare instructions (FEQ.S, FLT.S, FLE.S) perform the
            specified comparison between floating-point registers (rs1 = rs2, rs1
            < rs2, rs1 \leq rs2) writing 1 to the integer register rd if the condition
            holds, and 0 otherwise.
          - 'FLT.S and FLE.S perform what the IEEE 754-2008 standard refers to as
            signaling comparisons: that is, they set the invalid operation exception
            flag if either input is NaN. FEQ.S performs a quiet comparison: it only
            sets the invalid operation exception flag if either input is a signaling
            NaN. For all three instructions, the result is 0 if either operand is
            NaN.'
    iss_code:
    - require_either_extension('D', EXT_ZDINX);
    - require_fp;
    - WRITE_RD(f64_le(FRS1_D, FRS2_D));
    - set_fp_exceptions;
  fle.h:
    opcode:
    - fle.h
    - rd
    - rs1
    - rs2
    - 31..27=0x14
    - 14..12=0
    - 26..25=2
    - 6..2=0x14
    - 1..0=3
    opcode_group: zfh
    opcode_args: *1
    iss_code:
    - require_either_extension(EXT_ZFH, EXT_ZHINX);
    - require_fp;
    - WRITE_RD(f16_le(FRS1_H, FRS2_H));
    - set_fp_exceptions;
  fle.q:
    opcode:
    - fle.q
    - rd
    - rs1
    - rs2
    - 31..27=0x14
    - 14..12=0
    - 26..25=3
    - 6..2=0x14
    - 1..0=3
    opcode_group: q
    opcode_args: *1
    main_desc: q
    main_id: "#single-precision-floating-point-compare-instructions"
    desc:
      q:
        "#single-precision-floating-point-compare-instructions":
          text:
          - Floating-point compare instructions (FEQ.S, FLT.S, FLE.S) perform the
            specified comparison between floating-point registers (rs1 = rs2, rs1
            < rs2, rs1 \leq rs2) writing 1 to the integer register rd if the condition
            holds, and 0 otherwise.
          - 'FLT.S and FLE.S perform what the IEEE 754-2008 standard refers to as
            signaling comparisons: that is, they set the invalid operation exception
            flag if either input is NaN. FEQ.S performs a quiet comparison: it only
            sets the invalid operation exception flag if either input is a signaling
            NaN. For all three instructions, the result is 0 if either operand is
            NaN.'
    iss_code:
    - require_extension('Q');
    - require_fp;
    - WRITE_RD(f128_le(f128(FRS1), f128(FRS2)));
    - set_fp_exceptions;
  fle.s:
    opcode:
    - fle.s
    - rd
    - rs1
    - rs2
    - 31..27=0x14
    - 14..12=0
    - 26..25=0
    - 6..2=0x14
    - 1..0=3
    opcode_group: f
    opcode_args: *1
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/f.html"
    main_desc: f
    main_id: "#single-precision-floating-point-compare-instructions"
    desc:
      f:
        "#single-precision-floating-point-compare-instructions":
          text:
          - Floating-point compare instructions (FEQ.S, FLT.S, FLE.S) perform the
            specified comparison between floating-point registers (rs1 = rs2, rs1
            < rs2, rs1 \leq rs2) writing 1 to the integer register rd if the condition
            holds, and 0 otherwise.
          - 'FLT.S and FLE.S perform what the IEEE 754-2008 standard refers to as
            signaling comparisons: that is, they set the invalid operation exception
            flag if either input is NaN. FEQ.S performs a quiet comparison: it only
            sets the invalid operation exception flag if either input is a signaling
            NaN. For all three instructions, the result is 0 if either operand is
            NaN.'
    iss_code:
    - require_either_extension('F', EXT_ZFINX);
    - require_fp;
    - WRITE_RD(f32_le(FRS1_F, FRS2_F));
    - set_fp_exceptions;
  flh:
    opcode:
    - flh
    - rd
    - rs1
    - imm12
    - 14..12=1
    - 6..2=0x01
    - 1..0=3
    opcode_group: zfh
    opcode_args: *2
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/zfh.html"
    main_desc: zfh
    main_id: "#half-precision-load-and-store-instructions"
    desc:
      zfh:
        "#half-precision-load-and-store-instructions":
          text:
          - FLH and FSH are only guaranteed to execute atomically if the effective
            address is naturally aligned.
          - FLH and FSH do not modify the bits being transferred; in particular, the
            payloads of non-canonical NaNs are preserved. FLH NaN-boxes the result
            written to rd, whereas FSH ignores all but the lower 16 bits in rs2.
        "#zfhmin-standard-extension-for-minimal-half-precision-floating-point-support":
          text:
          - 'The Zfhmin extension includes the following instructions from the Zfh
            extension: FLH, FSH, FMV.X.H, FMV.H.X, FCVT.S.H, and FCVT.H.S. If the
            D extension is present, the FCVT.D.H and FCVT.H.D instructions are also
            included. If the Q extension is present, the FCVT.Q.H and FCVT.H.Q instructions
            are additionally included.'
      zfinx:
        "#zhinx":
          text:
          - The Zhinx extension adds all of the instructions that the Zfh extension
            adds, except for the transfer instructions FLH, FSH, FMV.H.X, and FMV.X.H.
      hypervisor:
        "#sec:tinst-vals":
          text:
          - For a standard load instruction that is not a compressed instruction and
            is one of LB, LBU, LH, LHU, LW, LWU, LD, FLW, FLD, FLQ, or FLH, the transformed
            instruction has the format shown in Figure 1.46 .
          - Transformed noncompressed load instruction (LB, LBU, LH, LHU, LW, LWU,
            LD, FLW, FLD, FLQ, or FLH). Fields funct3, rd, and opcode are the same
            as the trapping load instruction.
          - In decoding the contents of mtinst or htinst, once software has determined
            that the register contains the encoding of a standard basic load (LB,
            LBU, LH, LHU, LW, LWU, LD, FLW, FLD, FLQ, or FLH) or basic store (SB,
            SH, SW, SD, FSW, FSD, FSQ, or FSH), it is not necessary to confirm also
            that the immediate offset fields (31:25, and 24:20 or 11:7) are zeros.
            The knowledge that the register's value is the encoding of a basic load/store
            is sufficient to prove that the trapping instruction is of the same kind.
      v:
        "#sec-vector-loadstore-width-encoding":
          text:
          - FLH/FSH
    iss_code:
    - require_extension(EXT_INTERNAL_ZFH_MOVE);
    - require_fp;
    - WRITE_FRD(f16(MMU.load<uint16_t>(RS1 + insn.i_imm())));
  flq:
    opcode:
    - flq
    - rd
    - rs1
    - imm12
    - 14..12=4
    - 6..2=0x01
    - 1..0=3
    opcode_group: q
    opcode_args: *2
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/q.html"
    main_desc: q
    main_id: "#quad-precision-load-and-store-instructions"
    desc:
      q:
        "#quad-precision-load-and-store-instructions":
          text:
          - FLQ and FSQ are only guaranteed to execute atomically if the effective
            address is naturally aligned and XLEN=128.
          - FLQ and FSQ do not modify the bits being transferred; in particular, the
            payloads of non-canonical NaNs are preserved.
      hypervisor:
        "#sec:tinst-vals":
          text:
          - For a standard load instruction that is not a compressed instruction and
            is one of LB, LBU, LH, LHU, LW, LWU, LD, FLW, FLD, FLQ, or FLH, the transformed
            instruction has the format shown in Figure 1.46 .
          - Transformed noncompressed load instruction (LB, LBU, LH, LHU, LW, LWU,
            LD, FLW, FLD, FLQ, or FLH). Fields funct3, rd, and opcode are the same
            as the trapping load instruction.
          - In decoding the contents of mtinst or htinst, once software has determined
            that the register contains the encoding of a standard basic load (LB,
            LBU, LH, LHU, LW, LWU, LD, FLW, FLD, FLQ, or FLH) or basic store (SB,
            SH, SW, SD, FSW, FSD, FSQ, or FSH), it is not necessary to confirm also
            that the immediate offset fields (31:25, and 24:20 or 11:7) are zeros.
            The knowledge that the register's value is the encoding of a basic load/store
            is sufficient to prove that the trapping instruction is of the same kind.
      v:
        "#sec-vector-loadstore-width-encoding":
          text:
          - FLQ/FSQ
    iss_code:
    - require_extension('Q');
    - require_fp;
    - WRITE_FRD(MMU.load_float128(RS1 + insn.i_imm()));
  flt.d:
    opcode:
    - flt.d
    - rd
    - rs1
    - rs2
    - 31..27=0x14
    - 14..12=1
    - 26..25=1
    - 6..2=0x14
    - 1..0=3
    opcode_group: d
    opcode_args: *1
    main_desc: d
    main_id: "#single-precision-floating-point-compare-instructions"
    desc:
      d:
        "#single-precision-floating-point-compare-instructions":
          text:
          - Floating-point compare instructions (FEQ.S, FLT.S, FLE.S) perform the
            specified comparison between floating-point registers (rs1 = rs2, rs1
            < rs2, rs1 \leq rs2) writing 1 to the integer register rd if the condition
            holds, and 0 otherwise.
          - 'FLT.S and FLE.S perform what the IEEE 754-2008 standard refers to as
            signaling comparisons: that is, they set the invalid operation exception
            flag if either input is NaN. FEQ.S performs a quiet comparison: it only
            sets the invalid operation exception flag if either input is a signaling
            NaN. For all three instructions, the result is 0 if either operand is
            NaN.'
    iss_code:
    - require_either_extension('D', EXT_ZDINX);
    - require_fp;
    - WRITE_RD(f64_lt(FRS1_D, FRS2_D));
    - set_fp_exceptions;
  flt.h:
    opcode:
    - flt.h
    - rd
    - rs1
    - rs2
    - 31..27=0x14
    - 14..12=1
    - 26..25=2
    - 6..2=0x14
    - 1..0=3
    opcode_group: zfh
    opcode_args: *1
    iss_code:
    - require_either_extension(EXT_ZFH, EXT_ZHINX);
    - require_fp;
    - WRITE_RD(f16_lt(FRS1_H, FRS2_H));
    - set_fp_exceptions;
  flt.q:
    opcode:
    - flt.q
    - rd
    - rs1
    - rs2
    - 31..27=0x14
    - 14..12=1
    - 26..25=3
    - 6..2=0x14
    - 1..0=3
    opcode_group: q
    opcode_args: *1
    main_desc: q
    main_id: "#single-precision-floating-point-compare-instructions"
    desc:
      q:
        "#single-precision-floating-point-compare-instructions":
          text:
          - Floating-point compare instructions (FEQ.S, FLT.S, FLE.S) perform the
            specified comparison between floating-point registers (rs1 = rs2, rs1
            < rs2, rs1 \leq rs2) writing 1 to the integer register rd if the condition
            holds, and 0 otherwise.
          - 'FLT.S and FLE.S perform what the IEEE 754-2008 standard refers to as
            signaling comparisons: that is, they set the invalid operation exception
            flag if either input is NaN. FEQ.S performs a quiet comparison: it only
            sets the invalid operation exception flag if either input is a signaling
            NaN. For all three instructions, the result is 0 if either operand is
            NaN.'
    iss_code:
    - require_extension('Q');
    - require_fp;
    - WRITE_RD(f128_lt(f128(FRS1), f128(FRS2)));
    - set_fp_exceptions;
  flt.s:
    opcode:
    - flt.s
    - rd
    - rs1
    - rs2
    - 31..27=0x14
    - 14..12=1
    - 26..25=0
    - 6..2=0x14
    - 1..0=3
    opcode_group: f
    opcode_args: *1
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/f.html"
    main_desc: f
    main_id: "#single-precision-floating-point-compare-instructions"
    desc:
      f:
        "#single-precision-floating-point-compare-instructions":
          text:
          - Floating-point compare instructions (FEQ.S, FLT.S, FLE.S) perform the
            specified comparison between floating-point registers (rs1 = rs2, rs1
            < rs2, rs1 \leq rs2) writing 1 to the integer register rd if the condition
            holds, and 0 otherwise.
          - 'FLT.S and FLE.S perform what the IEEE 754-2008 standard refers to as
            signaling comparisons: that is, they set the invalid operation exception
            flag if either input is NaN. FEQ.S performs a quiet comparison: it only
            sets the invalid operation exception flag if either input is a signaling
            NaN. For all three instructions, the result is 0 if either operand is
            NaN.'
    iss_code:
    - require_either_extension('F', EXT_ZFINX);
    - require_fp;
    - WRITE_RD(f32_lt(FRS1_F, FRS2_F));
    - set_fp_exceptions;
  flw:
    opcode:
    - flw
    - rd
    - rs1
    - imm12
    - 14..12=2
    - 6..2=0x01
    - 1..0=3
    opcode_group: f
    opcode_args: *2
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/f.html"
    main_desc: f
    main_id: "#single-precision-load-and-store-instructions"
    desc:
      f:
        "#single-precision-load-and-store-instructions":
          text:
          - Floating-point loads and stores use the same base+offset addressing mode
            as the integer base ISAs, with a base address in register rs1 and a 12-bit
            signed byte offset. The FLW instruction loads a single-precision floating-point
            value from memory into floating-point register rd. FSW stores a single-precision
            value from floating-point register rs2 to memory.
          - FLW and FSW are only guaranteed to execute atomically if the effective
            address is naturally aligned.
          - FLW and FSW do not modify the bits being transferred; in particular, the
            payloads of non-canonical NaNs are preserved.
      zfinx:
        "#sec:zfinx":
          text:
          - The Zfinx extension adds all of the instructions that the F extension
            adds, except for the transfer instructions FLW, FSW, FMV.W.X, FMV.X.W,
            C.FLW[SP], and C.FSW[SP].
      hypervisor:
        "#sec:tinst-vals":
          text:
          - For a standard load instruction that is not a compressed instruction and
            is one of LB, LBU, LH, LHU, LW, LWU, LD, FLW, FLD, FLQ, or FLH, the transformed
            instruction has the format shown in Figure 1.46 .
          - Transformed noncompressed load instruction (LB, LBU, LH, LHU, LW, LWU,
            LD, FLW, FLD, FLQ, or FLH). Fields funct3, rd, and opcode are the same
            as the trapping load instruction.
          - In decoding the contents of mtinst or htinst, once software has determined
            that the register contains the encoding of a standard basic load (LB,
            LBU, LH, LHU, LW, LWU, LD, FLW, FLD, FLQ, or FLH) or basic store (SB,
            SH, SW, SD, FSW, FSD, FSQ, or FSH), it is not necessary to confirm also
            that the immediate offset fields (31:25, and 24:20 or 11:7) are zeros.
            The knowledge that the register's value is the encoding of a basic load/store
            is sufficient to prove that the trapping instruction is of the same kind.
      v:
        "#sec-vector-loadstore-width-encoding":
          text:
          - FLW/FSW
    iss_code:
    - require_extension('F');
    - require_fp;
    - WRITE_FRD(f32(MMU.load<uint32_t>(RS1 + insn.i_imm())));
  fmadd.d:
    opcode:
    - fmadd.d
    - rd
    - rs1
    - rs2
    - rs3
    - rm
    - 26..25=1
    - 6..2=0x10
    - 1..0=3
    opcode_group: d
    opcode_args: &22
    - rd
    - rs1
    - rs2
    - rs3
    main_desc: d
    main_id: "#sec:single-float-compute"
    desc:
      d:
        "#sec:single-float-compute":
          text:
          - FMADD.S multiplies the values in rs1 and rs2, adds the value in rs3, and
            writes the final result to rd. FMADD.S computes (rs1rs2)+rs3.
    iss_code:
    - require_either_extension('D', EXT_ZDINX);
    - require_fp;
    - softfloat_roundingMode = RM;
    - WRITE_FRD_D(f64_mulAdd(FRS1_D, FRS2_D, FRS3_D));
    - set_fp_exceptions;
  fmadd.h:
    opcode:
    - fmadd.h
    - rd
    - rs1
    - rs2
    - rs3
    - rm
    - 26..25=2
    - 6..2=0x10
    - 1..0=3
    opcode_group: zfh
    opcode_args: *22
    iss_code:
    - require_either_extension(EXT_ZFH, EXT_ZHINX);
    - require_fp;
    - softfloat_roundingMode = RM;
    - WRITE_FRD_H(f16_mulAdd(FRS1_H, FRS2_H, FRS3_H));
    - set_fp_exceptions;
  fmadd.q:
    opcode:
    - fmadd.q
    - rd
    - rs1
    - rs2
    - rs3
    - rm
    - 26..25=3
    - 6..2=0x10
    - 1..0=3
    opcode_group: q
    opcode_args: *22
    main_desc: q
    main_id: "#sec:single-float-compute"
    desc:
      q:
        "#sec:single-float-compute":
          text:
          - FMADD.S multiplies the values in rs1 and rs2, adds the value in rs3, and
            writes the final result to rd. FMADD.S computes (rs1rs2)+rs3.
    iss_code:
    - require_extension('Q');
    - require_fp;
    - softfloat_roundingMode = RM;
    - WRITE_FRD(f128_mulAdd(f128(FRS1), f128(FRS2), f128(FRS3)));
    - set_fp_exceptions;
  fmadd.s:
    opcode:
    - fmadd.s
    - rd
    - rs1
    - rs2
    - rs3
    - rm
    - 26..25=0
    - 6..2=0x10
    - 1..0=3
    opcode_group: f
    opcode_args: *22
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/f.html"
    main_desc: f
    main_id: "#sec:single-float-compute"
    desc:
      f:
        "#sec:single-float-compute":
          text:
          - FMADD.S multiplies the values in rs1 and rs2, adds the value in rs3, and
            writes the final result to rd. FMADD.S computes (rs1rs2)+rs3.
    iss_code:
    - require_either_extension('F', EXT_ZFINX);
    - require_fp;
    - softfloat_roundingMode = RM;
    - WRITE_FRD_F(f32_mulAdd(FRS1_F, FRS2_F, FRS3_F));
    - set_fp_exceptions;
  fmax.d:
    opcode:
    - fmax.d
    - rd
    - rs1
    - rs2
    - 31..27=0x05
    - 14..12=1
    - 26..25=1
    - 6..2=0x14
    - 1..0=3
    opcode_group: d
    opcode_args: *1
    main_desc: d
    main_id: "#sec:single-float-compute"
    desc:
      d:
        "#sec:single-float-compute":
          text:
          - Floating-point minimum-number and maximum-number instructions FMIN.S and
            FMAX.S write, respectively, the smaller or larger of rs1 and rs2 to rd.
            For the purposes of these instructions only, the value - 0.0 is considered
            to be less than the value + 0.0. If both inputs are NaNs, the result is
            the canonical NaN. If only one operand is a NaN, the result is the non-NaN
            operand. Signaling NaN inputs set the invalid operation exception flag,
            even when the result is not NaN.
          - Note that in version 2.2 of the F extension, the FMIN.S and FMAX.S instructions
            were amended to implement the proposed IEEE 754-201x minimumNumber and
            maximumNumber operations, rather than the IEEE 754-2008 minNum and maxNum
            operations. These operations differ in their handling of signaling NaNs.
    iss_code:
    - require_either_extension('D', EXT_ZDINX);
    - require_fp;
    - bool greater = f64_lt_quiet(FRS2_D, FRS1_D) ||
    - "(f64_eq(FRS2_D, FRS1_D) && (FRS2_D.v & F64_SIGN));"
    - if (isNaNF64UI(FRS1_D.v) && isNaNF64UI(FRS2_D.v))
    - WRITE_FRD_D(f64(defaultNaNF64UI));
    - else
    - 'WRITE_FRD_D((greater || isNaNF64UI(FRS2_D.v) ? FRS1_D : FRS2_D));'
    - set_fp_exceptions;
  fmax.h:
    opcode:
    - fmax.h
    - rd
    - rs1
    - rs2
    - 31..27=0x05
    - 14..12=1
    - 26..25=2
    - 6..2=0x14
    - 1..0=3
    opcode_group: zfh
    opcode_args: *1
    iss_code:
    - require_either_extension(EXT_ZFH, EXT_ZHINX);
    - require_fp;
    - WRITE_FRD_H(f16_max(FRS1_H, FRS2_H));
    - set_fp_exceptions;
  fmax.q:
    opcode:
    - fmax.q
    - rd
    - rs1
    - rs2
    - 31..27=0x05
    - 14..12=1
    - 26..25=3
    - 6..2=0x14
    - 1..0=3
    opcode_group: q
    opcode_args: *1
    main_desc: q
    main_id: "#sec:single-float-compute"
    desc:
      q:
        "#sec:single-float-compute":
          text:
          - Floating-point minimum-number and maximum-number instructions FMIN.S and
            FMAX.S write, respectively, the smaller or larger of rs1 and rs2 to rd.
            For the purposes of these instructions only, the value - 0.0 is considered
            to be less than the value + 0.0. If both inputs are NaNs, the result is
            the canonical NaN. If only one operand is a NaN, the result is the non-NaN
            operand. Signaling NaN inputs set the invalid operation exception flag,
            even when the result is not NaN.
          - Note that in version 2.2 of the F extension, the FMIN.S and FMAX.S instructions
            were amended to implement the proposed IEEE 754-201x minimumNumber and
            maximumNumber operations, rather than the IEEE 754-2008 minNum and maxNum
            operations. These operations differ in their handling of signaling NaNs.
    iss_code:
    - require_extension('Q');
    - require_fp;
    - bool greater = f128_lt_quiet(f128(FRS2), f128(FRS1)) ||
    - "(f128_eq(f128(FRS2), f128(FRS1)) && (f128(FRS2).v[1] & F64_SIGN));"
    - if (isNaNF128(f128(FRS1)) && isNaNF128(f128(FRS2)))
    - WRITE_FRD(f128(defaultNaNF128()));
    - else
    - 'WRITE_FRD(greater || isNaNF128(f128(FRS2)) ? FRS1 : FRS2);'
    - set_fp_exceptions;
  fmax.s:
    opcode:
    - fmax.s
    - rd
    - rs1
    - rs2
    - 31..27=0x05
    - 14..12=1
    - 26..25=0
    - 6..2=0x14
    - 1..0=3
    opcode_group: f
    opcode_args: *1
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/f.html"
    main_desc: f
    main_id: "#sec:single-float-compute"
    desc:
      f:
        "#sec:single-float-compute":
          text:
          - Floating-point minimum-number and maximum-number instructions FMIN.S and
            FMAX.S write, respectively, the smaller or larger of rs1 and rs2 to rd.
            For the purposes of these instructions only, the value - 0.0 is considered
            to be less than the value + 0.0. If both inputs are NaNs, the result is
            the canonical NaN. If only one operand is a NaN, the result is the non-NaN
            operand. Signaling NaN inputs set the invalid operation exception flag,
            even when the result is not NaN.
          - Note that in version 2.2 of the F extension, the FMIN.S and FMAX.S instructions
            were amended to implement the proposed IEEE 754-201x minimumNumber and
            maximumNumber operations, rather than the IEEE 754-2008 minNum and maxNum
            operations. These operations differ in their handling of signaling NaNs.
    iss_code:
    - require_either_extension('F', EXT_ZFINX);
    - require_fp;
    - bool greater = f32_lt_quiet(FRS2_F, FRS1_F) ||
    - "(f32_eq(FRS2_F, FRS1_F) && (FRS2_F.v & F32_SIGN));"
    - if (isNaNF32UI(FRS1_F.v) && isNaNF32UI(FRS2_F.v))
    - WRITE_FRD_F(f32(defaultNaNF32UI));
    - else
    - 'WRITE_FRD_F((greater || isNaNF32UI(FRS2_F.v) ? FRS1_F : FRS2_F));'
    - set_fp_exceptions;
  fmin.d:
    opcode:
    - fmin.d
    - rd
    - rs1
    - rs2
    - 31..27=0x05
    - 14..12=0
    - 26..25=1
    - 6..2=0x14
    - 1..0=3
    opcode_group: d
    opcode_args: *1
    main_desc: d
    main_id: "#sec:single-float-compute"
    desc:
      d:
        "#sec:single-float-compute":
          text:
          - Floating-point minimum-number and maximum-number instructions FMIN.S and
            FMAX.S write, respectively, the smaller or larger of rs1 and rs2 to rd.
            For the purposes of these instructions only, the value - 0.0 is considered
            to be less than the value + 0.0. If both inputs are NaNs, the result is
            the canonical NaN. If only one operand is a NaN, the result is the non-NaN
            operand. Signaling NaN inputs set the invalid operation exception flag,
            even when the result is not NaN.
          - Note that in version 2.2 of the F extension, the FMIN.S and FMAX.S instructions
            were amended to implement the proposed IEEE 754-201x minimumNumber and
            maximumNumber operations, rather than the IEEE 754-2008 minNum and maxNum
            operations. These operations differ in their handling of signaling NaNs.
    iss_code:
    - require_either_extension('D', EXT_ZDINX);
    - require_fp;
    - bool less = f64_lt_quiet(FRS1_D, FRS2_D) ||
    - "(f64_eq(FRS1_D, FRS2_D) && (FRS1_D.v & F64_SIGN));"
    - if (isNaNF64UI(FRS1_D.v) && isNaNF64UI(FRS2_D.v))
    - WRITE_FRD_D(f64(defaultNaNF64UI));
    - else
    - 'WRITE_FRD_D((less || isNaNF64UI(FRS2_D.v) ? FRS1_D : FRS2_D));'
    - set_fp_exceptions;
  fmin.h:
    opcode:
    - fmin.h
    - rd
    - rs1
    - rs2
    - 31..27=0x05
    - 14..12=0
    - 26..25=2
    - 6..2=0x14
    - 1..0=3
    opcode_group: zfh
    opcode_args: *1
    iss_code:
    - require_either_extension(EXT_ZFH, EXT_ZHINX);
    - require_fp;
    - WRITE_FRD_H(f16_min(FRS1_H, FRS2_H));
    - set_fp_exceptions;
  fmin.q:
    opcode:
    - fmin.q
    - rd
    - rs1
    - rs2
    - 31..27=0x05
    - 14..12=0
    - 26..25=3
    - 6..2=0x14
    - 1..0=3
    opcode_group: q
    opcode_args: *1
    main_desc: q
    main_id: "#sec:single-float-compute"
    desc:
      q:
        "#sec:single-float-compute":
          text:
          - Floating-point minimum-number and maximum-number instructions FMIN.S and
            FMAX.S write, respectively, the smaller or larger of rs1 and rs2 to rd.
            For the purposes of these instructions only, the value - 0.0 is considered
            to be less than the value + 0.0. If both inputs are NaNs, the result is
            the canonical NaN. If only one operand is a NaN, the result is the non-NaN
            operand. Signaling NaN inputs set the invalid operation exception flag,
            even when the result is not NaN.
          - Note that in version 2.2 of the F extension, the FMIN.S and FMAX.S instructions
            were amended to implement the proposed IEEE 754-201x minimumNumber and
            maximumNumber operations, rather than the IEEE 754-2008 minNum and maxNum
            operations. These operations differ in their handling of signaling NaNs.
    iss_code:
    - require_extension('Q');
    - require_fp;
    - bool less = f128_lt_quiet(f128(FRS1), f128(FRS2)) ||
    - "(f128_eq(f128(FRS1), f128(FRS2)) && (f128(FRS1).v[1] & F64_SIGN));"
    - if (isNaNF128(f128(FRS1)) && isNaNF128(f128(FRS2)))
    - WRITE_FRD(f128(defaultNaNF128()));
    - else
    - 'WRITE_FRD(less || isNaNF128(f128(FRS2)) ? FRS1 : FRS2);'
    - set_fp_exceptions;
  fmin.s:
    opcode:
    - fmin.s
    - rd
    - rs1
    - rs2
    - 31..27=0x05
    - 14..12=0
    - 26..25=0
    - 6..2=0x14
    - 1..0=3
    opcode_group: f
    opcode_args: *1
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/f.html"
    main_desc: f
    main_id: "#sec:single-float-compute"
    desc:
      f:
        "#sec:single-float-compute":
          text:
          - Floating-point minimum-number and maximum-number instructions FMIN.S and
            FMAX.S write, respectively, the smaller or larger of rs1 and rs2 to rd.
            For the purposes of these instructions only, the value - 0.0 is considered
            to be less than the value + 0.0. If both inputs are NaNs, the result is
            the canonical NaN. If only one operand is a NaN, the result is the non-NaN
            operand. Signaling NaN inputs set the invalid operation exception flag,
            even when the result is not NaN.
          - Note that in version 2.2 of the F extension, the FMIN.S and FMAX.S instructions
            were amended to implement the proposed IEEE 754-201x minimumNumber and
            maximumNumber operations, rather than the IEEE 754-2008 minNum and maxNum
            operations. These operations differ in their handling of signaling NaNs.
    iss_code:
    - require_either_extension('F', EXT_ZFINX);
    - require_fp;
    - bool less = f32_lt_quiet(FRS1_F, FRS2_F) ||
    - "(f32_eq(FRS1_F, FRS2_F) && (FRS1_F.v & F32_SIGN));"
    - if (isNaNF32UI(FRS1_F.v) && isNaNF32UI(FRS2_F.v))
    - WRITE_FRD_F(f32(defaultNaNF32UI));
    - else
    - 'WRITE_FRD_F((less || isNaNF32UI(FRS2_F.v) ? FRS1_F : FRS2_F));'
    - set_fp_exceptions;
  fmsub.d:
    opcode:
    - fmsub.d
    - rd
    - rs1
    - rs2
    - rs3
    - rm
    - 26..25=1
    - 6..2=0x11
    - 1..0=3
    opcode_group: d
    opcode_args: *22
    main_desc: d
    main_id: "#sec:single-float-compute"
    desc:
      d:
        "#sec:single-float-compute":
          text:
          - FMSUB.S multiplies the values in rs1 and rs2, subtracts the value in rs3,
            and writes the final result to rd. FMSUB.S computes (rs1rs2)-rs3.
    iss_code:
    - require_either_extension('D', EXT_ZDINX);
    - require_fp;
    - softfloat_roundingMode = RM;
    - WRITE_FRD_D(f64_mulAdd(FRS1_D, FRS2_D, f64(FRS3_D.v ^ F64_SIGN)));
    - set_fp_exceptions;
  fmsub.h:
    opcode:
    - fmsub.h
    - rd
    - rs1
    - rs2
    - rs3
    - rm
    - 26..25=2
    - 6..2=0x11
    - 1..0=3
    opcode_group: zfh
    opcode_args: *22
    iss_code:
    - require_either_extension(EXT_ZFH, EXT_ZHINX);
    - require_fp;
    - softfloat_roundingMode = RM;
    - WRITE_FRD_H(f16_mulAdd(FRS1_H, FRS2_H, f16(FRS3_H.v ^ F16_SIGN)));
    - set_fp_exceptions;
  fmsub.q:
    opcode:
    - fmsub.q
    - rd
    - rs1
    - rs2
    - rs3
    - rm
    - 26..25=3
    - 6..2=0x11
    - 1..0=3
    opcode_group: q
    opcode_args: *22
    main_desc: q
    main_id: "#sec:single-float-compute"
    desc:
      q:
        "#sec:single-float-compute":
          text:
          - FMSUB.S multiplies the values in rs1 and rs2, subtracts the value in rs3,
            and writes the final result to rd. FMSUB.S computes (rs1rs2)-rs3.
    iss_code:
    - require_extension('Q');
    - require_fp;
    - softfloat_roundingMode = RM;
    - WRITE_FRD(f128_mulAdd(f128(FRS1), f128(FRS2), f128_negate(f128(FRS3))));
    - set_fp_exceptions;
  fmsub.s:
    opcode:
    - fmsub.s
    - rd
    - rs1
    - rs2
    - rs3
    - rm
    - 26..25=0
    - 6..2=0x11
    - 1..0=3
    opcode_group: f
    opcode_args: *22
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/f.html"
    main_desc: f
    main_id: "#sec:single-float-compute"
    desc:
      f:
        "#sec:single-float-compute":
          text:
          - FMSUB.S multiplies the values in rs1 and rs2, subtracts the value in rs3,
            and writes the final result to rd. FMSUB.S computes (rs1rs2)-rs3.
    iss_code:
    - require_either_extension('F', EXT_ZFINX);
    - require_fp;
    - softfloat_roundingMode = RM;
    - WRITE_FRD_F(f32_mulAdd(FRS1_F, FRS2_F, f32(FRS3_F.v ^ F32_SIGN)));
    - set_fp_exceptions;
  fmul.d:
    opcode:
    - fmul.d
    - rd
    - rs1
    - rs2
    - 31..27=0x02
    - rm
    - 26..25=1
    - 6..2=0x14
    - 1..0=3
    opcode_group: d
    opcode_args: *1
    main_desc: d
    main_id: "#sec:single-float-compute"
    desc:
      d:
        "#sec:single-float-compute":
          text:
          - Floating-point arithmetic instructions with one or two source operands
            use the R-type format with the OP-FP major opcode. FADD.S and FMUL.S perform
            single-precision floating-point addition and multiplication respectively,
            between rs1 and rs2. FSUB.S performs the single-precision floating-point
            subtraction of rs2 from rs1. FDIV.S performs the single-precision floating-point
            division of rs1 by rs2. FSQRT.S computes the square root of rs1. In each
            case, the result is written to rd.
    iss_code:
    - require_either_extension('D', EXT_ZDINX);
    - require_fp;
    - softfloat_roundingMode = RM;
    - WRITE_FRD_D(f64_mul(FRS1_D, FRS2_D));
    - set_fp_exceptions;
  fmul.h:
    opcode:
    - fmul.h
    - rd
    - rs1
    - rs2
    - 31..27=0x02
    - rm
    - 26..25=2
    - 6..2=0x14
    - 1..0=3
    opcode_group: zfh
    opcode_args: *1
    iss_code:
    - require_either_extension(EXT_ZFH, EXT_ZHINX);
    - require_fp;
    - softfloat_roundingMode = RM;
    - WRITE_FRD_H(f16_mul(FRS1_H, FRS2_H));
    - set_fp_exceptions;
  fmul.q:
    opcode:
    - fmul.q
    - rd
    - rs1
    - rs2
    - 31..27=0x02
    - rm
    - 26..25=3
    - 6..2=0x14
    - 1..0=3
    opcode_group: q
    opcode_args: *1
    main_desc: q
    main_id: "#sec:single-float-compute"
    desc:
      q:
        "#sec:single-float-compute":
          text:
          - Floating-point arithmetic instructions with one or two source operands
            use the R-type format with the OP-FP major opcode. FADD.S and FMUL.S perform
            single-precision floating-point addition and multiplication respectively,
            between rs1 and rs2. FSUB.S performs the single-precision floating-point
            subtraction of rs2 from rs1. FDIV.S performs the single-precision floating-point
            division of rs1 by rs2. FSQRT.S computes the square root of rs1. In each
            case, the result is written to rd.
    iss_code:
    - require_extension('Q');
    - require_fp;
    - softfloat_roundingMode = RM;
    - WRITE_FRD(f128_mul(f128(FRS1), f128(FRS2)));
    - set_fp_exceptions;
  fmul.s:
    opcode:
    - fmul.s
    - rd
    - rs1
    - rs2
    - 31..27=0x02
    - rm
    - 26..25=0
    - 6..2=0x14
    - 1..0=3
    opcode_group: f
    opcode_args: *1
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/f.html"
    main_desc: f
    main_id: "#sec:single-float-compute"
    desc:
      f:
        "#sec:single-float-compute":
          text:
          - Floating-point arithmetic instructions with one or two source operands
            use the R-type format with the OP-FP major opcode. FADD.S and FMUL.S perform
            single-precision floating-point addition and multiplication respectively,
            between rs1 and rs2. FSUB.S performs the single-precision floating-point
            subtraction of rs2 from rs1. FDIV.S performs the single-precision floating-point
            division of rs1 by rs2. FSQRT.S computes the square root of rs1. In each
            case, the result is written to rd.
    iss_code:
    - require_either_extension('F', EXT_ZFINX);
    - require_fp;
    - softfloat_roundingMode = RM;
    - WRITE_FRD_F(f32_mul(FRS1_F, FRS2_F));
    - set_fp_exceptions;
  fmv.d:
    opcode:
    - fmv.d
    - rd
    - rs
    opcode_group: psuedo
    opcode_args:
    - rd
    - rs
    psuedo_to_base:
    - fsgnj.d rd, rs, rs
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/d.html"
    main_desc: d
    main_id: "#double-precision-floating-point-conversion-and-move-instructions"
    desc:
      d:
        "#double-precision-floating-point-conversion-and-move-instructions":
          text:
          - For XLEN>=64 only, instructions are provided to move bit patterns between
            the floating-point and integer registers. FMV.X.D moves the double-precision
            value in floating-point register rs1 to a representation in IEEE 754-2008
            standard encoding in integer register rd. FMV.D.X moves the double-precision
            value encoded in IEEE 754-2008 standard encoding from the integer register
            rs1 to the floating-point register rd.
          - FMV.X.D and FMV.D.X do not modify the bits being transferred; in particular,
            the payloads of non-canonical NaNs are preserved.
      zfinx:
        "#zdinx":
          text:
          - The Zdinx extension adds all of the instructions that the D extension
            adds, except for the transfer instructions FLD, FSD, FMV.D.X, FMV.X.D,
            C.FLD[SP], and C.FSD[SP].
  fmv.d.x:
    opcode:
    - fmv.d.x
    - rd
    - rs1
    - 24..20=0
    - 31..27=0x1E
    - 14..12=0
    - 26..25=1
    - 6..2=0x14
    - 1..0=3
    opcode_group: d
    opcode_args: *3
    main_desc: d
    main_id: "#single-precision-floating-point-conversion-and-move-instructions"
    desc:
      d:
        "#single-precision-floating-point-conversion-and-move-instructions":
          text:
          - Floating-point to floating-point sign-injection instructions, FSGNJ.S,
            FSGNJN.S, and FSGNJX.S, produce a result that takes all bits except the
            sign bit from rs1. For FSGNJ, the result's sign bit is rs2's sign bit;
            for FSGNJN, the result's sign bit is the opposite of rs2's sign bit; and
            for FSGNJX, the sign bit is the XOR of the sign bits of rs1 and rs2. Sign-injection
            instructions do not set floating-point exception flags, nor do they canonicalize
            NaNs. Note, FSGNJ.S rx, ry, ry moves ry to rx (assembler pseudoinstruction
            FMV.S rx, ry); FSGNJN.S rx, ry, ry moves the negation of ry to rx (assembler
            pseudoinstruction FNEG.S rx, ry); and FSGNJX.S rx, ry, ry moves the absolute
            value of ry to rx (assembler pseudoinstruction FABS.S rx, ry).
          - The FMV.W.X and FMV.X.W instructions were previously called FMV.S.X and
            FMV.X.S. The use of W is more consistent with their semantics as an instruction
            that moves 32 bits without interpreting them. This became clearer after
            defining NaN-boxing. To avoid disturbing existing code, both the W and
            S versions will be supported by tools.
  fmv.h.x:
    opcode:
    - fmv.h.x
    - rd
    - rs1
    - 24..20=0
    - 31..27=0x1E
    - 14..12=0
    - 26..25=2
    - 6..2=0x14
    - 1..0=3
    opcode_group: zfh
    opcode_args: *3
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/zfh.html"
    main_desc: zfh
    main_id: "#half-precision-convert-and-move-instructions"
    desc:
      zfh:
        "#half-precision-convert-and-move-instructions":
          text:
          - FMV.H.X moves the half-precision value encoded in IEEE 754-2008 standard
            encoding from the lower 16 bits of integer register rs1 to the floating-point
            register rd, NaN-boxing the result.
          - FMV.X.H and FMV.H.X do not modify the bits being transferred; in particular,
            the payloads of non-canonical NaNs are preserved.
        "#zfhmin-standard-extension-for-minimal-half-precision-floating-point-support":
          text:
          - 'The Zfhmin extension includes the following instructions from the Zfh
            extension: FLH, FSH, FMV.X.H, FMV.H.X, FCVT.S.H, and FCVT.H.S. If the
            D extension is present, the FCVT.D.H and FCVT.H.D instructions are also
            included. If the Q extension is present, the FCVT.Q.H and FCVT.H.Q instructions
            are additionally included.'
      zfinx:
        "#zhinx":
          text:
          - The Zhinx extension adds all of the instructions that the Zfh extension
            adds, except for the transfer instructions FLH, FSH, FMV.H.X, and FMV.X.H.
  fmv.s:
    opcode:
    - fmv.s
    - rd
    - rs
    opcode_group: psuedo
    opcode_args:
    - rd
    - rs
    psuedo_to_base:
    - fsgnj.s rd, rs, rs
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/f.html"
    main_desc: f
    main_id: "#single-precision-floating-point-conversion-and-move-instructions"
    desc:
      f:
        "#single-precision-floating-point-conversion-and-move-instructions":
          text:
          - Floating-point to floating-point sign-injection instructions, FSGNJ.S,
            FSGNJN.S, and FSGNJX.S, produce a result that takes all bits except the
            sign bit from rs1. For FSGNJ, the result's sign bit is rs2's sign bit;
            for FSGNJN, the result's sign bit is the opposite of rs2's sign bit; and
            for FSGNJX, the sign bit is the XOR of the sign bits of rs1 and rs2. Sign-injection
            instructions do not set floating-point exception flags, nor do they canonicalize
            NaNs. Note, FSGNJ.S rx, ry, ry moves ry to rx (assembler pseudoinstruction
            FMV.S rx, ry); FSGNJN.S rx, ry, ry moves the negation of ry to rx (assembler
            pseudoinstruction FNEG.S rx, ry); and FSGNJX.S rx, ry, ry moves the absolute
            value of ry to rx (assembler pseudoinstruction FABS.S rx, ry).
          - The FMV.W.X and FMV.X.W instructions were previously called FMV.S.X and
            FMV.X.S. The use of W is more consistent with their semantics as an instruction
            that moves 32 bits without interpreting them. This became clearer after
            defining NaN-boxing. To avoid disturbing existing code, both the W and
            S versions will be supported by tools.
  fmv.s.x:
    opcode:
    - fmv.s.x
    - rd
    - rs1
    - 24..20=0
    - 31..27=0x1E
    - 14..12=0
    - 26..25=0
    - 6..2=0x14
    - 1..0=3
    opcode_group: f
    opcode_args: *3
    pseudo_src: rv_f
    pseudo_op: fmv.w.x
  fmv.w.x:
    opcode:
    - fmv.w.x
    - rd
    - rs1
    - 24..20=0
    - 31..27=0x1E
    - 14..12=0
    - 26..25=0
    - 6..2=0x14
    - 1..0=3
    opcode_group: f
    opcode_args: *3
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/f.html"
    main_desc: f
    main_id: "#single-precision-floating-point-conversion-and-move-instructions"
    desc:
      f:
        "#single-precision-floating-point-conversion-and-move-instructions":
          text:
          - FMV.W.X moves the single-precision value encoded in IEEE 754-2008 standard
            encoding from the lower 32 bits of integer register rs1 to the floating-point
            register rd. The bits are not modified in the transfer, and in particular,
            the payloads of non-canonical NaNs are preserved.
          - The FMV.W.X and FMV.X.W instructions were previously called FMV.S.X and
            FMV.X.S. The use of W is more consistent with their semantics as an instruction
            that moves 32 bits without interpreting them. This became clearer after
            defining NaN-boxing. To avoid disturbing existing code, both the W and
            S versions will be supported by tools.
      zfinx:
        "#sec:zfinx":
          text:
          - The Zfinx extension adds all of the instructions that the F extension
            adds, except for the transfer instructions FLW, FSW, FMV.W.X, FMV.X.W,
            C.FLW[SP], and C.FSW[SP].
  fmv.x.d:
    opcode:
    - fmv.x.d
    - rd
    - rs1
    - 24..20=0
    - 31..27=0x1C
    - 14..12=0
    - 26..25=1
    - 6..2=0x14
    - 1..0=3
    opcode_group: d
    opcode_args: *3
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/d.html"
    main_desc: d
    main_id: "#double-precision-floating-point-conversion-and-move-instructions"
    desc:
      d:
        "#double-precision-floating-point-conversion-and-move-instructions":
          text:
          - For XLEN>=64 only, instructions are provided to move bit patterns between
            the floating-point and integer registers. FMV.X.D moves the double-precision
            value in floating-point register rs1 to a representation in IEEE 754-2008
            standard encoding in integer register rd. FMV.D.X moves the double-precision
            value encoded in IEEE 754-2008 standard encoding from the integer register
            rs1 to the floating-point register rd.
          - FMV.X.D and FMV.D.X do not modify the bits being transferred; in particular,
            the payloads of non-canonical NaNs are preserved.
      zfinx:
        "#zdinx":
          text:
          - The Zdinx extension adds all of the instructions that the D extension
            adds, except for the transfer instructions FLD, FSD, FMV.D.X, FMV.X.D,
            C.FLD[SP], and C.FSD[SP].
  fmv.x.h:
    opcode:
    - fmv.x.h
    - rd
    - rs1
    - 24..20=0
    - 31..27=0x1C
    - 14..12=0
    - 26..25=2
    - 6..2=0x14
    - 1..0=3
    opcode_group: zfh
    opcode_args: *3
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/zfh.html"
    main_desc: zfh
    main_id: "#half-precision-convert-and-move-instructions"
    desc:
      zfh:
        "#half-precision-convert-and-move-instructions":
          text:
          - Instructions are provided to move bit patterns between the floating-point
            and integer registers. FMV.X.H moves the half-precision value in floating-point
            register rs1 to a representation in IEEE 754-2008 standard encoding in
            integer register rd, filling the upper XLEN-16 bits with copies of the
            floating-point number's sign bit.
          - FMV.X.H and FMV.H.X do not modify the bits being transferred; in particular,
            the payloads of non-canonical NaNs are preserved.
        "#zfhmin-standard-extension-for-minimal-half-precision-floating-point-support":
          text:
          - 'The Zfhmin extension includes the following instructions from the Zfh
            extension: FLH, FSH, FMV.X.H, FMV.H.X, FCVT.S.H, and FCVT.H.S. If the
            D extension is present, the FCVT.D.H and FCVT.H.D instructions are also
            included. If the Q extension is present, the FCVT.Q.H and FCVT.H.Q instructions
            are additionally included.'
      zfinx:
        "#zhinx":
          text:
          - The Zhinx extension adds all of the instructions that the Zfh extension
            adds, except for the transfer instructions FLH, FSH, FMV.H.X, and FMV.X.H.
  fmv.x.s:
    opcode:
    - fmv.x.s
    - rd
    - rs1
    - 24..20=0
    - 31..27=0x1C
    - 14..12=0
    - 26..25=0
    - 6..2=0x14
    - 1..0=3
    opcode_group: f
    opcode_args: *3
    pseudo_src: rv_f
    pseudo_op: fmv.x.w
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/f.html"
    main_desc: f
    main_id: "#single-precision-floating-point-conversion-and-move-instructions"
    desc:
      f:
        "#single-precision-floating-point-conversion-and-move-instructions":
          text:
          - The FMV.W.X and FMV.X.W instructions were previously called FMV.S.X and
            FMV.X.S. The use of W is more consistent with their semantics as an instruction
            that moves 32 bits without interpreting them. This became clearer after
            defining NaN-boxing. To avoid disturbing existing code, both the W and
            S versions will be supported by tools.
  fmv.x.w:
    opcode:
    - fmv.x.w
    - rd
    - rs1
    - 24..20=0
    - 31..27=0x1C
    - 14..12=0
    - 26..25=0
    - 6..2=0x14
    - 1..0=3
    opcode_group: f
    opcode_args: *3
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/f.html"
    main_desc: f
    main_id: "#single-precision-floating-point-conversion-and-move-instructions"
    desc:
      f:
        "#single-precision-floating-point-conversion-and-move-instructions":
          text:
          - Instructions are provided to move bit patterns between the floating-point
            and integer registers. FMV.X.W moves the single-precision value in floating-point
            register rs1 represented in IEEE 754-2008 encoding to the lower 32 bits
            of integer register rd. The bits are not modified in the transfer, and
            in particular, the payloads of non-canonical NaNs are preserved. For RV64,
            the higher 32 bits of the destination register are filled with copies
            of the floating-point number's sign bit.
          - The FMV.W.X and FMV.X.W instructions were previously called FMV.S.X and
            FMV.X.S. The use of W is more consistent with their semantics as an instruction
            that moves 32 bits without interpreting them. This became clearer after
            defining NaN-boxing. To avoid disturbing existing code, both the W and
            S versions will be supported by tools.
      zfinx:
        "#sec:zfinx":
          text:
          - The Zfinx extension adds all of the instructions that the F extension
            adds, except for the transfer instructions FLW, FSW, FMV.W.X, FMV.X.W,
            C.FLW[SP], and C.FSW[SP].
  fneg.d:
    opcode:
    - fneg.d
    - rd
    - rs
    opcode_group: psuedo
    opcode_args:
    - rd
    - rs
    psuedo_to_base:
    - fsgnjn.d rd, rs, rs
    main_desc: d
    main_id: "#single-precision-floating-point-conversion-and-move-instructions"
    desc:
      d:
        "#single-precision-floating-point-conversion-and-move-instructions":
          text:
          - Floating-point to floating-point sign-injection instructions, FSGNJ.S,
            FSGNJN.S, and FSGNJX.S, produce a result that takes all bits except the
            sign bit from rs1. For FSGNJ, the result's sign bit is rs2's sign bit;
            for FSGNJN, the result's sign bit is the opposite of rs2's sign bit; and
            for FSGNJX, the sign bit is the XOR of the sign bits of rs1 and rs2. Sign-injection
            instructions do not set floating-point exception flags, nor do they canonicalize
            NaNs. Note, FSGNJ.S rx, ry, ry moves ry to rx (assembler pseudoinstruction
            FMV.S rx, ry); FSGNJN.S rx, ry, ry moves the negation of ry to rx (assembler
            pseudoinstruction FNEG.S rx, ry); and FSGNJX.S rx, ry, ry moves the absolute
            value of ry to rx (assembler pseudoinstruction FABS.S rx, ry).
  fneg.s:
    opcode:
    - fneg.s
    - rd
    - rs
    opcode_group: psuedo
    opcode_args:
    - rd
    - rs
    psuedo_to_base:
    - fsgnjn.s rd, rs, rs
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/f.html"
    main_desc: f
    main_id: "#single-precision-floating-point-conversion-and-move-instructions"
    desc:
      f:
        "#single-precision-floating-point-conversion-and-move-instructions":
          text:
          - Floating-point to floating-point sign-injection instructions, FSGNJ.S,
            FSGNJN.S, and FSGNJX.S, produce a result that takes all bits except the
            sign bit from rs1. For FSGNJ, the result's sign bit is rs2's sign bit;
            for FSGNJN, the result's sign bit is the opposite of rs2's sign bit; and
            for FSGNJX, the sign bit is the XOR of the sign bits of rs1 and rs2. Sign-injection
            instructions do not set floating-point exception flags, nor do they canonicalize
            NaNs. Note, FSGNJ.S rx, ry, ry moves ry to rx (assembler pseudoinstruction
            FMV.S rx, ry); FSGNJN.S rx, ry, ry moves the negation of ry to rx (assembler
            pseudoinstruction FNEG.S rx, ry); and FSGNJX.S rx, ry, ry moves the absolute
            value of ry to rx (assembler pseudoinstruction FABS.S rx, ry).
  fnmadd.d:
    opcode:
    - fnmadd.d
    - rd
    - rs1
    - rs2
    - rs3
    - rm
    - 26..25=1
    - 6..2=0x13
    - 1..0=3
    opcode_group: d
    opcode_args: *22
    main_desc: d
    main_id: "#sec:single-float-compute"
    desc:
      d:
        "#sec:single-float-compute":
          text:
          - FNMADD.S multiplies the values in rs1 and rs2, negates the product, subtracts
            the value in rs3, and writes the final result to rd. FNMADD.S computes
            -(rs1rs2)-rs3.
    iss_code:
    - require_either_extension('D', EXT_ZDINX);
    - require_fp;
    - softfloat_roundingMode = RM;
    - WRITE_FRD_D(f64_mulAdd(f64(FRS1_D.v ^ F64_SIGN), FRS2_D, f64(FRS3_D.v ^ F64_SIGN)));
    - set_fp_exceptions;
  fnmadd.h:
    opcode:
    - fnmadd.h
    - rd
    - rs1
    - rs2
    - rs3
    - rm
    - 26..25=2
    - 6..2=0x13
    - 1..0=3
    opcode_group: zfh
    opcode_args: *22
    iss_code:
    - require_either_extension(EXT_ZFH, EXT_ZHINX);
    - require_fp;
    - softfloat_roundingMode = RM;
    - WRITE_FRD_H(f16_mulAdd(f16(FRS1_H.v ^ F16_SIGN), FRS2_H, f16(FRS3_H.v ^ F16_SIGN)));
    - set_fp_exceptions;
  fnmadd.q:
    opcode:
    - fnmadd.q
    - rd
    - rs1
    - rs2
    - rs3
    - rm
    - 26..25=3
    - 6..2=0x13
    - 1..0=3
    opcode_group: q
    opcode_args: *22
    main_desc: q
    main_id: "#sec:single-float-compute"
    desc:
      q:
        "#sec:single-float-compute":
          text:
          - FNMADD.S multiplies the values in rs1 and rs2, negates the product, subtracts
            the value in rs3, and writes the final result to rd. FNMADD.S computes
            -(rs1rs2)-rs3.
    iss_code:
    - require_extension('Q');
    - require_fp;
    - softfloat_roundingMode = RM;
    - WRITE_FRD(f128_mulAdd(f128_negate(f128(FRS1)), f128(FRS2), f128_negate(f128(FRS3))));
    - set_fp_exceptions;
  fnmadd.s:
    opcode:
    - fnmadd.s
    - rd
    - rs1
    - rs2
    - rs3
    - rm
    - 26..25=0
    - 6..2=0x13
    - 1..0=3
    opcode_group: f
    opcode_args: *22
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/f.html"
    main_desc: f
    main_id: "#sec:single-float-compute"
    desc:
      f:
        "#sec:single-float-compute":
          text:
          - FNMADD.S multiplies the values in rs1 and rs2, negates the product, subtracts
            the value in rs3, and writes the final result to rd. FNMADD.S computes
            -(rs1rs2)-rs3.
    iss_code:
    - require_either_extension('F', EXT_ZFINX);
    - require_fp;
    - softfloat_roundingMode = RM;
    - WRITE_FRD_F(f32_mulAdd(f32(FRS1_F.v ^ F32_SIGN), FRS2_F, f32(FRS3_F.v ^ F32_SIGN)));
    - set_fp_exceptions;
  fnmsub.d:
    opcode:
    - fnmsub.d
    - rd
    - rs1
    - rs2
    - rs3
    - rm
    - 26..25=1
    - 6..2=0x12
    - 1..0=3
    opcode_group: d
    opcode_args: *22
    main_desc: d
    main_id: "#sec:single-float-compute"
    desc:
      d:
        "#sec:single-float-compute":
          text:
          - FNMSUB.S multiplies the values in rs1 and rs2, negates the product, adds
            the value in rs3, and writes the final result to rd. FNMSUB.S computes
            -(rs1rs2)+rs3.
    iss_code:
    - require_either_extension('D', EXT_ZDINX);
    - require_fp;
    - softfloat_roundingMode = RM;
    - WRITE_FRD_D(f64_mulAdd(f64(FRS1_D.v ^ F64_SIGN), FRS2_D, FRS3_D));
    - set_fp_exceptions;
  fnmsub.h:
    opcode:
    - fnmsub.h
    - rd
    - rs1
    - rs2
    - rs3
    - rm
    - 26..25=2
    - 6..2=0x12
    - 1..0=3
    opcode_group: zfh
    opcode_args: *22
    iss_code:
    - require_either_extension(EXT_ZFH, EXT_ZHINX);
    - require_fp;
    - softfloat_roundingMode = RM;
    - WRITE_FRD_H(f16_mulAdd(f16(FRS1_H.v ^ F16_SIGN), FRS2_H, FRS3_H));
    - set_fp_exceptions;
  fnmsub.q:
    opcode:
    - fnmsub.q
    - rd
    - rs1
    - rs2
    - rs3
    - rm
    - 26..25=3
    - 6..2=0x12
    - 1..0=3
    opcode_group: q
    opcode_args: *22
    main_desc: q
    main_id: "#sec:single-float-compute"
    desc:
      q:
        "#sec:single-float-compute":
          text:
          - FNMSUB.S multiplies the values in rs1 and rs2, negates the product, adds
            the value in rs3, and writes the final result to rd. FNMSUB.S computes
            -(rs1rs2)+rs3.
    iss_code:
    - require_extension('Q');
    - require_fp;
    - softfloat_roundingMode = RM;
    - WRITE_FRD(f128_mulAdd(f128_negate(f128(FRS1)), f128(FRS2), f128(FRS3)));
    - set_fp_exceptions;
  fnmsub.s:
    opcode:
    - fnmsub.s
    - rd
    - rs1
    - rs2
    - rs3
    - rm
    - 26..25=0
    - 6..2=0x12
    - 1..0=3
    opcode_group: f
    opcode_args: *22
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/f.html"
    main_desc: f
    main_id: "#sec:single-float-compute"
    desc:
      f:
        "#sec:single-float-compute":
          text:
          - FNMSUB.S multiplies the values in rs1 and rs2, negates the product, adds
            the value in rs3, and writes the final result to rd. FNMSUB.S computes
            -(rs1rs2)+rs3.
    iss_code:
    - require_either_extension('F', EXT_ZFINX);
    - require_fp;
    - softfloat_roundingMode = RM;
    - WRITE_FRD_F(f32_mulAdd(f32(FRS1_F.v ^ F32_SIGN), FRS2_F, FRS3_F));
    - set_fp_exceptions;
  frcsr:
    opcode:
    - frcsr
    - rd
    - 19..15=0
    - 31..20=0x003
    - 14..12=2
    - 6..2=0x1C
    - 1..0=3
    opcode_group: zicsr
    opcode_args: &23
    - rd
    pseudo_src: rv_zicsr
    pseudo_op: csrrs
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/f.html"
    main_desc: f
    main_id: "#floating-point-control-and-status-register"
    desc:
      f:
        "#floating-point-control-and-status-register":
          text:
          - The fcsr register can be read and written with the FRCSR and FSCSR instructions,
            which are assembler pseudoinstructions built on the underlying CSR access
            instructions. FRCSR reads fcsr by copying it into integer register rd.
            FSCSR swaps the value in fcsr by copying the original value into integer
            register rd, and then writing a new value obtained from integer register
            rs1 into fcsr.
  frflags:
    opcode:
    - frflags
    - rd
    - 19..15=0
    - 31..20=0x001
    - 14..12=2
    - 6..2=0x1C
    - 1..0=3
    opcode_group: zicsr
    opcode_args: *23
    pseudo_src: rv_zicsr
    pseudo_op: csrrs
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/f.html"
    main_desc: f
    main_id: "#floating-point-control-and-status-register"
    desc:
      f:
        "#floating-point-control-and-status-register":
          text:
          - The fields within the fcsr can also be accessed individually through different
            CSR addresses, and separate assembler pseudoinstructions are defined for
            these accesses. The FRRM instruction reads the Rounding Mode field frm
            and copies it into the least-significant three bits of integer register
            rd, with zero in all other bits. FSRM swaps the value in frm by copying
            the original value into integer register rd, and then writing a new value
            obtained from the three least-significant bits of integer register rs1
            into frm. FRFLAGS and FSFLAGS are defined analogously for the Accrued
            Exception Flags field fflags.
  frrm:
    opcode:
    - frrm
    - rd
    - 19..15=0
    - 31..20=0x002
    - 14..12=2
    - 6..2=0x1C
    - 1..0=3
    opcode_group: zicsr
    opcode_args: *23
    pseudo_src: rv_zicsr
    pseudo_op: csrrs
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/f.html"
    main_desc: f
    main_id: "#floating-point-control-and-status-register"
    desc:
      f:
        "#floating-point-control-and-status-register":
          text:
          - The fields within the fcsr can also be accessed individually through different
            CSR addresses, and separate assembler pseudoinstructions are defined for
            these accesses. The FRRM instruction reads the Rounding Mode field frm
            and copies it into the least-significant three bits of integer register
            rd, with zero in all other bits. FSRM swaps the value in frm by copying
            the original value into integer register rd, and then writing a new value
            obtained from the three least-significant bits of integer register rs1
            into frm. FRFLAGS and FSFLAGS are defined analogously for the Accrued
            Exception Flags field fflags.
  fscsr:
    opcode:
    - fscsr
    - rd
    - rs1
    - 31..20=0x003
    - 14..12=1
    - 6..2=0x1C
    - 1..0=3
    opcode_group: zicsr
    opcode_args: *3
    pseudo_src: rv_zicsr
    pseudo_op: csrrw
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/f.html"
    main_desc: f
    main_id: "#floating-point-control-and-status-register"
    desc:
      f:
        "#floating-point-control-and-status-register":
          text:
          - The fcsr register can be read and written with the FRCSR and FSCSR instructions,
            which are assembler pseudoinstructions built on the underlying CSR access
            instructions. FRCSR reads fcsr by copying it into integer register rd.
            FSCSR swaps the value in fcsr by copying the original value into integer
            register rd, and then writing a new value obtained from integer register
            rs1 into fcsr.
  fsd:
    opcode:
    - fsd
    - imm12hi
    - rs1
    - rs2
    - imm12lo
    - 14..12=3
    - 6..2=0x09
    - 1..0=3
    opcode_group: d
    opcode_args: &24
    - rs1
    - rs2
    - imm12
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/d.html"
    main_desc: d
    main_id: "#fld_fsd"
    desc:
      d:
        "#fld_fsd":
          text:
          - The FLD instruction loads a double-precision floating-point value from
            memory into floating-point register rd. FSD stores a double-precision
            value from the floating-point registers to memory.
          - FLD and FSD are only guaranteed to execute atomically if the effective
            address is naturally aligned and XLEN>=64.
          - FLD and FSD do not modify the bits being transferred; in particular, the
            payloads of non-canonical NaNs are preserved.
      rvwmo:
        "#sec:rvwmo:primitives":
          text:
          - Among instructions in RV32GC and RV64GC, each aligned memory instruction
            gives rise to exactly one memory operation, with two exceptions. First,
            an unsuccessful SC instruction does not give rise to any memory operations.
            Second, FLD and FSD instructions may each give rise to multiple memory
            operations if XLEN<64, as stated in Section [fld_fsd] and clarified below.
            An aligned AMO gives rise to a single memory operation that is both a
            load operation and a store operation simultaneously.
          - A misaligned load or store instruction may be decomposed into a set of
            component memory operations of any granularity. An FLD or FSD instruction
            for which XLEN<64 may also be decomposed into a set of component memory
            operations of any granularity. The memory operations generated by such
            instructions are not ordered with respect to each other in program order,
            but they are ordered normally with respect to the memory operations generated
            by preceding and subsequent instructions in program order. The atomics
            extension "A" does not require execution environments to support misaligned
            atomic instructions at all; however, if misaligned atomics are supported
            via the "Zam" extension, LRs, SCs, and AMOs may be decomposed subject
            to the constraints of the atomicity axiom for misaligned atomics, which
            is defined in Chapter [sec:zam] .
      zfinx:
        "#zdinx":
          text:
          - The Zdinx extension adds all of the instructions that the D extension
            adds, except for the transfer instructions FLD, FSD, FMV.D.X, FMV.X.D,
            C.FLD[SP], and C.FSD[SP].
      machine:
        "#priority-and-matching-logic":
          text:
          - On some implementations, misaligned loads, stores, and instruction fetches
            may also be decomposed into multiple accesses, some of which may succeed
            before an access-fault exception occurs. In particular, a portion of a
            misaligned store that passes the PMP check may become visible, even if
            another portion fails the PMP check. The same behavior may manifest for
            floating-point stores wider than XLEN bits (e.g., the FSD instruction
            in RV32D), even when the store address is naturally aligned.
      hypervisor:
        "#sec:tinst-vals":
          text:
          - For a standard store instruction that is not a compressed instruction
            and is one of SB, SH, SW, SD, FSW, FSD, FSQ, or FSH, the transformed instruction
            has the format shown in Figure 1.47 .
          - Transformed noncompressed store instruction (SB, SH, SW, SD, FSW, FSD,
            FSQ, or FSH). Fields rs2, funct3, and opcode are the same as the trapping
            store instruction.
          - In decoding the contents of mtinst or htinst, once software has determined
            that the register contains the encoding of a standard basic load (LB,
            LBU, LH, LHU, LW, LWU, LD, FLW, FLD, FLQ, or FLH) or basic store (SB,
            SH, SW, SD, FSW, FSD, FSQ, or FSH), it is not necessary to confirm also
            that the immediate offset fields (31:25, and 24:20 or 11:7) are zeros.
            The knowledge that the register's value is the encoding of a basic load/store
            is sufficient to prove that the trapping instruction is of the same kind.
      v:
        "#sec-vector-loadstore-width-encoding":
          text:
          - FLD/FSD
    iss_code:
    - require_extension('D');
    - require_fp;
    - MMU.store<uint64_t>(RS1 + insn.s_imm(), FRS2.v[0]);
  fsflags:
    opcode:
    - fsflags
    - rd
    - rs1
    - 31..20=0x001
    - 14..12=1
    - 6..2=0x1C
    - 1..0=3
    opcode_group: zicsr
    opcode_args: *3
    pseudo_src: rv_zicsr
    pseudo_op: csrrw
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/f.html"
    main_desc: f
    main_id: "#floating-point-control-and-status-register"
    desc:
      f:
        "#floating-point-control-and-status-register":
          text:
          - The fields within the fcsr can also be accessed individually through different
            CSR addresses, and separate assembler pseudoinstructions are defined for
            these accesses. The FRRM instruction reads the Rounding Mode field frm
            and copies it into the least-significant three bits of integer register
            rd, with zero in all other bits. FSRM swaps the value in frm by copying
            the original value into integer register rd, and then writing a new value
            obtained from the three least-significant bits of integer register rs1
            into frm. FRFLAGS and FSFLAGS are defined analogously for the Accrued
            Exception Flags field fflags.
  fsflagsi:
    opcode:
    - fsflagsi
    - rd
    - zimm
    - 31..20=0x001
    - 14..12=5
    - 6..2=0x1C
    - 1..0=3
    opcode_group: zicsr
    opcode_args: *20
    pseudo_src: rv_zicsr
    pseudo_op: csrrwi
  fsgnj.d:
    opcode:
    - fsgnj.d
    - rd
    - rs1
    - rs2
    - 31..27=0x04
    - 14..12=0
    - 26..25=1
    - 6..2=0x14
    - 1..0=3
    opcode_group: d
    opcode_args: *1
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/d.html"
    main_desc: d
    main_id: "#double-precision-floating-point-conversion-and-move-instructions"
    desc:
      d:
        "#double-precision-floating-point-conversion-and-move-instructions":
          text:
          - Floating-point to floating-point sign-injection instructions, FSGNJ.D,
            FSGNJN.D, and FSGNJX.D are defined analogously to the single-precision
            sign-injection instruction.
      zfinx:
        "#processing-of-wider-values":
          text:
          - Load-pair and store-pair instructions are not provided, so transferring
            double-precision operands in RV32Zdinx from or to memory requires two
            loads or stores. Register moves need only a single FSGNJ.D instruction,
            however.
    iss_code:
    - require_either_extension('D', EXT_ZDINX);
    - require_fp;
    - WRITE_FRD_D(fsgnj64(freg(FRS1_D), freg(FRS2_D), false, false));
  fsgnj.h:
    opcode:
    - fsgnj.h
    - rd
    - rs1
    - rs2
    - 31..27=0x04
    - 14..12=0
    - 26..25=2
    - 6..2=0x14
    - 1..0=3
    opcode_group: zfh
    opcode_args: *1
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/zfh.html"
    main_desc: zfh
    main_id: "#half-precision-convert-and-move-instructions"
    desc:
      zfh:
        "#half-precision-convert-and-move-instructions":
          text:
          - Floating-point to floating-point sign-injection instructions, FSGNJ.H,
            FSGNJN.H, and FSGNJX.H are defined analogously to the single-precision
            sign-injection instruction.
        "#zfhmin-standard-extension-for-minimal-half-precision-floating-point-support":
          text:
          - Zfhmin does not include the FSGNJ.H instruction, because it suffices to
            instead use the FSGNJ.S instruction to move half-precision values between
            floating-point registers.
    iss_code:
    - require_either_extension(EXT_ZFH, EXT_ZHINX);
    - require_fp;
    - WRITE_FRD_H(fsgnj16(freg(FRS1_H), freg(FRS2_H), false, false));
  fsgnj.q:
    opcode:
    - fsgnj.q
    - rd
    - rs1
    - rs2
    - 31..27=0x04
    - 14..12=0
    - 26..25=3
    - 6..2=0x14
    - 1..0=3
    opcode_group: q
    opcode_args: *1
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/q.html"
    main_desc: q
    main_id: "#quad-precision-convert-and-move-instructions"
    desc:
      q:
        "#quad-precision-convert-and-move-instructions":
          text:
          - Floating-point to floating-point sign-injection instructions, FSGNJ.Q,
            FSGNJN.Q, and FSGNJX.Q are defined analogously to the double-precision
            sign-injection instruction.
    iss_code:
    - require_extension('Q');
    - require_fp;
    - WRITE_FRD(fsgnj128(FRS1, FRS2, false, false));
  fsgnj.s:
    opcode:
    - fsgnj.s
    - rd
    - rs1
    - rs2
    - 31..27=0x04
    - 14..12=0
    - 26..25=0
    - 6..2=0x14
    - 1..0=3
    opcode_group: f
    opcode_args: *1
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/f.html"
    main_desc: f
    main_id: "#single-precision-floating-point-conversion-and-move-instructions"
    desc:
      f:
        "#single-precision-floating-point-conversion-and-move-instructions":
          text:
          - Floating-point to floating-point sign-injection instructions, FSGNJ.S,
            FSGNJN.S, and FSGNJX.S, produce a result that takes all bits except the
            sign bit from rs1. For FSGNJ, the result's sign bit is rs2's sign bit;
            for FSGNJN, the result's sign bit is the opposite of rs2's sign bit; and
            for FSGNJX, the sign bit is the XOR of the sign bits of rs1 and rs2. Sign-injection
            instructions do not set floating-point exception flags, nor do they canonicalize
            NaNs. Note, FSGNJ.S rx, ry, ry moves ry to rx (assembler pseudoinstruction
            FMV.S rx, ry); FSGNJN.S rx, ry, ry moves the negation of ry to rx (assembler
            pseudoinstruction FNEG.S rx, ry); and FSGNJX.S rx, ry, ry moves the absolute
            value of ry to rx (assembler pseudoinstruction FABS.S rx, ry).
      zfh:
        "#zfhmin-standard-extension-for-minimal-half-precision-floating-point-support":
          text:
          - Zfhmin does not include the FSGNJ.H instruction, because it suffices to
            instead use the FSGNJ.S instruction to move half-precision values between
            floating-point registers.
    iss_code:
    - require_either_extension('F', EXT_ZFINX);
    - require_fp;
    - WRITE_FRD_F(fsgnj32(freg(FRS1_F), freg(FRS2_F), false, false));
  fsgnjn.d:
    opcode:
    - fsgnjn.d
    - rd
    - rs1
    - rs2
    - 31..27=0x04
    - 14..12=1
    - 26..25=1
    - 6..2=0x14
    - 1..0=3
    opcode_group: d
    opcode_args: *1
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/d.html"
    main_desc: d
    main_id: "#double-precision-floating-point-conversion-and-move-instructions"
    desc:
      d:
        "#double-precision-floating-point-conversion-and-move-instructions":
          text:
          - Floating-point to floating-point sign-injection instructions, FSGNJ.D,
            FSGNJN.D, and FSGNJX.D are defined analogously to the single-precision
            sign-injection instruction.
    iss_code:
    - require_either_extension('D', EXT_ZDINX);
    - require_fp;
    - WRITE_FRD_D(fsgnj64(freg(FRS1_D), freg(FRS2_D), true, false));
  fsgnjn.h:
    opcode:
    - fsgnjn.h
    - rd
    - rs1
    - rs2
    - 31..27=0x04
    - 14..12=1
    - 26..25=2
    - 6..2=0x14
    - 1..0=3
    opcode_group: zfh
    opcode_args: *1
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/zfh.html"
    main_desc: zfh
    main_id: "#half-precision-convert-and-move-instructions"
    desc:
      zfh:
        "#half-precision-convert-and-move-instructions":
          text:
          - Floating-point to floating-point sign-injection instructions, FSGNJ.H,
            FSGNJN.H, and FSGNJX.H are defined analogously to the single-precision
            sign-injection instruction.
    iss_code:
    - require_either_extension(EXT_ZFH, EXT_ZHINX);
    - require_fp;
    - WRITE_FRD_H(fsgnj16(freg(FRS1_H), freg(FRS2_H), true, false));
  fsgnjn.q:
    opcode:
    - fsgnjn.q
    - rd
    - rs1
    - rs2
    - 31..27=0x04
    - 14..12=1
    - 26..25=3
    - 6..2=0x14
    - 1..0=3
    opcode_group: q
    opcode_args: *1
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/q.html"
    main_desc: q
    main_id: "#quad-precision-convert-and-move-instructions"
    desc:
      q:
        "#quad-precision-convert-and-move-instructions":
          text:
          - Floating-point to floating-point sign-injection instructions, FSGNJ.Q,
            FSGNJN.Q, and FSGNJX.Q are defined analogously to the double-precision
            sign-injection instruction.
    iss_code:
    - require_extension('Q');
    - require_fp;
    - WRITE_FRD(fsgnj128(FRS1, FRS2, true, false));
  fsgnjn.s:
    opcode:
    - fsgnjn.s
    - rd
    - rs1
    - rs2
    - 31..27=0x04
    - 14..12=1
    - 26..25=0
    - 6..2=0x14
    - 1..0=3
    opcode_group: f
    opcode_args: *1
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/f.html"
    main_desc: f
    main_id: "#single-precision-floating-point-conversion-and-move-instructions"
    desc:
      f:
        "#single-precision-floating-point-conversion-and-move-instructions":
          text:
          - Floating-point to floating-point sign-injection instructions, FSGNJ.S,
            FSGNJN.S, and FSGNJX.S, produce a result that takes all bits except the
            sign bit from rs1. For FSGNJ, the result's sign bit is rs2's sign bit;
            for FSGNJN, the result's sign bit is the opposite of rs2's sign bit; and
            for FSGNJX, the sign bit is the XOR of the sign bits of rs1 and rs2. Sign-injection
            instructions do not set floating-point exception flags, nor do they canonicalize
            NaNs. Note, FSGNJ.S rx, ry, ry moves ry to rx (assembler pseudoinstruction
            FMV.S rx, ry); FSGNJN.S rx, ry, ry moves the negation of ry to rx (assembler
            pseudoinstruction FNEG.S rx, ry); and FSGNJX.S rx, ry, ry moves the absolute
            value of ry to rx (assembler pseudoinstruction FABS.S rx, ry).
    iss_code:
    - require_either_extension('F', EXT_ZFINX);
    - require_fp;
    - WRITE_FRD_F(fsgnj32(freg(FRS1_F), freg(FRS2_F), true, false));
  fsgnjx.d:
    opcode:
    - fsgnjx.d
    - rd
    - rs1
    - rs2
    - 31..27=0x04
    - 14..12=2
    - 26..25=1
    - 6..2=0x14
    - 1..0=3
    opcode_group: d
    opcode_args: *1
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/d.html"
    main_desc: d
    main_id: "#double-precision-floating-point-conversion-and-move-instructions"
    desc:
      d:
        "#double-precision-floating-point-conversion-and-move-instructions":
          text:
          - Floating-point to floating-point sign-injection instructions, FSGNJ.D,
            FSGNJN.D, and FSGNJX.D are defined analogously to the single-precision
            sign-injection instruction.
    iss_code:
    - require_either_extension('D', EXT_ZDINX);
    - require_fp;
    - WRITE_FRD_D(fsgnj64(freg(FRS1_D), freg(FRS2_D), false, true));
  fsgnjx.h:
    opcode:
    - fsgnjx.h
    - rd
    - rs1
    - rs2
    - 31..27=0x04
    - 14..12=2
    - 26..25=2
    - 6..2=0x14
    - 1..0=3
    opcode_group: zfh
    opcode_args: *1
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/zfh.html"
    main_desc: zfh
    main_id: "#half-precision-convert-and-move-instructions"
    desc:
      zfh:
        "#half-precision-convert-and-move-instructions":
          text:
          - Floating-point to floating-point sign-injection instructions, FSGNJ.H,
            FSGNJN.H, and FSGNJX.H are defined analogously to the single-precision
            sign-injection instruction.
    iss_code:
    - require_either_extension(EXT_ZFH, EXT_ZHINX);
    - require_fp;
    - WRITE_FRD_H(fsgnj16(freg(FRS1_H), freg(FRS2_H), false, true));
  fsgnjx.q:
    opcode:
    - fsgnjx.q
    - rd
    - rs1
    - rs2
    - 31..27=0x04
    - 14..12=2
    - 26..25=3
    - 6..2=0x14
    - 1..0=3
    opcode_group: q
    opcode_args: *1
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/q.html"
    main_desc: q
    main_id: "#quad-precision-convert-and-move-instructions"
    desc:
      q:
        "#quad-precision-convert-and-move-instructions":
          text:
          - Floating-point to floating-point sign-injection instructions, FSGNJ.Q,
            FSGNJN.Q, and FSGNJX.Q are defined analogously to the double-precision
            sign-injection instruction.
    iss_code:
    - require_extension('Q');
    - require_fp;
    - WRITE_FRD(fsgnj128(FRS1, FRS2, false, true));
  fsgnjx.s:
    opcode:
    - fsgnjx.s
    - rd
    - rs1
    - rs2
    - 31..27=0x04
    - 14..12=2
    - 26..25=0
    - 6..2=0x14
    - 1..0=3
    opcode_group: f
    opcode_args: *1
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/f.html"
    main_desc: f
    main_id: "#single-precision-floating-point-conversion-and-move-instructions"
    desc:
      f:
        "#single-precision-floating-point-conversion-and-move-instructions":
          text:
          - Floating-point to floating-point sign-injection instructions, FSGNJ.S,
            FSGNJN.S, and FSGNJX.S, produce a result that takes all bits except the
            sign bit from rs1. For FSGNJ, the result's sign bit is rs2's sign bit;
            for FSGNJN, the result's sign bit is the opposite of rs2's sign bit; and
            for FSGNJX, the sign bit is the XOR of the sign bits of rs1 and rs2. Sign-injection
            instructions do not set floating-point exception flags, nor do they canonicalize
            NaNs. Note, FSGNJ.S rx, ry, ry moves ry to rx (assembler pseudoinstruction
            FMV.S rx, ry); FSGNJN.S rx, ry, ry moves the negation of ry to rx (assembler
            pseudoinstruction FNEG.S rx, ry); and FSGNJX.S rx, ry, ry moves the absolute
            value of ry to rx (assembler pseudoinstruction FABS.S rx, ry).
    iss_code:
    - require_either_extension('F', EXT_ZFINX);
    - require_fp;
    - WRITE_FRD_F(fsgnj32(freg(FRS1_F), freg(FRS2_F), false, true));
  fsh:
    opcode:
    - fsh
    - imm12hi
    - rs1
    - rs2
    - imm12lo
    - 14..12=1
    - 6..2=0x09
    - 1..0=3
    opcode_group: zfh
    opcode_args: *24
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/zfh.html"
    main_desc: zfh
    main_id: "#half-precision-load-and-store-instructions"
    desc:
      zfh:
        "#half-precision-load-and-store-instructions":
          text:
          - FLH and FSH are only guaranteed to execute atomically if the effective
            address is naturally aligned.
          - FLH and FSH do not modify the bits being transferred; in particular, the
            payloads of non-canonical NaNs are preserved. FLH NaN-boxes the result
            written to rd, whereas FSH ignores all but the lower 16 bits in rs2.
        "#zfhmin-standard-extension-for-minimal-half-precision-floating-point-support":
          text:
          - 'The Zfhmin extension includes the following instructions from the Zfh
            extension: FLH, FSH, FMV.X.H, FMV.H.X, FCVT.S.H, and FCVT.H.S. If the
            D extension is present, the FCVT.D.H and FCVT.H.D instructions are also
            included. If the Q extension is present, the FCVT.Q.H and FCVT.H.Q instructions
            are additionally included.'
      zfinx:
        "#zhinx":
          text:
          - The Zhinx extension adds all of the instructions that the Zfh extension
            adds, except for the transfer instructions FLH, FSH, FMV.H.X, and FMV.X.H.
      hypervisor:
        "#sec:tinst-vals":
          text:
          - For a standard store instruction that is not a compressed instruction
            and is one of SB, SH, SW, SD, FSW, FSD, FSQ, or FSH, the transformed instruction
            has the format shown in Figure 1.47 .
          - Transformed noncompressed store instruction (SB, SH, SW, SD, FSW, FSD,
            FSQ, or FSH). Fields rs2, funct3, and opcode are the same as the trapping
            store instruction.
          - In decoding the contents of mtinst or htinst, once software has determined
            that the register contains the encoding of a standard basic load (LB,
            LBU, LH, LHU, LW, LWU, LD, FLW, FLD, FLQ, or FLH) or basic store (SB,
            SH, SW, SD, FSW, FSD, FSQ, or FSH), it is not necessary to confirm also
            that the immediate offset fields (31:25, and 24:20 or 11:7) are zeros.
            The knowledge that the register's value is the encoding of a basic load/store
            is sufficient to prove that the trapping instruction is of the same kind.
      v:
        "#sec-vector-loadstore-width-encoding":
          text:
          - FLH/FSH
    iss_code:
    - require_extension(EXT_INTERNAL_ZFH_MOVE);
    - require_fp;
    - MMU.store<uint16_t>(RS1 + insn.s_imm(), FRS2.v[0]);
  fsq:
    opcode:
    - fsq
    - imm12hi
    - rs1
    - rs2
    - imm12lo
    - 14..12=4
    - 6..2=0x09
    - 1..0=3
    opcode_group: q
    opcode_args: *24
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/q.html"
    main_desc: q
    main_id: "#quad-precision-load-and-store-instructions"
    desc:
      q:
        "#quad-precision-load-and-store-instructions":
          text:
          - FLQ and FSQ are only guaranteed to execute atomically if the effective
            address is naturally aligned and XLEN=128.
          - FLQ and FSQ do not modify the bits being transferred; in particular, the
            payloads of non-canonical NaNs are preserved.
      hypervisor:
        "#sec:tinst-vals":
          text:
          - For a standard store instruction that is not a compressed instruction
            and is one of SB, SH, SW, SD, FSW, FSD, FSQ, or FSH, the transformed instruction
            has the format shown in Figure 1.47 .
          - Transformed noncompressed store instruction (SB, SH, SW, SD, FSW, FSD,
            FSQ, or FSH). Fields rs2, funct3, and opcode are the same as the trapping
            store instruction.
          - In decoding the contents of mtinst or htinst, once software has determined
            that the register contains the encoding of a standard basic load (LB,
            LBU, LH, LHU, LW, LWU, LD, FLW, FLD, FLQ, or FLH) or basic store (SB,
            SH, SW, SD, FSW, FSD, FSQ, or FSH), it is not necessary to confirm also
            that the immediate offset fields (31:25, and 24:20 or 11:7) are zeros.
            The knowledge that the register's value is the encoding of a basic load/store
            is sufficient to prove that the trapping instruction is of the same kind.
      v:
        "#sec-vector-loadstore-width-encoding":
          text:
          - FLQ/FSQ
    iss_code:
    - require_extension('Q');
    - require_fp;
    - MMU.store_float128(RS1 + insn.s_imm(), FRS2);
  fsqrt.d:
    opcode:
    - fsqrt.d
    - rd
    - rs1
    - 24..20=0
    - 31..27=0x0B
    - rm
    - 26..25=1
    - 6..2=0x14
    - 1..0=3
    opcode_group: d
    opcode_args: *3
    main_desc: d
    main_id: "#sec:single-float-compute"
    desc:
      d:
        "#sec:single-float-compute":
          text:
          - Floating-point arithmetic instructions with one or two source operands
            use the R-type format with the OP-FP major opcode. FADD.S and FMUL.S perform
            single-precision floating-point addition and multiplication respectively,
            between rs1 and rs2. FSUB.S performs the single-precision floating-point
            subtraction of rs2 from rs1. FDIV.S performs the single-precision floating-point
            division of rs1 by rs2. FSQRT.S computes the square root of rs1. In each
            case, the result is written to rd.
    iss_code:
    - require_either_extension('D', EXT_ZDINX);
    - require_fp;
    - softfloat_roundingMode = RM;
    - WRITE_FRD_D(f64_sqrt(FRS1_D));
    - set_fp_exceptions;
  fsqrt.h:
    opcode:
    - fsqrt.h
    - rd
    - rs1
    - 24..20=0
    - 31..27=0x0B
    - rm
    - 26..25=2
    - 6..2=0x14
    - 1..0=3
    opcode_group: zfh
    opcode_args: *3
    iss_code:
    - require_either_extension(EXT_ZFH, EXT_ZHINX);
    - require_fp;
    - softfloat_roundingMode = RM;
    - WRITE_FRD_H(f16_sqrt(FRS1_H));
    - set_fp_exceptions;
  fsqrt.q:
    opcode:
    - fsqrt.q
    - rd
    - rs1
    - 24..20=0
    - 31..27=0x0B
    - rm
    - 26..25=3
    - 6..2=0x14
    - 1..0=3
    opcode_group: q
    opcode_args: *3
    main_desc: q
    main_id: "#sec:single-float-compute"
    desc:
      q:
        "#sec:single-float-compute":
          text:
          - Floating-point arithmetic instructions with one or two source operands
            use the R-type format with the OP-FP major opcode. FADD.S and FMUL.S perform
            single-precision floating-point addition and multiplication respectively,
            between rs1 and rs2. FSUB.S performs the single-precision floating-point
            subtraction of rs2 from rs1. FDIV.S performs the single-precision floating-point
            division of rs1 by rs2. FSQRT.S computes the square root of rs1. In each
            case, the result is written to rd.
    iss_code:
    - require_extension('Q');
    - require_fp;
    - softfloat_roundingMode = RM;
    - WRITE_FRD(f128_sqrt(f128(FRS1)));
    - set_fp_exceptions;
  fsqrt.s:
    opcode:
    - fsqrt.s
    - rd
    - rs1
    - 24..20=0
    - 31..27=0x0B
    - rm
    - 26..25=0
    - 6..2=0x14
    - 1..0=3
    opcode_group: f
    opcode_args: *3
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/f.html"
    main_desc: f
    main_id: "#sec:single-float-compute"
    desc:
      f:
        "#sec:single-float-compute":
          text:
          - Floating-point arithmetic instructions with one or two source operands
            use the R-type format with the OP-FP major opcode. FADD.S and FMUL.S perform
            single-precision floating-point addition and multiplication respectively,
            between rs1 and rs2. FSUB.S performs the single-precision floating-point
            subtraction of rs2 from rs1. FDIV.S performs the single-precision floating-point
            division of rs1 by rs2. FSQRT.S computes the square root of rs1. In each
            case, the result is written to rd.
    iss_code:
    - require_either_extension('F', EXT_ZFINX);
    - require_fp;
    - softfloat_roundingMode = RM;
    - WRITE_FRD_F(f32_sqrt(FRS1_F));
    - set_fp_exceptions;
  fsrm:
    opcode:
    - fsrm
    - rd
    - rs1
    - 31..20=0x002
    - 14..12=1
    - 6..2=0x1C
    - 1..0=3
    opcode_group: zicsr
    opcode_args: *3
    pseudo_src: rv_zicsr
    pseudo_op: csrrw
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/f.html"
    main_desc: f
    main_id: "#floating-point-control-and-status-register"
    desc:
      f:
        "#floating-point-control-and-status-register":
          text:
          - The fields within the fcsr can also be accessed individually through different
            CSR addresses, and separate assembler pseudoinstructions are defined for
            these accesses. The FRRM instruction reads the Rounding Mode field frm
            and copies it into the least-significant three bits of integer register
            rd, with zero in all other bits. FSRM swaps the value in frm by copying
            the original value into integer register rd, and then writing a new value
            obtained from the three least-significant bits of integer register rs1
            into frm. FRFLAGS and FSFLAGS are defined analogously for the Accrued
            Exception Flags field fflags.
  fsrmi:
    opcode:
    - fsrmi
    - rd
    - zimm
    - 31..20=0x002
    - 14..12=5
    - 6..2=0x1C
    - 1..0=3
    opcode_group: zicsr
    opcode_args: *20
    pseudo_src: rv_zicsr
    pseudo_op: csrrwi
  fsub.d:
    opcode:
    - fsub.d
    - rd
    - rs1
    - rs2
    - 31..27=0x01
    - rm
    - 26..25=1
    - 6..2=0x14
    - 1..0=3
    opcode_group: d
    opcode_args: *1
    main_desc: d
    main_id: "#sec:single-float-compute"
    desc:
      d:
        "#sec:single-float-compute":
          text:
          - Floating-point arithmetic instructions with one or two source operands
            use the R-type format with the OP-FP major opcode. FADD.S and FMUL.S perform
            single-precision floating-point addition and multiplication respectively,
            between rs1 and rs2. FSUB.S performs the single-precision floating-point
            subtraction of rs2 from rs1. FDIV.S performs the single-precision floating-point
            division of rs1 by rs2. FSQRT.S computes the square root of rs1. In each
            case, the result is written to rd.
    iss_code:
    - require_either_extension('D', EXT_ZDINX);
    - require_fp;
    - softfloat_roundingMode = RM;
    - WRITE_FRD_D(f64_sub(FRS1_D, FRS2_D));
    - set_fp_exceptions;
  fsub.h:
    opcode:
    - fsub.h
    - rd
    - rs1
    - rs2
    - 31..27=0x01
    - rm
    - 26..25=2
    - 6..2=0x14
    - 1..0=3
    opcode_group: zfh
    opcode_args: *1
    iss_code:
    - require_either_extension(EXT_ZFH, EXT_ZHINX);
    - require_fp;
    - softfloat_roundingMode = RM;
    - WRITE_FRD_H(f16_sub(FRS1_H, FRS2_H));
    - set_fp_exceptions;
  fsub.q:
    opcode:
    - fsub.q
    - rd
    - rs1
    - rs2
    - 31..27=0x01
    - rm
    - 26..25=3
    - 6..2=0x14
    - 1..0=3
    opcode_group: q
    opcode_args: *1
    main_desc: q
    main_id: "#sec:single-float-compute"
    desc:
      q:
        "#sec:single-float-compute":
          text:
          - Floating-point arithmetic instructions with one or two source operands
            use the R-type format with the OP-FP major opcode. FADD.S and FMUL.S perform
            single-precision floating-point addition and multiplication respectively,
            between rs1 and rs2. FSUB.S performs the single-precision floating-point
            subtraction of rs2 from rs1. FDIV.S performs the single-precision floating-point
            division of rs1 by rs2. FSQRT.S computes the square root of rs1. In each
            case, the result is written to rd.
    iss_code:
    - require_extension('Q');
    - require_fp;
    - softfloat_roundingMode = RM;
    - WRITE_FRD(f128_sub(f128(FRS1), f128(FRS2)));
    - set_fp_exceptions;
  fsub.s:
    opcode:
    - fsub.s
    - rd
    - rs1
    - rs2
    - 31..27=0x01
    - rm
    - 26..25=0
    - 6..2=0x14
    - 1..0=3
    opcode_group: f
    opcode_args: *1
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/f.html"
    main_desc: f
    main_id: "#sec:single-float-compute"
    desc:
      f:
        "#sec:single-float-compute":
          text:
          - Floating-point arithmetic instructions with one or two source operands
            use the R-type format with the OP-FP major opcode. FADD.S and FMUL.S perform
            single-precision floating-point addition and multiplication respectively,
            between rs1 and rs2. FSUB.S performs the single-precision floating-point
            subtraction of rs2 from rs1. FDIV.S performs the single-precision floating-point
            division of rs1 by rs2. FSQRT.S computes the square root of rs1. In each
            case, the result is written to rd.
    iss_code:
    - require_either_extension('F', EXT_ZFINX);
    - require_fp;
    - softfloat_roundingMode = RM;
    - WRITE_FRD_F(f32_sub(FRS1_F, FRS2_F));
    - set_fp_exceptions;
  fsw:
    opcode:
    - fsw
    - imm12hi
    - rs1
    - rs2
    - imm12lo
    - 14..12=2
    - 6..2=0x09
    - 1..0=3
    opcode_group: f
    opcode_args: *24
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/f.html"
    main_desc: f
    main_id: "#single-precision-load-and-store-instructions"
    desc:
      f:
        "#single-precision-load-and-store-instructions":
          text:
          - Floating-point loads and stores use the same base+offset addressing mode
            as the integer base ISAs, with a base address in register rs1 and a 12-bit
            signed byte offset. The FLW instruction loads a single-precision floating-point
            value from memory into floating-point register rd. FSW stores a single-precision
            value from floating-point register rs2 to memory.
          - FLW and FSW are only guaranteed to execute atomically if the effective
            address is naturally aligned.
          - FLW and FSW do not modify the bits being transferred; in particular, the
            payloads of non-canonical NaNs are preserved.
      zfinx:
        "#sec:zfinx":
          text:
          - The Zfinx extension adds all of the instructions that the F extension
            adds, except for the transfer instructions FLW, FSW, FMV.W.X, FMV.X.W,
            C.FLW[SP], and C.FSW[SP].
      hypervisor:
        "#sec:tinst-vals":
          text:
          - For a standard store instruction that is not a compressed instruction
            and is one of SB, SH, SW, SD, FSW, FSD, FSQ, or FSH, the transformed instruction
            has the format shown in Figure 1.47 .
          - Transformed noncompressed store instruction (SB, SH, SW, SD, FSW, FSD,
            FSQ, or FSH). Fields rs2, funct3, and opcode are the same as the trapping
            store instruction.
          - In decoding the contents of mtinst or htinst, once software has determined
            that the register contains the encoding of a standard basic load (LB,
            LBU, LH, LHU, LW, LWU, LD, FLW, FLD, FLQ, or FLH) or basic store (SB,
            SH, SW, SD, FSW, FSD, FSQ, or FSH), it is not necessary to confirm also
            that the immediate offset fields (31:25, and 24:20 or 11:7) are zeros.
            The knowledge that the register's value is the encoding of a basic load/store
            is sufficient to prove that the trapping instruction is of the same kind.
      v:
        "#sec-vector-loadstore-width-encoding":
          text:
          - FLW/FSW
    iss_code:
    - require_extension('F');
    - require_fp;
    - MMU.store<uint32_t>(RS1 + insn.s_imm(), FRS2.v[0]);
  hfence.gvma:
    opcode:
    - hfence.gvma
    - 11..7=0
    - rs1
    - rs2
    - 31..25=0x31
    - 14..12=0
    - 6..2=0x1C
    - 1..0=3
    opcode_group: h
    opcode_args: &25
    - rs1
    - rs2
    main_url_base: "/riscv-priv-isa-manual/Priv-v1.12/supervisor.html"
    main_desc: supervisor
    main_id: "#svinval"
    desc:
      supervisor:
        "#svinval":
          text:
          - The Svinval extension splits SFENCE.VMA, HFENCE.VVMA, and HFENCE.GVMA
            instructions into finer-grained invalidation and ordering operations that
            can be more efficiently batched or pipelined on certain classes of high-performance
            implementation.
          - 'If the hypervisor extension is implemented, the Svinval extension also
            provides two additional instructions: HINVAL.VVMA and HINVAL.GVMA. These
            have the same semantics as SINVAL.VMA, except that they combine with SFENCE.W.INVAL
            and SFENCE.INVAL.IR to replace HFENCE.VVMA and HFENCE.GVMA, respectively,
            instead of SFENCE.VMA. In addition, HINVAL.GVMA uses VMIDs instead of
            ASIDs.'
          - SINVAL.VMA, HINVAL.VVMA, and HINVAL.GVMA require the same permissions
            and raise the same exceptions as SFENCE.VMA, HFENCE.VVMA, and HFENCE.GVMA,
            respectively. In particular, an attempt to execute any of these instructions
            in U-mode always raises an illegal instruction exception, and an attempt
            to execute SINVAL.VMA or HINVAL.GVMA in S-mode or HS-mode when mstatus.TVM=1
            also raises an illegal instruction exception. An attempt to execute HINVAL.VVMA
            or HINVAL.GVMA in VS-mode or VU-mode, or to execute SINVAL.VMA in VU-mode,
            raises a virtual instruction exception. When hstatus.VTVM=1, an attempt
            to execute SINVAL.VMA in VS-mode also raises a virtual instruction exception.
          - High-performance implementations will be able to pipeline the address-translation
            cache invalidation operations, and will defer any pipeline stalls or other
            memory ordering enforcement until an SFENCE.W.INVAL, SFENCE.INVAL.IR,
            SFENCE.VMA, HFENCE.GVMA, or HFENCE.VVMA instruction is executed.
          - Simpler implementations may implement SINVAL.VMA, HINVAL.VVMA, and HINVAL.GVMA
            identically to SFENCE.VMA, HFENCE.VVMA, and HFENCE.GVMA, respectively,
            while implementing SFENCE.W.INVAL and SFENCE.INVAL.IR instructions as
            no-ops.
      hypervisor:
        "#sec:hgatp":
          text:
          - Note that writing hgatp does not imply any ordering constraints between
            page-table updates and subsequent G-stage address translations. If the
            new virtual machine's guest physical page tables have been modified, or
            if a VMID is reused, it may be necessary to execute an HFENCE.GVMA instruction
            (see Section 1.3.2 ) before or after writing hgatp.
        "#sec:hfence.vma":
          text:
          - The hypervisor memory-management fence instructions, HFENCE.VVMA and HFENCE.GVMA,
            perform a function similar to SFENCE.VMA (Section [sec:sfence.vma] ),
            except applying to the VS-level memory-management data structures controlled
            by CSR vsatp (HFENCE.VVMA) or the guest-physical memory-management data
            structures controlled by CSR hgatp (HFENCE.GVMA). Instruction SFENCE.VMA
            applies only to the memory-management data structures controlled by the
            current satp (either the HS-level satp when V=0 or vsatp when V=1).
          - HFENCE.GVMA is valid only in HS-mode when mstatus.TVM=0, or in M-mode
            (irrespective of mstatus.TVM). Executing an HFENCE.GVMA instruction guarantees
            that any previous stores already visible to the current hart are ordered
            before all subsequent implicit reads by that hart of guest-physical memory-management
            data structures done for instructions that follow the HFENCE.GVMA. If
            operand rs1 x0, it specifies a single guest physical address, shifted
            right by 2 bits, and if operand rs2 x0, it specifies a single virtual
            machine identifier (VMID).
          - Simpler implementations of HFENCE.GVMA can ignore the guest physical address
            in rs1 and the VMID value in rs2 and always perform a global fence for
            the guest-physical memory management of all virtual machines, or even
            a global fence for all memory-management data structures.
          - If hgatp.MODE is changed for a given VMID, an HFENCE.GVMA with rs1=x0
            (and rs2 set to either x0 or the VMID) must be executed to order subsequent
            guest translations with the MODE change--even if the old MODE or new MODE
            is Bare.
          - Attempts to execute HFENCE.VVMA or HFENCE.GVMA when V=1 cause a virtual
            instruction trap, while attempts to do the same in U-mode cause an illegal
            instruction trap. Attempting to execute HFENCE.GVMA in HS-mode when mstatus.TVM=1
            also causes an illegal instruction trap.
        "#machine-status-registers-mstatus-and-mstatush":
          text:
          - Setting TVM=1 prevents HS-mode from accessing hgatp or executing HFENCE.GVMA
            or HINVAL.GVMA, but has no effect on accesses to vsatp or instructions
            HFENCE.VVMA or HINVAL.VVMA.
        "#memory-management-fences":
          text:
          - Hypervisor instructions HFENCE.VVMA and HFENCE.GVMA provide additional
            memory-management fences to complement SFENCE.VMA. These instructions
            are described in Section 1.3.2 .
          - Section [pmp-vmem] discusses the intersection between physical memory
            protection (PMP) and page-based address translation. It is noted there
            that, when PMP settings are modified in a manner that affects either the
            physical memory that holds page tables or the physical memory to which
            page tables point, M-mode software must synchronize the PMP settings with
            the virtual memory system. For HS-level address translation, this is accomplished
            by executing in M-mode an SFENCE.VMA instruction with rs1=x0 and rs2=x0,
            after the PMP CSRs are written. If G-stage address translation is in use
            and is not Bare, synchronization with its data structures is also needed.
            When PMP settings are modified in a manner that affects either the physical
            memory that holds guest-physical page tables or the physical memory to
            which guest-physical page tables point, an HFENCE.GVMA instruction with
            rs1=x0 and rs2=x0 must be executed in M-mode after the PMP CSRs are written.
            An HFENCE.VVMA instruction is not required.
  hfence.vvma:
    opcode:
    - hfence.vvma
    - 11..7=0
    - rs1
    - rs2
    - 31..25=0x11
    - 14..12=0
    - 6..2=0x1C
    - 1..0=3
    opcode_group: h
    opcode_args: *25
    main_url_base: "/riscv-priv-isa-manual/Priv-v1.12/supervisor.html"
    main_desc: supervisor
    main_id: "#svinval"
    desc:
      supervisor:
        "#svinval":
          text:
          - The Svinval extension splits SFENCE.VMA, HFENCE.VVMA, and HFENCE.GVMA
            instructions into finer-grained invalidation and ordering operations that
            can be more efficiently batched or pipelined on certain classes of high-performance
            implementation.
          - 'If the hypervisor extension is implemented, the Svinval extension also
            provides two additional instructions: HINVAL.VVMA and HINVAL.GVMA. These
            have the same semantics as SINVAL.VMA, except that they combine with SFENCE.W.INVAL
            and SFENCE.INVAL.IR to replace HFENCE.VVMA and HFENCE.GVMA, respectively,
            instead of SFENCE.VMA. In addition, HINVAL.GVMA uses VMIDs instead of
            ASIDs.'
          - SINVAL.VMA, HINVAL.VVMA, and HINVAL.GVMA require the same permissions
            and raise the same exceptions as SFENCE.VMA, HFENCE.VVMA, and HFENCE.GVMA,
            respectively. In particular, an attempt to execute any of these instructions
            in U-mode always raises an illegal instruction exception, and an attempt
            to execute SINVAL.VMA or HINVAL.GVMA in S-mode or HS-mode when mstatus.TVM=1
            also raises an illegal instruction exception. An attempt to execute HINVAL.VVMA
            or HINVAL.GVMA in VS-mode or VU-mode, or to execute SINVAL.VMA in VU-mode,
            raises a virtual instruction exception. When hstatus.VTVM=1, an attempt
            to execute SINVAL.VMA in VS-mode also raises a virtual instruction exception.
          - High-performance implementations will be able to pipeline the address-translation
            cache invalidation operations, and will defer any pipeline stalls or other
            memory ordering enforcement until an SFENCE.W.INVAL, SFENCE.INVAL.IR,
            SFENCE.VMA, HFENCE.GVMA, or HFENCE.VVMA instruction is executed.
          - Simpler implementations may implement SINVAL.VMA, HINVAL.VVMA, and HINVAL.GVMA
            identically to SFENCE.VMA, HFENCE.VVMA, and HFENCE.GVMA, respectively,
            while implementing SFENCE.W.INVAL and SFENCE.INVAL.IR instructions as
            no-ops.
      hypervisor:
        "#sec:hfence.vma":
          text:
          - The hypervisor memory-management fence instructions, HFENCE.VVMA and HFENCE.GVMA,
            perform a function similar to SFENCE.VMA (Section [sec:sfence.vma] ),
            except applying to the VS-level memory-management data structures controlled
            by CSR vsatp (HFENCE.VVMA) or the guest-physical memory-management data
            structures controlled by CSR hgatp (HFENCE.GVMA). Instruction SFENCE.VMA
            applies only to the memory-management data structures controlled by the
            current satp (either the HS-level satp when V=0 or vsatp when V=1).
          - HFENCE.VVMA is valid only in M-mode or HS-mode. Its effect is much the
            same as temporarily entering VS-mode and executing SFENCE.VMA. Executing
            an HFENCE.VVMA guarantees that any previous stores already visible to
            the current hart are ordered before all subsequent implicit reads by that
            hart of the VS-level memory-management data structures, when those implicit
            reads are for instructions that
          - are subsequent to the HFENCE.VVMA, and
          - execute when hgatp.VMID has the same setting as it did when HFENCE.VVMA
            executed.
          - Implicit reads need not be ordered when hgatp.VMID is different than at
            the time HFENCE.VVMA executed. If operand rs1 x0, it specifies a single
            guest virtual address, and if operand rs2 x0, it specifies a single guest
            address-space identifier (ASID).
          - An HFENCE.VVMA instruction applies only to a single virtual machine, identified
            by the setting of hgatp.VMID when HFENCE.VVMA executes.
          - Simpler implementations of HFENCE.VVMA can ignore the guest virtual address
            in rs1 and the guest ASID value in rs2, as well as hgatp.VMID, and always
            perform a global fence for the VS-level memory management of all virtual
            machines, or even a global fence for all memory-management data structures.
          - Neither mstatus.TVM nor hstatus.VTVM causes HFENCE.VVMA to trap.
          - Attempts to execute HFENCE.VVMA or HFENCE.GVMA when V=1 cause a virtual
            instruction trap, while attempts to do the same in U-mode cause an illegal
            instruction trap. Attempting to execute HFENCE.GVMA in HS-mode when mstatus.TVM=1
            also causes an illegal instruction trap.
        "#machine-status-registers-mstatus-and-mstatush":
          text:
          - Setting TVM=1 prevents HS-mode from accessing hgatp or executing HFENCE.GVMA
            or HINVAL.GVMA, but has no effect on accesses to vsatp or instructions
            HFENCE.VVMA or HINVAL.VVMA.
          - However, setting TVM=1 does not cause traps for accesses to vsatp or instructions
            HFENCE.VVMA or HINVAL.VVMA, or for any actions taken in VS-mode, because
            M-level software is not expected to need to involve itself in VS-stage
            address translation. For virtual machines, it should be sufficient, and
            in all likelihood faster as well, to leave VS-stage address translation
            alone and merge all other translation stages into G-stage shadow page
            tables controlled by hgatp. This assumption does place some constraints
            on possible future RISC-V extensions that current machines will be able
            to emulate efficiently.
        "#memory-management-fences":
          text:
          - Hypervisor instructions HFENCE.VVMA and HFENCE.GVMA provide additional
            memory-management fences to complement SFENCE.VMA. These instructions
            are described in Section 1.3.2 .
          - Section [pmp-vmem] discusses the intersection between physical memory
            protection (PMP) and page-based address translation. It is noted there
            that, when PMP settings are modified in a manner that affects either the
            physical memory that holds page tables or the physical memory to which
            page tables point, M-mode software must synchronize the PMP settings with
            the virtual memory system. For HS-level address translation, this is accomplished
            by executing in M-mode an SFENCE.VMA instruction with rs1=x0 and rs2=x0,
            after the PMP CSRs are written. If G-stage address translation is in use
            and is not Bare, synchronization with its data structures is also needed.
            When PMP settings are modified in a manner that affects either the physical
            memory that holds guest-physical page tables or the physical memory to
            which guest-physical page tables point, an HFENCE.GVMA instruction with
            rs1=x0 and rs2=x0 must be executed in M-mode after the PMP CSRs are written.
            An HFENCE.VVMA instruction is not required.
  hinval.gvma:
    opcode:
    - hinval.gvma
    - 11..7=0
    - rs1
    - rs2
    - 31..25=0x33
    - 14..12=0
    - 6..2=0x1C
    - 1..0=3
    opcode_group: svinval
    opcode_args: *25
    main_url_base: "/riscv-priv-isa-manual/Priv-v1.12/supervisor.html"
    main_desc: supervisor
    main_id: "#svinval"
    desc:
      supervisor:
        "#svinval":
          text:
          - 'If the hypervisor extension is implemented, the Svinval extension also
            provides two additional instructions: HINVAL.VVMA and HINVAL.GVMA. These
            have the same semantics as SINVAL.VMA, except that they combine with SFENCE.W.INVAL
            and SFENCE.INVAL.IR to replace HFENCE.VVMA and HFENCE.GVMA, respectively,
            instead of SFENCE.VMA. In addition, HINVAL.GVMA uses VMIDs instead of
            ASIDs.'
          - SINVAL.VMA, HINVAL.VVMA, and HINVAL.GVMA require the same permissions
            and raise the same exceptions as SFENCE.VMA, HFENCE.VVMA, and HFENCE.GVMA,
            respectively. In particular, an attempt to execute any of these instructions
            in U-mode always raises an illegal instruction exception, and an attempt
            to execute SINVAL.VMA or HINVAL.GVMA in S-mode or HS-mode when mstatus.TVM=1
            also raises an illegal instruction exception. An attempt to execute HINVAL.VVMA
            or HINVAL.GVMA in VS-mode or VU-mode, or to execute SINVAL.VMA in VU-mode,
            raises a virtual instruction exception. When hstatus.VTVM=1, an attempt
            to execute SINVAL.VMA in VS-mode also raises a virtual instruction exception.
          - In typical usage, software will invalidate a range of virtual addresses
            in the address-translation caches by executing an SFENCE.W.INVAL instruction,
            executing a series of SINVAL.VMA, HINVAL.VVMA, or HINVAL.GVMA instructions
            to the addresses (and optionally ASIDs or VMIDs) in question, and then
            executing an SFENCE.INVAL.IR instruction.
          - Simpler implementations may implement SINVAL.VMA, HINVAL.VVMA, and HINVAL.GVMA
            identically to SFENCE.VMA, HFENCE.VVMA, and HFENCE.GVMA, respectively,
            while implementing SFENCE.W.INVAL and SFENCE.INVAL.IR instructions as
            no-ops.
      hypervisor:
        "#machine-status-registers-mstatus-and-mstatush":
          text:
          - Setting TVM=1 prevents HS-mode from accessing hgatp or executing HFENCE.GVMA
            or HINVAL.GVMA, but has no effect on accesses to vsatp or instructions
            HFENCE.VVMA or HINVAL.VVMA.
  hinval.vvma:
    opcode:
    - hinval.vvma
    - 11..7=0
    - rs1
    - rs2
    - 31..25=0x13
    - 14..12=0
    - 6..2=0x1C
    - 1..0=3
    opcode_group: svinval
    opcode_args: *25
    main_url_base: "/riscv-priv-isa-manual/Priv-v1.12/supervisor.html"
    main_desc: supervisor
    main_id: "#svinval"
    desc:
      supervisor:
        "#svinval":
          text:
          - 'If the hypervisor extension is implemented, the Svinval extension also
            provides two additional instructions: HINVAL.VVMA and HINVAL.GVMA. These
            have the same semantics as SINVAL.VMA, except that they combine with SFENCE.W.INVAL
            and SFENCE.INVAL.IR to replace HFENCE.VVMA and HFENCE.GVMA, respectively,
            instead of SFENCE.VMA. In addition, HINVAL.GVMA uses VMIDs instead of
            ASIDs.'
          - SINVAL.VMA, HINVAL.VVMA, and HINVAL.GVMA require the same permissions
            and raise the same exceptions as SFENCE.VMA, HFENCE.VVMA, and HFENCE.GVMA,
            respectively. In particular, an attempt to execute any of these instructions
            in U-mode always raises an illegal instruction exception, and an attempt
            to execute SINVAL.VMA or HINVAL.GVMA in S-mode or HS-mode when mstatus.TVM=1
            also raises an illegal instruction exception. An attempt to execute HINVAL.VVMA
            or HINVAL.GVMA in VS-mode or VU-mode, or to execute SINVAL.VMA in VU-mode,
            raises a virtual instruction exception. When hstatus.VTVM=1, an attempt
            to execute SINVAL.VMA in VS-mode also raises a virtual instruction exception.
          - In typical usage, software will invalidate a range of virtual addresses
            in the address-translation caches by executing an SFENCE.W.INVAL instruction,
            executing a series of SINVAL.VMA, HINVAL.VVMA, or HINVAL.GVMA instructions
            to the addresses (and optionally ASIDs or VMIDs) in question, and then
            executing an SFENCE.INVAL.IR instruction.
          - Simpler implementations may implement SINVAL.VMA, HINVAL.VVMA, and HINVAL.GVMA
            identically to SFENCE.VMA, HFENCE.VVMA, and HFENCE.GVMA, respectively,
            while implementing SFENCE.W.INVAL and SFENCE.INVAL.IR instructions as
            no-ops.
      hypervisor:
        "#machine-status-registers-mstatus-and-mstatush":
          text:
          - Setting TVM=1 prevents HS-mode from accessing hgatp or executing HFENCE.GVMA
            or HINVAL.GVMA, but has no effect on accesses to vsatp or instructions
            HFENCE.VVMA or HINVAL.VVMA.
          - However, setting TVM=1 does not cause traps for accesses to vsatp or instructions
            HFENCE.VVMA or HINVAL.VVMA, or for any actions taken in VS-mode, because
            M-level software is not expected to need to involve itself in VS-stage
            address translation. For virtual machines, it should be sufficient, and
            in all likelihood faster as well, to leave VS-stage address translation
            alone and merge all other translation stages into G-stage shadow page
            tables controlled by hgatp. This assumption does place some constraints
            on possible future RISC-V extensions that current machines will be able
            to emulate efficiently.
  hlv.b:
    opcode:
    - hlv.b
    - rd
    - rs1
    - 24..20=0x0
    - 31..25=0x30
    - 14..12=4
    - 6..2=0x1C
    - 1..0=3
    opcode_group: h
    opcode_args: *3
    main_url_base: "/riscv-priv-isa-manual/Priv-v1.12/hypervisor.html"
    main_desc: hypervisor
    main_id: "#hypervisor-virtual-machine-load-and-store-instructions"
    desc:
      hypervisor:
        "#hypervisor-virtual-machine-load-and-store-instructions":
          text:
          - 'For every RV32I or RV64I load instruction, LB, LBU, LH, LHU, LW, LWU,
            and LD, there is a corresponding virtual-machine load instruction: HLV.B,
            HLV.BU, HLV.H, HLV.HU, HLV.W, HLV.WU, and HLV.D. For every RV32I or RV64I
            store instruction, SB, SH, SW, and SD, there is a corresponding virtual-machine
            store instruction: HSV.B, HSV.H, HSV.W, and HSV.D. Instructions HLV.WU,
            HLV.D, and HSV.D are not valid for RV32, of course.'
    iss_code:
    - require_extension('H');
    - require_novirt();
    - 'require_privilege(get_field(STATE.hstatus->read(), HSTATUS_HU) ? PRV_U : PRV_S);'
    - WRITE_RD(MMU.guest_load<int8_t>(RS1));
  hlv.bu:
    opcode:
    - hlv.bu
    - rd
    - rs1
    - 24..20=0x1
    - 31..25=0x30
    - 14..12=4
    - 6..2=0x1C
    - 1..0=3
    opcode_group: h
    opcode_args: *3
    main_url_base: "/riscv-priv-isa-manual/Priv-v1.12/hypervisor.html"
    main_desc: hypervisor
    main_id: "#hypervisor-virtual-machine-load-and-store-instructions"
    desc:
      hypervisor:
        "#hypervisor-virtual-machine-load-and-store-instructions":
          text:
          - 'For every RV32I or RV64I load instruction, LB, LBU, LH, LHU, LW, LWU,
            and LD, there is a corresponding virtual-machine load instruction: HLV.B,
            HLV.BU, HLV.H, HLV.HU, HLV.W, HLV.WU, and HLV.D. For every RV32I or RV64I
            store instruction, SB, SH, SW, and SD, there is a corresponding virtual-machine
            store instruction: HSV.B, HSV.H, HSV.W, and HSV.D. Instructions HLV.WU,
            HLV.D, and HSV.D are not valid for RV32, of course.'
  hlv.d:
    opcode:
    - hlv.d
    - rd
    - rs1
    - 24..20=0x0
    - 31..25=0x36
    - 14..12=4
    - 6..2=0x1C
    - 1..0=3
    opcode_group: h
    opcode_args: *3
    main_url_base: "/riscv-priv-isa-manual/Priv-v1.12/hypervisor.html"
    main_desc: hypervisor
    main_id: "#hypervisor-virtual-machine-load-and-store-instructions"
    desc:
      hypervisor:
        "#hypervisor-virtual-machine-load-and-store-instructions":
          text:
          - 'For every RV32I or RV64I load instruction, LB, LBU, LH, LHU, LW, LWU,
            and LD, there is a corresponding virtual-machine load instruction: HLV.B,
            HLV.BU, HLV.H, HLV.HU, HLV.W, HLV.WU, and HLV.D. For every RV32I or RV64I
            store instruction, SB, SH, SW, and SD, there is a corresponding virtual-machine
            store instruction: HSV.B, HSV.H, HSV.W, and HSV.D. Instructions HLV.WU,
            HLV.D, and HSV.D are not valid for RV32, of course.'
    iss_code:
    - require_extension('H');
    - require_rv64;
    - require_novirt();
    - 'require_privilege(get_field(STATE.hstatus->read(), HSTATUS_HU) ? PRV_U : PRV_S);'
    - WRITE_RD(MMU.guest_load<int64_t>(RS1));
  hlv.h:
    opcode:
    - hlv.h
    - rd
    - rs1
    - 24..20=0x0
    - 31..25=0x32
    - 14..12=4
    - 6..2=0x1C
    - 1..0=3
    opcode_group: h
    opcode_args: *3
    main_url_base: "/riscv-priv-isa-manual/Priv-v1.12/hypervisor.html"
    main_desc: hypervisor
    main_id: "#hypervisor-virtual-machine-load-and-store-instructions"
    desc:
      hypervisor:
        "#hypervisor-virtual-machine-load-and-store-instructions":
          text:
          - 'For every RV32I or RV64I load instruction, LB, LBU, LH, LHU, LW, LWU,
            and LD, there is a corresponding virtual-machine load instruction: HLV.B,
            HLV.BU, HLV.H, HLV.HU, HLV.W, HLV.WU, and HLV.D. For every RV32I or RV64I
            store instruction, SB, SH, SW, and SD, there is a corresponding virtual-machine
            store instruction: HSV.B, HSV.H, HSV.W, and HSV.D. Instructions HLV.WU,
            HLV.D, and HSV.D are not valid for RV32, of course.'
    iss_code:
    - require_extension('H');
    - require_novirt();
    - 'require_privilege(get_field(STATE.hstatus->read(), HSTATUS_HU) ? PRV_U : PRV_S);'
    - WRITE_RD(MMU.guest_load<int16_t>(RS1));
  hlv.hu:
    opcode:
    - hlv.hu
    - rd
    - rs1
    - 24..20=0x1
    - 31..25=0x32
    - 14..12=4
    - 6..2=0x1C
    - 1..0=3
    opcode_group: h
    opcode_args: *3
    main_url_base: "/riscv-priv-isa-manual/Priv-v1.12/hypervisor.html"
    main_desc: hypervisor
    main_id: "#hypervisor-virtual-machine-load-and-store-instructions"
    desc:
      hypervisor:
        "#hypervisor-virtual-machine-load-and-store-instructions":
          text:
          - 'For every RV32I or RV64I load instruction, LB, LBU, LH, LHU, LW, LWU,
            and LD, there is a corresponding virtual-machine load instruction: HLV.B,
            HLV.BU, HLV.H, HLV.HU, HLV.W, HLV.WU, and HLV.D. For every RV32I or RV64I
            store instruction, SB, SH, SW, and SD, there is a corresponding virtual-machine
            store instruction: HSV.B, HSV.H, HSV.W, and HSV.D. Instructions HLV.WU,
            HLV.D, and HSV.D are not valid for RV32, of course.'
          - Instructions HLVX.HU and HLVX.WU are the same as HLV.HU and HLV.WU, except
            that execute permission takes the place of read permission during address
            translation. That is, the memory being read must be executable in both
            stages of address translation, but read permission is not required. For
            the supervisor physical address that results from address translation,
            the supervisor physical memory attributes must grant both execute and
            read permissions. (The supervisor physical memory attributes are the machine's
            physical memory attributes as modified by physical memory protection,
            Section [sec:pmp] , for supervisor level.)
  hlv.w:
    opcode:
    - hlv.w
    - rd
    - rs1
    - 24..20=0x0
    - 31..25=0x34
    - 14..12=4
    - 6..2=0x1C
    - 1..0=3
    opcode_group: h
    opcode_args: *3
    main_url_base: "/riscv-priv-isa-manual/Priv-v1.12/hypervisor.html"
    main_desc: hypervisor
    main_id: "#hypervisor-virtual-machine-load-and-store-instructions"
    desc:
      hypervisor:
        "#hypervisor-virtual-machine-load-and-store-instructions":
          text:
          - 'For every RV32I or RV64I load instruction, LB, LBU, LH, LHU, LW, LWU,
            and LD, there is a corresponding virtual-machine load instruction: HLV.B,
            HLV.BU, HLV.H, HLV.HU, HLV.W, HLV.WU, and HLV.D. For every RV32I or RV64I
            store instruction, SB, SH, SW, and SD, there is a corresponding virtual-machine
            store instruction: HSV.B, HSV.H, HSV.W, and HSV.D. Instructions HLV.WU,
            HLV.D, and HSV.D are not valid for RV32, of course.'
          - HLVX.WU is valid for RV32, even though LWU and HLV.WU are not. (For RV32,
            HLVX.WU can be considered a variant of HLV.W, as sign extension is irrelevant
            for 32-bit values.)
    iss_code:
    - require_extension('H');
    - require_novirt();
    - 'require_privilege(get_field(STATE.hstatus->read(), HSTATUS_HU) ? PRV_U : PRV_S);'
    - WRITE_RD(MMU.guest_load<int32_t>(RS1));
  hlv.wu:
    opcode:
    - hlv.wu
    - rd
    - rs1
    - 24..20=0x1
    - 31..25=0x34
    - 14..12=4
    - 6..2=0x1C
    - 1..0=3
    opcode_group: h
    opcode_args: *3
    main_url_base: "/riscv-priv-isa-manual/Priv-v1.12/hypervisor.html"
    main_desc: hypervisor
    main_id: "#hypervisor-virtual-machine-load-and-store-instructions"
    desc:
      hypervisor:
        "#hypervisor-virtual-machine-load-and-store-instructions":
          text:
          - 'For every RV32I or RV64I load instruction, LB, LBU, LH, LHU, LW, LWU,
            and LD, there is a corresponding virtual-machine load instruction: HLV.B,
            HLV.BU, HLV.H, HLV.HU, HLV.W, HLV.WU, and HLV.D. For every RV32I or RV64I
            store instruction, SB, SH, SW, and SD, there is a corresponding virtual-machine
            store instruction: HSV.B, HSV.H, HSV.W, and HSV.D. Instructions HLV.WU,
            HLV.D, and HSV.D are not valid for RV32, of course.'
          - Instructions HLVX.HU and HLVX.WU are the same as HLV.HU and HLV.WU, except
            that execute permission takes the place of read permission during address
            translation. That is, the memory being read must be executable in both
            stages of address translation, but read permission is not required. For
            the supervisor physical address that results from address translation,
            the supervisor physical memory attributes must grant both execute and
            read permissions. (The supervisor physical memory attributes are the machine's
            physical memory attributes as modified by physical memory protection,
            Section [sec:pmp] , for supervisor level.)
          - HLVX.WU is valid for RV32, even though LWU and HLV.WU are not. (For RV32,
            HLVX.WU can be considered a variant of HLV.W, as sign extension is irrelevant
            for 32-bit values.)
  hlvx.hu:
    opcode:
    - hlvx.hu
    - rd
    - rs1
    - 24..20=0x3
    - 31..25=0x32
    - 14..12=4
    - 6..2=0x1C
    - 1..0=3
    opcode_group: h
    opcode_args: *3
    main_url_base: "/riscv-priv-isa-manual/Priv-v1.12/hypervisor.html"
    main_desc: hypervisor
    main_id: "#hypervisor-virtual-machine-load-and-store-instructions"
    desc:
      hypervisor:
        "#hypervisor-virtual-machine-load-and-store-instructions":
          text:
          - Instructions HLVX.HU and HLVX.WU are the same as HLV.HU and HLV.WU, except
            that execute permission takes the place of read permission during address
            translation. That is, the memory being read must be executable in both
            stages of address translation, but read permission is not required. For
            the supervisor physical address that results from address translation,
            the supervisor physical memory attributes must grant both execute and
            read permissions. (The supervisor physical memory attributes are the machine's
            physical memory attributes as modified by physical memory protection,
            Section [sec:pmp] , for supervisor level.)
  hlvx.wu:
    opcode:
    - hlvx.wu
    - rd
    - rs1
    - 24..20=0x3
    - 31..25=0x34
    - 14..12=4
    - 6..2=0x1C
    - 1..0=3
    opcode_group: h
    opcode_args: *3
    main_url_base: "/riscv-priv-isa-manual/Priv-v1.12/hypervisor.html"
    main_desc: hypervisor
    main_id: "#hypervisor-virtual-machine-load-and-store-instructions"
    desc:
      hypervisor:
        "#hypervisor-virtual-machine-load-and-store-instructions":
          text:
          - Instructions HLVX.HU and HLVX.WU are the same as HLV.HU and HLV.WU, except
            that execute permission takes the place of read permission during address
            translation. That is, the memory being read must be executable in both
            stages of address translation, but read permission is not required. For
            the supervisor physical address that results from address translation,
            the supervisor physical memory attributes must grant both execute and
            read permissions. (The supervisor physical memory attributes are the machine's
            physical memory attributes as modified by physical memory protection,
            Section [sec:pmp] , for supervisor level.)
          - HLVX.WU is valid for RV32, even though LWU and HLV.WU are not. (For RV32,
            HLVX.WU can be considered a variant of HLV.W, as sign extension is irrelevant
            for 32-bit values.)
  hsv.b:
    opcode:
    - hsv.b
    - 11..7=0
    - rs1
    - rs2
    - 31..25=0x31
    - 14..12=4
    - 6..2=0x1C
    - 1..0=3
    opcode_group: h
    opcode_args: *25
    main_url_base: "/riscv-priv-isa-manual/Priv-v1.12/hypervisor.html"
    main_desc: hypervisor
    main_id: "#hypervisor-virtual-machine-load-and-store-instructions"
    desc:
      hypervisor:
        "#hypervisor-virtual-machine-load-and-store-instructions":
          text:
          - 'For every RV32I or RV64I load instruction, LB, LBU, LH, LHU, LW, LWU,
            and LD, there is a corresponding virtual-machine load instruction: HLV.B,
            HLV.BU, HLV.H, HLV.HU, HLV.W, HLV.WU, and HLV.D. For every RV32I or RV64I
            store instruction, SB, SH, SW, and SD, there is a corresponding virtual-machine
            store instruction: HSV.B, HSV.H, HSV.W, and HSV.D. Instructions HLV.WU,
            HLV.D, and HSV.D are not valid for RV32, of course.'
    iss_code:
    - require_extension('H');
    - require_novirt();
    - 'require_privilege(get_field(STATE.hstatus->read(), HSTATUS_HU) ? PRV_U : PRV_S);'
    - MMU.guest_store<uint8_t>(RS1, RS2);
  hsv.d:
    opcode:
    - hsv.d
    - 11..7=0
    - rs1
    - rs2
    - 31..25=0x37
    - 14..12=4
    - 6..2=0x1C
    - 1..0=3
    opcode_group: h
    opcode_args: *25
    main_url_base: "/riscv-priv-isa-manual/Priv-v1.12/hypervisor.html"
    main_desc: hypervisor
    main_id: "#hypervisor-virtual-machine-load-and-store-instructions"
    desc:
      hypervisor:
        "#hypervisor-virtual-machine-load-and-store-instructions":
          text:
          - 'For every RV32I or RV64I load instruction, LB, LBU, LH, LHU, LW, LWU,
            and LD, there is a corresponding virtual-machine load instruction: HLV.B,
            HLV.BU, HLV.H, HLV.HU, HLV.W, HLV.WU, and HLV.D. For every RV32I or RV64I
            store instruction, SB, SH, SW, and SD, there is a corresponding virtual-machine
            store instruction: HSV.B, HSV.H, HSV.W, and HSV.D. Instructions HLV.WU,
            HLV.D, and HSV.D are not valid for RV32, of course.'
    iss_code:
    - require_extension('H');
    - require_rv64;
    - require_novirt();
    - 'require_privilege(get_field(STATE.hstatus->read(), HSTATUS_HU) ? PRV_U : PRV_S);'
    - MMU.guest_store<uint64_t>(RS1, RS2);
  hsv.h:
    opcode:
    - hsv.h
    - 11..7=0
    - rs1
    - rs2
    - 31..25=0x33
    - 14..12=4
    - 6..2=0x1C
    - 1..0=3
    opcode_group: h
    opcode_args: *25
    main_url_base: "/riscv-priv-isa-manual/Priv-v1.12/hypervisor.html"
    main_desc: hypervisor
    main_id: "#hypervisor-virtual-machine-load-and-store-instructions"
    desc:
      hypervisor:
        "#hypervisor-virtual-machine-load-and-store-instructions":
          text:
          - 'For every RV32I or RV64I load instruction, LB, LBU, LH, LHU, LW, LWU,
            and LD, there is a corresponding virtual-machine load instruction: HLV.B,
            HLV.BU, HLV.H, HLV.HU, HLV.W, HLV.WU, and HLV.D. For every RV32I or RV64I
            store instruction, SB, SH, SW, and SD, there is a corresponding virtual-machine
            store instruction: HSV.B, HSV.H, HSV.W, and HSV.D. Instructions HLV.WU,
            HLV.D, and HSV.D are not valid for RV32, of course.'
    iss_code:
    - require_extension('H');
    - require_novirt();
    - 'require_privilege(get_field(STATE.hstatus->read(), HSTATUS_HU) ? PRV_U : PRV_S);'
    - MMU.guest_store<uint16_t>(RS1, RS2);
  hsv.w:
    opcode:
    - hsv.w
    - 11..7=0
    - rs1
    - rs2
    - 31..25=0x35
    - 14..12=4
    - 6..2=0x1C
    - 1..0=3
    opcode_group: h
    opcode_args: *25
    main_url_base: "/riscv-priv-isa-manual/Priv-v1.12/hypervisor.html"
    main_desc: hypervisor
    main_id: "#hypervisor-virtual-machine-load-and-store-instructions"
    desc:
      hypervisor:
        "#hypervisor-virtual-machine-load-and-store-instructions":
          text:
          - 'For every RV32I or RV64I load instruction, LB, LBU, LH, LHU, LW, LWU,
            and LD, there is a corresponding virtual-machine load instruction: HLV.B,
            HLV.BU, HLV.H, HLV.HU, HLV.W, HLV.WU, and HLV.D. For every RV32I or RV64I
            store instruction, SB, SH, SW, and SD, there is a corresponding virtual-machine
            store instruction: HSV.B, HSV.H, HSV.W, and HSV.D. Instructions HLV.WU,
            HLV.D, and HSV.D are not valid for RV32, of course.'
    iss_code:
    - require_extension('H');
    - require_novirt();
    - 'require_privilege(get_field(STATE.hstatus->read(), HSTATUS_HU) ? PRV_U : PRV_S);'
    - MMU.guest_store<uint32_t>(RS1, RS2);
  j:
    opcode:
    - j
    - offset
    opcode_group: psuedo
    opcode_args:
    - offset
    psuedo_to_base:
    - jal x0, offset
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/rv32.html"
    main_desc: rv32
    main_id: "#immediate-encoding-variants"
    desc:
      rv32:
        "#immediate-encoding-variants":
          text:
          - There are a further two variants of the instruction formats (B/J) based
            on the handling of immediates, as shown in Figure 1.3 .
          - Similarly, the only difference between the U and J formats is that the
            20-bit immediate is shifted left by 12 bits to form U immediates and by
            1 bit to form J immediates. The location of instruction bits in the U
            and J format immediates is chosen to maximize overlap with the other formats
            and with each other.
          - Although more complex implementations might have separate adders for branch
            and jump calculations and so would not benefit from keeping the location
            of immediate bits constant across types of instruction, we wanted to reduce
            the hardware cost of the simplest implementations. By rotating bits in
            the instruction encoding of B and J immediates instead of using dynamic
            hardware muxes to multiply the immediate by 2, we reduce instruction signal
            fanout and immediate mux costs by around a factor of 2. The scrambled
            immediate encoding will add negligible time to static or ahead-of-time
            compilation. For dynamic generation of instructions, there is some small
            additional overhead, but the most common short forward branches have straightforward
            immediate encodings.
        "#unconditional-jumps":
          text:
          - The jump and link (JAL) instruction uses the J-type format, where the
            J-immediate encodes a signed offset in multiples of 2 bytes. The offset
            is sign-extended and added to the address of the jump instruction to form
            the jump target address. Jumps can therefore target a 1MiB range. JAL
            stores the address of the instruction following the jump (pc+4) into register
            rd. The standard software calling convention uses x1 as the return address
            register and x5 as an alternate link register.
          - Plain unconditional jumps (assembler pseudoinstruction J) are encoded
            as a JAL with rd=x0.
      rvwmo:
        "#ch:memorymodel":
          text:
          - This chapter defines the memory model for regular main memory operations.
            The interaction of the memory model with I/O memory, instruction fetches,
            FENCE.I, page table walks, and SFENCE.VMA is not (yet) formalized. Some
            or all of the above may be formalized in a future revision of this specification.
            The RV128 base ISA and future ISA extensions such as the "V" vector and
            "J" JIT extensions will need to be incorporated into a future revision
            as well.
      machine:
        "#sec:misa":
          text:
          - J
  jal:
    opcode:
    - jal
    - rd
    - jimm20
    - 6..2=0x1b
    - 1..0=3
    opcode_group: i
    opcode_args: &41
    - rd
    - jimm20
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/rv32.html"
    main_desc: rv32
    main_id: "#integer-register-immediate-instructions"
    desc:
      rv32:
        "#programmers-model-for-base-integer-isa":
          text:
          - Hardware might choose to accelerate function calls and returns that use
            x1 or x5. See the descriptions of the JAL and JALR instructions.
        "#integer-register-immediate-instructions":
          text:
          - The current PC can be obtained by setting the U-immediate to 0. Although
            a JAL +4 instruction could also be used to obtain the local PC (of the
            instruction following the JAL), it might cause pipeline breaks in simpler
            microarchitectures or pollute BTB structures in more complex microarchitectures.
        "#unconditional-jumps":
          text:
          - The jump and link (JAL) instruction uses the J-type format, where the
            J-immediate encodes a signed offset in multiples of 2 bytes. The offset
            is sign-extended and added to the address of the jump instruction to form
            the jump target address. Jumps can therefore target a 1MiB range. JAL
            stores the address of the instruction following the jump (pc+4) into register
            rd. The standard software calling convention uses x1 as the return address
            register and x5 as an alternate link register.
          - Plain unconditional jumps (assembler pseudoinstruction J) are encoded
            as a JAL with rd=x0.
          - The JAL and JALR instructions will generate an instruction-address-misaligned
            exception if the target address is not aligned to a four-byte boundary.
          - Return-address prediction stacks are a common feature of high-performance
            instruction-fetch units, but require accurate detection of instructions
            used for procedure calls and returns to be effective. For RISC-V, hints
            as to the instructions' usage are encoded implicitly via the register
            numbers used. A JAL instruction should push the return address onto a
            return-address stack (RAS) only when rd is x1 or x5. JALR instructions
            should push/pop a RAS as shown in the Table [rashints] .
        "#conditional-branches":
          text:
          - Unlike some other architectures, the RISC-V jump (JAL with rd=x0) instruction
            should always be used for unconditional branches instead of a conditional
            branch instruction with an always-true condition. RISC-V jumps are also
            PC-relative and support a much wider offset range than branches, and will
            not pollute conditional-branch prediction tables.
    iss_code:
    - reg_t tmp = npc;
    - set_pc(JUMP_TARGET);
    - WRITE_RD(tmp);
  jalr:
    opcode:
    - jalr
    - rd
    - rs1
    - imm12
    - 14..12=0
    - 6..2=0x19
    - 1..0=3
    opcode_group: i
    opcode_args: *2
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/rv32.html"
    main_desc: rv32
    main_id: "#integer-register-immediate-instructions"
    desc:
      rv32:
        "#programmers-model-for-base-integer-isa":
          text:
          - Hardware might choose to accelerate function calls and returns that use
            x1 or x5. See the descriptions of the JAL and JALR instructions.
        "#integer-register-immediate-instructions":
          text:
          - The AUIPC instruction supports two-instruction sequences to access arbitrary
            offsets from the PC for both control-flow transfers and data accesses.
            The combination of an AUIPC and the 12-bit immediate in a JALR can transfer
            control to any 32-bit PC-relative address, while an AUIPC plus the 12-bit
            immediate offset in regular load or store instructions can access any
            32-bit PC-relative data address.
        "#unconditional-jumps":
          text:
          - The indirect jump instruction JALR (jump and link register) uses the I-type
            encoding. The target address is obtained by adding the sign-extended 12-bit
            I-immediate to the register rs1, then setting the least-significant bit
            of the result to zero. The address of the instruction following the jump
            (pc+4) is written to register rd. Register x0 can be used as the destination
            if the result is not required.
          - The unconditional jump instructions all use PC-relative addressing to
            help support position-independent code. The JALR instruction was defined
            to enable a two-instruction sequence to jump anywhere in a 32-bit absolute
            address range. A LUI instruction can first load rs1 with the upper 20
            bits of a target address, then JALR can add in the lower bits. Similarly,
            AUIPC then JALR can jump anywhere in a 32-bit pc-relative address range.
          - Note that the JALR instruction does not treat the 12-bit immediate as
            multiples of 2 bytes, unlike the conditional branch instructions. This
            avoids one more immediate format in hardware. In practice, most uses of
            JALR will have either a zero immediate or be paired with a LUI or AUIPC,
            so the slight reduction in range is not significant.
          - Clearing the least-significant bit when calculating the JALR target address
            both simplifies the hardware slightly and allows the low bit of function
            pointers to be used to store auxiliary information. Although there is
            potentially a slight loss of error checking in this case, in practice
            jumps to an incorrect instruction address will usually quickly raise an
            exception.
          - When used with a base rs1=x0, JALR can be used to implement a single instruction
            subroutine call to the lowest 2KiB or highest 2KiB address region from
            anywhere in the address space, which could be used to implement fast calls
            to a small runtime library. Alternatively, an ABI could dedicate a general-purpose
            register to point to a library elsewhere in the address space.
          - The JAL and JALR instructions will generate an instruction-address-misaligned
            exception if the target address is not aligned to a four-byte boundary.
          - Return-address prediction stacks are a common feature of high-performance
            instruction-fetch units, but require accurate detection of instructions
            used for procedure calls and returns to be effective. For RISC-V, hints
            as to the instructions' usage are encoded implicitly via the register
            numbers used. A JAL instruction should push the return address onto a
            return-address stack (RAS) only when rd is x1 or x5. JALR instructions
            should push/pop a RAS as shown in the Table [rashints] .
      rv64:
        "#integer-register-immediate-instructions":
          text:
          - Note that the set of address offsets that can be formed by pairing LUI
            with LD, AUIPC with JALR, etc.in RV64I is [ - 231 - 211, 231 - 211 - 1].
      a:
        "#sec:lrscseq":
          text:
          - An LR/SC sequence begins with an LR instruction and ends with an SC instruction.
            The dynamic code executed between the LR and SC instructions can only
            contain instructions from the base "I" instruction set, excluding loads,
            stores, backward jumps, taken backward branches, JALR, FENCE, and SYSTEM
            instructions. If the "C" extension is supported, then compressed forms
            of the aforementioned "I" instructions are also permitted.
    iss_code:
    - reg_t tmp = npc;
    - set_pc((RS1 + insn.i_imm()) & ~reg_t(1));
    - WRITE_RD(tmp);
  jr:
    opcode:
    - jr
    - rs
    opcode_group: psuedo
    opcode_args:
    - rs
    psuedo_to_base:
    - jalr x0, rs, 0
  la:
    opcode:
    - la
    - rd
    - symbol
    opcode_group: psuedo
    opcode_args:
    - rd
    - symbol
    psuedo_to_base:
    - auipc rd, symbol@GOT[31:12]
    - l{w\
  lb:
    opcode:
    - lb
    - rd
    - rs1
    - imm12
    - 14..12=0
    - 6..2=0x00
    - 1..0=3
    opcode_group: i
    opcode_args: *2
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/rv32.html"
    main_desc: rv32
    main_id: "#sec:rv32:ldst"
    desc:
      rv32:
        "#sec:rv32:ldst":
          text:
          - The LW instruction loads a 32-bit value from memory into rd. LH loads
            a 16-bit value from memory, then sign-extends to 32-bits before storing
            in rd. LHU loads a 16-bit value from memory but then zero extends to 32-bits
            before storing in rd. LB and LBU are defined analogously for 8-bit values.
            The SW, SH, and SB instructions store 32-bit, 16-bit, and 8-bit values
            from the low bits of register rs2 to memory.
      rv64:
        "#load-and-store-instructions":
          text:
          - The LW instruction loads a 32-bit value from memory and sign-extends this
            to 64 bits before storing it in register rd for RV64I. The LWU instruction,
            on the other hand, zero-extends the 32-bit value from memory for RV64I.
            LH and LHU are defined analogously for 16-bit values, as are LB and LBU
            for 8-bit values. The SD, SW, SH, and SB instructions store 64-bit, 32-bit,
            16-bit, and 8-bit values from the low bits of register rs2 to memory respectively.
      hypervisor:
        "#hypervisor-virtual-machine-load-and-store-instructions":
          text:
          - 'For every RV32I or RV64I load instruction, LB, LBU, LH, LHU, LW, LWU,
            and LD, there is a corresponding virtual-machine load instruction: HLV.B,
            HLV.BU, HLV.H, HLV.HU, HLV.W, HLV.WU, and HLV.D. For every RV32I or RV64I
            store instruction, SB, SH, SW, and SD, there is a corresponding virtual-machine
            store instruction: HSV.B, HSV.H, HSV.W, and HSV.D. Instructions HLV.WU,
            HLV.D, and HSV.D are not valid for RV32, of course.'
        "#sec:tinst-vals":
          text:
          - For a standard load instruction that is not a compressed instruction and
            is one of LB, LBU, LH, LHU, LW, LWU, LD, FLW, FLD, FLQ, or FLH, the transformed
            instruction has the format shown in Figure 1.46 .
          - Transformed noncompressed load instruction (LB, LBU, LH, LHU, LW, LWU,
            LD, FLW, FLD, FLQ, or FLH). Fields funct3, rd, and opcode are the same
            as the trapping load instruction.
          - In decoding the contents of mtinst or htinst, once software has determined
            that the register contains the encoding of a standard basic load (LB,
            LBU, LH, LHU, LW, LWU, LD, FLW, FLD, FLQ, or FLH) or basic store (SB,
            SH, SW, SD, FSW, FSD, FSQ, or FSH), it is not necessary to confirm also
            that the immediate offset fields (31:25, and 24:20 or 11:7) are zeros.
            The knowledge that the register's value is the encoding of a basic load/store
            is sufficient to prove that the trapping instruction is of the same kind.
    iss_code:
    - WRITE_RD(MMU.load<int8_t>(RS1 + insn.i_imm()));
  lbu:
    opcode:
    - lbu
    - rd
    - rs1
    - imm12
    - 14..12=4
    - 6..2=0x00
    - 1..0=3
    opcode_group: i
    opcode_args: *2
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/rv32.html"
    main_desc: rv32
    main_id: "#sec:rv32:ldst"
    desc:
      rv32:
        "#sec:rv32:ldst":
          text:
          - The LW instruction loads a 32-bit value from memory into rd. LH loads
            a 16-bit value from memory, then sign-extends to 32-bits before storing
            in rd. LHU loads a 16-bit value from memory but then zero extends to 32-bits
            before storing in rd. LB and LBU are defined analogously for 8-bit values.
            The SW, SH, and SB instructions store 32-bit, 16-bit, and 8-bit values
            from the low bits of register rs2 to memory.
      rv64:
        "#load-and-store-instructions":
          text:
          - The LW instruction loads a 32-bit value from memory and sign-extends this
            to 64 bits before storing it in register rd for RV64I. The LWU instruction,
            on the other hand, zero-extends the 32-bit value from memory for RV64I.
            LH and LHU are defined analogously for 16-bit values, as are LB and LBU
            for 8-bit values. The SD, SW, SH, and SB instructions store 64-bit, 32-bit,
            16-bit, and 8-bit values from the low bits of register rs2 to memory respectively.
      hypervisor:
        "#hypervisor-virtual-machine-load-and-store-instructions":
          text:
          - 'For every RV32I or RV64I load instruction, LB, LBU, LH, LHU, LW, LWU,
            and LD, there is a corresponding virtual-machine load instruction: HLV.B,
            HLV.BU, HLV.H, HLV.HU, HLV.W, HLV.WU, and HLV.D. For every RV32I or RV64I
            store instruction, SB, SH, SW, and SD, there is a corresponding virtual-machine
            store instruction: HSV.B, HSV.H, HSV.W, and HSV.D. Instructions HLV.WU,
            HLV.D, and HSV.D are not valid for RV32, of course.'
        "#sec:tinst-vals":
          text:
          - For a standard load instruction that is not a compressed instruction and
            is one of LB, LBU, LH, LHU, LW, LWU, LD, FLW, FLD, FLQ, or FLH, the transformed
            instruction has the format shown in Figure 1.46 .
          - Transformed noncompressed load instruction (LB, LBU, LH, LHU, LW, LWU,
            LD, FLW, FLD, FLQ, or FLH). Fields funct3, rd, and opcode are the same
            as the trapping load instruction.
          - In decoding the contents of mtinst or htinst, once software has determined
            that the register contains the encoding of a standard basic load (LB,
            LBU, LH, LHU, LW, LWU, LD, FLW, FLD, FLQ, or FLH) or basic store (SB,
            SH, SW, SD, FSW, FSD, FSQ, or FSH), it is not necessary to confirm also
            that the immediate offset fields (31:25, and 24:20 or 11:7) are zeros.
            The knowledge that the register's value is the encoding of a basic load/store
            is sufficient to prove that the trapping instruction is of the same kind.
    iss_code:
    - WRITE_RD(MMU.load<uint8_t>(RS1 + insn.i_imm()));
  ld:
    opcode:
    - ld
    - rd
    - rs1
    - imm12
    - 14..12=3
    - 6..2=0x00
    - 1..0=3
    opcode_group: i
    opcode_args: *2
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/rv64.html"
    main_desc: rv64
    main_id: "#integer-register-immediate-instructions"
    desc:
      rv64:
        "#integer-register-immediate-instructions":
          text:
          - Note that the set of address offsets that can be formed by pairing LUI
            with LD, AUIPC with JALR, etc.in RV64I is [ - 231 - 211, 231 - 211 - 1].
        "#load-and-store-instructions":
          text:
          - The LD instruction loads a 64-bit value from memory into register rd for
            RV64I.
      hypervisor:
        "#hypervisor-virtual-machine-load-and-store-instructions":
          text:
          - 'For every RV32I or RV64I load instruction, LB, LBU, LH, LHU, LW, LWU,
            and LD, there is a corresponding virtual-machine load instruction: HLV.B,
            HLV.BU, HLV.H, HLV.HU, HLV.W, HLV.WU, and HLV.D. For every RV32I or RV64I
            store instruction, SB, SH, SW, and SD, there is a corresponding virtual-machine
            store instruction: HSV.B, HSV.H, HSV.W, and HSV.D. Instructions HLV.WU,
            HLV.D, and HSV.D are not valid for RV32, of course.'
        "#sec:tinst-vals":
          text:
          - For a standard load instruction that is not a compressed instruction and
            is one of LB, LBU, LH, LHU, LW, LWU, LD, FLW, FLD, FLQ, or FLH, the transformed
            instruction has the format shown in Figure 1.46 .
          - Transformed noncompressed load instruction (LB, LBU, LH, LHU, LW, LWU,
            LD, FLW, FLD, FLQ, or FLH). Fields funct3, rd, and opcode are the same
            as the trapping load instruction.
          - In decoding the contents of mtinst or htinst, once software has determined
            that the register contains the encoding of a standard basic load (LB,
            LBU, LH, LHU, LW, LWU, LD, FLW, FLD, FLQ, or FLH) or basic store (SB,
            SH, SW, SD, FSW, FSD, FSQ, or FSH), it is not necessary to confirm also
            that the immediate offset fields (31:25, and 24:20 or 11:7) are zeros.
            The knowledge that the register's value is the encoding of a basic load/store
            is sufficient to prove that the trapping instruction is of the same kind.
    iss_code:
    - require_rv64;
    - WRITE_RD(MMU.load<int64_t>(RS1 + insn.i_imm()));
  lga:
    opcode:
    - lga
    - rd
    - symbol
    opcode_group: psuedo
    opcode_args:
    - rd
    - symbol
    psuedo_to_base:
    - auipc rd, symbol@GOT[31:12]
    - l{w\
  lh:
    opcode:
    - lh
    - rd
    - rs1
    - imm12
    - 14..12=1
    - 6..2=0x00
    - 1..0=3
    opcode_group: i
    opcode_args: *2
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/rv32.html"
    main_desc: rv32
    main_id: "#sec:rv32:ldst"
    desc:
      rv32:
        "#sec:rv32:ldst":
          text:
          - The LW instruction loads a 32-bit value from memory into rd. LH loads
            a 16-bit value from memory, then sign-extends to 32-bits before storing
            in rd. LHU loads a 16-bit value from memory but then zero extends to 32-bits
            before storing in rd. LB and LBU are defined analogously for 8-bit values.
            The SW, SH, and SB instructions store 32-bit, 16-bit, and 8-bit values
            from the low bits of register rs2 to memory.
      rv64:
        "#load-and-store-instructions":
          text:
          - The LW instruction loads a 32-bit value from memory and sign-extends this
            to 64 bits before storing it in register rd for RV64I. The LWU instruction,
            on the other hand, zero-extends the 32-bit value from memory for RV64I.
            LH and LHU are defined analogously for 16-bit values, as are LB and LBU
            for 8-bit values. The SD, SW, SH, and SB instructions store 64-bit, 32-bit,
            16-bit, and 8-bit values from the low bits of register rs2 to memory respectively.
      hypervisor:
        "#hypervisor-virtual-machine-load-and-store-instructions":
          text:
          - 'For every RV32I or RV64I load instruction, LB, LBU, LH, LHU, LW, LWU,
            and LD, there is a corresponding virtual-machine load instruction: HLV.B,
            HLV.BU, HLV.H, HLV.HU, HLV.W, HLV.WU, and HLV.D. For every RV32I or RV64I
            store instruction, SB, SH, SW, and SD, there is a corresponding virtual-machine
            store instruction: HSV.B, HSV.H, HSV.W, and HSV.D. Instructions HLV.WU,
            HLV.D, and HSV.D are not valid for RV32, of course.'
        "#sec:tinst-vals":
          text:
          - For a standard load instruction that is not a compressed instruction and
            is one of LB, LBU, LH, LHU, LW, LWU, LD, FLW, FLD, FLQ, or FLH, the transformed
            instruction has the format shown in Figure 1.46 .
          - Transformed noncompressed load instruction (LB, LBU, LH, LHU, LW, LWU,
            LD, FLW, FLD, FLQ, or FLH). Fields funct3, rd, and opcode are the same
            as the trapping load instruction.
          - In decoding the contents of mtinst or htinst, once software has determined
            that the register contains the encoding of a standard basic load (LB,
            LBU, LH, LHU, LW, LWU, LD, FLW, FLD, FLQ, or FLH) or basic store (SB,
            SH, SW, SD, FSW, FSD, FSQ, or FSH), it is not necessary to confirm also
            that the immediate offset fields (31:25, and 24:20 or 11:7) are zeros.
            The knowledge that the register's value is the encoding of a basic load/store
            is sufficient to prove that the trapping instruction is of the same kind.
    iss_code:
    - WRITE_RD(MMU.load<int16_t>(RS1 + insn.i_imm()));
  lhu:
    opcode:
    - lhu
    - rd
    - rs1
    - imm12
    - 14..12=5
    - 6..2=0x00
    - 1..0=3
    opcode_group: i
    opcode_args: *2
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/rv32.html"
    main_desc: rv32
    main_id: "#sec:rv32:ldst"
    desc:
      rv32:
        "#sec:rv32:ldst":
          text:
          - The LW instruction loads a 32-bit value from memory into rd. LH loads
            a 16-bit value from memory, then sign-extends to 32-bits before storing
            in rd. LHU loads a 16-bit value from memory but then zero extends to 32-bits
            before storing in rd. LB and LBU are defined analogously for 8-bit values.
            The SW, SH, and SB instructions store 32-bit, 16-bit, and 8-bit values
            from the low bits of register rs2 to memory.
      rv64:
        "#load-and-store-instructions":
          text:
          - The LW instruction loads a 32-bit value from memory and sign-extends this
            to 64 bits before storing it in register rd for RV64I. The LWU instruction,
            on the other hand, zero-extends the 32-bit value from memory for RV64I.
            LH and LHU are defined analogously for 16-bit values, as are LB and LBU
            for 8-bit values. The SD, SW, SH, and SB instructions store 64-bit, 32-bit,
            16-bit, and 8-bit values from the low bits of register rs2 to memory respectively.
      hypervisor:
        "#hypervisor-virtual-machine-load-and-store-instructions":
          text:
          - 'For every RV32I or RV64I load instruction, LB, LBU, LH, LHU, LW, LWU,
            and LD, there is a corresponding virtual-machine load instruction: HLV.B,
            HLV.BU, HLV.H, HLV.HU, HLV.W, HLV.WU, and HLV.D. For every RV32I or RV64I
            store instruction, SB, SH, SW, and SD, there is a corresponding virtual-machine
            store instruction: HSV.B, HSV.H, HSV.W, and HSV.D. Instructions HLV.WU,
            HLV.D, and HSV.D are not valid for RV32, of course.'
        "#sec:tinst-vals":
          text:
          - For a standard load instruction that is not a compressed instruction and
            is one of LB, LBU, LH, LHU, LW, LWU, LD, FLW, FLD, FLQ, or FLH, the transformed
            instruction has the format shown in Figure 1.46 .
          - Transformed noncompressed load instruction (LB, LBU, LH, LHU, LW, LWU,
            LD, FLW, FLD, FLQ, or FLH). Fields funct3, rd, and opcode are the same
            as the trapping load instruction.
          - In decoding the contents of mtinst or htinst, once software has determined
            that the register contains the encoding of a standard basic load (LB,
            LBU, LH, LHU, LW, LWU, LD, FLW, FLD, FLQ, or FLH) or basic store (SB,
            SH, SW, SD, FSW, FSD, FSQ, or FSH), it is not necessary to confirm also
            that the immediate offset fields (31:25, and 24:20 or 11:7) are zeros.
            The knowledge that the register's value is the encoding of a basic load/store
            is sufficient to prove that the trapping instruction is of the same kind.
    iss_code:
    - WRITE_RD(MMU.load<uint16_t>(RS1 + insn.i_imm()));
  li:
    opcode:
    - li
    - rd
    - immediate
    opcode_group: psuedo
    opcode_args:
    - rd
    - immediate
    psuedo_to_base:
    - "*Myriad sequences*"
  lla:
    opcode:
    - lla
    - rd
    - symbol
    opcode_group: psuedo
    opcode_args:
    - rd
    - symbol
    psuedo_to_base:
    - auipc rd, symbol[31:12]
    - addi rd, rd, symbol[11:0]
  lr.d:
    opcode:
    - lr.d
    - rd
    - rs1
    - 24..20=0
    - aq
    - rl
    - 31..29=0
    - 28..27=2
    - 14..12=3
    - 6..2=0x0B
    - 1..0=3
    opcode_group: a
    opcode_args: *3
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/a.html"
    main_desc: a
    main_id: "#sec:lrsc"
    desc:
      a:
        "#sec:lrsc":
          text:
          - 'Complex atomic memory operations on a single memory word or doubleword
            are performed with the load-reserved (LR) and store-conditional (SC) instructions.
            LR.W loads a word from the address in rs1, places the sign-extended value
            in rd, and registers a reservation set--a set of bytes that subsumes the
            bytes in the addressed word. SC.W conditionally writes a word in rs2 to
            the address in rs1: the SC.W succeeds only if the reservation is still
            valid and the reservation set contains the bytes being written. If the
            SC.W succeeds, the instruction writes the word in rs2 to memory, and it
            writes zero to rd. If the SC.W fails, the instruction does not write to
            memory, and it writes a nonzero value to rd. Regardless of success or
            failure, executing an SC.W instruction invalidates any reservation held
            by this hart. LR.D and SC.D act analogously on doublewords and are only
            available on RV64. For RV64, LR.W and SC.W sign-extend the value placed
            in rd.'
    iss_code:
    - require_extension('A');
    - require_rv64;
    - WRITE_RD(MMU.load_reserved<int64_t>(RS1));
  lr.w:
    opcode:
    - lr.w
    - rd
    - rs1
    - 24..20=0
    - aq
    - rl
    - 31..29=0
    - 28..27=2
    - 14..12=2
    - 6..2=0x0B
    - 1..0=3
    opcode_group: a
    opcode_args: *3
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/a.html"
    main_desc: a
    main_id: "#sec:lrsc"
    desc:
      a:
        "#sec:lrsc":
          text:
          - 'Complex atomic memory operations on a single memory word or doubleword
            are performed with the load-reserved (LR) and store-conditional (SC) instructions.
            LR.W loads a word from the address in rs1, places the sign-extended value
            in rd, and registers a reservation set--a set of bytes that subsumes the
            bytes in the addressed word. SC.W conditionally writes a word in rs2 to
            the address in rs1: the SC.W succeeds only if the reservation is still
            valid and the reservation set contains the bytes being written. If the
            SC.W succeeds, the instruction writes the word in rs2 to memory, and it
            writes zero to rd. If the SC.W fails, the instruction does not write to
            memory, and it writes a nonzero value to rd. Regardless of success or
            failure, executing an SC.W instruction invalidates any reservation held
            by this hart. LR.D and SC.D act analogously on doublewords and are only
            available on RV64. For RV64, LR.W and SC.W sign-extend the value placed
            in rd.'
    iss_code:
    - require_extension('A');
    - WRITE_RD(MMU.load_reserved<int32_t>(RS1));
  lui:
    opcode:
    - lui
    - rd
    - imm20
    - 6..2=0x0D
    - 1..0=3
    opcode_group: i
    opcode_args: *26
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/rv32.html"
    main_desc: rv32
    main_id: "#integer-register-immediate-instructions"
    desc:
      rv32:
        "#integer-register-immediate-instructions":
          text:
          - LUI (load upper immediate) is used to build 32-bit constants and uses
            the U-type format. LUI places the 32-bit U-immediate value into the destination
            register rd, filling in the lowest 12 bits with zeros.
        "#unconditional-jumps":
          text:
          - The unconditional jump instructions all use PC-relative addressing to
            help support position-independent code. The JALR instruction was defined
            to enable a two-instruction sequence to jump anywhere in a 32-bit absolute
            address range. A LUI instruction can first load rs1 with the upper 20
            bits of a target address, then JALR can add in the lower bits. Similarly,
            AUIPC then JALR can jump anywhere in a 32-bit pc-relative address range.
          - Note that the JALR instruction does not treat the 12-bit immediate as
            multiples of 2 bytes, unlike the conditional branch instructions. This
            avoids one more immediate format in hardware. In practice, most uses of
            JALR will have either a zero immediate or be paired with a LUI or AUIPC,
            so the slight reduction in range is not significant.
      rv64:
        "#integer-register-immediate-instructions":
          text:
          - LUI (load upper immediate) uses the same opcode as RV32I. LUI places the
            32-bit U-immediate into register rd, filling in the lowest 12 bits with
            zeros. The 32-bit result is sign-extended to 64 bits.
          - Note that the set of address offsets that can be formed by pairing LUI
            with LD, AUIPC with JALR, etc.in RV64I is [ - 231 - 211, 231 - 211 - 1].
    iss_code:
    - WRITE_RD(insn.u_imm());
  lw:
    opcode:
    - lw
    - rd
    - rs1
    - imm12
    - 14..12=2
    - 6..2=0x00
    - 1..0=3
    opcode_group: i
    opcode_args: *2
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/rv32.html"
    main_desc: rv32
    main_id: "#sec:rv32:ldst"
    desc:
      rv32:
        "#sec:rv32:ldst":
          text:
          - The LW instruction loads a 32-bit value from memory into rd. LH loads
            a 16-bit value from memory, then sign-extends to 32-bits before storing
            in rd. LHU loads a 16-bit value from memory but then zero extends to 32-bits
            before storing in rd. LB and LBU are defined analogously for 8-bit values.
            The SW, SH, and SB instructions store 32-bit, 16-bit, and 8-bit values
            from the low bits of register rs2 to memory.
      rv64:
        "#load-and-store-instructions":
          text:
          - The LW instruction loads a 32-bit value from memory and sign-extends this
            to 64 bits before storing it in register rd for RV64I. The LWU instruction,
            on the other hand, zero-extends the 32-bit value from memory for RV64I.
            LH and LHU are defined analogously for 16-bit values, as are LB and LBU
            for 8-bit values. The SD, SW, SH, and SB instructions store 64-bit, 32-bit,
            16-bit, and 8-bit values from the low bits of register rs2 to memory respectively.
      hypervisor:
        "#hypervisor-virtual-machine-load-and-store-instructions":
          text:
          - 'For every RV32I or RV64I load instruction, LB, LBU, LH, LHU, LW, LWU,
            and LD, there is a corresponding virtual-machine load instruction: HLV.B,
            HLV.BU, HLV.H, HLV.HU, HLV.W, HLV.WU, and HLV.D. For every RV32I or RV64I
            store instruction, SB, SH, SW, and SD, there is a corresponding virtual-machine
            store instruction: HSV.B, HSV.H, HSV.W, and HSV.D. Instructions HLV.WU,
            HLV.D, and HSV.D are not valid for RV32, of course.'
        "#sec:tinst-vals":
          text:
          - In this case, the instruction that trapped is the same kind as indicated
            by the register value, and the register value is the transformation of
            the trapping instruction, as defined later. For example, if bits 1:0 are
            binary 11 and the register value is the encoding of a standard LW (load
            word) instruction, then the trapping instruction is LW, and the register
            value is the transformation of the trapping LW instruction.
          - To be forward-compatible with future revisions of this standard, software
            that interprets a nonzero value from mtinst or htinst must fully verify
            that the value conforms to one of the cases listed above. For instance,
            for RV64, discovering that bits 6:0 of mtinst are 0000011 and bits 14:12
            are 010 is not sufficient to establish that the first case applies and
            the trapping instruction is a standard LW instruction; rather, software
            must also confirm that bits 63:32 of mtinst are all zeros. A future standard
            might define new values for 64-bit mtinst that are nonzero in bits 63:32
            yet may coincidentally have in bits 31:0 the same bit patterns as standard
            RV64 instructions.
          - For a standard load instruction that is not a compressed instruction and
            is one of LB, LBU, LH, LHU, LW, LWU, LD, FLW, FLD, FLQ, or FLH, the transformed
            instruction has the format shown in Figure 1.46 .
          - Transformed noncompressed load instruction (LB, LBU, LH, LHU, LW, LWU,
            LD, FLW, FLD, FLQ, or FLH). Fields funct3, rd, and opcode are the same
            as the trapping load instruction.
          - In decoding the contents of mtinst or htinst, once software has determined
            that the register contains the encoding of a standard basic load (LB,
            LBU, LH, LHU, LW, LWU, LD, FLW, FLD, FLQ, or FLH) or basic store (SB,
            SH, SW, SD, FSW, FSD, FSQ, or FSH), it is not necessary to confirm also
            that the immediate offset fields (31:25, and 24:20 or 11:7) are zeros.
            The knowledge that the register's value is the encoding of a basic load/store
            is sufficient to prove that the trapping instruction is of the same kind.
    iss_code:
    - WRITE_RD(MMU.load<int32_t>(RS1 + insn.i_imm()));
  lwu:
    opcode:
    - lwu
    - rd
    - rs1
    - imm12
    - 14..12=6
    - 6..2=0x00
    - 1..0=3
    opcode_group: i
    opcode_args: *2
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/rv64.html"
    main_desc: rv64
    main_id: "#load-and-store-instructions"
    desc:
      rv64:
        "#load-and-store-instructions":
          text:
          - The LW instruction loads a 32-bit value from memory and sign-extends this
            to 64 bits before storing it in register rd for RV64I. The LWU instruction,
            on the other hand, zero-extends the 32-bit value from memory for RV64I.
            LH and LHU are defined analogously for 16-bit values, as are LB and LBU
            for 8-bit values. The SD, SW, SH, and SB instructions store 64-bit, 32-bit,
            16-bit, and 8-bit values from the low bits of register rs2 to memory respectively.
      hypervisor:
        "#hypervisor-virtual-machine-load-and-store-instructions":
          text:
          - 'For every RV32I or RV64I load instruction, LB, LBU, LH, LHU, LW, LWU,
            and LD, there is a corresponding virtual-machine load instruction: HLV.B,
            HLV.BU, HLV.H, HLV.HU, HLV.W, HLV.WU, and HLV.D. For every RV32I or RV64I
            store instruction, SB, SH, SW, and SD, there is a corresponding virtual-machine
            store instruction: HSV.B, HSV.H, HSV.W, and HSV.D. Instructions HLV.WU,
            HLV.D, and HSV.D are not valid for RV32, of course.'
          - HLVX.WU is valid for RV32, even though LWU and HLV.WU are not. (For RV32,
            HLVX.WU can be considered a variant of HLV.W, as sign extension is irrelevant
            for 32-bit values.)
        "#sec:tinst-vals":
          text:
          - For a standard load instruction that is not a compressed instruction and
            is one of LB, LBU, LH, LHU, LW, LWU, LD, FLW, FLD, FLQ, or FLH, the transformed
            instruction has the format shown in Figure 1.46 .
          - Transformed noncompressed load instruction (LB, LBU, LH, LHU, LW, LWU,
            LD, FLW, FLD, FLQ, or FLH). Fields funct3, rd, and opcode are the same
            as the trapping load instruction.
          - In decoding the contents of mtinst or htinst, once software has determined
            that the register contains the encoding of a standard basic load (LB,
            LBU, LH, LHU, LW, LWU, LD, FLW, FLD, FLQ, or FLH) or basic store (SB,
            SH, SW, SD, FSW, FSD, FSQ, or FSH), it is not necessary to confirm also
            that the immediate offset fields (31:25, and 24:20 or 11:7) are zeros.
            The knowledge that the register's value is the encoding of a basic load/store
            is sufficient to prove that the trapping instruction is of the same kind.
    iss_code:
    - require_rv64;
    - WRITE_RD(MMU.load<uint32_t>(RS1 + insn.i_imm()));
  max:
    opcode:
    - max
    - rd
    - rs1
    - rs2
    - 31..25=5
    - 14..12=6
    - 6..2=0x0C
    - 1..0=3
    opcode_group: zbb
    opcode_args: *1
    iss_code:
    - require_either_extension(EXT_ZBPBO, EXT_ZBB);
    - 'WRITE_RD(sext_xlen(sreg_t(RS1) > sreg_t(RS2) ? RS1 : RS2));'
  maxu:
    opcode:
    - maxu
    - rd
    - rs1
    - rs2
    - 31..25=5
    - 14..12=7
    - 6..2=0x0C
    - 1..0=3
    opcode_group: zbb
    opcode_args: *1
    iss_code:
    - require_extension(EXT_ZBB);
    - 'WRITE_RD(sext_xlen(RS1 > RS2 ? RS1 : RS2));'
  min:
    opcode:
    - min
    - rd
    - rs1
    - rs2
    - 31..25=5
    - 14..12=4
    - 6..2=0x0C
    - 1..0=3
    opcode_group: zbb
    opcode_args: *1
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_register_grouping_vlmul20"
    desc:
      v:
        "#_vector_register_grouping_vlmul20":
          text:
          - MIN
        "#_vector_loadstore_whole_register_instructions":
          text:
          - MIN
    iss_code:
    - require_either_extension(EXT_ZBPBO, EXT_ZBB);
    - 'WRITE_RD(sext_xlen(sreg_t(RS1) < sreg_t(RS2) ? RS1 : RS2));'
  minu:
    opcode:
    - minu
    - rd
    - rs1
    - rs2
    - 31..25=5
    - 14..12=5
    - 6..2=0x0C
    - 1..0=3
    opcode_group: zbb
    opcode_args: *1
    iss_code:
    - require_extension(EXT_ZBB);
    - 'WRITE_RD(sext_xlen(RS1 < RS2 ? RS1 : RS2));'
  mret:
    opcode:
    - mret
    - 11..7=0
    - 19..15=0
    - 31..20=0x302
    - 14..12=0
    - 6..2=0x1C
    - 1..0=3
    opcode_group: system
    opcode_args: *18
    main_url_base: "/riscv-priv-isa-manual/Priv-v1.12/machine.html"
    main_desc: machine
    main_id: "#privstack"
    desc:
      machine:
        "#privstack":
          text:
          - An MRET or SRET instruction is used to return from a trap in M-mode or
            S-mode respectively. When executing an xRET instruction, supposing xPP
            holds the value y, xIE is set to xPIE; the privilege mode is changed to
            y; xPIE is set to 1; and xPP is set to the least-privileged supported
            mode (U if U-mode is implemented, else M). If xPP M, xRET also sets MPRV=0.
        "#memory-privilege-in-mstatus-register":
          text:
          - An MRET or SRET instruction that changes the privilege mode to a mode
            less privileged than M also sets MPRV=0.
        "#machine-trap-delegation-registers-medeleg-and-mideleg":
          text:
          - By default, all traps at any privilege level are handled in machine mode,
            though a machine-mode handler can redirect traps back to the appropriate
            level with the MRET instruction (Section 1.3.2 ). To increase performance,
            implementations can provide individual read/write bits within medeleg
            and mideleg to indicate that certain exceptions and interrupts should
            be processed directly by a lower privilege level. The machine exception
            delegation register (medeleg) and machine interrupt delegation register
            ( mideleg) are MXLEN-bit read/write registers.
        "#machine-exception-program-counter-mepc":
          text:
          - If an implementation allows IALIGN to be either 16 or 32 (by changing
            CSR misa, for example), then, whenever IALIGN=32, bit mepc[1] is masked
            on reads so that it appears to be 0. This masking occurs also for the
            implicit read by the MRET instruction. Though masked, mepc[1] remains
            writable when IALIGN=32.
        "#otherpriv":
          text:
          - To return after handling a trap, there are separate trap return instructions
            per privilege level, MRET and SRET. MRET is always provided. SRET must
            be provided if supervisor mode is supported, and should raise an illegal
            instruction exception otherwise. SRET should also raise an illegal instruction
            exception when TSR=1 in mstatus, as described in Section 1.1.6.5 . An
            xRET instruction can be executed in privilege mode x or higher, where
            executing a lower-privilege xRET instruction will pop the relevant lower-privilege
            interrupt enable and privilege mode stack. In addition to manipulating
            the privilege stack as described in Section 1.1.6.1 , xRET sets the pc
            to the value stored in the xepc register.
      hypervisor:
        "#machine-status-registers-mstatus-and-mstatush":
          text:
          - The MPV bit (Machine Previous Virtualization Mode) is written by the implementation
            whenever a trap is taken into M-mode. Just as the MPP field is set to
            the (nominal) privilege mode at the time of the trap, the MPV bit is set
            to the value of the virtualization mode V at the time of the trap. When
            an MRET instruction is executed, the virtualization mode V is set to MPV,
            unless MPP=3, in which case V remains 0.
        "#trap-return":
          text:
          - The MRET instruction is used to return from a trap taken into M-mode.
            MRET first determines what the new privilege mode will be according to
            the values of MPP and MPV in mstatus or mstatush, as encoded in Table
            [h-mpp] . MRET then in mstatus/mstatush sets MPV=0, MPP=0, MIE=MPIE, and
            MPIE=1. Lastly, MRET sets the privilege mode as previously determined,
            and sets pc=mepc.
    iss_code:
    - require_privilege(PRV_M);
    - set_pc_and_serialize(p->get_state()->mepc->read());
    - reg_t s = STATE.mstatus->read();
    - reg_t prev_prv = get_field(s, MSTATUS_MPP);
    - reg_t prev_virt = get_field(s, MSTATUS_MPV);
    - if (prev_prv != PRV_M)
    - s = set_field(s, MSTATUS_MPRV, 0);
    - s = set_field(s, MSTATUS_MIE, get_field(s, MSTATUS_MPIE));
    - s = set_field(s, MSTATUS_MPIE, 1);
    - 's = set_field(s, MSTATUS_MPP, p->extension_enabled(''U'') ? PRV_U : PRV_M);'
    - s = set_field(s, MSTATUS_MPV, 0);
    - p->put_csr(CSR_MSTATUS, s);
    - p->set_privilege(prev_prv, prev_virt);
  mul:
    opcode:
    - mul
    - rd
    - rs1
    - rs2
    - 31..25=1
    - 14..12=0
    - 6..2=0x0C
    - 1..0=3
    opcode_group: m
    opcode_args: *1
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/m.html"
    main_desc: m
    main_id: "#multiplication-operations"
    desc:
      m:
        "#multiplication-operations":
          text:
          - 'MUL performs an XLEN-bitXLEN-bit multiplication of rs1 by rs2 and places
            the lower XLEN bits in the destination register. MULH, MULHU, and MULHSU
            perform the same multiplication but return the upper XLEN bits of the
            full 2XLEN-bit product, for signedsigned, unsignedunsigned, and signedrs1unsignedrs2
            multiplication, respectively. If both the high and low bits of the same
            product are required, then the recommended code sequence is: MULH[[S]U]
            rdh, rs1, rs2; MUL rdl, rs1, rs2 (source register specifiers must be in
            same order and rdh cannot be the same as rs1 or rs2). Microarchitectures
            can then fuse these into a single multiply operation instead of performing
            two separate multiplies.'
          - In RV64, MUL can be used to obtain the upper 32 bits of the 64-bit product,
            but signed arguments must be proper 32-bit signed values, whereas unsigned
            arguments must have their upper 32 bits clear. If the arguments are not
            known to be sign- or zero-extended, an alternative is to shift both arguments
            left by 32 bits, then use MULH[[S]U].
        "#zmmul-extension-version-0.1":
          text:
          - 'The Zmmul extension implements the multiplication subset of the M extension.
            It adds all of the instructions defined in Section 1.1 , namely: MUL,
            MULH, MULHU, MULHSU, and (for RV64 only) MULW. The encodings are identical
            to those of the corresponding M-extension instructions.'
    iss_code:
    - require_either_extension('M', EXT_ZMMUL);
    - WRITE_RD(sext_xlen(RS1 * RS2));
  mulh:
    opcode:
    - mulh
    - rd
    - rs1
    - rs2
    - 31..25=1
    - 14..12=1
    - 6..2=0x0C
    - 1..0=3
    opcode_group: m
    opcode_args: *1
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/m.html"
    main_desc: m
    main_id: "#multiplication-operations"
    desc:
      m:
        "#multiplication-operations":
          text:
          - 'MUL performs an XLEN-bitXLEN-bit multiplication of rs1 by rs2 and places
            the lower XLEN bits in the destination register. MULH, MULHU, and MULHSU
            perform the same multiplication but return the upper XLEN bits of the
            full 2XLEN-bit product, for signedsigned, unsignedunsigned, and signedrs1unsignedrs2
            multiplication, respectively. If both the high and low bits of the same
            product are required, then the recommended code sequence is: MULH[[S]U]
            rdh, rs1, rs2; MUL rdl, rs1, rs2 (source register specifiers must be in
            same order and rdh cannot be the same as rs1 or rs2). Microarchitectures
            can then fuse these into a single multiply operation instead of performing
            two separate multiplies.'
          - In RV64, MUL can be used to obtain the upper 32 bits of the 64-bit product,
            but signed arguments must be proper 32-bit signed values, whereas unsigned
            arguments must have their upper 32 bits clear. If the arguments are not
            known to be sign- or zero-extended, an alternative is to shift both arguments
            left by 32 bits, then use MULH[[S]U].
        "#zmmul-extension-version-0.1":
          text:
          - 'The Zmmul extension implements the multiplication subset of the M extension.
            It adds all of the instructions defined in Section 1.1 , namely: MUL,
            MULH, MULHU, MULHSU, and (for RV64 only) MULW. The encodings are identical
            to those of the corresponding M-extension instructions.'
    iss_code:
    - require_either_extension('M', EXT_ZMMUL);
    - if (xlen == 64)
    - WRITE_RD(mulh(RS1, RS2));
    - else
    - WRITE_RD(sext32((sext32(RS1) * sext32(RS2)) >> 32));
  mulhsu:
    opcode:
    - mulhsu
    - rd
    - rs1
    - rs2
    - 31..25=1
    - 14..12=2
    - 6..2=0x0C
    - 1..0=3
    opcode_group: m
    opcode_args: *1
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/m.html"
    main_desc: m
    main_id: "#multiplication-operations"
    desc:
      m:
        "#multiplication-operations":
          text:
          - 'MUL performs an XLEN-bitXLEN-bit multiplication of rs1 by rs2 and places
            the lower XLEN bits in the destination register. MULH, MULHU, and MULHSU
            perform the same multiplication but return the upper XLEN bits of the
            full 2XLEN-bit product, for signedsigned, unsignedunsigned, and signedrs1unsignedrs2
            multiplication, respectively. If both the high and low bits of the same
            product are required, then the recommended code sequence is: MULH[[S]U]
            rdh, rs1, rs2; MUL rdl, rs1, rs2 (source register specifiers must be in
            same order and rdh cannot be the same as rs1 or rs2). Microarchitectures
            can then fuse these into a single multiply operation instead of performing
            two separate multiplies.'
          - MULHSU is used in multi-word signed multiplication to multiply the most-significant
            word of the multiplicand (which contains the sign bit) with the less-significant
            words of the multiplier (which are unsigned).
        "#zmmul-extension-version-0.1":
          text:
          - 'The Zmmul extension implements the multiplication subset of the M extension.
            It adds all of the instructions defined in Section 1.1 , namely: MUL,
            MULH, MULHU, MULHSU, and (for RV64 only) MULW. The encodings are identical
            to those of the corresponding M-extension instructions.'
    iss_code:
    - require_either_extension('M', EXT_ZMMUL);
    - if (xlen == 64)
    - WRITE_RD(mulhsu(RS1, RS2));
    - else
    - WRITE_RD(sext32((sext32(RS1) * reg_t((uint32_t)RS2)) >> 32));
  mulhu:
    opcode:
    - mulhu
    - rd
    - rs1
    - rs2
    - 31..25=1
    - 14..12=3
    - 6..2=0x0C
    - 1..0=3
    opcode_group: m
    opcode_args: *1
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/m.html"
    main_desc: m
    main_id: "#multiplication-operations"
    desc:
      m:
        "#multiplication-operations":
          text:
          - 'MUL performs an XLEN-bitXLEN-bit multiplication of rs1 by rs2 and places
            the lower XLEN bits in the destination register. MULH, MULHU, and MULHSU
            perform the same multiplication but return the upper XLEN bits of the
            full 2XLEN-bit product, for signedsigned, unsignedunsigned, and signedrs1unsignedrs2
            multiplication, respectively. If both the high and low bits of the same
            product are required, then the recommended code sequence is: MULH[[S]U]
            rdh, rs1, rs2; MUL rdl, rs1, rs2 (source register specifiers must be in
            same order and rdh cannot be the same as rs1 or rs2). Microarchitectures
            can then fuse these into a single multiply operation instead of performing
            two separate multiplies.'
        "#zmmul-extension-version-0.1":
          text:
          - 'The Zmmul extension implements the multiplication subset of the M extension.
            It adds all of the instructions defined in Section 1.1 , namely: MUL,
            MULH, MULHU, MULHSU, and (for RV64 only) MULW. The encodings are identical
            to those of the corresponding M-extension instructions.'
    iss_code:
    - require_either_extension('M', EXT_ZMMUL);
    - if (xlen == 64)
    - WRITE_RD(mulhu(RS1, RS2));
    - else
    - WRITE_RD(sext32(((uint64_t)(uint32_t)RS1 * (uint64_t)(uint32_t)RS2) >> 32));
  mulw:
    opcode:
    - mulw
    - rd
    - rs1
    - rs2
    - 31..25=1
    - 14..12=0
    - 6..2=0x0E
    - 1..0=3
    opcode_group: m
    opcode_args: *1
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/m.html"
    main_desc: m
    main_id: "#multiplication-operations"
    desc:
      m:
        "#multiplication-operations":
          text:
          - MULW is an RV64 instruction that multiplies the lower 32 bits of the source
            registers, placing the sign-extension of the lower 32 bits of the result
            into the destination register.
        "#zmmul-extension-version-0.1":
          text:
          - 'The Zmmul extension implements the multiplication subset of the M extension.
            It adds all of the instructions defined in Section 1.1 , namely: MUL,
            MULH, MULHU, MULHSU, and (for RV64 only) MULW. The encodings are identical
            to those of the corresponding M-extension instructions.'
    iss_code:
    - require_either_extension('M', EXT_ZMMUL);
    - require_rv64;
    - WRITE_RD(sext32(RS1 * RS2));
  mv:
    opcode:
    - mv
    - rd
    - rs
    opcode_group: psuedo
    opcode_args:
    - rd
    - rs
    psuedo_to_base:
    - addi rd, rs, 0
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/rv32.html"
    main_desc: rv32
    main_id: "#integer-register-immediate-instructions"
    desc:
      rv32:
        "#integer-register-immediate-instructions":
          text:
          - ADDI adds the sign-extended 12-bit immediate to register rs1. Arithmetic
            overflow is ignored and the result is simply the low XLEN bits of the
            result. ADDI rd, rs1, 0 is used to implement the MV rd, rs1 assembler
            pseudoinstruction.
      f:
        "#single-precision-floating-point-conversion-and-move-instructions":
          text:
          - The sign-injection instructions provide floating-point MV, ABS, and NEG,
            as well as supporting a few other operations, including the IEEE copySign
            operation and sign manipulation in transcendental math function libraries.
            Although MV, ABS, and NEG only need a single register operand, whereas
            FSGNJ instructions need two, it is unlikely most microarchitectures would
            add optimizations to benefit from the reduced number of register reads
            for these relatively infrequent instructions. Even in this case, a microarchitecture
            can simply detect when both source registers are the same for FSGNJ instructions
            and only read a single copy.
      c:
        "#integer-register-register-operations":
          text:
          - C.MV expands to a different instruction than the canonical MV pseudoinstruction,
            which instead uses ADDI. Implementations that handle MV specially, e.g.
            using register-renaming hardware, may find it more convenient to expand
            C.MV to MV instead of ADD, at slight additional hardware cost.
  neg:
    opcode:
    - neg
    - rd
    - rs
    opcode_group: psuedo
    opcode_args:
    - rd
    - rs
    psuedo_to_base:
    - sub rd, x0, rs
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/f.html"
    main_desc: f
    main_id: "#single-precision-floating-point-conversion-and-move-instructions"
    desc:
      f:
        "#single-precision-floating-point-conversion-and-move-instructions":
          text:
          - The sign-injection instructions provide floating-point MV, ABS, and NEG,
            as well as supporting a few other operations, including the IEEE copySign
            operation and sign manipulation in transcendental math function libraries.
            Although MV, ABS, and NEG only need a single register operand, whereas
            FSGNJ instructions need two, it is unlikely most microarchitectures would
            add optimizations to benefit from the reduced number of register reads
            for these relatively infrequent instructions. Even in this case, a microarchitecture
            can simply detect when both source registers are the same for FSGNJ instructions
            and only read a single copy.
  negw:
    opcode:
    - negw
    - rd
    - rs
    opcode_group: psuedo
    opcode_args:
    - rd
    - rs
    psuedo_to_base:
    - subw rd, x0, rs
  nop:
    opcode:
    - nop
    opcode_group: psuedo
    opcode_args: []
    psuedo_to_base:
    - addi x0, x0, 0
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/rv32.html"
    main_desc: rv32
    main_id: "#nop-instruction"
    desc:
      rv32:
        "#rv32":
          text:
          - RV32I was designed to be sufficient to form a compiler target and to support
            modern operating system environments. The ISA was also designed to reduce
            the hardware required in a minimal implementation. RV32I contains 40 unique
            instructions, though a simple implementation might cover the ECALL/EBREAK
            instructions with a single SYSTEM hardware instruction that always traps
            and might be able to implement the FENCE instruction as a NOP, reducing
            base instruction count to 38 total. RV32I can emulate almost any other
            ISA extension (except the A extension, which requires additional hardware
            support for atomicity).
        "#nop-instruction":
          text:
          - The NOP instruction does not change any architecturally visible state,
            except for advancing the pc and incrementing any applicable performance
            counters. NOP is encoded as ADDI x0, x0, 0.
          - NOPs can be used to align code segments to microarchitecturally significant
            address boundaries, or to leave space for inline code modifications. Although
            there are many possible ways to encode a NOP, we define a canonical NOP
            encoding to allow microarchitectural optimizations as well as for more
            readable disassembly output. The other NOP encodings are made available
            for HINT instructions (Section 1.9 ).
          - ADDI was chosen for the NOP encoding as this is most likely to take fewest
            resources to execute across a range of systems (if not optimized away
            in decode). In particular, the instruction only reads one register. Also,
            an ADDI functional unit is more likely to be available in a superscalar
            design as adds are the most common operation. In particular, address-generation
            functional units can execute ADDI using the same hardware needed for base+offset
            address calculations, while register-register ADD or logical/shift operations
            require additional hardware.
        "#environment-call-and-breakpoints":
          text:
          - The shift NOP instructions are still considered available for use as HINTs.
          - 'slli x0, x0, 0x1f # Entry NOP ebreak # Break to debugger srai x0, x0,
            7 # NOP encoding the semihosting call number 7'
        "#sec:rv32i-hints":
          text:
          - RV32I reserves a large encoding space for HINT instructions, which are
            usually used to communicate performance hints to the microarchitecture.
            Like the NOP instruction, HINTs do not change any architecturally visible
            state, except for advancing the pc and any applicable performance counters.
            Implementations are always allowed to ignore the encoded hints.
      machine:
        "#wfi":
          text:
          - The purpose of the WFI instruction is to provide a hint to the implementation,
            and so a legal implementation is to simply implement WFI as a NOP.
          - As implementations are free to implement WFI as a NOP, software must explicitly
            check for any relevant pending but disabled interrupts in the code following
            an WFI, and should loop back to the WFI if no suitable interrupt was detected.
            The mip or sip registers can be interrogated to determine the presence
            of any interrupt in machine or supervisor mode respectively.
  not:
    opcode:
    - not
    - rd
    - rs
    opcode_group: psuedo
    opcode_args:
    - rd
    - rs
    psuedo_to_base:
    - xori rd, rs, -1
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/rv32.html"
    main_desc: rv32
    main_id: "#integer-register-immediate-instructions"
    desc:
      rv32:
        "#integer-register-immediate-instructions":
          text:
          - ANDI, ORI, XORI are logical operations that perform bitwise AND, OR, and
            XOR on register rs1 and the sign-extended 12-bit immediate and place the
            result in rd. Note, XORI rd, rs1, -1 performs a bitwise logical inversion
            of register rs1 (assembler pseudoinstruction NOT rd, rs).
  or:
    opcode:
    - or
    - rd
    - rs1
    - rs2
    - 31..25=0
    - 14..12=6
    - 6..2=0x0C
    - 1..0=3
    opcode_group: i
    opcode_args: *1
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/rv32.html"
    main_desc: rv32
    main_id: "#integer-register-register-operations"
    desc:
      rv32:
        "#integer-register-immediate-instructions":
          text:
          - ANDI, ORI, XORI are logical operations that perform bitwise AND, OR, and
            XOR on register rs1 and the sign-extended 12-bit immediate and place the
            result in rd. Note, XORI rd, rs1, -1 performs a bitwise logical inversion
            of register rs1 (assembler pseudoinstruction NOT rd, rs).
        "#integer-register-register-operations":
          text:
          - ADD performs the addition of rs1 and rs2. SUB performs the subtraction
            of rs2 from rs1. Overflows are ignored and the low XLEN bits of results
            are written to the destination rd. SLT and SLTU perform signed and unsigned
            compares respectively, writing 1 to rd if rs1 < rs2, 0 otherwise. Note,
            SLTU rd, x0, rs2 sets rd to 1 if rs2 is not equal to zero, otherwise sets
            rd to zero (assembler pseudoinstruction SNEZ rd, rs). AND, OR, and XOR
            perform bitwise logical operations.
      a:
        "#sec:amo":
          text:
          - The operations supported are swap, integer add, bitwise AND, bitwise OR,
            bitwise XOR, and signed and unsigned integer maximum and minimum. Without
            ordering constraints, these AMOs can be used to implement parallel reduction
            operations, where typically the return value would be discarded by writing
            to x0.
      c:
        "#integer-register-register-operations":
          text:
          - C.OR computes the bitwise OR of the values in registers rd' and rs2',
            then writes the result to register rd'. C.OR expands into or rd', rd',
            rs2'.
      machine:
        "#extension-context-status-in-mstatus-register":
          text:
          - The SD bit is read-only and is set when either the FS, VS, or XS bits
            encode a Dirty state (i.e., SD=((FS==11) OR (XS==11) OR (VS==11))). This
            allows privileged code to quickly determine when no additional context
            save is required beyond the integer register set and PC.
        "#machine-interrupt-registers-mip-and-mie":
          text:
          - If supervisor mode is implemented, bits mip.SEIP and mie.SEIE are the
            interrupt-pending and interrupt-enable bits for supervisor-level external
            interrupts. SEIP is writable in mip, and may be written by M-mode software
            to indicate to S-mode that an external interrupt is pending. Additionally,
            the platform-level interrupt controller may generate supervisor-level
            external interrupts. Supervisor-level external interrupts are made pending
            based on the logical-OR of the software-writable SEIP bit and the signal
            from the external interrupt controller. When mip is read with a CSR instruction,
            the value of the SEIP bit returned in the rd destination register is the
            logical-OR of the software-writable bit and the interrupt signal from
            the interrupt controller, but the signal from the interrupt controller
            is not used to calculate the value written to SEIP. Only the software-writable
            SEIP bit participates in the read-modify-write sequence of a CSRRS or
            CSRRC instruction.
      hypervisor:
        "#sec:hinterruptregs":
          text:
          - 'Bits hip.VSEIP and hie.VSEIE are the interrupt-pending and interrupt-enable
            bits for VS-level external interrupts. VSEIP is read-only in hip, and
            is the logical-OR of these interrupt sources:'
          - Bits hip.VSTIP and hie.VSTIE are the interrupt-pending and interrupt-enable
            bits for VS-level timer interrupts. VSTIP is read-only in hip, and is
            the logical-OR of hvip.VSTIP and any other platform-specific timer interrupt
            signal directed to VS-level.
      v:
        "#_vector_fixed_point_rounding_mode_register_vxrm":
          text:
          - round-to-odd (OR bits into LSB, aka "jam")
    iss_code:
    - WRITE_RD(RS1 | RS2);
  orc.b:
    opcode:
    - orc.b
    - rd
    - rs1
    - 31..20=0x287
    - 14..12=0x5
    - 6..0=0x13
    opcode_group: zbb
    opcode_args: *3
    pseudo_src: rv64_zbp
    pseudo_op: gorci
  ori:
    opcode:
    - ori
    - rd
    - rs1
    - imm12
    - 14..12=6
    - 6..2=0x04
    - 1..0=3
    opcode_group: i
    opcode_args: *2
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/rv32.html"
    main_desc: rv32
    main_id: "#integer-register-immediate-instructions"
    desc:
      rv32:
        "#integer-register-immediate-instructions":
          text:
          - ANDI, ORI, XORI are logical operations that perform bitwise AND, OR, and
            XOR on register rs1 and the sign-extended 12-bit immediate and place the
            result in rd. Note, XORI rd, rs1, -1 performs a bitwise logical inversion
            of register rs1 (assembler pseudoinstruction NOT rd, rs).
    iss_code:
    - "// prefetch.i/r/w hint when rd = 0 and i_imm[4:0] = 0/1/3"
    - WRITE_RD(insn.i_imm() | RS1);
  orn:
    opcode:
    - orn
    - rd
    - rs1
    - rs2
    - 31..25=32
    - 14..12=6
    - 6..2=0x0C
    - 1..0=3
    opcode_group: zbb
    opcode_args: *1
    iss_code:
    - require_either_extension(EXT_ZBB, EXT_ZBKB);
    - WRITE_RD(RS1 | ~RS2);
  pause:
    opcode:
    - pause
    - 31..28=0
    - 27..24=1
    - 23..20=0
    - 19..15=0
    - 14..12=0
    - 11..7=0
    - 6..2=0x03
    - 1..0=3
    opcode_group: i
    opcode_args: *18
    pseudo_src: rv_i
    pseudo_op: fence
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/zihintpause.html"
    main_desc: zihintpause
    main_id: "#chap:zihintpause"
    desc:
      zihintpause:
        "#chap:zihintpause":
          text:
          - The PAUSE instruction is a HINT that indicates the current hart's rate
            of instruction retirement should be temporarily reduced or paused. The
            duration of its effect must be bounded and may be zero. No architectural
            state is changed.
          - Software can use the PAUSE instruction to reduce energy consumption while
            executing spin-wait code sequences. Multithreaded cores might temporarily
            relinquish execution resources to other harts when PAUSE is executed.
            It is recommended that a PAUSE instruction generally be included in the
            code sequence for a spin-wait loop.
          - A future extension might add primitives similar to the x86 MONITOR/MWAIT
            instructions, which provide a more efficient mechanism to wait on writes
            to a specific memory location. However, these instructions would not supplant
            PAUSE. PAUSE is more appropriate when polling for non-memory events, when
            polling for multiple events, or when software does not know precisely
            what events it is polling for.
          - The duration of a PAUSE instruction's effect may vary significantly within
            and among implementations. In typical implementations this duration should
            be much less than the time to perform a context switch, probably more
            on the rough order of an on-chip cache miss latency or a cacheless access
            to main memory.
          - A series of PAUSE instructions can be used to create a cumulative delay
            loosely proportional to the number of PAUSE instructions. In spin-wait
            loops in portable code, however, only one PAUSE instruction should be
            used before re-evaluating loop conditions, else the hart might stall longer
            than optimal on some implementations, degrading system performance.
          - PAUSE is encoded as a FENCE instruction with pred=W, succ=0, fm=0, rd=x0,
            and rs1=x0.
          - PAUSE is encoded as a hint within the FENCE opcode because some implementations
            are expected to deliberately stall the PAUSE instruction until outstanding
            memory transactions have completed. Because the successor set is null,
            however, PAUSE does not mandate any particular memory ordering--hence,
            it truly is a HINT.
          - Like other FENCE instructions, PAUSE cannot be used within LR/SC sequences
            without voiding the forward-progress guarantee.
          - The choice of a predecessor set of W is arbitrary, since the successor
            set is null. Other HINTs similar to PAUSE might be encoded with other
            predecessor sets.
  prefetch.i:
    opcode:
    - prefetch.i
    - rs1
    - imm12hi
    - 24..20=0
    - 14..12=6
    - 11..7=0
    - 6..2=0x04
    - 1..0=3
    opcode_group: zicbo
    opcode_args: &27
    - rs1
    - imm12hi
    pseudo_src: rv_i
    pseudo_op: ori
  prefetch.r:
    opcode:
    - prefetch.r
    - rs1
    - imm12hi
    - 24..20=1
    - 14..12=6
    - 11..7=0
    - 6..2=0x04
    - 1..0=3
    opcode_group: zicbo
    opcode_args: *27
    pseudo_src: rv_i
    pseudo_op: ori
  prefetch.w:
    opcode:
    - prefetch.w
    - rs1
    - imm12hi
    - 24..20=3
    - 14..12=6
    - 11..7=0
    - 6..2=0x04
    - 1..0=3
    opcode_group: zicbo
    opcode_args: *27
    pseudo_src: rv_i
    pseudo_op: ori
  rdcycle:
    opcode:
    - rdcycle
    - rd
    - 19..15=0
    - 31..20=0xC00
    - 14..12=2
    - 6..2=0x1C
    - 1..0=3
    opcode_group: zicsr
    opcode_args: *23
    pseudo_src: rv_zicsr
    pseudo_op: csrrs
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/counters.html"
    main_desc: counters
    main_id: "#zicntr-standard-extension-for-base-counters-and-timers"
    desc:
      counters:
        "#zicntr-standard-extension-for-base-counters-and-timers":
          text:
          - RV32I provides a number of 64-bit read-only user-level counters, which
            are mapped into the 12-bit CSR address space and accessed in 32-bit pieces
            using CSRRS instructions. In RV64I, the CSR instructions can manipulate
            64-bit CSRs. In particular, the RDCYCLE, RDTIME, and RDINSTRET pseudoinstructions
            read the full 64 bits of the cycle, time, and instret counters. Hence,
            the RDCYCLEH, RDTIMEH, and RDINSTRETH instructions are RV32I-only.
          - The RDCYCLE pseudoinstruction reads the low XLEN bits of the cycle CSR
            which holds a count of the number of clock cycles executed by the processor
            core on which the hart is running from an arbitrary start time in the
            past. RDCYCLEH is an RV32I-only instruction that reads bits 63-32 of the
            same cycle counter. The underlying 64-bit counter should never overflow
            in practice. The rate at which the cycle counter advances will depend
            on the implementation and operating environment. The execution environment
            should provide a means to determine the current rate (cycles/second) at
            which the cycle counter is incrementing.
          - RDCYCLE is intended to return the number of cycles executed by the processor
            core, not the hart. Precisely defining what is a "core" is difficult given
            some implementation choices (e.g., AMD Bulldozer). Precisely defining
            what is a "clock cycle" is also difficult given the range of implementations
            (including software emulations), but the intent is that RDCYCLE is used
            for performance monitoring along with the other performance counters.
            In particular, where there is one hart/core, one would expect cycle-count/instructions-retired
            to measure CPI for a hart.
          - Even though there is no precise definition that works for all platforms,
            this is still a useful facility for most platforms, and an imprecise,
            common, "usually correct" standard here is better than no standard. The
            intent of RDCYCLE was primarily performance monitoring/tuning, and the
            specification was written with that goal in mind.
          - On some simple platforms, cycle count might represent a valid implementation
            of RDTIME, in which case RDTIME and RDCYCLE may return the same result.
  rdcycleh:
    opcode:
    - rdcycleh
    - rd
    - 19..15=0
    - 31..20=0xC80
    - 14..12=2
    - 6..2=0x1C
    - 1..0=3
    opcode_group: zicsr
    opcode_args: *23
    pseudo_src: rv_zicsr
    pseudo_op: csrrs
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/counters.html"
    main_desc: counters
    main_id: "#zicntr-standard-extension-for-base-counters-and-timers"
    desc:
      counters:
        "#zicntr-standard-extension-for-base-counters-and-timers":
          text:
          - RV32I provides a number of 64-bit read-only user-level counters, which
            are mapped into the 12-bit CSR address space and accessed in 32-bit pieces
            using CSRRS instructions. In RV64I, the CSR instructions can manipulate
            64-bit CSRs. In particular, the RDCYCLE, RDTIME, and RDINSTRET pseudoinstructions
            read the full 64 bits of the cycle, time, and instret counters. Hence,
            the RDCYCLEH, RDTIMEH, and RDINSTRETH instructions are RV32I-only.
          - The RDCYCLE pseudoinstruction reads the low XLEN bits of the cycle CSR
            which holds a count of the number of clock cycles executed by the processor
            core on which the hart is running from an arbitrary start time in the
            past. RDCYCLEH is an RV32I-only instruction that reads bits 63-32 of the
            same cycle counter. The underlying 64-bit counter should never overflow
            in practice. The rate at which the cycle counter advances will depend
            on the implementation and operating environment. The execution environment
            should provide a means to determine the current rate (cycles/second) at
            which the cycle counter is incrementing.
  rdinstret:
    opcode:
    - rdinstret
    - rd
    - 19..15=0
    - 31..20=0xC02
    - 14..12=2
    - 6..2=0x1C
    - 1..0=3
    opcode_group: zicsr
    opcode_args: *23
    pseudo_src: rv_zicsr
    pseudo_op: csrrs
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/counters.html"
    main_desc: counters
    main_id: "#zicntr-standard-extension-for-base-counters-and-timers"
    desc:
      counters:
        "#zicntr-standard-extension-for-base-counters-and-timers":
          text:
          - RV32I provides a number of 64-bit read-only user-level counters, which
            are mapped into the 12-bit CSR address space and accessed in 32-bit pieces
            using CSRRS instructions. In RV64I, the CSR instructions can manipulate
            64-bit CSRs. In particular, the RDCYCLE, RDTIME, and RDINSTRET pseudoinstructions
            read the full 64 bits of the cycle, time, and instret counters. Hence,
            the RDCYCLEH, RDTIMEH, and RDINSTRETH instructions are RV32I-only.
          - The RDINSTRET pseudoinstruction reads the low XLEN bits of the instret
            CSR, which counts the number of instructions retired by this hart from
            some arbitrary start point in the past. RDINSTRETH is an RV32I-only instruction
            that reads bits 63-32 of the same instruction counter. The underlying
            64-bit counter should never overflow in practice.
  rdinstreth:
    opcode:
    - rdinstreth
    - rd
    - 19..15=0
    - 31..20=0xC82
    - 14..12=2
    - 6..2=0x1C
    - 1..0=3
    opcode_group: zicsr
    opcode_args: *23
    pseudo_src: rv_zicsr
    pseudo_op: csrrs
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/counters.html"
    main_desc: counters
    main_id: "#zicntr-standard-extension-for-base-counters-and-timers"
    desc:
      counters:
        "#zicntr-standard-extension-for-base-counters-and-timers":
          text:
          - RV32I provides a number of 64-bit read-only user-level counters, which
            are mapped into the 12-bit CSR address space and accessed in 32-bit pieces
            using CSRRS instructions. In RV64I, the CSR instructions can manipulate
            64-bit CSRs. In particular, the RDCYCLE, RDTIME, and RDINSTRET pseudoinstructions
            read the full 64 bits of the cycle, time, and instret counters. Hence,
            the RDCYCLEH, RDTIMEH, and RDINSTRETH instructions are RV32I-only.
          - The RDINSTRET pseudoinstruction reads the low XLEN bits of the instret
            CSR, which counts the number of instructions retired by this hart from
            some arbitrary start point in the past. RDINSTRETH is an RV32I-only instruction
            that reads bits 63-32 of the same instruction counter. The underlying
            64-bit counter should never overflow in practice.
  rdtime:
    opcode:
    - rdtime
    - rd
    - 19..15=0
    - 31..20=0xC01
    - 14..12=2
    - 6..2=0x1C
    - 1..0=3
    opcode_group: zicsr
    opcode_args: *23
    pseudo_src: rv_zicsr
    pseudo_op: csrrs
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/counters.html"
    main_desc: counters
    main_id: "#zicntr-standard-extension-for-base-counters-and-timers"
    desc:
      counters:
        "#zicntr-standard-extension-for-base-counters-and-timers":
          text:
          - RV32I provides a number of 64-bit read-only user-level counters, which
            are mapped into the 12-bit CSR address space and accessed in 32-bit pieces
            using CSRRS instructions. In RV64I, the CSR instructions can manipulate
            64-bit CSRs. In particular, the RDCYCLE, RDTIME, and RDINSTRET pseudoinstructions
            read the full 64 bits of the cycle, time, and instret counters. Hence,
            the RDCYCLEH, RDTIMEH, and RDINSTRETH instructions are RV32I-only.
          - The RDTIME pseudoinstruction reads the low XLEN bits of the time CSR,
            which counts wall-clock real time that has passed from an arbitrary start
            time in the past. RDTIMEH is an RV32I-only instruction that reads bits
            63-32 of the same real-time counter. The underlying 64-bit counter increments
            by one with each tick of the real-time clock, and, for realistic real-time
            clock frequencies, should never overflow in practice. The execution environment
            should provide a means of determining the period of a counter tick (seconds/tick).
            The period must be constant. The real-time clocks of all harts in a single
            user application should be synchronized to within one tick of the real-time
            clock. The environment should provide a means to determine the accuracy
            of the clock (i.e., the maximum relative error between the nominal and
            actual real-time clock periods).
          - On some simple platforms, cycle count might represent a valid implementation
            of RDTIME, in which case RDTIME and RDCYCLE may return the same result.
  rdtimeh:
    opcode:
    - rdtimeh
    - rd
    - 19..15=0
    - 31..20=0xC81
    - 14..12=2
    - 6..2=0x1C
    - 1..0=3
    opcode_group: zicsr
    opcode_args: *23
    pseudo_src: rv_zicsr
    pseudo_op: csrrs
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/counters.html"
    main_desc: counters
    main_id: "#zicntr-standard-extension-for-base-counters-and-timers"
    desc:
      counters:
        "#zicntr-standard-extension-for-base-counters-and-timers":
          text:
          - RV32I provides a number of 64-bit read-only user-level counters, which
            are mapped into the 12-bit CSR address space and accessed in 32-bit pieces
            using CSRRS instructions. In RV64I, the CSR instructions can manipulate
            64-bit CSRs. In particular, the RDCYCLE, RDTIME, and RDINSTRET pseudoinstructions
            read the full 64 bits of the cycle, time, and instret counters. Hence,
            the RDCYCLEH, RDTIMEH, and RDINSTRETH instructions are RV32I-only.
          - The RDTIME pseudoinstruction reads the low XLEN bits of the time CSR,
            which counts wall-clock real time that has passed from an arbitrary start
            time in the past. RDTIMEH is an RV32I-only instruction that reads bits
            63-32 of the same real-time counter. The underlying 64-bit counter increments
            by one with each tick of the real-time clock, and, for realistic real-time
            clock frequencies, should never overflow in practice. The execution environment
            should provide a means of determining the period of a counter tick (seconds/tick).
            The period must be constant. The real-time clocks of all harts in a single
            user application should be synchronized to within one tick of the real-time
            clock. The environment should provide a means to determine the accuracy
            of the clock (i.e., the maximum relative error between the nominal and
            actual real-time clock periods).
  rem:
    opcode:
    - rem
    - rd
    - rs1
    - rs2
    - 31..25=1
    - 14..12=6
    - 6..2=0x0C
    - 1..0=3
    opcode_group: m
    opcode_args: *1
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/m.html"
    main_desc: m
    main_id: "#division-operations"
    desc:
      m:
        "#division-operations":
          text:
          - DIV and DIVU perform an XLEN bits by XLEN bits signed and unsigned integer
            division of rs1 by rs2, rounding towards zero. REM and REMU provide the
            remainder of the corresponding division operation. For REM, the sign of
            the result equals the sign of the dividend.
          - 'If both the quotient and remainder are required from the same division,
            the recommended code sequence is: DIV[U] rdq, rs1, rs2; REM[U] rdr, rs1,
            rs2 (rdq cannot be the same as rs1 or rs2). Microarchitectures can then
            fuse these into a single divide operation instead of performing two separate
            divides.'
          - REM[W]
    iss_code:
    - require_extension('M');
    - sreg_t lhs = sext_xlen(RS1);
    - sreg_t rhs = sext_xlen(RS2);
    - if (rhs == 0)
    - WRITE_RD(lhs);
    - else if (lhs == INT64_MIN && rhs == -1)
    - WRITE_RD(0);
    - else
    - WRITE_RD(sext_xlen(lhs % rhs));
  remu:
    opcode:
    - remu
    - rd
    - rs1
    - rs2
    - 31..25=1
    - 14..12=7
    - 6..2=0x0C
    - 1..0=3
    opcode_group: m
    opcode_args: *1
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/m.html"
    main_desc: m
    main_id: "#division-operations"
    desc:
      m:
        "#division-operations":
          text:
          - DIV and DIVU perform an XLEN bits by XLEN bits signed and unsigned integer
            division of rs1 by rs2, rounding towards zero. REM and REMU provide the
            remainder of the corresponding division operation. For REM, the sign of
            the result equals the sign of the dividend.
          - REMU[W]
    iss_code:
    - require_extension('M');
    - reg_t lhs = zext_xlen(RS1);
    - reg_t rhs = zext_xlen(RS2);
    - if (rhs == 0)
    - WRITE_RD(sext_xlen(RS1));
    - else
    - WRITE_RD(sext_xlen(lhs % rhs));
  remuw:
    opcode:
    - remuw
    - rd
    - rs1
    - rs2
    - 31..25=1
    - 14..12=7
    - 6..2=0x0E
    - 1..0=3
    opcode_group: m
    opcode_args: *1
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/m.html"
    main_desc: m
    main_id: "#division-operations"
    desc:
      m:
        "#division-operations":
          text:
          - DIVW and DIVUW are RV64 instructions that divide the lower 32 bits of
            rs1 by the lower 32 bits of rs2, treating them as signed and unsigned
            integers respectively, placing the 32-bit quotient in rd, sign-extended
            to 64 bits. REMW and REMUW are RV64 instructions that provide the corresponding
            signed and unsigned remainder operations respectively. Both REMW and REMUW
            always sign-extend the 32-bit result to 64 bits, including on a divide
            by zero.
    iss_code:
    - require_extension('M');
    - require_rv64;
    - reg_t lhs = zext32(RS1);
    - reg_t rhs = zext32(RS2);
    - if (rhs == 0)
    - WRITE_RD(sext32(lhs));
    - else
    - WRITE_RD(sext32(lhs % rhs));
  remw:
    opcode:
    - remw
    - rd
    - rs1
    - rs2
    - 31..25=1
    - 14..12=6
    - 6..2=0x0E
    - 1..0=3
    opcode_group: m
    opcode_args: *1
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/m.html"
    main_desc: m
    main_id: "#division-operations"
    desc:
      m:
        "#division-operations":
          text:
          - DIVW and DIVUW are RV64 instructions that divide the lower 32 bits of
            rs1 by the lower 32 bits of rs2, treating them as signed and unsigned
            integers respectively, placing the 32-bit quotient in rd, sign-extended
            to 64 bits. REMW and REMUW are RV64 instructions that provide the corresponding
            signed and unsigned remainder operations respectively. Both REMW and REMUW
            always sign-extend the 32-bit result to 64 bits, including on a divide
            by zero.
    iss_code:
    - require_extension('M');
    - require_rv64;
    - sreg_t lhs = sext32(RS1);
    - sreg_t rhs = sext32(RS2);
    - if (rhs == 0)
    - WRITE_RD(lhs);
    - else
    - WRITE_RD(sext32(lhs % rhs));
  ret:
    opcode:
    - ret
    opcode_group: psuedo
    opcode_args: []
    psuedo_to_base:
    - jalr x0, x1, 0
  rev8:
    opcode:
    - rev8
    - rd
    - rs1
    - 31..20=0x6B8
    - 14..12=5
    - 6..0=0x13
    opcode_group: zkn
    opcode_args: *3
    pseudo_src: rv64_zbp
    pseudo_op: grevi
  rol:
    opcode:
    - rol
    - rd
    - rs1
    - rs2
    - 31..25=0x30
    - 14..12=1
    - 6..2=0x0C
    - 1..0=3
    opcode_group: zbb
    opcode_args: *1
    iss_code:
    - require_either_extension(EXT_ZBB, EXT_ZBKB);
    - int shamt = RS2 & (xlen-1);
    - int rshamt = -shamt & (xlen-1);
    - WRITE_RD(sext_xlen((RS1 << shamt) | (zext_xlen(RS1) >> rshamt)));
  rolw:
    opcode:
    - rolw
    - rd
    - rs1
    - rs2
    - 31..25=0x30
    - 14..12=1
    - 6..2=0x0E
    - 1..0=3
    opcode_group: zbb
    opcode_args: *1
    iss_code:
    - require_rv64;
    - require_either_extension(EXT_ZBB, EXT_ZBKB);
    - int shamt = RS2 & 31;
    - int rshamt = -shamt & 31;
    - WRITE_RD(sext32((RS1 << shamt) | (zext32(RS1) >> rshamt)));
  ror:
    opcode:
    - ror
    - rd
    - rs1
    - rs2
    - 31..25=0x30
    - 14..12=5
    - 6..2=0x0C
    - 1..0=3
    opcode_group: zbb
    opcode_args: *1
    iss_code:
    - require_either_extension(EXT_ZBB, EXT_ZBKB);
    - int shamt = RS2 & (xlen-1);
    - int rshamt = -shamt & (xlen-1);
    - WRITE_RD(sext_xlen((RS1 << rshamt) | (zext_xlen(RS1) >> shamt)));
  rori:
    opcode:
    - rori
    - rd
    - rs1
    - 31..26=0x18
    - shamtd
    - 14..12=5
    - 6..2=0x04
    - 1..0=3
    opcode_group: zbb
    opcode_args: *3
    iss_code:
    - require_either_extension(EXT_ZBB, EXT_ZBKB);
    - require(SHAMT < xlen);
    - int shamt = SHAMT & (xlen-1);
    - int rshamt = -shamt & (xlen-1);
    - WRITE_RD(sext_xlen((RS1 << rshamt) | (zext_xlen(RS1) >> shamt)));
  roriw:
    opcode:
    - roriw
    - rd
    - rs1
    - 31..25=0x30
    - shamtw
    - 14..12=5
    - 6..2=0x06
    - 1..0=3
    opcode_group: zbb
    opcode_args: *3
    iss_code:
    - require_rv64;
    - require_either_extension(EXT_ZBB, EXT_ZBKB);
    - require(SHAMT < 32);
    - int shamt = SHAMT & 31;
    - int rshamt = -shamt & 31;
    - WRITE_RD(sext32((RS1 << rshamt) | (zext32(RS1) >> shamt)));
  rorw:
    opcode:
    - rorw
    - rd
    - rs1
    - rs2
    - 31..25=0x30
    - 14..12=5
    - 6..2=0x0E
    - 1..0=3
    opcode_group: zbb
    opcode_args: *1
    iss_code:
    - require_rv64;
    - require_either_extension(EXT_ZBB, EXT_ZBKB);
    - int shamt = RS2 & 31;
    - int rshamt = -shamt & 31;
    - WRITE_RD(sext32((RS1 << rshamt) | (zext32(RS1) >> shamt)));
  sb:
    opcode:
    - sb
    - imm12hi
    - rs1
    - rs2
    - imm12lo
    - 14..12=0
    - 6..2=0x08
    - 1..0=3
    opcode_group: i
    opcode_args: *24
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/rv32.html"
    main_desc: rv32
    main_id: "#sec:rv32:ldst"
    desc:
      rv32:
        "#sec:rv32:ldst":
          text:
          - The LW instruction loads a 32-bit value from memory into rd. LH loads
            a 16-bit value from memory, then sign-extends to 32-bits before storing
            in rd. LHU loads a 16-bit value from memory but then zero extends to 32-bits
            before storing in rd. LB and LBU are defined analogously for 8-bit values.
            The SW, SH, and SB instructions store 32-bit, 16-bit, and 8-bit values
            from the low bits of register rs2 to memory.
      rv64:
        "#load-and-store-instructions":
          text:
          - The LW instruction loads a 32-bit value from memory and sign-extends this
            to 64 bits before storing it in register rd for RV64I. The LWU instruction,
            on the other hand, zero-extends the 32-bit value from memory for RV64I.
            LH and LHU are defined analogously for 16-bit values, as are LB and LBU
            for 8-bit values. The SD, SW, SH, and SB instructions store 64-bit, 32-bit,
            16-bit, and 8-bit values from the low bits of register rs2 to memory respectively.
      hypervisor:
        "#hypervisor-virtual-machine-load-and-store-instructions":
          text:
          - 'For every RV32I or RV64I load instruction, LB, LBU, LH, LHU, LW, LWU,
            and LD, there is a corresponding virtual-machine load instruction: HLV.B,
            HLV.BU, HLV.H, HLV.HU, HLV.W, HLV.WU, and HLV.D. For every RV32I or RV64I
            store instruction, SB, SH, SW, and SD, there is a corresponding virtual-machine
            store instruction: HSV.B, HSV.H, HSV.W, and HSV.D. Instructions HLV.WU,
            HLV.D, and HSV.D are not valid for RV32, of course.'
        "#sec:tinst-vals":
          text:
          - For a standard store instruction that is not a compressed instruction
            and is one of SB, SH, SW, SD, FSW, FSD, FSQ, or FSH, the transformed instruction
            has the format shown in Figure 1.47 .
          - Transformed noncompressed store instruction (SB, SH, SW, SD, FSW, FSD,
            FSQ, or FSH). Fields rs2, funct3, and opcode are the same as the trapping
            store instruction.
          - In decoding the contents of mtinst or htinst, once software has determined
            that the register contains the encoding of a standard basic load (LB,
            LBU, LH, LHU, LW, LWU, LD, FLW, FLD, FLQ, or FLH) or basic store (SB,
            SH, SW, SD, FSW, FSD, FSQ, or FSH), it is not necessary to confirm also
            that the immediate offset fields (31:25, and 24:20 or 11:7) are zeros.
            The knowledge that the register's value is the encoding of a basic load/store
            is sufficient to prove that the trapping instruction is of the same kind.
    iss_code:
    - MMU.store<uint8_t>(RS1 + insn.s_imm(), RS2);
  sbreak:
    opcode:
    - sbreak
    - 11..7=0
    - 19..15=0
    - 31..20=0x001
    - 14..12=0
    - 6..2=0x1C
    - 1..0=3
    opcode_group: i
    opcode_args: *18
    pseudo_src: rv_i
    pseudo_op: ebreak
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/rv32.html"
    main_desc: rv32
    main_id: "#environment-call-and-breakpoints"
    desc:
      rv32:
        "#environment-call-and-breakpoints":
          text:
          - ECALL and EBREAK were previously named SCALL and SBREAK. The instructions
            have the same functionality and encoding, but were renamed to reflect
            that they can be used more generally than to call a supervisor-level operating
            system or debugger.
  sc.d:
    opcode:
    - sc.d
    - rd
    - rs1
    - rs2
    - aq
    - rl
    - 31..29=0
    - 28..27=3
    - 14..12=3
    - 6..2=0x0B
    - 1..0=3
    opcode_group: a
    opcode_args: *1
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/a.html"
    main_desc: a
    main_id: "#sec:lrsc"
    desc:
      a:
        "#sec:lrsc":
          text:
          - 'Complex atomic memory operations on a single memory word or doubleword
            are performed with the load-reserved (LR) and store-conditional (SC) instructions.
            LR.W loads a word from the address in rs1, places the sign-extended value
            in rd, and registers a reservation set--a set of bytes that subsumes the
            bytes in the addressed word. SC.W conditionally writes a word in rs2 to
            the address in rs1: the SC.W succeeds only if the reservation is still
            valid and the reservation set contains the bytes being written. If the
            SC.W succeeds, the instruction writes the word in rs2 to memory, and it
            writes zero to rd. If the SC.W fails, the instruction does not write to
            memory, and it writes a nonzero value to rd. Regardless of success or
            failure, executing an SC.W instruction invalidates any reservation held
            by this hart. LR.D and SC.D act analogously on doublewords and are only
            available on RV64. For RV64, LR.W and SC.W sign-extend the value placed
            in rd.'
    iss_code:
    - require_extension('A');
    - require_rv64;
    - ''
    - bool have_reservation = MMU.store_conditional<uint64_t>(RS1, RS2);
    - ''
    - WRITE_RD(!have_reservation);
  sc.w:
    opcode:
    - sc.w
    - rd
    - rs1
    - rs2
    - aq
    - rl
    - 31..29=0
    - 28..27=3
    - 14..12=2
    - 6..2=0x0B
    - 1..0=3
    opcode_group: a
    opcode_args: *1
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/a.html"
    main_desc: a
    main_id: "#sec:lrsc"
    desc:
      a:
        "#sec:lrsc":
          text:
          - 'Complex atomic memory operations on a single memory word or doubleword
            are performed with the load-reserved (LR) and store-conditional (SC) instructions.
            LR.W loads a word from the address in rs1, places the sign-extended value
            in rd, and registers a reservation set--a set of bytes that subsumes the
            bytes in the addressed word. SC.W conditionally writes a word in rs2 to
            the address in rs1: the SC.W succeeds only if the reservation is still
            valid and the reservation set contains the bytes being written. If the
            SC.W succeeds, the instruction writes the word in rs2 to memory, and it
            writes zero to rd. If the SC.W fails, the instruction does not write to
            memory, and it writes a nonzero value to rd. Regardless of success or
            failure, executing an SC.W instruction invalidates any reservation held
            by this hart. LR.D and SC.D act analogously on doublewords and are only
            available on RV64. For RV64, LR.W and SC.W sign-extend the value placed
            in rd.'
    iss_code:
    - require_extension('A');
    - ''
    - bool have_reservation = MMU.store_conditional<uint32_t>(RS1, RS2);
    - ''
    - WRITE_RD(!have_reservation);
  scall:
    opcode:
    - scall
    - 11..7=0
    - 19..15=0
    - 31..20=0x000
    - 14..12=0
    - 6..2=0x1C
    - 1..0=3
    opcode_group: i
    opcode_args: *18
    pseudo_src: rv_i
    pseudo_op: ecall
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/rv32.html"
    main_desc: rv32
    main_id: "#environment-call-and-breakpoints"
    desc:
      rv32:
        "#environment-call-and-breakpoints":
          text:
          - ECALL and EBREAK were previously named SCALL and SBREAK. The instructions
            have the same functionality and encoding, but were renamed to reflect
            that they can be used more generally than to call a supervisor-level operating
            system or debugger.
  sd:
    opcode:
    - sd
    - imm12hi
    - rs1
    - rs2
    - imm12lo
    - 14..12=3
    - 6..2=0x08
    - 1..0=3
    opcode_group: i
    opcode_args: *24
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/rv64.html"
    main_desc: rv64
    main_id: "#load-and-store-instructions"
    desc:
      rv64:
        "#load-and-store-instructions":
          text:
          - The LW instruction loads a 32-bit value from memory and sign-extends this
            to 64 bits before storing it in register rd for RV64I. The LWU instruction,
            on the other hand, zero-extends the 32-bit value from memory for RV64I.
            LH and LHU are defined analogously for 16-bit values, as are LB and LBU
            for 8-bit values. The SD, SW, SH, and SB instructions store 64-bit, 32-bit,
            16-bit, and 8-bit values from the low bits of register rs2 to memory respectively.
      machine:
        "#machine-status-registers-mstatus-and-mstatush":
          text:
          - For RV32 only, mstatush is a 32-bit read/write register formatted as shown
            in Figure 1.8 . Bits 30:4 of mstatush generally contain the same fields
            found in bits 62:36 of mstatus for RV64. Fields SD, SXL, and UXL do not
            exist in mstatush.
        "#extension-context-status-in-mstatus-register":
          text:
          - The design anticipates that most context switches will not need to save/restore
            state in either or both of the floating-point unit or other extensions,
            so provides a fast check via the SD bit.
          - The SD bit is a read-only bit that summarizes whether either the FS, VS,
            or XS fields signal the presence of some dirty state that will require
            saving extended user context to memory. If FS, XS, and VS are all read-only
            zero, then SD is also always zero.
          - The SD bit is read-only and is set when either the FS, VS, or XS bits
            encode a Dirty state (i.e., SD=((FS==11) OR (XS==11) OR (VS==11))). This
            allows privileged code to quickly determine when no additional context
            save is required beyond the integer register set and PC.
      hypervisor:
        "#virtual-supervisor-status-register-vsstatus":
          text:
          - Read-only fields SD and XS summarize the extension context status as it
            is visible to VS-mode only. For example, the value of the HS-level sstatus.FS
            does not affect vsstatus.SD.
        "#hypervisor-virtual-machine-load-and-store-instructions":
          text:
          - 'For every RV32I or RV64I load instruction, LB, LBU, LH, LHU, LW, LWU,
            and LD, there is a corresponding virtual-machine load instruction: HLV.B,
            HLV.BU, HLV.H, HLV.HU, HLV.W, HLV.WU, and HLV.D. For every RV32I or RV64I
            store instruction, SB, SH, SW, and SD, there is a corresponding virtual-machine
            store instruction: HSV.B, HSV.H, HSV.W, and HSV.D. Instructions HLV.WU,
            HLV.D, and HSV.D are not valid for RV32, of course.'
        "#sec:tinst-vals":
          text:
          - For a standard store instruction that is not a compressed instruction
            and is one of SB, SH, SW, SD, FSW, FSD, FSQ, or FSH, the transformed instruction
            has the format shown in Figure 1.47 .
          - Transformed noncompressed store instruction (SB, SH, SW, SD, FSW, FSD,
            FSQ, or FSH). Fields rs2, funct3, and opcode are the same as the trapping
            store instruction.
          - In decoding the contents of mtinst or htinst, once software has determined
            that the register contains the encoding of a standard basic load (LB,
            LBU, LH, LHU, LW, LWU, LD, FLW, FLD, FLQ, or FLH) or basic store (SB,
            SH, SW, SD, FSW, FSD, FSQ, or FSH), it is not necessary to confirm also
            that the immediate offset fields (31:25, and 24:20 or 11:7) are zeros.
            The knowledge that the register's value is the encoding of a basic load/store
            is sufficient to prove that the trapping instruction is of the same kind.
      v:
        "#_vector_context_status_in_mstatus":
          text:
          - If mstatus.VS is Dirty, mstatus.SD is 1; otherwise, mstatus.SD is set
            in accordance with existing specifications.
        "#_vector_context_status_in_vsstatus":
          text:
          - If vsstatus.VS is Dirty, vsstatus.SD is 1; otherwise, vsstatus.SD is set
            in accordance with existing specifications.
          - If mstatus.VS is Dirty, mstatus.SD is 1; otherwise, mstatus.SD is set
            in accordance with existing specifications.
    iss_code:
    - require_rv64;
    - MMU.store<uint64_t>(RS1 + insn.s_imm(), RS2);
  seqz:
    opcode:
    - seqz
    - rd
    - rs
    opcode_group: psuedo
    opcode_args:
    - rd
    - rs
    psuedo_to_base:
    - sltiu rd, rs, 1
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/rv32.html"
    main_desc: rv32
    main_id: "#integer-register-immediate-instructions"
    desc:
      rv32:
        "#integer-register-immediate-instructions":
          text:
          - SLTI (set less than immediate) places the value 1 in register rd if register
            rs1 is less than the sign-extended immediate when both are treated as
            signed numbers, else 0 is written to rd. SLTIU is similar but compares
            the values as unsigned numbers (i.e., the immediate is first sign-extended
            to XLEN bits then treated as an unsigned number). Note, SLTIU rd, rs1,
            1 sets rd to 1 if rs1 equals zero, otherwise sets rd to 0 (assembler pseudoinstruction
            SEQZ rd, rs).
  sext.b:
    opcode:
    - sext.b
    - rd
    - rs1
    - 31..20=0x604
    - 14..12=1
    - 6..2=0x04
    - 1..0=3
    opcode_group: zbb
    opcode_args: *3
    iss_code:
    - require_extension(EXT_ZBB);
    - WRITE_RD((sreg_t)(int8_t)(RS1));
  sext.h:
    opcode:
    - sext.h
    - rd
    - rs1
    - 31..20=0x605
    - 14..12=1
    - 6..2=0x04
    - 1..0=3
    opcode_group: zbb
    opcode_args: *3
    iss_code:
    - require_extension(EXT_ZBB);
    - WRITE_RD((sreg_t)(int16_t)(RS1));
  sext.w:
    opcode:
    - sext.w
    - rd
    - rs
    opcode_group: psuedo
    opcode_args:
    - rd
    - rs
    psuedo_to_base:
    - addiw rd, rs, 0
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/rv64.html"
    main_desc: rv64
    main_id: "#integer-register-immediate-instructions"
    desc:
      rv64:
        "#integer-register-immediate-instructions":
          text:
          - ADDIW is an RV64I instruction that adds the sign-extended 12-bit immediate
            to register rs1 and produces the proper sign-extension of a 32-bit result
            in rd. Overflows are ignored and the result is the low 32 bits of the
            result sign-extended to 64 bits. Note, ADDIW rd, rs1, 0 writes the sign-extension
            of the lower 32 bits of register rs1 into register rd (assembler pseudoinstruction
            SEXT.W).
  sfence.inval.ir:
    opcode:
    - sfence.inval.ir
    - 11..7=0
    - 19..15=0x0
    - 24..20=0x1
    - 31..25=0x0c
    - 14..12=0
    - 6..2=0x1C
    - 1..0=3
    opcode_group: svinval
    opcode_args: *18
    main_url_base: "/riscv-priv-isa-manual/Priv-v1.12/supervisor.html"
    main_desc: supervisor
    main_id: "#svinval"
    desc:
      supervisor:
        "#svinval":
          text:
          - The SINVAL.VMA instruction invalidates any address-translation cache entries
            that an SFENCE.VMA instruction with the same values of rs1 and rs2 would
            invalidate. However, unlike SFENCE.VMA, SINVAL.VMA instructions are only
            ordered with respect to SFENCE.VMA, SFENCE.W.INVAL, and SFENCE.INVAL.IR
            instructions as defined below.
          - The SFENCE.W.INVAL instruction guarantees that any previous stores already
            visible to the current RISC-V hart are ordered before subsequent SINVAL.VMA
            instructions executed by the same hart. The SFENCE.INVAL.IR instruction
            guarantees that any previous SINVAL.VMA instructions executed by the current
            hart are ordered before subsequent implicit references by that hart to
            the memory-management data structures.
          - 'When executed in order (but not necessarily consecutively) by a single
            hart, the sequence SFENCE.W.INVAL, SINVAL.VMA, and SFENCE.INVAL.IR has
            the same effect as a hypothetical SFENCE.VMA instruction in which:'
          - reads and writes following the SFENCE.INVAL.IR are considered to be those
            subsequent to the SFENCE.VMA.
          - 'If the hypervisor extension is implemented, the Svinval extension also
            provides two additional instructions: HINVAL.VVMA and HINVAL.GVMA. These
            have the same semantics as SINVAL.VMA, except that they combine with SFENCE.W.INVAL
            and SFENCE.INVAL.IR to replace HFENCE.VVMA and HFENCE.GVMA, respectively,
            instead of SFENCE.VMA. In addition, HINVAL.GVMA uses VMIDs instead of
            ASIDs.'
          - SFENCE.W.INVAL and SFENCE.INVAL.IR instructions do not need to be trapped
            when mstatus.TVM=1 or when hstatus.VTVM=1, as they only have ordering
            effects but no visible side effects. Trapping of the SINVAL.VMA instruction
            is sufficient to enable emulation of the intended overall TLB maintenance
            functionality.
          - In typical usage, software will invalidate a range of virtual addresses
            in the address-translation caches by executing an SFENCE.W.INVAL instruction,
            executing a series of SINVAL.VMA, HINVAL.VVMA, or HINVAL.GVMA instructions
            to the addresses (and optionally ASIDs or VMIDs) in question, and then
            executing an SFENCE.INVAL.IR instruction.
          - High-performance implementations will be able to pipeline the address-translation
            cache invalidation operations, and will defer any pipeline stalls or other
            memory ordering enforcement until an SFENCE.W.INVAL, SFENCE.INVAL.IR,
            SFENCE.VMA, HFENCE.GVMA, or HFENCE.VVMA instruction is executed.
          - Simpler implementations may implement SINVAL.VMA, HINVAL.VVMA, and HINVAL.GVMA
            identically to SFENCE.VMA, HFENCE.VVMA, and HFENCE.GVMA, respectively,
            while implementing SFENCE.W.INVAL and SFENCE.INVAL.IR instructions as
            no-ops.
  sfence.vma:
    opcode:
    - sfence.vma
    - 11..7=0
    - rs1
    - rs2
    - 31..25=0x09
    - 14..12=0
    - 6..2=0x1C
    - 1..0=3
    opcode_group: s
    opcode_args: *25
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/rvwmo.html"
    main_desc: rvwmo
    main_id: "#ch:memorymodel"
    desc:
      rvwmo:
        "#ch:memorymodel":
          text:
          - This chapter defines the memory model for regular main memory operations.
            The interaction of the memory model with I/O memory, instruction fetches,
            FENCE.I, page table walks, and SFENCE.VMA is not (yet) formalized. Some
            or all of the above may be formalized in a future revision of this specification.
            The RV128 base ISA and future ISA extensions such as the "V" vector and
            "J" JIT extensions will need to be incorporated into a future revision
            as well.
      machine:
        "#endianness-control-in-mstatus-and-mstatush-registers":
          text:
          - For implicit accesses to supervisor-level memory management data structures,
            such as page tables, endianness is always controlled by SBE. Since changing
            SBE alters the implementation's interpretation of these data structures,
            if any such data structures remain in use across a change to SBE, M-mode
            software must follow such a change to SBE by executing an SFENCE.VMA instruction
            with rs1=x0 and rs2=x0.
          - Only in contrived scenarios will a given memory-management data structure
            be interpreted as both little-endian and big-endian. In practice, SBE
            will only be changed at runtime on world switches, in which case neither
            the old nor new memory-management data structure will be reinterpreted
            in a different endianness. In this case, no additional SFENCE.VMA is necessary,
            beyond what would ordinarily be required for a world switch.
        "#virt-control":
          text:
          - field that supports intercepting supervisor virtual-memory management
            operations. When TVM=1, attempts to read or write the satp CSR or execute
            an SFENCE.VMA or SINVAL.VMA instruction while executing in S-mode will
            raise an illegal instruction exception. When TVM=0, these operations are
            permitted in S-mode. TVM is read-only 0 when S-mode is not supported.
          - Trapping satp accesses and the SFENCE.VMA and SINVAL.VMA instructions
            provides the hooks necessary to lazily populate shadow page tables.
        "#pmp-vmem":
          text:
          - Implementations with virtual memory are permitted to perform address translations
            speculatively and earlier than required by an explicit memory access,
            and are permitted to cache them in address translation cache structures--including
            possibly caching the identity mappings from effective address to physical
            address used in Bare translation modes and M-mode. The PMP settings for
            the resulting physical address may be checked (and possibly cached) at
            any point between the address translation and the explicit memory access.
            Hence, when the PMP settings are modified, M-mode software must synchronize
            the PMP settings with the virtual memory system and any PMP or address-translation
            caches. This is accomplished by executing an SFENCE.VMA instruction with
            rs1=x0 and rs2=x0, after the PMP CSRs are written.
          - If page-based virtual memory is not implemented, memory accesses check
            the PMP settings synchronously, so no SFENCE.VMA is needed.
      supervisor:
        "#sec:satp":
          text:
          - Translations that began while satp was active are not required to complete
            or terminate when satp is no longer active, unless an SFENCE.VMA instruction
            matching the address and ASID is executed. The SFENCE.VMA instruction
            must be used to ensure that updates to the address-translation data structures
            are observed by subsequent implicit reads to those structures by a hart.
          - Note that writing satp does not imply any ordering constraints between
            page-table updates and subsequent address translations, nor does it imply
            any invalidation of address-translation caches. If the new address space's
            page tables have been modified, or if an ASID is reused, it may be necessary
            to execute an SFENCE.VMA instruction (see Section 1.2.1 ) after, or in
            some cases before, writing satp.
        "#sec:sfence.vma":
          text:
          - The supervisor memory-management fence instruction SFENCE.VMA is used
            to synchronize updates to in-memory memory-management data structures
            with current execution. Instruction execution causes implicit reads and
            writes to these data structures; however, these implicit references are
            ordinarily not ordered with respect to explicit loads and stores. Executing
            an SFENCE.VMA instruction guarantees that any previous stores already
            visible to the current RISC-V hart are ordered before certain implicit
            references by subsequent instructions in that hart to the memory-management
            data structures. The specific set of operations ordered by SFENCE.VMA
            is determined by rs1 and rs2, as described below. SFENCE.VMA is also used
            to invalidate entries in the address-translation cache associated with
            a hart (see Section 1.3.2 ). Further details on the behavior of this instruction
            are described in Section [virt-control] and Section [pmp-vmem] .
          - The SFENCE.VMA is used to flush any local hardware caches related to address
            translation. It is specified as a fence rather than a TLB flush to provide
            cleaner semantics with respect to which instructions are affected by the
            flush operation and to support a wider variety of dynamic caching structures
            and memory-management schemes. SFENCE.VMA is also used by higher privilege
            levels to synchronize page table writes and the address translation hardware.
          - SFENCE.VMA orders only the local hart's implicit references to the memory-management
            data structures.
          - Consequently, other harts must be notified separately when the memory-management
            data structures have been modified. One approach is to use 1) a local
            data fence to ensure local writes are visible globally, then 2) an interprocessor
            interrupt to the other thread, then 3) a local SFENCE.VMA in the interrupt
            handler of the remote thread, and finally 4) signal back to originating
            thread that operation is complete. This is, of course, the RISC-V analog
            to a TLB shootdown.
          - 'For the common case that the translation data structures have only been
            modified for a single address mapping (i.e., one page or superpage), rs1
            can specify a virtual address within that mapping to effect a translation
            fence for that mapping only. Furthermore, for the common case that the
            translation data structures have only been modified for a single address-space
            identifier, rs2 can specify the address space. The behavior of SFENCE.VMA
            depends on rs1 and rs2 as follows:'
          - If the value held in rs1 is not a valid virtual address, then the SFENCE.VMA
            instruction has no effect. No exception is raised in this case.
          - It is always legal to over-fence, e.g., by fencing only based on a subset
            of the bits in rs1 and/or rs2, and/or by simply treating all SFENCE.VMA
            instructions as having rs1=x0 and/or rs2=x0. For example, simpler implementations
            can ignore the virtual address in rs1 and the ASID value in rs2 and always
            perform a global fence. The choice not to raise an exception when an invalid
            virtual address is held in rs1 facilitates this type of simplification.
          - An implicit read of the memory-management data structures may return any
            translation for an address that was valid at any time since the most recent
            SFENCE.VMA that subsumes that address. The ordering implied by SFENCE.VMA
            does not place implicit reads and writes to the memory-management data
            structures into the global memory order in a way that interacts cleanly
            with the standard RVWMO ordering rules. In particular, even though an
            SFENCE.VMA orders prior explicit accesses before subsequent implicit accesses,
            and those implicit accesses are ordered before their associated explicit
            accesses, SFENCE.VMA does not necessarily place prior explicit accesses
            before subsequent explicit accesses in the global memory order. These
            implicit loads also need not otherwise obey normal program order semantics
            with respect to prior loads or stores to the same address.
          - A consequence of this specification is that an implementation may use
            any translation for an address that was valid at any time since the most
            recent SFENCE.VMA that subsumes that address. In particular, if a leaf
            PTE is modified but a subsuming SFENCE.VMA is not executed, either the
            old translation or the new translation will be used, but the choice is
            unpredictable. The behavior is otherwise well-defined.
          - 'In a conventional TLB design, it is possible for multiple entries to
            match a single address if, for example, a page is upgraded to a superpage
            without first clearing the original non-leaf PTE''s valid bit and executing
            an SFENCE.VMA with rs1=x0. In this case, a similar remark applies: it
            is unpredictable whether the old non-leaf PTE or the new leaf PTE is used,
            but the behavior is otherwise well defined.'
          - Changes to the sstatus fields SUM and MXR take effect immediately, without
            the need to execute an SFENCE.VMA instruction. Changing satp.MODE from
            Bare to other modes and vice versa also takes effect immediately, without
            the need to execute an SFENCE.VMA instruction. Likewise, changes to satp.ASID
            take effect immediately.
          - 'The following common situations typically require executing an SFENCE.VMA
            instruction:'
          - When software recycles an ASID (i.e., reassociates it with a different
            page table), it should first change satp to point to the new page table
            using the recycled ASID, then execute SFENCE.VMA with rs1=x0 and rs2 set
            to the recycled ASID. Alternatively, software can execute the same SFENCE.VMA
            instruction while a different ASID is loaded into satp, provided the next
            time satp is loaded with the recycled ASID, it is simultaneously loaded
            with the new page table.
          - If the implementation does not provide ASIDs, or software chooses to always
            use ASID 0, then after every satp write, software should execute SFENCE.VMA
            with rs1=x0. In the common case that no global translations have been
            modified, rs2 should be set to a register other than x0 but which contains
            the value zero, so that global translations are not flushed.
          - If software modifies a non-leaf PTE, it should execute SFENCE.VMA with
            rs1=x0. If any PTE along the traversal path had its G bit set, rs2 must
            be x0; otherwise, rs2 should be set to the ASID for which the translation
            is being modified.
          - If software modifies a leaf PTE, it should execute SFENCE.VMA with rs1
            set to a virtual address within the page. If any PTE along the traversal
            path had its G bit set, rs2 must be x0; otherwise, rs2 should be set to
            the ASID for which the translation is being modified.
          - For the special cases of increasing the permissions on a leaf PTE and
            changing an invalid PTE to a valid leaf, software may choose to execute
            the SFENCE.VMA lazily. After modifying the PTE but before executing SFENCE.VMA,
            either the new or old permissions will be used. In the latter case, a
            page-fault exception might occur, at which point software should execute
            SFENCE.VMA in accordance with the previous bullet point.
          - For implementations that make satp.MODE read-only zero (always Bare),
            attempts to execute an SFENCE.VMA instruction might raise an illegal instruction
            exception.
        "#sec:translation":
          text:
          - Global mappings need not be stored redundantly in address-translation
            caches for multiple ASIDs. Additionally, they need not be flushed from
            local address-translation caches when an SFENCE.VMA instruction is executed
            with rs2 x0.
        "#sv32algorithm":
          text:
          - The results of implicit address-translation reads in step 2 may be held
            in a read-only, incoherent address-translation cache but not shared with
            other harts. The address-translation cache may hold an arbitrary number
            of entries, including an arbitrary number of entries for the same address
            and ASID. Entries in the address-translation cache may then satisfy subsequent
            step 2 reads if the ASID associated with the entry matches the ASID loaded
            in step 0 or if the entry is associated with a global mapping. To ensure
            that implicit reads observe writes to the same memory locations, an SFENCE.VMA
            instruction must be executed after the writes to flush the relevant cached
            translations.
          - 'It is permitted for multiple address-translation cache entries to co-exist
            for the same address. This represents the fact that in a conventional
            TLB hierarchy, it is possible for multiple entries to match a single address
            if, for example, a page is upgraded to a superpage without first clearing
            the original non-leaf PTE''s valid bit and executing an SFENCE.VMA with
            rs1=x0, or if multiple TLBs exist in parallel at a given level of the
            hierarchy. In this case, just as if an SFENCE.VMA is not executed between
            a write to the memory-management tables and subsequent implicit read of
            the same address: it is unpredictable whether the old non-leaf PTE or
            the new leaf PTE is used, but the behavior is otherwise well defined.'
          - Speculative executions of the address-translation algorithm behave as
            non-speculative executions of the algorithm do, except that they must
            not set the dirty bit for a PTE, they must not trigger an exception, and
            they must not create address-translation cache entries if those entries
            would have been invalidated by any SFENCE.VMA instruction executed by
            the hart since the speculative execution of the algorithm began.
          - For instance, it is illegal for both non-speculative and speculative executions
            of the translation algorithm to begin, read the level 2 page table, pause
            while the hart executes an SFENCE.VMA with rs1=rs2=x0, then resume using
            the now-stale level 2 PTE, as subsequent implicit reads could populate
            the address-translation cache with stale PTEs.
          - In many implementations, an SFENCE.VMA instruction with rs1=x0 will therefore
            either terminate all previously-launched speculative executions of the
            address-translation algorithm (for the specified ASID, if applicable),
            or simply wait for them to complete (in which case any address-translation
            cache entries created will be invalidated by the SFENCE.VMA as appropriate).
            Likewise, an SFENCE.VMA instruction with rs1 x0 generally must either
            ensure that previously-launched speculative executions of the address-translation
            algorithm (for the specified ASID, if applicable) are prevented from creating
            new address-translation cache entries mapping leaf PTEs, or wait for them
            to complete.
        "#svnapot":
          text:
          - 'In typical usage scenarios, NAPOT PTEs in the same region will have the
            same attributes, same PPNs, and same values for bits 5-0. RSW remains
            reserved for supervisor software control. It is the responsibility of
            the OS and/or hypervisor to configure the page tables in such a way that
            there are no inconsistencies between NAPOT PTEs and other NAPOT or non-NAPOT
            PTEs that overlap the same address range. If an update needs to be made,
            the OS generally should first mark all of the PTEs invalid, then issue
            SFENCE.VMA instruction(s) covering all 4 KiB regions within the range
            (either via a single SFENCE.VMA with rs1=x0, or with multiple SFENCE.VMA
            instructions with rs1 x0), then update the PTE(s), as described in Section
            1.2.1 , unless any inconsistencies are known to be benign. If any inconsistencies
            do exist, then the effect is the same as when SFENCE.VMA is used incorrectly:
            one of the translations will be chosen, but the choice is unpredictable.'
        "#svinval":
          text:
          - The Svinval extension splits SFENCE.VMA, HFENCE.VVMA, and HFENCE.GVMA
            instructions into finer-grained invalidation and ordering operations that
            can be more efficiently batched or pipelined on certain classes of high-performance
            implementation.
          - The SINVAL.VMA instruction invalidates any address-translation cache entries
            that an SFENCE.VMA instruction with the same values of rs1 and rs2 would
            invalidate. However, unlike SFENCE.VMA, SINVAL.VMA instructions are only
            ordered with respect to SFENCE.VMA, SFENCE.W.INVAL, and SFENCE.INVAL.IR
            instructions as defined below.
          - 'When executed in order (but not necessarily consecutively) by a single
            hart, the sequence SFENCE.W.INVAL, SINVAL.VMA, and SFENCE.INVAL.IR has
            the same effect as a hypothetical SFENCE.VMA instruction in which:'
          - the values of rs1 and rs2 for the SFENCE.VMA are the same as those used
            in the SINVAL.VMA,
          - reads and writes prior to the SFENCE.W.INVAL are considered to be those
            prior to the SFENCE.VMA, and
          - reads and writes following the SFENCE.INVAL.IR are considered to be those
            subsequent to the SFENCE.VMA.
          - 'If the hypervisor extension is implemented, the Svinval extension also
            provides two additional instructions: HINVAL.VVMA and HINVAL.GVMA. These
            have the same semantics as SINVAL.VMA, except that they combine with SFENCE.W.INVAL
            and SFENCE.INVAL.IR to replace HFENCE.VVMA and HFENCE.GVMA, respectively,
            instead of SFENCE.VMA. In addition, HINVAL.GVMA uses VMIDs instead of
            ASIDs.'
          - SINVAL.VMA, HINVAL.VVMA, and HINVAL.GVMA require the same permissions
            and raise the same exceptions as SFENCE.VMA, HFENCE.VVMA, and HFENCE.GVMA,
            respectively. In particular, an attempt to execute any of these instructions
            in U-mode always raises an illegal instruction exception, and an attempt
            to execute SINVAL.VMA or HINVAL.GVMA in S-mode or HS-mode when mstatus.TVM=1
            also raises an illegal instruction exception. An attempt to execute HINVAL.VVMA
            or HINVAL.GVMA in VS-mode or VU-mode, or to execute SINVAL.VMA in VU-mode,
            raises a virtual instruction exception. When hstatus.VTVM=1, an attempt
            to execute SINVAL.VMA in VS-mode also raises a virtual instruction exception.
          - High-performance implementations will be able to pipeline the address-translation
            cache invalidation operations, and will defer any pipeline stalls or other
            memory ordering enforcement until an SFENCE.W.INVAL, SFENCE.INVAL.IR,
            SFENCE.VMA, HFENCE.GVMA, or HFENCE.VVMA instruction is executed.
          - Simpler implementations may implement SINVAL.VMA, HINVAL.VVMA, and HINVAL.GVMA
            identically to SFENCE.VMA, HFENCE.VVMA, and HFENCE.GVMA, respectively,
            while implementing SFENCE.W.INVAL and SFENCE.INVAL.IR instructions as
            no-ops.
      hypervisor:
        "#hypervisor-status-register-hstatus":
          text:
          - The hstatus fields VTSR, VTW, and VTVM are defined analogously to the
            mstatus fields TSR, TW, and TVM, but affect execution only in VS-mode,
            and cause virtual instruction exceptions instead of illegal instruction
            exceptions. When VTSR=1, an attempt in VS-mode to execute SRET raises
            a virtual instruction exception. When VTW=1 (and assuming mstatus.TW=0),
            an attempt in VS-mode to execute WFI raises a virtual instruction exception
            if the WFI does not complete within an implementation-specific, bounded
            time limit. When VTVM=1, an attempt in VS-mode to execute SFENCE.VMA or
            SINVAL.VMA or to access CSR satp raises a virtual instruction exception.
        "#sec:hfence.vma":
          text:
          - The hypervisor memory-management fence instructions, HFENCE.VVMA and HFENCE.GVMA,
            perform a function similar to SFENCE.VMA (Section [sec:sfence.vma] ),
            except applying to the VS-level memory-management data structures controlled
            by CSR vsatp (HFENCE.VVMA) or the guest-physical memory-management data
            structures controlled by CSR hgatp (HFENCE.GVMA). Instruction SFENCE.VMA
            applies only to the memory-management data structures controlled by the
            current satp (either the HS-level satp when V=0 or vsatp when V=1).
          - HFENCE.VVMA is valid only in M-mode or HS-mode. Its effect is much the
            same as temporarily entering VS-mode and executing SFENCE.VMA. Executing
            an HFENCE.VVMA guarantees that any previous stores already visible to
            the current hart are ordered before all subsequent implicit reads by that
            hart of the VS-level memory-management data structures, when those implicit
            reads are for instructions that
        "#memory-management-fences":
          text:
          - The behavior of the SFENCE.VMA instruction is affected by the current
            virtualization mode V. When V=0, the virtual-address argument is an HS-level
            virtual address, and the ASID argument is an HS-level ASID. The instruction
            orders stores only to HS-level address-translation structures with subsequent
            HS-level address translations.
          - When V=1, the virtual-address argument to SFENCE.VMA is a guest virtual
            address within the current virtual machine, and the ASID argument is a
            VS-level ASID within the current virtual machine. The current virtual
            machine is identified by the VMID field of CSR hgatp, and the effective
            ASID can be considered to be the combination of this VMID with the VS-level
            ASID. The SFENCE.VMA instruction orders stores only to the VS-level address-translation
            structures with subsequent VS-stage address translations for the same
            virtual machine, i.e., only when hgatp.VMID is the same as when the SFENCE.VMA
            executed.
          - Hypervisor instructions HFENCE.VVMA and HFENCE.GVMA provide additional
            memory-management fences to complement SFENCE.VMA. These instructions
            are described in Section 1.3.2 .
          - Section [pmp-vmem] discusses the intersection between physical memory
            protection (PMP) and page-based address translation. It is noted there
            that, when PMP settings are modified in a manner that affects either the
            physical memory that holds page tables or the physical memory to which
            page tables point, M-mode software must synchronize the PMP settings with
            the virtual memory system. For HS-level address translation, this is accomplished
            by executing in M-mode an SFENCE.VMA instruction with rs1=x0 and rs2=x0,
            after the PMP CSRs are written. If G-stage address translation is in use
            and is not Bare, synchronization with its data structures is also needed.
            When PMP settings are modified in a manner that affects either the physical
            memory that holds guest-physical page tables or the physical memory to
            which guest-physical page tables point, an HFENCE.GVMA instruction with
            rs1=x0 and rs2=x0 must be executed in M-mode after the PMP CSRs are written.
            An HFENCE.VVMA instruction is not required.
        "#trap-cause-codes":
          text:
          - in VS-mode, attempts to execute an SFENCE.VMA or SINVAL.VMA instruction
            or to access satp, when hstatus.VTVM=1.
  sfence.w.inval:
    opcode:
    - sfence.w.inval
    - 11..7=0
    - 19..15=0x0
    - 24..20=0x0
    - 31..25=0x0c
    - 14..12=0
    - 6..2=0x1C
    - 1..0=3
    opcode_group: svinval
    opcode_args: *18
    main_url_base: "/riscv-priv-isa-manual/Priv-v1.12/supervisor.html"
    main_desc: supervisor
    main_id: "#svinval"
    desc:
      supervisor:
        "#svinval":
          text:
          - The SINVAL.VMA instruction invalidates any address-translation cache entries
            that an SFENCE.VMA instruction with the same values of rs1 and rs2 would
            invalidate. However, unlike SFENCE.VMA, SINVAL.VMA instructions are only
            ordered with respect to SFENCE.VMA, SFENCE.W.INVAL, and SFENCE.INVAL.IR
            instructions as defined below.
          - The SFENCE.W.INVAL instruction guarantees that any previous stores already
            visible to the current RISC-V hart are ordered before subsequent SINVAL.VMA
            instructions executed by the same hart. The SFENCE.INVAL.IR instruction
            guarantees that any previous SINVAL.VMA instructions executed by the current
            hart are ordered before subsequent implicit references by that hart to
            the memory-management data structures.
          - 'When executed in order (but not necessarily consecutively) by a single
            hart, the sequence SFENCE.W.INVAL, SINVAL.VMA, and SFENCE.INVAL.IR has
            the same effect as a hypothetical SFENCE.VMA instruction in which:'
          - reads and writes prior to the SFENCE.W.INVAL are considered to be those
            prior to the SFENCE.VMA, and
          - 'If the hypervisor extension is implemented, the Svinval extension also
            provides two additional instructions: HINVAL.VVMA and HINVAL.GVMA. These
            have the same semantics as SINVAL.VMA, except that they combine with SFENCE.W.INVAL
            and SFENCE.INVAL.IR to replace HFENCE.VVMA and HFENCE.GVMA, respectively,
            instead of SFENCE.VMA. In addition, HINVAL.GVMA uses VMIDs instead of
            ASIDs.'
          - SFENCE.W.INVAL and SFENCE.INVAL.IR instructions do not need to be trapped
            when mstatus.TVM=1 or when hstatus.VTVM=1, as they only have ordering
            effects but no visible side effects. Trapping of the SINVAL.VMA instruction
            is sufficient to enable emulation of the intended overall TLB maintenance
            functionality.
          - In typical usage, software will invalidate a range of virtual addresses
            in the address-translation caches by executing an SFENCE.W.INVAL instruction,
            executing a series of SINVAL.VMA, HINVAL.VVMA, or HINVAL.GVMA instructions
            to the addresses (and optionally ASIDs or VMIDs) in question, and then
            executing an SFENCE.INVAL.IR instruction.
          - High-performance implementations will be able to pipeline the address-translation
            cache invalidation operations, and will defer any pipeline stalls or other
            memory ordering enforcement until an SFENCE.W.INVAL, SFENCE.INVAL.IR,
            SFENCE.VMA, HFENCE.GVMA, or HFENCE.VVMA instruction is executed.
          - Simpler implementations may implement SINVAL.VMA, HINVAL.VVMA, and HINVAL.GVMA
            identically to SFENCE.VMA, HFENCE.VVMA, and HFENCE.GVMA, respectively,
            while implementing SFENCE.W.INVAL and SFENCE.INVAL.IR instructions as
            no-ops.
  sgtz:
    opcode:
    - sgtz
    - rd
    - rs
    opcode_group: psuedo
    opcode_args:
    - rd
    - rs
    psuedo_to_base:
    - slt rd, x0, rs
  sh:
    opcode:
    - sh
    - imm12hi
    - rs1
    - rs2
    - imm12lo
    - 14..12=1
    - 6..2=0x08
    - 1..0=3
    opcode_group: i
    opcode_args: *24
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/rv32.html"
    main_desc: rv32
    main_id: "#sec:rv32:ldst"
    desc:
      rv32:
        "#sec:rv32:ldst":
          text:
          - The LW instruction loads a 32-bit value from memory into rd. LH loads
            a 16-bit value from memory, then sign-extends to 32-bits before storing
            in rd. LHU loads a 16-bit value from memory but then zero extends to 32-bits
            before storing in rd. LB and LBU are defined analogously for 8-bit values.
            The SW, SH, and SB instructions store 32-bit, 16-bit, and 8-bit values
            from the low bits of register rs2 to memory.
      rv64:
        "#load-and-store-instructions":
          text:
          - The LW instruction loads a 32-bit value from memory and sign-extends this
            to 64 bits before storing it in register rd for RV64I. The LWU instruction,
            on the other hand, zero-extends the 32-bit value from memory for RV64I.
            LH and LHU are defined analogously for 16-bit values, as are LB and LBU
            for 8-bit values. The SD, SW, SH, and SB instructions store 64-bit, 32-bit,
            16-bit, and 8-bit values from the low bits of register rs2 to memory respectively.
      hypervisor:
        "#hypervisor-virtual-machine-load-and-store-instructions":
          text:
          - 'For every RV32I or RV64I load instruction, LB, LBU, LH, LHU, LW, LWU,
            and LD, there is a corresponding virtual-machine load instruction: HLV.B,
            HLV.BU, HLV.H, HLV.HU, HLV.W, HLV.WU, and HLV.D. For every RV32I or RV64I
            store instruction, SB, SH, SW, and SD, there is a corresponding virtual-machine
            store instruction: HSV.B, HSV.H, HSV.W, and HSV.D. Instructions HLV.WU,
            HLV.D, and HSV.D are not valid for RV32, of course.'
        "#sec:tinst-vals":
          text:
          - For a standard store instruction that is not a compressed instruction
            and is one of SB, SH, SW, SD, FSW, FSD, FSQ, or FSH, the transformed instruction
            has the format shown in Figure 1.47 .
          - Transformed noncompressed store instruction (SB, SH, SW, SD, FSW, FSD,
            FSQ, or FSH). Fields rs2, funct3, and opcode are the same as the trapping
            store instruction.
          - In decoding the contents of mtinst or htinst, once software has determined
            that the register contains the encoding of a standard basic load (LB,
            LBU, LH, LHU, LW, LWU, LD, FLW, FLD, FLQ, or FLH) or basic store (SB,
            SH, SW, SD, FSW, FSD, FSQ, or FSH), it is not necessary to confirm also
            that the immediate offset fields (31:25, and 24:20 or 11:7) are zeros.
            The knowledge that the register's value is the encoding of a basic load/store
            is sufficient to prove that the trapping instruction is of the same kind.
    iss_code:
    - MMU.store<uint16_t>(RS1 + insn.s_imm(), RS2);
  sh1add:
    opcode:
    - sh1add
    - rd
    - rs1
    - rs2
    - 31..25=16
    - 14..12=2
    - 6..2=0x0C
    - 1..0=3
    opcode_group: zba
    opcode_args: *1
    iss_code:
    - require_extension(EXT_ZBA);
    - WRITE_RD(sext_xlen((RS1 << 1) + RS2));
  sh1add.uw:
    opcode:
    - sh1add.uw
    - rd
    - rs1
    - rs2
    - 31..25=16
    - 14..12=2
    - 6..2=0x0E
    - 1..0=3
    opcode_group: zba
    opcode_args: *1
  sh2add:
    opcode:
    - sh2add
    - rd
    - rs1
    - rs2
    - 31..25=16
    - 14..12=4
    - 6..2=0x0C
    - 1..0=3
    opcode_group: zba
    opcode_args: *1
    iss_code:
    - require_extension(EXT_ZBA);
    - WRITE_RD(sext_xlen((RS1 << 2) + RS2));
  sh2add.uw:
    opcode:
    - sh2add.uw
    - rd
    - rs1
    - rs2
    - 31..25=16
    - 14..12=4
    - 6..2=0x0E
    - 1..0=3
    opcode_group: zba
    opcode_args: *1
  sh3add:
    opcode:
    - sh3add
    - rd
    - rs1
    - rs2
    - 31..25=16
    - 14..12=6
    - 6..2=0x0C
    - 1..0=3
    opcode_group: zba
    opcode_args: *1
    iss_code:
    - require_extension(EXT_ZBA);
    - WRITE_RD(sext_xlen((RS1 << 3) + RS2));
  sh3add.uw:
    opcode:
    - sh3add.uw
    - rd
    - rs1
    - rs2
    - 31..25=16
    - 14..12=6
    - 6..2=0x0E
    - 1..0=3
    opcode_group: zba
    opcode_args: *1
  sha256sig0:
    opcode:
    - sha256sig0
    - rd
    - rs1
    - 31..30=0
    - 29..25=0b01000
    - 24..20=0b00010
    - 14..12=1
    - 6..0=0x13
    opcode_group: zknh
    opcode_args: *3
    iss_code:
    - ''
    - require_extension(EXT_ZKNH);
    - ''
    - "#define ROR32(a,amt) ((a << (-amt & (32-1))) | (a >> (amt & (32-1))))"
    - ''
    - uint32_t a = RS1;
    - ''
    - WRITE_RD(
    - sext32(ROR32(a, 7) ^ ROR32(a,18) ^ (a >> 3))
    - ");"
    - ''
    - "#undef ROR32"
    - ''
  sha256sig1:
    opcode:
    - sha256sig1
    - rd
    - rs1
    - 31..30=0
    - 29..25=0b01000
    - 24..20=0b00011
    - 14..12=1
    - 6..0=0x13
    opcode_group: zknh
    opcode_args: *3
    iss_code:
    - ''
    - require_extension(EXT_ZKNH);
    - ''
    - "#define ROR32(a,amt) ((a << (-amt & (32-1))) | (a >> (amt & (32-1))))"
    - ''
    - uint32_t a = RS1;
    - ''
    - WRITE_RD(
    - sext32(ROR32(a, 17) ^ ROR32(a,19) ^ (a >> 10))
    - ");"
    - ''
    - "#undef ROR32"
    - ''
  sha256sum0:
    opcode:
    - sha256sum0
    - rd
    - rs1
    - 31..30=0
    - 29..25=0b01000
    - 24..20=0b00000
    - 14..12=1
    - 6..0=0x13
    opcode_group: zknh
    opcode_args: *3
    iss_code:
    - ''
    - require_extension(EXT_ZKNH);
    - ''
    - "#define ROR32(a,amt) ((a << (-amt & (32-1))) | (a >> (amt & (32-1))))"
    - ''
    - uint32_t a = RS1;
    - ''
    - WRITE_RD(
    - sext32(ROR32(a, 2) ^ ROR32(a,13) ^ ROR32(a, 22))
    - ");"
    - ''
    - "#undef ROR32"
    - ''
  sha256sum1:
    opcode:
    - sha256sum1
    - rd
    - rs1
    - 31..30=0
    - 29..25=0b01000
    - 24..20=0b00001
    - 14..12=1
    - 6..0=0x13
    opcode_group: zknh
    opcode_args: *3
    iss_code:
    - ''
    - require_extension(EXT_ZKNH);
    - ''
    - "#define ROR32(a,amt) ((a << (-amt & (32-1))) | (a >> (amt & (32-1))))"
    - ''
    - uint32_t a = RS1;
    - ''
    - WRITE_RD(
    - sext32(ROR32(a, 6) ^ ROR32(a,11) ^ ROR32(a, 25))
    - ");"
    - ''
    - "#undef ROR32"
    - ''
  sha512sig0:
    opcode:
    - sha512sig0
    - rd
    - rs1
    - 31..30=0
    - 29..25=0b01000
    - 24..20=0b00110
    - 14..12=1
    - 6..0=0x13
    opcode_group: zknh
    opcode_args: *3
    iss_code:
    - require_rv64;
    - require_extension(EXT_ZKNH);
    - ''
    - "#define ROR64(a,amt) ((a << (-amt & (64-1))) | (a >> (amt & (64-1))))"
    - ''
    - uint64_t a = RS1;
    - ''
    - WRITE_RD(
    - ROR64(a,  1) ^ ROR64(a, 8) ^ (a >>  7)
    - ");"
    - ''
    - "#undef ROR64"
    - ''
  sha512sig0h:
    opcode:
    - sha512sig0h
    - rd
    - rs1
    - rs2
    - 31..30=1
    - 29..25=0b01110
    - 14..12=0
    - 6..0=0x33
    opcode_group: zknh
    opcode_args: *1
    iss_code:
    - ''
    - require_rv32;
    - require_extension(EXT_ZKNH);
    - ''
    - reg_t result =
    - "(zext32(RS1) >>  1) ^ (zext32(RS1) >>  7) ^ (zext32(RS1) >>  8) ^"
    - "(zext32(RS2) << 31) ^                       (zext32(RS2) << 24);"
    - ''
    - WRITE_RD(sext_xlen(result));
  sha512sig0l:
    opcode:
    - sha512sig0l
    - rd
    - rs1
    - rs2
    - 31..30=1
    - 29..25=0b01010
    - 14..12=0
    - 6..0=0x33
    opcode_group: zknh
    opcode_args: *1
    iss_code:
    - ''
    - require_rv32;
    - require_extension(EXT_ZKNH);
    - ''
    - reg_t result =
    - "(zext32(RS1) >>  1) ^ (zext32(RS1) >>  7) ^ (zext32(RS1) >>  8) ^"
    - "(zext32(RS2) << 31) ^ (zext32(RS2) << 25) ^ (zext32(RS2) << 24);"
    - ''
    - WRITE_RD(sext_xlen(result));
  sha512sig1:
    opcode:
    - sha512sig1
    - rd
    - rs1
    - 31..30=0
    - 29..25=0b01000
    - 24..20=0b00111
    - 14..12=1
    - 6..0=0x13
    opcode_group: zknh
    opcode_args: *3
    iss_code:
    - require_rv64;
    - require_extension(EXT_ZKNH);
    - ''
    - "#define ROR64(a,amt) ((a << (-amt & (64-1))) | (a >> (amt & (64-1))))"
    - ''
    - uint64_t a = RS1;
    - ''
    - WRITE_RD(
    - ROR64(a, 19) ^ ROR64(a,61) ^ (a >>  6)
    - ");"
    - ''
    - "#undef ROR64"
    - ''
  sha512sig1h:
    opcode:
    - sha512sig1h
    - rd
    - rs1
    - rs2
    - 31..30=1
    - 29..25=0b01111
    - 14..12=0
    - 6..0=0x33
    opcode_group: zknh
    opcode_args: *1
    iss_code:
    - ''
    - require_rv32;
    - require_extension(EXT_ZKNH);
    - ''
    - reg_t result =
    - "(zext32(RS1) <<  3) ^ (zext32(RS1) >>  6) ^ (zext32(RS1) >> 19) ^"
    - "(zext32(RS2) >> 29) ^                       (zext32(RS2) << 13);"
    - ''
    - WRITE_RD(sext_xlen(result));
  sha512sig1l:
    opcode:
    - sha512sig1l
    - rd
    - rs1
    - rs2
    - 31..30=1
    - 29..25=0b01011
    - 14..12=0
    - 6..0=0x33
    opcode_group: zknh
    opcode_args: *1
    iss_code:
    - ''
    - require_rv32;
    - require_extension(EXT_ZKNH);
    - ''
    - reg_t result =
    - "(zext32(RS1) <<  3) ^ (zext32(RS1) >>  6) ^ (zext32(RS1) >> 19) ^"
    - "(zext32(RS2) >> 29) ^ (zext32(RS2) << 26) ^ (zext32(RS2) << 13);"
    - ''
    - WRITE_RD(sext_xlen(result));
  sha512sum0:
    opcode:
    - sha512sum0
    - rd
    - rs1
    - 31..30=0
    - 29..25=0b01000
    - 24..20=0b00100
    - 14..12=1
    - 6..0=0x13
    opcode_group: zknh
    opcode_args: *3
    iss_code:
    - require_rv64;
    - require_extension(EXT_ZKNH);
    - ''
    - "#define ROR64(a,amt) ((a << (-amt & (64-1))) | (a >> (amt & (64-1))))"
    - ''
    - uint64_t a = RS1;
    - ''
    - WRITE_RD(
    - ROR64(a, 28) ^ ROR64(a,34) ^ ROR64(a,39)
    - ");"
    - ''
    - "#undef ROR64"
    - ''
  sha512sum0r:
    opcode:
    - sha512sum0r
    - rd
    - rs1
    - rs2
    - 31..30=1
    - 29..25=0b01000
    - 14..12=0
    - 6..0=0x33
    opcode_group: zknh
    opcode_args: *1
    iss_code:
    - ''
    - require_rv32;
    - require_extension(EXT_ZKNH);
    - ''
    - reg_t result =
    - "(zext32(RS1) << 25) ^ (zext32(RS1) << 30) ^ (zext32(RS1) >> 28) ^"
    - "(zext32(RS2) >>  7) ^ (zext32(RS2) >>  2) ^ (zext32(RS2) <<  4);"
    - ''
    - WRITE_RD(sext_xlen(result));
  sha512sum1:
    opcode:
    - sha512sum1
    - rd
    - rs1
    - 31..30=0
    - 29..25=0b01000
    - 24..20=0b00101
    - 14..12=1
    - 6..0=0x13
    opcode_group: zknh
    opcode_args: *3
    iss_code:
    - require_rv64;
    - require_extension(EXT_ZKNH);
    - ''
    - "#define ROR64(a,amt) ((a << (-amt & (64-1))) | (a >> (amt & (64-1))))"
    - ''
    - uint64_t a = RS1;
    - ''
    - WRITE_RD(
    - ROR64(a, 14) ^ ROR64(a, 18) ^ ROR64(a, 41)
    - ");"
    - ''
    - "#undef ROR64"
    - ''
  sha512sum1r:
    opcode:
    - sha512sum1r
    - rd
    - rs1
    - rs2
    - 31..30=1
    - 29..25=0b01001
    - 14..12=0
    - 6..0=0x33
    opcode_group: zknh
    opcode_args: *1
    iss_code:
    - ''
    - require_rv32;
    - require_extension(EXT_ZKNH);
    - ''
    - reg_t result =
    - "(zext32(RS1) << 23) ^ (zext32(RS1) >> 14) ^ (zext32(RS1) >> 18) ^"
    - "(zext32(RS2) >>  9) ^ (zext32(RS2) << 18) ^ (zext32(RS2) << 14);"
    - ''
    - WRITE_RD(sext_xlen(result));
  sinval.vma:
    opcode:
    - sinval.vma
    - 11..7=0
    - rs1
    - rs2
    - 31..25=0x0b
    - 14..12=0
    - 6..2=0x1C
    - 1..0=3
    opcode_group: svinval
    opcode_args: *25
    main_url_base: "/riscv-priv-isa-manual/Priv-v1.12/machine.html"
    main_desc: machine
    main_id: "#virt-control"
    desc:
      machine:
        "#virt-control":
          text:
          - field that supports intercepting supervisor virtual-memory management
            operations. When TVM=1, attempts to read or write the satp CSR or execute
            an SFENCE.VMA or SINVAL.VMA instruction while executing in S-mode will
            raise an illegal instruction exception. When TVM=0, these operations are
            permitted in S-mode. TVM is read-only 0 when S-mode is not supported.
          - Trapping satp accesses and the SFENCE.VMA and SINVAL.VMA instructions
            provides the hooks necessary to lazily populate shadow page tables.
      supervisor:
        "#svinval":
          text:
          - The SINVAL.VMA instruction invalidates any address-translation cache entries
            that an SFENCE.VMA instruction with the same values of rs1 and rs2 would
            invalidate. However, unlike SFENCE.VMA, SINVAL.VMA instructions are only
            ordered with respect to SFENCE.VMA, SFENCE.W.INVAL, and SFENCE.INVAL.IR
            instructions as defined below.
          - The SFENCE.W.INVAL instruction guarantees that any previous stores already
            visible to the current RISC-V hart are ordered before subsequent SINVAL.VMA
            instructions executed by the same hart. The SFENCE.INVAL.IR instruction
            guarantees that any previous SINVAL.VMA instructions executed by the current
            hart are ordered before subsequent implicit references by that hart to
            the memory-management data structures.
          - 'When executed in order (but not necessarily consecutively) by a single
            hart, the sequence SFENCE.W.INVAL, SINVAL.VMA, and SFENCE.INVAL.IR has
            the same effect as a hypothetical SFENCE.VMA instruction in which:'
          - the values of rs1 and rs2 for the SFENCE.VMA are the same as those used
            in the SINVAL.VMA,
          - 'If the hypervisor extension is implemented, the Svinval extension also
            provides two additional instructions: HINVAL.VVMA and HINVAL.GVMA. These
            have the same semantics as SINVAL.VMA, except that they combine with SFENCE.W.INVAL
            and SFENCE.INVAL.IR to replace HFENCE.VVMA and HFENCE.GVMA, respectively,
            instead of SFENCE.VMA. In addition, HINVAL.GVMA uses VMIDs instead of
            ASIDs.'
          - SINVAL.VMA, HINVAL.VVMA, and HINVAL.GVMA require the same permissions
            and raise the same exceptions as SFENCE.VMA, HFENCE.VVMA, and HFENCE.GVMA,
            respectively. In particular, an attempt to execute any of these instructions
            in U-mode always raises an illegal instruction exception, and an attempt
            to execute SINVAL.VMA or HINVAL.GVMA in S-mode or HS-mode when mstatus.TVM=1
            also raises an illegal instruction exception. An attempt to execute HINVAL.VVMA
            or HINVAL.GVMA in VS-mode or VU-mode, or to execute SINVAL.VMA in VU-mode,
            raises a virtual instruction exception. When hstatus.VTVM=1, an attempt
            to execute SINVAL.VMA in VS-mode also raises a virtual instruction exception.
          - SFENCE.W.INVAL and SFENCE.INVAL.IR instructions do not need to be trapped
            when mstatus.TVM=1 or when hstatus.VTVM=1, as they only have ordering
            effects but no visible side effects. Trapping of the SINVAL.VMA instruction
            is sufficient to enable emulation of the intended overall TLB maintenance
            functionality.
          - In typical usage, software will invalidate a range of virtual addresses
            in the address-translation caches by executing an SFENCE.W.INVAL instruction,
            executing a series of SINVAL.VMA, HINVAL.VVMA, or HINVAL.GVMA instructions
            to the addresses (and optionally ASIDs or VMIDs) in question, and then
            executing an SFENCE.INVAL.IR instruction.
          - Simpler implementations may implement SINVAL.VMA, HINVAL.VVMA, and HINVAL.GVMA
            identically to SFENCE.VMA, HFENCE.VVMA, and HFENCE.GVMA, respectively,
            while implementing SFENCE.W.INVAL and SFENCE.INVAL.IR instructions as
            no-ops.
      hypervisor:
        "#hypervisor-status-register-hstatus":
          text:
          - The hstatus fields VTSR, VTW, and VTVM are defined analogously to the
            mstatus fields TSR, TW, and TVM, but affect execution only in VS-mode,
            and cause virtual instruction exceptions instead of illegal instruction
            exceptions. When VTSR=1, an attempt in VS-mode to execute SRET raises
            a virtual instruction exception. When VTW=1 (and assuming mstatus.TW=0),
            an attempt in VS-mode to execute WFI raises a virtual instruction exception
            if the WFI does not complete within an implementation-specific, bounded
            time limit. When VTVM=1, an attempt in VS-mode to execute SFENCE.VMA or
            SINVAL.VMA or to access CSR satp raises a virtual instruction exception.
        "#trap-cause-codes":
          text:
          - in VS-mode, attempts to execute an SFENCE.VMA or SINVAL.VMA instruction
            or to access satp, when hstatus.VTVM=1.
  sll:
    opcode:
    - sll
    - rd
    - rs1
    - rs2
    - 31..25=0
    - 14..12=1
    - 6..2=0x0C
    - 1..0=3
    opcode_group: i
    opcode_args: *1
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/rv32.html"
    main_desc: rv32
    main_id: "#integer-register-register-operations"
    desc:
      rv32:
        "#integer-register-register-operations":
          text:
          - SLL, SRL, and SRA perform logical left, logical right, and arithmetic
            right shifts on the value in register rs1 by the shift amount held in
            the lower 5 bits of register rs2.
      rv64:
        "#integer-register-register-operations":
          text:
          - SLL, SRL, and SRA perform logical left, logical right, and arithmetic
            right shifts on the value in register rs1 by the shift amount held in
            register rs2. In RV64I, only the low 6 bits of rs2 are considered for
            the shift amount.
      rv128:
        "#rv128":
          text:
          - Shifts by an immediate (SLLI/SRLI/SRAI) are now encoded using the low
            7 bits of the I-immediate, and variable shifts (SLL/SRL/SRA) use the low
            7 bits of the shift amount source register.
    iss_code:
    - WRITE_RD(sext_xlen(RS1 << (RS2 & (xlen-1))));
  slli:
    opcode:
    - slli
    - rd
    - rs1
    - 31..26=0
    - shamtd
    - 14..12=1
    - 6..2=0x04
    - 1..0=3
    opcode_group: i
    opcode_args: *3
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/rv32.html"
    main_desc: rv32
    main_id: "#integer-register-immediate-instructions"
    desc:
      rv32:
        "#integer-register-immediate-instructions":
          text:
          - Shifts by a constant are encoded as a specialization of the I-type format.
            The operand to be shifted is in rs1, and the shift amount is encoded in
            the lower 5 bits of the I-immediate field. The right shift type is encoded
            in bit 30. SLLI is a logical left shift (zeros are shifted into the lower
            bits); SRLI is a logical right shift (zeros are shifted into the upper
            bits); and SRAI is an arithmetic right shift (the original sign bit is
            copied into the vacated upper bits).
      rv64:
        "#integer-register-immediate-instructions":
          text:
          - Shifts by a constant are encoded as a specialization of the I-type format
            using the same instruction opcode as RV32I. The operand to be shifted
            is in rs1, and the shift amount is encoded in the lower 6 bits of the
            I-immediate field for RV64I. The right shift type is encoded in bit 30.
            SLLI is a logical left shift (zeros are shifted into the lower bits);
            SRLI is a logical right shift (zeros are shifted into the upper bits);
            and SRAI is an arithmetic right shift (the original sign bit is copied
            into the vacated upper bits).
      rv128:
        "#rv128":
          text:
          - Shifts by an immediate (SLLI/SRLI/SRAI) are now encoded using the low
            7 bits of the I-immediate, and variable shifts (SLL/SRL/SRA) use the low
            7 bits of the shift amount source register.
    iss_code:
    - require(SHAMT < xlen);
    - WRITE_RD(sext_xlen(RS1 << SHAMT));
  slli.uw:
    opcode:
    - slli.uw
    - rd
    - rs1
    - 31..26=2
    - shamtd
    - 14..12=1
    - 6..2=0x06
    - 1..0=3
    opcode_group: zba
    opcode_args: *3
  slli_rv32:
    opcode:
    - slli_rv32
    - rd
    - rs1
    - shamtw
    - 31..25=0
    - 14..12=1
    - 6..2=0x04
    - 1..0=3
    opcode_group: i
    opcode_args: *3
    pseudo_src: rv64_i
    pseudo_op: slli
  slliw:
    opcode:
    - slliw
    - rd
    - rs1
    - 31..25=0
    - shamtw
    - 14..12=1
    - 6..2=0x06
    - 1..0=3
    opcode_group: i
    opcode_args: *3
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/rv64.html"
    main_desc: rv64
    main_id: "#integer-register-immediate-instructions"
    desc:
      rv64:
        "#integer-register-immediate-instructions":
          text:
          - SLLIW, SRLIW, and SRAIW are RV64I-only instructions that are analogously
            defined but operate on 32-bit values and sign-extend their 32-bit results
            to 64 bits. SLLIW, SRLIW, and SRAIW encodings with imm[5] 0 are reserved.
          - Previously, SLLIW, SRLIW, and SRAIW with imm[5] 0 were defined to cause
            illegal instruction exceptions, whereas now they are marked as reserved.
            This is a backwards-compatible change.
    iss_code:
    - require_rv64;
    - WRITE_RD(sext32(RS1 << SHAMT));
  sllw:
    opcode:
    - sllw
    - rd
    - rs1
    - rs2
    - 31..25=0
    - 14..12=1
    - 6..2=0x0E
    - 1..0=3
    opcode_group: i
    opcode_args: *1
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/rv64.html"
    main_desc: rv64
    main_id: "#integer-register-register-operations"
    desc:
      rv64:
        "#integer-register-register-operations":
          text:
          - SLLW, SRLW, and SRAW are RV64I-only instructions that are analogously
            defined but operate on 32-bit values and sign-extend their 32-bit results
            to 64 bits. The shift amount is given by rs2[4:0].
    iss_code:
    - require_rv64;
    - WRITE_RD(sext32(RS1 << (RS2 & 0x1F)));
  slt:
    opcode:
    - slt
    - rd
    - rs1
    - rs2
    - 31..25=0
    - 14..12=2
    - 6..2=0x0C
    - 1..0=3
    opcode_group: i
    opcode_args: *1
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/rv32.html"
    main_desc: rv32
    main_id: "#integer-register-register-operations"
    desc:
      rv32:
        "#integer-register-register-operations":
          text:
          - ADD performs the addition of rs1 and rs2. SUB performs the subtraction
            of rs2 from rs1. Overflows are ignored and the low XLEN bits of results
            are written to the destination rd. SLT and SLTU perform signed and unsigned
            compares respectively, writing 1 to rd if rs1 < rs2, 0 otherwise. Note,
            SLTU rd, x0, rs2 sets rd to 1 if rs2 is not equal to zero, otherwise sets
            rd to zero (assembler pseudoinstruction SNEZ rd, rs). AND, OR, and XOR
            perform bitwise logical operations.
      a:
        "#sec:lrsc":
          text:
          - We reserve a failure code of 1 to mean "unspecified" so that simple implementations
            may return this value using the existing mux required for the SLT/SLTU
            instructions. More specific failure codes might be defined in future versions
            or extensions to the ISA.
    iss_code:
    - WRITE_RD(sreg_t(RS1) < sreg_t(RS2));
  slti:
    opcode:
    - slti
    - rd
    - rs1
    - imm12
    - 14..12=2
    - 6..2=0x04
    - 1..0=3
    opcode_group: i
    opcode_args: *2
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/rv32.html"
    main_desc: rv32
    main_id: "#integer-register-immediate-instructions"
    desc:
      rv32:
        "#integer-register-immediate-instructions":
          text:
          - SLTI (set less than immediate) places the value 1 in register rd if register
            rs1 is less than the sign-extended immediate when both are treated as
            signed numbers, else 0 is written to rd. SLTIU is similar but compares
            the values as unsigned numbers (i.e., the immediate is first sign-extended
            to XLEN bits then treated as an unsigned number). Note, SLTIU rd, rs1,
            1 sets rd to 1 if rs1 equals zero, otherwise sets rd to 0 (assembler pseudoinstruction
            SEQZ rd, rs).
    iss_code:
    - WRITE_RD(sreg_t(RS1) < sreg_t(insn.i_imm()));
  sltiu:
    opcode:
    - sltiu
    - rd
    - rs1
    - imm12
    - 14..12=3
    - 6..2=0x04
    - 1..0=3
    opcode_group: i
    opcode_args: *2
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/rv32.html"
    main_desc: rv32
    main_id: "#integer-register-immediate-instructions"
    desc:
      rv32:
        "#integer-register-immediate-instructions":
          text:
          - SLTI (set less than immediate) places the value 1 in register rd if register
            rs1 is less than the sign-extended immediate when both are treated as
            signed numbers, else 0 is written to rd. SLTIU is similar but compares
            the values as unsigned numbers (i.e., the immediate is first sign-extended
            to XLEN bits then treated as an unsigned number). Note, SLTIU rd, rs1,
            1 sets rd to 1 if rs1 equals zero, otherwise sets rd to 0 (assembler pseudoinstruction
            SEQZ rd, rs).
    iss_code:
    - WRITE_RD(RS1 < reg_t(insn.i_imm()));
  sltu:
    opcode:
    - sltu
    - rd
    - rs1
    - rs2
    - 31..25=0
    - 14..12=3
    - 6..2=0x0C
    - 1..0=3
    opcode_group: i
    opcode_args: *1
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/rv32.html"
    main_desc: rv32
    main_id: "#integer-register-register-operations"
    desc:
      rv32:
        "#integer-register-register-operations":
          text:
          - ADD performs the addition of rs1 and rs2. SUB performs the subtraction
            of rs2 from rs1. Overflows are ignored and the low XLEN bits of results
            are written to the destination rd. SLT and SLTU perform signed and unsigned
            compares respectively, writing 1 to rd if rs1 < rs2, 0 otherwise. Note,
            SLTU rd, x0, rs2 sets rd to 1 if rs2 is not equal to zero, otherwise sets
            rd to zero (assembler pseudoinstruction SNEZ rd, rs). AND, OR, and XOR
            perform bitwise logical operations.
      rv64:
        "#integer-computational-instructions":
          text:
          - The compiler and calling convention maintain an invariant that all 32-bit
            values are held in a sign-extended format in 64-bit registers. Even 32-bit
            unsigned integers extend bit 31 into bits 63 through 32. Consequently,
            conversion between unsigned and signed 32-bit integers is a no-op, as
            is conversion from a signed 32-bit integer to a signed 64-bit integer.
            Existing 64-bit wide SLTU and unsigned branch compares still operate correctly
            on unsigned 32-bit integers under this invariant. Similarly, existing
            64-bit wide logical operations on 32-bit sign-extended integers preserve
            the sign-extension property. A few new instructions (ADD[I]W/SUBW/SxxW)
            are required for addition and shifts to ensure reasonable performance
            for 32-bit values.
      a:
        "#sec:lrsc":
          text:
          - We reserve a failure code of 1 to mean "unspecified" so that simple implementations
            may return this value using the existing mux required for the SLT/SLTU
            instructions. More specific failure codes might be defined in future versions
            or extensions to the ISA.
    iss_code:
    - WRITE_RD(RS1 < RS2);
  sltz:
    opcode:
    - sltz
    - rd
    - rs
    opcode_group: psuedo
    opcode_args:
    - rd
    - rs
    psuedo_to_base:
    - slt rd, rs, x0
  sm3p0:
    opcode:
    - sm3p0
    - rd
    - rs1
    - 31..30=0
    - 29..25=0b01000
    - 24..20=0b01000
    - 14..12=1
    - 6..0=0x13
    opcode_group: zksh
    opcode_args: *3
    iss_code:
    - ''
    - require_extension(EXT_ZKSH);
    - ''
    - "#define ROL32(a,amt) ((a >> (-amt & (32-1))) | (a << (amt & (32-1))))"
    - ''
    - uint32_t src    = RS1;
    - uint32_t result = src ^ ROL32(src, 9) ^ ROL32(src, 17);
    - ''
    - WRITE_RD(
    - sext32(result)
    - ");"
    - ''
    - "#undef ROL32"
    - ''
  sm3p1:
    opcode:
    - sm3p1
    - rd
    - rs1
    - 31..30=0
    - 29..25=0b01000
    - 24..20=0b01001
    - 14..12=1
    - 6..0=0x13
    opcode_group: zksh
    opcode_args: *3
    iss_code:
    - ''
    - require_extension(EXT_ZKSH);
    - ''
    - "#define ROL32(a,amt) ((a >> (-amt & (32-1))) | (a << (amt & (32-1))))"
    - ''
    - uint32_t src    = RS1;
    - uint32_t result = src ^ ROL32(src, 15) ^ ROL32(src, 23);
    - ''
    - WRITE_RD(
    - sext32(result)
    - ");"
    - ''
    - "#undef ROL32"
    - ''
  sm4ed:
    opcode:
    - sm4ed
    - rd
    - rs1
    - rs2
    - bs
    - 29..25=0b11000
    - 14..12=0
    - 6..0=0x33
    opcode_group: zksed
    opcode_args: *1
    iss_code:
    - ''
    - require_extension(EXT_ZKSED);
    - ''
    - '#include "sm4_common.h"'
    - ''
    - uint8_t  bs     = insn.bs();
    - ''
    - uint32_t sb_in  = (RS2 >> (8*bs)) & 0xFF;
    - uint32_t sb_out = (uint32_t)sm4_sbox[sb_in];
    - ''
    - uint32_t linear = sb_out ^  (sb_out         <<  8) ^
    - "(sb_out         <<  2) ^"
    - "(sb_out         << 18) ^"
    - "((sb_out & 0x3f) << 26) ^"
    - "((sb_out & 0xC0) << 10) ;"
    - ''
    - uint32_t rotl   = (linear << (8*bs)) | (linear >> (32-8*bs));
    - ''
    - uint32_t result = rotl ^ RS1;
    - ''
    - WRITE_RD(sext32(result));
    - ''
  sm4ks:
    opcode:
    - sm4ks
    - rd
    - rs1
    - rs2
    - bs
    - 29..25=0b11010
    - 14..12=0
    - 6..0=0x33
    opcode_group: zksed
    opcode_args: *1
    iss_code:
    - ''
    - require_extension(EXT_ZKSED);
    - ''
    - '#include "sm4_common.h"'
    - ''
    - uint8_t  bs     = insn.bs();
    - ''
    - uint32_t sb_in  = (RS2 >> (8*bs)) & 0xFF;
    - uint32_t sb_out = sm4_sbox[sb_in];
    - ''
    - uint32_t x      = sb_out ^
    - "((sb_out & 0x07) << 29) ^ ((sb_out & 0xFE) <<  7) ^"
    - "((sb_out & 0x01) << 23) ^ ((sb_out & 0xF8) << 13) ;"
    - ''
    - uint32_t rotl   = (x << (8*bs)) | (x >> (32-8*bs));
    - ''
    - uint32_t result = rotl ^ RS1;
    - ''
    - WRITE_RD(sext32(result));
    - ''
  snez:
    opcode:
    - snez
    - rd
    - rs
    opcode_group: psuedo
    opcode_args:
    - rd
    - rs
    psuedo_to_base:
    - sltu rd, x0, rs
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/rv32.html"
    main_desc: rv32
    main_id: "#integer-register-register-operations"
    desc:
      rv32:
        "#integer-register-register-operations":
          text:
          - ADD performs the addition of rs1 and rs2. SUB performs the subtraction
            of rs2 from rs1. Overflows are ignored and the low XLEN bits of results
            are written to the destination rd. SLT and SLTU perform signed and unsigned
            compares respectively, writing 1 to rd if rs1 < rs2, 0 otherwise. Note,
            SLTU rd, x0, rs2 sets rd to 1 if rs2 is not equal to zero, otherwise sets
            rd to zero (assembler pseudoinstruction SNEZ rd, rs). AND, OR, and XOR
            perform bitwise logical operations.
  sra:
    opcode:
    - sra
    - rd
    - rs1
    - rs2
    - 31..25=32
    - 14..12=5
    - 6..2=0x0C
    - 1..0=3
    opcode_group: i
    opcode_args: *1
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/rv32.html"
    main_desc: rv32
    main_id: "#integer-register-register-operations"
    desc:
      rv32:
        "#integer-register-register-operations":
          text:
          - SLL, SRL, and SRA perform logical left, logical right, and arithmetic
            right shifts on the value in register rs1 by the shift amount held in
            the lower 5 bits of register rs2.
      rv64:
        "#integer-register-register-operations":
          text:
          - SLL, SRL, and SRA perform logical left, logical right, and arithmetic
            right shifts on the value in register rs1 by the shift amount held in
            register rs2. In RV64I, only the low 6 bits of rs2 are considered for
            the shift amount.
      rv128:
        "#rv128":
          text:
          - Shifts by an immediate (SLLI/SRLI/SRAI) are now encoded using the low
            7 bits of the I-immediate, and variable shifts (SLL/SRL/SRA) use the low
            7 bits of the shift amount source register.
    iss_code:
    - WRITE_RD(sext_xlen(sext_xlen(RS1) >> (RS2 & (xlen-1))));
  srai:
    opcode:
    - srai
    - rd
    - rs1
    - 31..26=16
    - shamtd
    - 14..12=5
    - 6..2=0x04
    - 1..0=3
    opcode_group: i
    opcode_args: *3
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/rv32.html"
    main_desc: rv32
    main_id: "#integer-register-immediate-instructions"
    desc:
      rv32:
        "#integer-register-immediate-instructions":
          text:
          - Shifts by a constant are encoded as a specialization of the I-type format.
            The operand to be shifted is in rs1, and the shift amount is encoded in
            the lower 5 bits of the I-immediate field. The right shift type is encoded
            in bit 30. SLLI is a logical left shift (zeros are shifted into the lower
            bits); SRLI is a logical right shift (zeros are shifted into the upper
            bits); and SRAI is an arithmetic right shift (the original sign bit is
            copied into the vacated upper bits).
      rv64:
        "#integer-register-immediate-instructions":
          text:
          - Shifts by a constant are encoded as a specialization of the I-type format
            using the same instruction opcode as RV32I. The operand to be shifted
            is in rs1, and the shift amount is encoded in the lower 6 bits of the
            I-immediate field for RV64I. The right shift type is encoded in bit 30.
            SLLI is a logical left shift (zeros are shifted into the lower bits);
            SRLI is a logical right shift (zeros are shifted into the upper bits);
            and SRAI is an arithmetic right shift (the original sign bit is copied
            into the vacated upper bits).
      rv128:
        "#rv128":
          text:
          - Shifts by an immediate (SLLI/SRLI/SRAI) are now encoded using the low
            7 bits of the I-immediate, and variable shifts (SLL/SRL/SRA) use the low
            7 bits of the shift amount source register.
    iss_code:
    - require(SHAMT < xlen);
    - WRITE_RD(sext_xlen(sext_xlen(RS1) >> SHAMT));
  srai_rv32:
    opcode:
    - srai_rv32
    - rd
    - rs1
    - shamtw
    - 31..25=32
    - 14..12=5
    - 6..2=0x04
    - 1..0=3
    opcode_group: i
    opcode_args: *3
    pseudo_src: rv64_i
    pseudo_op: srai
  sraiw:
    opcode:
    - sraiw
    - rd
    - rs1
    - 31..25=32
    - shamtw
    - 14..12=5
    - 6..2=0x06
    - 1..0=3
    opcode_group: i
    opcode_args: *3
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/rv64.html"
    main_desc: rv64
    main_id: "#integer-register-immediate-instructions"
    desc:
      rv64:
        "#integer-register-immediate-instructions":
          text:
          - SLLIW, SRLIW, and SRAIW are RV64I-only instructions that are analogously
            defined but operate on 32-bit values and sign-extend their 32-bit results
            to 64 bits. SLLIW, SRLIW, and SRAIW encodings with imm[5] 0 are reserved.
          - Previously, SLLIW, SRLIW, and SRAIW with imm[5] 0 were defined to cause
            illegal instruction exceptions, whereas now they are marked as reserved.
            This is a backwards-compatible change.
    iss_code:
    - require_rv64;
    - WRITE_RD(sext32(int32_t(RS1) >> SHAMT));
  sraw:
    opcode:
    - sraw
    - rd
    - rs1
    - rs2
    - 31..25=32
    - 14..12=5
    - 6..2=0x0E
    - 1..0=3
    opcode_group: i
    opcode_args: *1
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/rv64.html"
    main_desc: rv64
    main_id: "#integer-register-register-operations"
    desc:
      rv64:
        "#integer-register-register-operations":
          text:
          - SLLW, SRLW, and SRAW are RV64I-only instructions that are analogously
            defined but operate on 32-bit values and sign-extend their 32-bit results
            to 64 bits. The shift amount is given by rs2[4:0].
    iss_code:
    - require_rv64;
    - WRITE_RD(sext32(int32_t(RS1) >> (RS2 & 0x1F)));
  sret:
    opcode:
    - sret
    - 11..7=0
    - 19..15=0
    - 31..20=0x102
    - 14..12=0
    - 6..2=0x1C
    - 1..0=3
    opcode_group: s
    opcode_args: *18
    main_url_base: "/riscv-priv-isa-manual/Priv-v1.12/machine.html"
    main_desc: machine
    main_id: "#privstack"
    desc:
      machine:
        "#privstack":
          text:
          - An MRET or SRET instruction is used to return from a trap in M-mode or
            S-mode respectively. When executing an xRET instruction, supposing xPP
            holds the value y, xIE is set to xPIE; the privilege mode is changed to
            y; xPIE is set to 1; and xPP is set to the least-privileged supported
            mode (U if U-mode is implemented, else M). If xPP M, xRET also sets MPRV=0.
        "#memory-privilege-in-mstatus-register":
          text:
          - An MRET or SRET instruction that changes the privilege mode to a mode
            less privileged than M also sets MPRV=0.
        "#virt-control":
          text:
          - The TSR (Trap SRET) bit is a
          - field that supports intercepting the supervisor exception return instruction,
            SRET. When TSR=1, attempts to execute SRET while executing in S-mode will
            raise an illegal instruction exception. When TSR=0, this operation is
            permitted in S-mode. TSR is read-only 0 when S-mode is not supported.
          - Trapping SRET is necessary to emulate the hypervisor extension (see Chapter
            [hypervisor] ) on implementations that do not provide it.
        "#otherpriv":
          text:
          - To return after handling a trap, there are separate trap return instructions
            per privilege level, MRET and SRET. MRET is always provided. SRET must
            be provided if supervisor mode is supported, and should raise an illegal
            instruction exception otherwise. SRET should also raise an illegal instruction
            exception when TSR=1 in mstatus, as described in Section 1.1.6.5 . An
            xRET instruction can be executed in privilege mode x or higher, where
            executing a lower-privilege xRET instruction will pop the relevant lower-privilege
            interrupt enable and privilege mode stack. In addition to manipulating
            the privilege stack as described in Section 1.1.6.1 , xRET sets the pc
            to the value stored in the xepc register.
      supervisor:
        "#sstatus":
          text:
          - The SPP bit indicates the privilege level at which a hart was executing
            before entering supervisor mode. When a trap is taken, SPP is set to 0
            if the trap originated from user mode, or 1 otherwise. When an SRET instruction
            (see Section [otherpriv] ) is executed to return from the trap handler,
            the privilege level is set to user mode if the SPP bit is 0, or supervisor
            mode if the SPP bit is 1; SPP is then set to 0.
          - The SPIE bit indicates whether supervisor interrupts were enabled prior
            to trapping into supervisor mode. When a trap is taken into supervisor
            mode, SPIE is set to SIE, and SIE is set to 0. When an SRET instruction
            is executed, SIE is set to SPIE, then SPIE is set to 1.
        "#supervisor-interrupt-registers-sip-and-sie":
          text:
          - These conditions for an interrupt trap to occur must be evaluated in a
            bounded amount of time from when an interrupt becomes, or ceases to be,
            pending in sip, and must also be evaluated immediately following the execution
            of an SRET instruction or an explicit write to a CSR on which these interrupt
            trap conditions expressly depend (including sip, sie and sstatus).
        "#supervisor-exception-program-counter-sepc":
          text:
          - If an implementation allows IALIGN to be either 16 or 32 (by changing
            CSR misa, for example), then, whenever IALIGN=32, bit sepc[1] is masked
            on reads so that it appears to be 0. This masking occurs also for the
            implicit read by the SRET instruction. Though masked, sepc[1] remains
            writable when IALIGN=32.
        "#supervisor-instructions":
          text:
          - In addition to the SRET instruction defined in Section [otherpriv] , one
            new supervisor-level instruction is provided.
      hypervisor:
        "#hypervisor-and-virtual-supervisor-csrs":
          text:
          - Matching VS CSRs exist only for the supervisor CSRs that must be duplicated,
            which are mainly those that get automatically written by traps or that
            impact instruction execution immediately after trap entry and/or right
            before SRET, when software alone is unable to swap a CSR at exactly the
            right moment. Currently, most supervisor CSRs fall into this category,
            but future ones might not.
        "#hypervisor-status-register-hstatus":
          text:
          - The hstatus fields VTSR, VTW, and VTVM are defined analogously to the
            mstatus fields TSR, TW, and TVM, but affect execution only in VS-mode,
            and cause virtual instruction exceptions instead of illegal instruction
            exceptions. When VTSR=1, an attempt in VS-mode to execute SRET raises
            a virtual instruction exception. When VTW=1 (and assuming mstatus.TW=0),
            an attempt in VS-mode to execute WFI raises a virtual instruction exception
            if the WFI does not complete within an implementation-specific, bounded
            time limit. When VTVM=1, an attempt in VS-mode to execute SFENCE.VMA or
            SINVAL.VMA or to access CSR satp raises a virtual instruction exception.
          - The SPV bit (Supervisor Previous Virtualization mode) is written by the
            implementation whenever a trap is taken into HS-mode. Just as the SPP
            bit in sstatus is set to the (nominal) privilege mode at the time of the
            trap, the SPV bit in hstatus is set to the value of the virtualization
            mode V at the time of the trap. When an SRET instruction is executed when
            V=0, V is set to SPV.
          - Without SPVP, if instructions HLV, HLVX, and HSV looked instead to sstatus.SPP
            for the effective privilege of their memory accesses, then, even with
            HU=1, U-mode could not access virtual machine memory at VS-level, because
            to enter U-mode using SRET always leaves SPP=0. Unlike SPP, field SPVP
            is untouched by transitions back-and-forth between HS-mode and U-mode.
        "#trap-cause-codes":
          text:
          - in VU-mode, attempts to execute WFI when mstatus.TW=0, or to execute a
            supervisor instruction (SRET or SFENCE);
          - in VS-mode, attempts to execute SRET when hstatus.VTSR=1; and
        "#trap-return":
          text:
          - The SRET instruction is used to return from a trap taken into HS-mode
            or VS-mode. Its behavior depends on the current virtualization mode.
          - When executed in M-mode or HS-mode (i.e., V=0), SRET first determines
            what the new privilege mode will be according to the values in hstatus.SPV
            and sstatus.SPP, as encoded in Table [h-spp] . SRET then sets hstatus.SPV=0,
            and in sstatus sets SPP=0, SIE=SPIE, and SPIE=1. Lastly, SRET sets the
            privilege mode as previously determined, and sets pc=sepc.
          - When executed in VS-mode (i.e., V=1), SRET sets the privilege mode according
            to Table [h-vspp] , in vsstatus sets SPP=0, SIE=SPIE, and SPIE=1, and
            lastly sets pc=vsepc.
    iss_code:
    - require_extension('S');
    - reg_t prev_hstatus = STATE.hstatus->read();
    - if (STATE.v) {
    - if (STATE.prv == PRV_U || get_field(prev_hstatus, HSTATUS_VTSR))
    - require_novirt();
    - "} else {"
    - 'require_privilege(get_field(STATE.mstatus->read(), MSTATUS_TSR) ? PRV_M : PRV_S);'
    - "}"
    - reg_t next_pc = p->get_state()->sepc->read();
    - set_pc_and_serialize(next_pc);
    - reg_t s = STATE.sstatus->read();
    - reg_t prev_prv = get_field(s, MSTATUS_SPP);
    - s = set_field(s, MSTATUS_SIE, get_field(s, MSTATUS_SPIE));
    - s = set_field(s, MSTATUS_SPIE, 1);
    - s = set_field(s, MSTATUS_SPP, PRV_U);
    - STATE.sstatus->write(s);
    - bool prev_virt = STATE.v;
    - if (!STATE.v) {
    - if (p->extension_enabled('H')) {
    - prev_virt = get_field(prev_hstatus, HSTATUS_SPV);
    - reg_t new_hstatus = set_field(prev_hstatus, HSTATUS_SPV, 0);
    - STATE.hstatus->write(new_hstatus);
    - "}"
    - ''
    - STATE.mstatus->write(set_field(STATE.mstatus->read(), MSTATUS_MPRV, 0));
    - "}"
    - p->set_privilege(prev_prv, prev_virt);
  srl:
    opcode:
    - srl
    - rd
    - rs1
    - rs2
    - 31..25=0
    - 14..12=5
    - 6..2=0x0C
    - 1..0=3
    opcode_group: i
    opcode_args: *1
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/rv32.html"
    main_desc: rv32
    main_id: "#integer-register-register-operations"
    desc:
      rv32:
        "#integer-register-register-operations":
          text:
          - SLL, SRL, and SRA perform logical left, logical right, and arithmetic
            right shifts on the value in register rs1 by the shift amount held in
            the lower 5 bits of register rs2.
      rv64:
        "#integer-register-register-operations":
          text:
          - SLL, SRL, and SRA perform logical left, logical right, and arithmetic
            right shifts on the value in register rs1 by the shift amount held in
            register rs2. In RV64I, only the low 6 bits of rs2 are considered for
            the shift amount.
      rv128:
        "#rv128":
          text:
          - Shifts by an immediate (SLLI/SRLI/SRAI) are now encoded using the low
            7 bits of the I-immediate, and variable shifts (SLL/SRL/SRA) use the low
            7 bits of the shift amount source register.
    iss_code:
    - WRITE_RD(sext_xlen(zext_xlen(RS1) >> (RS2 & (xlen-1))));
  srli:
    opcode:
    - srli
    - rd
    - rs1
    - 31..26=0
    - shamtd
    - 14..12=5
    - 6..2=0x04
    - 1..0=3
    opcode_group: i
    opcode_args: *3
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/rv32.html"
    main_desc: rv32
    main_id: "#integer-register-immediate-instructions"
    desc:
      rv32:
        "#integer-register-immediate-instructions":
          text:
          - Shifts by a constant are encoded as a specialization of the I-type format.
            The operand to be shifted is in rs1, and the shift amount is encoded in
            the lower 5 bits of the I-immediate field. The right shift type is encoded
            in bit 30. SLLI is a logical left shift (zeros are shifted into the lower
            bits); SRLI is a logical right shift (zeros are shifted into the upper
            bits); and SRAI is an arithmetic right shift (the original sign bit is
            copied into the vacated upper bits).
      rv64:
        "#integer-register-immediate-instructions":
          text:
          - Shifts by a constant are encoded as a specialization of the I-type format
            using the same instruction opcode as RV32I. The operand to be shifted
            is in rs1, and the shift amount is encoded in the lower 6 bits of the
            I-immediate field for RV64I. The right shift type is encoded in bit 30.
            SLLI is a logical left shift (zeros are shifted into the lower bits);
            SRLI is a logical right shift (zeros are shifted into the upper bits);
            and SRAI is an arithmetic right shift (the original sign bit is copied
            into the vacated upper bits).
      rv128:
        "#rv128":
          text:
          - Shifts by an immediate (SLLI/SRLI/SRAI) are now encoded using the low
            7 bits of the I-immediate, and variable shifts (SLL/SRL/SRA) use the low
            7 bits of the shift amount source register.
    iss_code:
    - require(SHAMT < xlen);
    - WRITE_RD(sext_xlen(zext_xlen(RS1) >> SHAMT));
  srli_rv32:
    opcode:
    - srli_rv32
    - rd
    - rs1
    - shamtw
    - 31..25=0
    - 14..12=5
    - 6..2=0x04
    - 1..0=3
    opcode_group: i
    opcode_args: *3
    pseudo_src: rv64_i
    pseudo_op: srli
  srliw:
    opcode:
    - srliw
    - rd
    - rs1
    - 31..25=0
    - shamtw
    - 14..12=5
    - 6..2=0x06
    - 1..0=3
    opcode_group: i
    opcode_args: *3
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/rv64.html"
    main_desc: rv64
    main_id: "#integer-register-immediate-instructions"
    desc:
      rv64:
        "#integer-register-immediate-instructions":
          text:
          - SLLIW, SRLIW, and SRAIW are RV64I-only instructions that are analogously
            defined but operate on 32-bit values and sign-extend their 32-bit results
            to 64 bits. SLLIW, SRLIW, and SRAIW encodings with imm[5] 0 are reserved.
          - Previously, SLLIW, SRLIW, and SRAIW with imm[5] 0 were defined to cause
            illegal instruction exceptions, whereas now they are marked as reserved.
            This is a backwards-compatible change.
    iss_code:
    - require_rv64;
    - WRITE_RD(sext32((uint32_t)RS1 >> SHAMT));
  srlw:
    opcode:
    - srlw
    - rd
    - rs1
    - rs2
    - 31..25=0
    - 14..12=5
    - 6..2=0x0E
    - 1..0=3
    opcode_group: i
    opcode_args: *1
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/rv64.html"
    main_desc: rv64
    main_id: "#integer-register-register-operations"
    desc:
      rv64:
        "#integer-register-register-operations":
          text:
          - SLLW, SRLW, and SRAW are RV64I-only instructions that are analogously
            defined but operate on 32-bit values and sign-extend their 32-bit results
            to 64 bits. The shift amount is given by rs2[4:0].
    iss_code:
    - require_rv64;
    - WRITE_RD(sext32((uint32_t)RS1 >> (RS2 & 0x1F)));
  sub:
    opcode:
    - sub
    - rd
    - rs1
    - rs2
    - 31..25=32
    - 14..12=0
    - 6..2=0x0C
    - 1..0=3
    opcode_group: i
    opcode_args: *1
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/rv32.html"
    main_desc: rv32
    main_id: "#integer-register-register-operations"
    desc:
      rv32:
        "#integer-register-register-operations":
          text:
          - ADD performs the addition of rs1 and rs2. SUB performs the subtraction
            of rs2 from rs1. Overflows are ignored and the low XLEN bits of results
            are written to the destination rd. SLT and SLTU perform signed and unsigned
            compares respectively, writing 1 to rd if rs1 < rs2, 0 otherwise. Note,
            SLTU rd, x0, rs2 sets rd to 1 if rs2 is not equal to zero, otherwise sets
            rd to zero (assembler pseudoinstruction SNEZ rd, rs). AND, OR, and XOR
            perform bitwise logical operations.
      rv64:
        "#integer-register-register-operations":
          text:
          - ADDW and SUBW are RV64I-only instructions that are defined analogously
            to ADD and SUB but operate on 32-bit values and produce signed 32-bit
            results. Overflows are ignored, and the low 32-bits of the result is sign-extended
            to 64-bits and written to the destination register.
    iss_code:
    - WRITE_RD(sext_xlen(RS1 - RS2));
  subw:
    opcode:
    - subw
    - rd
    - rs1
    - rs2
    - 31..25=32
    - 14..12=0
    - 6..2=0x0E
    - 1..0=3
    opcode_group: i
    opcode_args: *1
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/rv64.html"
    main_desc: rv64
    main_id: "#integer-register-register-operations"
    desc:
      rv64:
        "#integer-computational-instructions":
          text:
          - The compiler and calling convention maintain an invariant that all 32-bit
            values are held in a sign-extended format in 64-bit registers. Even 32-bit
            unsigned integers extend bit 31 into bits 63 through 32. Consequently,
            conversion between unsigned and signed 32-bit integers is a no-op, as
            is conversion from a signed 32-bit integer to a signed 64-bit integer.
            Existing 64-bit wide SLTU and unsigned branch compares still operate correctly
            on unsigned 32-bit integers under this invariant. Similarly, existing
            64-bit wide logical operations on 32-bit sign-extended integers preserve
            the sign-extension property. A few new instructions (ADD[I]W/SUBW/SxxW)
            are required for addition and shifts to ensure reasonable performance
            for 32-bit values.
        "#integer-register-register-operations":
          text:
          - ADDW and SUBW are RV64I-only instructions that are defined analogously
            to ADD and SUB but operate on 32-bit values and produce signed 32-bit
            results. Overflows are ignored, and the low 32-bits of the result is sign-extended
            to 64-bits and written to the destination register.
    iss_code:
    - require_rv64;
    - WRITE_RD(sext32(RS1 - RS2));
    - ''
  sw:
    opcode:
    - sw
    - imm12hi
    - rs1
    - rs2
    - imm12lo
    - 14..12=2
    - 6..2=0x08
    - 1..0=3
    opcode_group: i
    opcode_args: *24
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/rv32.html"
    main_desc: rv32
    main_id: "#sec:rv32:ldst"
    desc:
      rv32:
        "#sec:rv32:ldst":
          text:
          - The LW instruction loads a 32-bit value from memory into rd. LH loads
            a 16-bit value from memory, then sign-extends to 32-bits before storing
            in rd. LHU loads a 16-bit value from memory but then zero extends to 32-bits
            before storing in rd. LB and LBU are defined analogously for 8-bit values.
            The SW, SH, and SB instructions store 32-bit, 16-bit, and 8-bit values
            from the low bits of register rs2 to memory.
      rv64:
        "#load-and-store-instructions":
          text:
          - The LW instruction loads a 32-bit value from memory and sign-extends this
            to 64 bits before storing it in register rd for RV64I. The LWU instruction,
            on the other hand, zero-extends the 32-bit value from memory for RV64I.
            LH and LHU are defined analogously for 16-bit values, as are LB and LBU
            for 8-bit values. The SD, SW, SH, and SB instructions store 64-bit, 32-bit,
            16-bit, and 8-bit values from the low bits of register rs2 to memory respectively.
      machine:
        "#machine-environment-configuration-registers-menvcfg-and-menvcfgh":
          text:
          - Successor device output and memory writes (SW implied)
      supervisor:
        "#supervisor-environment-configuration-register-senvcfg":
          text:
          - Successor device output and memory writes (SW implied)
      hypervisor:
        "#hypervisor-environment-configuration-registers-henvcfg-and-henvcfgh":
          text:
          - Successor device output and memory writes (SW implied)
        "#hypervisor-virtual-machine-load-and-store-instructions":
          text:
          - 'For every RV32I or RV64I load instruction, LB, LBU, LH, LHU, LW, LWU,
            and LD, there is a corresponding virtual-machine load instruction: HLV.B,
            HLV.BU, HLV.H, HLV.HU, HLV.W, HLV.WU, and HLV.D. For every RV32I or RV64I
            store instruction, SB, SH, SW, and SD, there is a corresponding virtual-machine
            store instruction: HSV.B, HSV.H, HSV.W, and HSV.D. Instructions HLV.WU,
            HLV.D, and HSV.D are not valid for RV32, of course.'
        "#sec:tinst-vals":
          text:
          - For a standard store instruction that is not a compressed instruction
            and is one of SB, SH, SW, SD, FSW, FSD, FSQ, or FSH, the transformed instruction
            has the format shown in Figure 1.47 .
          - Transformed noncompressed store instruction (SB, SH, SW, SD, FSW, FSD,
            FSQ, or FSH). Fields rs2, funct3, and opcode are the same as the trapping
            store instruction.
          - In decoding the contents of mtinst or htinst, once software has determined
            that the register contains the encoding of a standard basic load (LB,
            LBU, LH, LHU, LW, LWU, LD, FLW, FLD, FLQ, or FLH) or basic store (SB,
            SH, SW, SD, FSW, FSD, FSQ, or FSH), it is not necessary to confirm also
            that the immediate offset fields (31:25, and 24:20 or 11:7) are zeros.
            The knowledge that the register's value is the encoding of a basic load/store
            is sufficient to prove that the trapping instruction is of the same kind.
    iss_code:
    - MMU.store<uint32_t>(RS1 + insn.s_imm(), RS2);
  tail:
    opcode:
    - tail
    - offset
    opcode_group: psuedo
    opcode_args:
    - offset
    psuedo_to_base:
    - auipc x6, offset[31:12]
    - jalr x0, x6, offset[11:0]
  unzip:
    opcode:
    - unzip
    - rd
    - rs1
    - 31..25=4
    - 24..20=15
    - 14..12=5
    - 6..2=4
    - 1..0=3
    opcode_group: zks
    opcode_args: *3
    pseudo_src: rv64_zbp
    pseudo_op: unshfli
  vaadd.vv:
    opcode:
    - vaadd.vv
    - 31..26=0x09
    - vm
    - vs2
    - vs1
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: &28
    - vs2
    - vs1
    - vd
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vaadd
  vaadd.vx:
    opcode:
    - vaadd.vx
    - 31..26=0x09
    - vm
    - vs2
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: &29
    - vs2
    - rs1
    - vd
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vaadd
  vaaddu.vv:
    opcode:
    - vaaddu.vv
    - 31..26=0x08
    - vm
    - vs2
    - vs1
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_single_width_averaging_add_and_subtract"
    desc:
      v:
        "#_vector_single_width_averaging_add_and_subtract":
          text:
          - The averaging add and subtract instructions right shift the result by
            one bit and round off the result according to the setting in vxrm. Both
            unsigned and signed versions are provided. For vaaddu and vaadd there
            can be no overflow in the result. For vasub and vasubu, overflow is ignored
            and the result wraps around.
          - "# Averaging add # Averaging adds of unsigned integers. vaaddu.vv vd,
            vs2, vs1, vm # roundoff_unsigned(vs2[i] + vs1[i], 1) vaaddu.vx vd, vs2,
            rs1, vm # roundoff_unsigned(vs2[i] + x[rs1], 1) # Averaging adds of signed
            integers. vaadd.vv vd, vs2, vs1, vm # roundoff_signed(vs2[i] + vs1[i],
            1) vaadd.vx vd, vs2, rs1, vm # roundoff_signed(vs2[i] + x[rs1], 1) # Averaging
            subtract # Averaging subtract of unsigned integers. vasubu.vv vd, vs2,
            vs1, vm # roundoff_unsigned(vs2[i] - vs1[i], 1) vasubu.vx vd, vs2, rs1,
            vm # roundoff_unsigned(vs2[i] - x[rs1], 1) # Averaging subtract of signed
            integers. vasub.vv vd, vs2, vs1, vm # roundoff_signed(vs2[i] - vs1[i],
            1) vasub.vx vd, vs2, rs1, vm # roundoff_signed(vs2[i] - x[rs1], 1)"
        "#_vector_instruction_listing":
          text:
          - vaaddu
  vaaddu.vx:
    opcode:
    - vaaddu.vx
    - 31..26=0x08
    - vm
    - vs2
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_single_width_averaging_add_and_subtract"
    desc:
      v:
        "#_vector_single_width_averaging_add_and_subtract":
          text:
          - The averaging add and subtract instructions right shift the result by
            one bit and round off the result according to the setting in vxrm. Both
            unsigned and signed versions are provided. For vaaddu and vaadd there
            can be no overflow in the result. For vasub and vasubu, overflow is ignored
            and the result wraps around.
          - "# Averaging add # Averaging adds of unsigned integers. vaaddu.vv vd,
            vs2, vs1, vm # roundoff_unsigned(vs2[i] + vs1[i], 1) vaaddu.vx vd, vs2,
            rs1, vm # roundoff_unsigned(vs2[i] + x[rs1], 1) # Averaging adds of signed
            integers. vaadd.vv vd, vs2, vs1, vm # roundoff_signed(vs2[i] + vs1[i],
            1) vaadd.vx vd, vs2, rs1, vm # roundoff_signed(vs2[i] + x[rs1], 1) # Averaging
            subtract # Averaging subtract of unsigned integers. vasubu.vv vd, vs2,
            vs1, vm # roundoff_unsigned(vs2[i] - vs1[i], 1) vasubu.vx vd, vs2, rs1,
            vm # roundoff_unsigned(vs2[i] - x[rs1], 1) # Averaging subtract of signed
            integers. vasub.vv vd, vs2, vs1, vm # roundoff_signed(vs2[i] - vs1[i],
            1) vasub.vx vd, vs2, rs1, vm # roundoff_signed(vs2[i] - x[rs1], 1)"
        "#_vector_instruction_listing":
          text:
          - vaaddu
  vadc.vim:
    opcode:
    - vadc.vim
    - 31..26=0x10
    - 25=0
    - vs2
    - simm5
    - 14..12=0x3
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: &30
    - vs2
    - simm5
    - vd
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_integer_add_with_carry_subtract_with_borrow_instructions"
    desc:
      v:
        "#_vector_integer_add_with_carry_subtract_with_borrow_instructions":
          text:
          - vadc and vsbc add or subtract the source operands and the carry-in or
            borrow-in, and write the result to vector register vd. These instructions
            are encoded as masked instructions (vm=0), but they operate on and write
            back all body elements. Encodings corresponding to the unmasked versions
            (vm=1) are reserved.
          - For vadc and vsbc, the instruction encoding is reserved if the destination
            vector register is v0.
          - "# Produce sum with carry. # vd[i] = vs2[i] + vs1[i] + v0.mask[i] vadc.vvm
            vd, vs2, vs1, v0 # Vector-vector # vd[i] = vs2[i] + x[rs1] + v0.mask[i]
            vadc.vxm vd, vs2, rs1, v0 # Vector-scalar # vd[i] = vs2[i] + imm + v0.mask[i]
            vadc.vim vd, vs2, imm, v0 # Vector-immediate # Produce carry out in mask
            register format # vd.mask[i] = carry_out(vs2[i] + vs1[i] + v0.mask[i])
            vmadc.vvm vd, vs2, vs1, v0 # Vector-vector # vd.mask[i] = carry_out(vs2[i]
            + x[rs1] + v0.mask[i]) vmadc.vxm vd, vs2, rs1, v0 # Vector-scalar # vd.mask[i]
            = carry_out(vs2[i] + imm + v0.mask[i]) vmadc.vim vd, vs2, imm, v0 # Vector-immediate
            # vd.mask[i] = carry_out(vs2[i] + vs1[i]) vmadc.vv vd, vs2, vs1 # Vector-vector,
            no carry-in # vd.mask[i] = carry_out(vs2[i] + x[rs1]) vmadc.vx vd, vs2,
            rs1 # Vector-scalar, no carry-in # vd.mask[i] = carry_out(vs2[i] + imm)
            vmadc.vi vd, vs2, imm # Vector-immediate, no carry-in"
        "#_vector_instruction_listing":
          text:
          - vadc
  vadc.vvm:
    opcode:
    - vadc.vvm
    - 31..26=0x10
    - 25=0
    - vs2
    - vs1
    - 14..12=0x0
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_integer_add_with_carry_subtract_with_borrow_instructions"
    desc:
      v:
        "#_vector_integer_add_with_carry_subtract_with_borrow_instructions":
          text:
          - vadc and vsbc add or subtract the source operands and the carry-in or
            borrow-in, and write the result to vector register vd. These instructions
            are encoded as masked instructions (vm=0), but they operate on and write
            back all body elements. Encodings corresponding to the unmasked versions
            (vm=1) are reserved.
          - For vadc and vsbc, the instruction encoding is reserved if the destination
            vector register is v0.
          - "# Produce sum with carry. # vd[i] = vs2[i] + vs1[i] + v0.mask[i] vadc.vvm
            vd, vs2, vs1, v0 # Vector-vector # vd[i] = vs2[i] + x[rs1] + v0.mask[i]
            vadc.vxm vd, vs2, rs1, v0 # Vector-scalar # vd[i] = vs2[i] + imm + v0.mask[i]
            vadc.vim vd, vs2, imm, v0 # Vector-immediate # Produce carry out in mask
            register format # vd.mask[i] = carry_out(vs2[i] + vs1[i] + v0.mask[i])
            vmadc.vvm vd, vs2, vs1, v0 # Vector-vector # vd.mask[i] = carry_out(vs2[i]
            + x[rs1] + v0.mask[i]) vmadc.vxm vd, vs2, rs1, v0 # Vector-scalar # vd.mask[i]
            = carry_out(vs2[i] + imm + v0.mask[i]) vmadc.vim vd, vs2, imm, v0 # Vector-immediate
            # vd.mask[i] = carry_out(vs2[i] + vs1[i]) vmadc.vv vd, vs2, vs1 # Vector-vector,
            no carry-in # vd.mask[i] = carry_out(vs2[i] + x[rs1]) vmadc.vx vd, vs2,
            rs1 # Vector-scalar, no carry-in # vd.mask[i] = carry_out(vs2[i] + imm)
            vmadc.vi vd, vs2, imm # Vector-immediate, no carry-in"
        "#_vector_instruction_listing":
          text:
          - vadc
  vadc.vxm:
    opcode:
    - vadc.vxm
    - 31..26=0x10
    - 25=0
    - vs2
    - rs1
    - 14..12=0x4
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_integer_add_with_carry_subtract_with_borrow_instructions"
    desc:
      v:
        "#_vector_integer_add_with_carry_subtract_with_borrow_instructions":
          text:
          - vadc and vsbc add or subtract the source operands and the carry-in or
            borrow-in, and write the result to vector register vd. These instructions
            are encoded as masked instructions (vm=0), but they operate on and write
            back all body elements. Encodings corresponding to the unmasked versions
            (vm=1) are reserved.
          - For vadc and vsbc, the instruction encoding is reserved if the destination
            vector register is v0.
          - "# Produce sum with carry. # vd[i] = vs2[i] + vs1[i] + v0.mask[i] vadc.vvm
            vd, vs2, vs1, v0 # Vector-vector # vd[i] = vs2[i] + x[rs1] + v0.mask[i]
            vadc.vxm vd, vs2, rs1, v0 # Vector-scalar # vd[i] = vs2[i] + imm + v0.mask[i]
            vadc.vim vd, vs2, imm, v0 # Vector-immediate # Produce carry out in mask
            register format # vd.mask[i] = carry_out(vs2[i] + vs1[i] + v0.mask[i])
            vmadc.vvm vd, vs2, vs1, v0 # Vector-vector # vd.mask[i] = carry_out(vs2[i]
            + x[rs1] + v0.mask[i]) vmadc.vxm vd, vs2, rs1, v0 # Vector-scalar # vd.mask[i]
            = carry_out(vs2[i] + imm + v0.mask[i]) vmadc.vim vd, vs2, imm, v0 # Vector-immediate
            # vd.mask[i] = carry_out(vs2[i] + vs1[i]) vmadc.vv vd, vs2, vs1 # Vector-vector,
            no carry-in # vd.mask[i] = carry_out(vs2[i] + x[rs1]) vmadc.vx vd, vs2,
            rs1 # Vector-scalar, no carry-in # vd.mask[i] = carry_out(vs2[i] + imm)
            vmadc.vi vd, vs2, imm # Vector-immediate, no carry-in"
        "#_vector_instruction_listing":
          text:
          - vadc
  vadd.vi:
    opcode:
    - vadd.vi
    - 31..26=0x00
    - vm
    - vs2
    - simm5
    - 14..12=0x3
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *30
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_single_width_integer_add_and_subtract"
    desc:
      v:
        "#_vector_single_width_integer_add_and_subtract":
          text:
          - "# Integer adds. vadd.vv vd, vs2, vs1, vm # Vector-vector vadd.vx vd,
            vs2, rs1, vm # vector-scalar vadd.vi vd, vs2, imm, vm # vector-immediate
            # Integer subtract vsub.vv vd, vs2, vs1, vm # Vector-vector vsub.vx vd,
            vs2, rs1, vm # vector-scalar # Integer reverse subtract vrsub.vx vd, vs2,
            rs1, vm # vd[i] = x[rs1] - vs2[i] vrsub.vi vd, vs2, imm, vm # vd[i] =
            imm - vs2[i]"
        "#_vector_instruction_listing":
          text:
          - vadd
  vadd.vv:
    opcode:
    - vadd.vv
    - 31..26=0x00
    - vm
    - vs2
    - vs1
    - 14..12=0x0
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_single_width_integer_add_and_subtract"
    desc:
      v:
        "#_vector_single_width_integer_add_and_subtract":
          text:
          - "# Integer adds. vadd.vv vd, vs2, vs1, vm # Vector-vector vadd.vx vd,
            vs2, rs1, vm # vector-scalar vadd.vi vd, vs2, imm, vm # vector-immediate
            # Integer subtract vsub.vv vd, vs2, vs1, vm # Vector-vector vsub.vx vd,
            vs2, rs1, vm # vector-scalar # Integer reverse subtract vrsub.vx vd, vs2,
            rs1, vm # vd[i] = x[rs1] - vs2[i] vrsub.vi vd, vs2, imm, vm # vd[i] =
            imm - vs2[i]"
        "#_vector_instruction_listing":
          text:
          - vadd
  vadd.vx:
    opcode:
    - vadd.vx
    - 31..26=0x00
    - vm
    - vs2
    - rs1
    - 14..12=0x4
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_single_width_integer_add_and_subtract"
    desc:
      v:
        "#_vector_single_width_integer_add_and_subtract":
          text:
          - "# Integer adds. vadd.vv vd, vs2, vs1, vm # Vector-vector vadd.vx vd,
            vs2, rs1, vm # vector-scalar vadd.vi vd, vs2, imm, vm # vector-immediate
            # Integer subtract vsub.vv vd, vs2, vs1, vm # Vector-vector vsub.vx vd,
            vs2, rs1, vm # vector-scalar # Integer reverse subtract vrsub.vx vd, vs2,
            rs1, vm # vd[i] = x[rs1] - vs2[i] vrsub.vi vd, vs2, imm, vm # vd[i] =
            imm - vs2[i]"
        "#_vector_instruction_listing":
          text:
          - vadd
  vamoaddei16.v:
    opcode:
    - vamoaddei16.v
    - 31..27=0x00
    - wd
    - vm
    - vs2
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x2f
    opcode_group: v
    opcode_args: *29
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
    iss_code:
    - "//vamoadde.v vd, (rs1), vs2, vd"
    - VI_AMO({ return lhs + vs3; }, uint, e16);
  vamoaddei32.v:
    opcode:
    - vamoaddei32.v
    - 31..27=0x00
    - wd
    - vm
    - vs2
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x2f
    opcode_group: v
    opcode_args: *29
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
    iss_code:
    - "//vamoadde.v vd, (rs1), vs2, vd"
    - VI_AMO({ return lhs + vs3; }, uint, e32);
  vamoaddei64.v:
    opcode:
    - vamoaddei64.v
    - 31..27=0x00
    - wd
    - vm
    - vs2
    - rs1
    - 14..12=0x7
    - vd
    - 6..0=0x2f
    opcode_group: v
    opcode_args: *29
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
    iss_code:
    - "//vamoadde.v vd, (rs1), vs2, vd"
    - VI_AMO({ return lhs + vs3; }, uint, e64);
  vamoaddei8.v:
    opcode:
    - vamoaddei8.v
    - 31..27=0x00
    - wd
    - vm
    - vs2
    - rs1
    - 14..12=0x0
    - vd
    - 6..0=0x2f
    opcode_group: v
    opcode_args: *29
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
    iss_code:
    - "//vamoadde.v vd, (rs1), vs2, vd"
    - VI_AMO({ return lhs + vs3; }, uint, e8);
  vamoandei16.v:
    opcode:
    - vamoandei16.v
    - 31..27=0x0c
    - wd
    - vm
    - vs2
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x2f
    opcode_group: v
    opcode_args: *29
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
    iss_code:
    - "//vamoande.v vd, (rs1), vs2, vd"
    - VI_AMO({ return lhs & vs3; }, uint, e16);
  vamoandei32.v:
    opcode:
    - vamoandei32.v
    - 31..27=0x0c
    - wd
    - vm
    - vs2
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x2f
    opcode_group: v
    opcode_args: *29
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
    iss_code:
    - "//vamoande.v vd, (rs1), vs2, vd"
    - VI_AMO({ return lhs & vs3; }, uint, e32);
  vamoandei64.v:
    opcode:
    - vamoandei64.v
    - 31..27=0x0c
    - wd
    - vm
    - vs2
    - rs1
    - 14..12=0x7
    - vd
    - 6..0=0x2f
    opcode_group: v
    opcode_args: *29
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
    iss_code:
    - "//vamoande.v vd, (rs1), vs2, vd"
    - VI_AMO({ return lhs & vs3; }, uint, e64);
  vamoandei8.v:
    opcode:
    - vamoandei8.v
    - 31..27=0x0c
    - wd
    - vm
    - vs2
    - rs1
    - 14..12=0x0
    - vd
    - 6..0=0x2f
    opcode_group: v
    opcode_args: *29
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
    iss_code:
    - "//vamoande.v vd, (rs1), vs2, vd"
    - VI_AMO({ return lhs & vs3; }, uint, e8);
  vamomaxei16.v:
    opcode:
    - vamomaxei16.v
    - 31..27=0x14
    - wd
    - vm
    - vs2
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x2f
    opcode_group: v
    opcode_args: *29
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
    iss_code:
    - "//vamomaxe.v vd, (rs1), vs2, vd"
    - 'VI_AMO({ return lhs >= vs3 ? lhs : vs3; }, int, e16);'
  vamomaxei32.v:
    opcode:
    - vamomaxei32.v
    - 31..27=0x14
    - wd
    - vm
    - vs2
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x2f
    opcode_group: v
    opcode_args: *29
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
    iss_code:
    - "//vamomaxe.v vd, (rs1), vs2, vd"
    - 'VI_AMO({ return lhs >= vs3 ? lhs : vs3; }, int, e32);'
  vamomaxei64.v:
    opcode:
    - vamomaxei64.v
    - 31..27=0x14
    - wd
    - vm
    - vs2
    - rs1
    - 14..12=0x7
    - vd
    - 6..0=0x2f
    opcode_group: v
    opcode_args: *29
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
    iss_code:
    - "//vamomaxe.v vd, (rs1), vs2, vd"
    - 'VI_AMO({ return lhs >= vs3 ? lhs : vs3; }, int, e64);'
  vamomaxei8.v:
    opcode:
    - vamomaxei8.v
    - 31..27=0x14
    - wd
    - vm
    - vs2
    - rs1
    - 14..12=0x0
    - vd
    - 6..0=0x2f
    opcode_group: v
    opcode_args: *29
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
    iss_code:
    - "//vamomaxe.v vd, (rs1), vs2, vd"
    - 'VI_AMO({ return lhs >= vs3 ? lhs : vs3; }, int, e8);'
  vamomaxuei16.v:
    opcode:
    - vamomaxuei16.v
    - 31..27=0x1c
    - wd
    - vm
    - vs2
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x2f
    opcode_group: v
    opcode_args: *29
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
    iss_code:
    - "//vamomaxue.v vd, (rs1), vs2, vd"
    - 'VI_AMO({ return lhs >= vs3 ? lhs : vs3;; }, uint, e16);'
  vamomaxuei32.v:
    opcode:
    - vamomaxuei32.v
    - 31..27=0x1c
    - wd
    - vm
    - vs2
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x2f
    opcode_group: v
    opcode_args: *29
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
    iss_code:
    - "//vamomaxue.v vd, (rs1), vs2, vd"
    - 'VI_AMO({ return lhs >= vs3 ? lhs : vs3;; }, uint, e32);'
  vamomaxuei64.v:
    opcode:
    - vamomaxuei64.v
    - 31..27=0x1c
    - wd
    - vm
    - vs2
    - rs1
    - 14..12=0x7
    - vd
    - 6..0=0x2f
    opcode_group: v
    opcode_args: *29
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
    iss_code:
    - "//vamomaxue.v vd, (rs1), vs2, vd"
    - 'VI_AMO({ return lhs >= vs3 ? lhs : vs3;; }, uint, e64);'
  vamomaxuei8.v:
    opcode:
    - vamomaxuei8.v
    - 31..27=0x1c
    - wd
    - vm
    - vs2
    - rs1
    - 14..12=0x0
    - vd
    - 6..0=0x2f
    opcode_group: v
    opcode_args: *29
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
    iss_code:
    - "//vamomaxue.v vd, (rs1), vs2, vd"
    - 'VI_AMO({ return lhs >= vs3 ? lhs : vs3;; }, uint, e8);'
  vamominei16.v:
    opcode:
    - vamominei16.v
    - 31..27=0x10
    - wd
    - vm
    - vs2
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x2f
    opcode_group: v
    opcode_args: *29
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
    iss_code:
    - "//vamomine.v vd, (rs1), vs2, vd"
    - 'VI_AMO({ return lhs < vs3 ? lhs : vs3; }, int, e16);'
  vamominei32.v:
    opcode:
    - vamominei32.v
    - 31..27=0x10
    - wd
    - vm
    - vs2
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x2f
    opcode_group: v
    opcode_args: *29
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
    iss_code:
    - "//vamomine.v vd, (rs1), vs2, vd"
    - 'VI_AMO({ return lhs < vs3 ? lhs : vs3; }, int, e32);'
  vamominei64.v:
    opcode:
    - vamominei64.v
    - 31..27=0x10
    - wd
    - vm
    - vs2
    - rs1
    - 14..12=0x7
    - vd
    - 6..0=0x2f
    opcode_group: v
    opcode_args: *29
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
    iss_code:
    - "//vamomine.v vd, (rs1), vs2, vd"
    - 'VI_AMO({ return lhs < vs3 ? lhs : vs3; }, int, e64);'
  vamominei8.v:
    opcode:
    - vamominei8.v
    - 31..27=0x10
    - wd
    - vm
    - vs2
    - rs1
    - 14..12=0x0
    - vd
    - 6..0=0x2f
    opcode_group: v
    opcode_args: *29
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
    iss_code:
    - "//vamomine.v vd, (rs1), vs2, vd"
    - 'VI_AMO({ return lhs < vs3 ? lhs : vs3; }, int, e8);'
  vamominuei16.v:
    opcode:
    - vamominuei16.v
    - 31..27=0x18
    - wd
    - vm
    - vs2
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x2f
    opcode_group: v
    opcode_args: *29
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
    iss_code:
    - "//vamominue.v vd, (rs1), vs2, vd"
    - 'VI_AMO({ return lhs < vs3 ? lhs : vs3;; }, uint, e16);'
  vamominuei32.v:
    opcode:
    - vamominuei32.v
    - 31..27=0x18
    - wd
    - vm
    - vs2
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x2f
    opcode_group: v
    opcode_args: *29
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
    iss_code:
    - "//vamominue.v vd, (rs1), vs2, vd"
    - 'VI_AMO({ return lhs < vs3 ? lhs : vs3;; }, uint, e32);'
  vamominuei64.v:
    opcode:
    - vamominuei64.v
    - 31..27=0x18
    - wd
    - vm
    - vs2
    - rs1
    - 14..12=0x7
    - vd
    - 6..0=0x2f
    opcode_group: v
    opcode_args: *29
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
    iss_code:
    - "//vamominue.v vd, (rs1), vs2, vd"
    - 'VI_AMO({ return lhs < vs3 ? lhs : vs3;; }, uint, e64);'
  vamominuei8.v:
    opcode:
    - vamominuei8.v
    - 31..27=0x18
    - wd
    - vm
    - vs2
    - rs1
    - 14..12=0x0
    - vd
    - 6..0=0x2f
    opcode_group: v
    opcode_args: *29
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
    iss_code:
    - "//vamominue.v vd, (rs1), vs2, vd"
    - 'VI_AMO({ return lhs < vs3 ? lhs : vs3;; }, uint, e8);'
  vamoorei16.v:
    opcode:
    - vamoorei16.v
    - 31..27=0x08
    - wd
    - vm
    - vs2
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x2f
    opcode_group: v
    opcode_args: *29
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
    iss_code:
    - "//vamoore.v vd, (rs1), vs2, vd"
    - VI_AMO({ return lhs | vs3; }, uint, e16);
  vamoorei32.v:
    opcode:
    - vamoorei32.v
    - 31..27=0x08
    - wd
    - vm
    - vs2
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x2f
    opcode_group: v
    opcode_args: *29
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
    iss_code:
    - "//vamoore.v vd, (rs1), vs2, vd"
    - VI_AMO({ return lhs | vs3; }, uint, e32);
  vamoorei64.v:
    opcode:
    - vamoorei64.v
    - 31..27=0x08
    - wd
    - vm
    - vs2
    - rs1
    - 14..12=0x7
    - vd
    - 6..0=0x2f
    opcode_group: v
    opcode_args: *29
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
    iss_code:
    - "//vamoore.v vd, (rs1), vs2, vd"
    - VI_AMO({ return lhs | vs3; }, uint, e64);
  vamoorei8.v:
    opcode:
    - vamoorei8.v
    - 31..27=0x08
    - wd
    - vm
    - vs2
    - rs1
    - 14..12=0x0
    - vd
    - 6..0=0x2f
    opcode_group: v
    opcode_args: *29
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
    iss_code:
    - "//vamoore.v vd, (rs1), vs2, vd"
    - VI_AMO({ return lhs | vs3; }, uint, e8);
  vamoswapei16.v:
    opcode:
    - vamoswapei16.v
    - 31..27=0x01
    - wd
    - vm
    - vs2
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x2f
    opcode_group: v
    opcode_args: *29
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
    iss_code:
    - "//vamoswape.v vd, (rs1), vs2, vd"
    - VI_AMO({ return vs3; }, uint, e16);
  vamoswapei32.v:
    opcode:
    - vamoswapei32.v
    - 31..27=0x01
    - wd
    - vm
    - vs2
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x2f
    opcode_group: v
    opcode_args: *29
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
    iss_code:
    - "//vamoswape.v vd, (rs1), vs2, vd"
    - VI_AMO({ return vs3; }, uint, e32);
  vamoswapei64.v:
    opcode:
    - vamoswapei64.v
    - 31..27=0x01
    - wd
    - vm
    - vs2
    - rs1
    - 14..12=0x7
    - vd
    - 6..0=0x2f
    opcode_group: v
    opcode_args: *29
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
    iss_code:
    - "//vamoswape.v vd, (rs1), vs2, vd"
    - VI_AMO({ return vs3; }, uint, e64);
  vamoswapei8.v:
    opcode:
    - vamoswapei8.v
    - 31..27=0x01
    - wd
    - vm
    - vs2
    - rs1
    - 14..12=0x0
    - vd
    - 6..0=0x2f
    opcode_group: v
    opcode_args: *29
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
    iss_code:
    - "//vamoswape.v vd, (rs1), vs2, vd"
    - VI_AMO({ return vs3; }, uint, e8);
  vamoxorei16.v:
    opcode:
    - vamoxorei16.v
    - 31..27=0x04
    - wd
    - vm
    - vs2
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x2f
    opcode_group: v
    opcode_args: *29
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
    iss_code:
    - "//vamoore.v vd, (rs1), vs2, vd"
    - VI_AMO({ return lhs ^ vs3; }, uint, e16);
  vamoxorei32.v:
    opcode:
    - vamoxorei32.v
    - 31..27=0x04
    - wd
    - vm
    - vs2
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x2f
    opcode_group: v
    opcode_args: *29
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
    iss_code:
    - "//vamoore.v vd, (rs1), vs2, vd"
    - VI_AMO({ return lhs ^ vs3; }, uint, e32);
  vamoxorei64.v:
    opcode:
    - vamoxorei64.v
    - 31..27=0x04
    - wd
    - vm
    - vs2
    - rs1
    - 14..12=0x7
    - vd
    - 6..0=0x2f
    opcode_group: v
    opcode_args: *29
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
    iss_code:
    - "//vamoore.v vd, (rs1), vs2, vd"
    - VI_AMO({ return lhs ^ vs3; }, uint, e64);
  vamoxorei8.v:
    opcode:
    - vamoxorei8.v
    - 31..27=0x04
    - wd
    - vm
    - vs2
    - rs1
    - 14..12=0x0
    - vd
    - 6..0=0x2f
    opcode_group: v
    opcode_args: *29
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
    iss_code:
    - "//vamoore.v vd, (rs1), vs2, vd"
    - VI_AMO({ return lhs ^ vs3; }, uint, e8);
  vand.vi:
    opcode:
    - vand.vi
    - 31..26=0x09
    - vm
    - vs2
    - simm5
    - 14..12=0x3
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *30
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_bitwise_logical_instructions"
    desc:
      v:
        "#_vector_bitwise_logical_instructions":
          text:
          - "# Bitwise logical operations. vand.vv vd, vs2, vs1, vm # Vector-vector
            vand.vx vd, vs2, rs1, vm # vector-scalar vand.vi vd, vs2, imm, vm # vector-immediate
            vor.vv vd, vs2, vs1, vm # Vector-vector vor.vx vd, vs2, rs1, vm # vector-scalar
            vor.vi vd, vs2, imm, vm # vector-immediate vxor.vv vd, vs2, vs1, vm #
            Vector-vector vxor.vx vd, vs2, rs1, vm # vector-scalar vxor.vi vd, vs2,
            imm, vm # vector-immediate"
        "#_vector_instruction_listing":
          text:
          - vand
  vand.vv:
    opcode:
    - vand.vv
    - 31..26=0x09
    - vm
    - vs2
    - vs1
    - 14..12=0x0
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_bitwise_logical_instructions"
    desc:
      v:
        "#_vector_bitwise_logical_instructions":
          text:
          - "# Bitwise logical operations. vand.vv vd, vs2, vs1, vm # Vector-vector
            vand.vx vd, vs2, rs1, vm # vector-scalar vand.vi vd, vs2, imm, vm # vector-immediate
            vor.vv vd, vs2, vs1, vm # Vector-vector vor.vx vd, vs2, rs1, vm # vector-scalar
            vor.vi vd, vs2, imm, vm # vector-immediate vxor.vv vd, vs2, vs1, vm #
            Vector-vector vxor.vx vd, vs2, rs1, vm # vector-scalar vxor.vi vd, vs2,
            imm, vm # vector-immediate"
        "#_vector_instruction_listing":
          text:
          - vand
  vand.vx:
    opcode:
    - vand.vx
    - 31..26=0x09
    - vm
    - vs2
    - rs1
    - 14..12=0x4
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_bitwise_logical_instructions"
    desc:
      v:
        "#_vector_bitwise_logical_instructions":
          text:
          - "# Bitwise logical operations. vand.vv vd, vs2, vs1, vm # Vector-vector
            vand.vx vd, vs2, rs1, vm # vector-scalar vand.vi vd, vs2, imm, vm # vector-immediate
            vor.vv vd, vs2, vs1, vm # Vector-vector vor.vx vd, vs2, rs1, vm # vector-scalar
            vor.vi vd, vs2, imm, vm # vector-immediate vxor.vv vd, vs2, vs1, vm #
            Vector-vector vxor.vx vd, vs2, rs1, vm # vector-scalar vxor.vi vd, vs2,
            imm, vm # vector-immediate"
        "#_vector_instruction_listing":
          text:
          - vand
  vasub.vv:
    opcode:
    - vasub.vv
    - 31..26=0x0b
    - vm
    - vs2
    - vs1
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vasub
  vasub.vx:
    opcode:
    - vasub.vx
    - 31..26=0x0b
    - vm
    - vs2
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vasub
  vasubu.vv:
    opcode:
    - vasubu.vv
    - 31..26=0x0a
    - vm
    - vs2
    - vs1
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vasubu
  vasubu.vx:
    opcode:
    - vasubu.vx
    - 31..26=0x0a
    - vm
    - vs2
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vasubu
  vcompress.vm:
    opcode:
    - vcompress.vm
    - 31..26=0x17
    - 25=1
    - vs2
    - vs1
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_compress_instruction"
    desc:
      v:
        "#_vector_compress_instruction":
          text:
          - vcompress is encoded as an unmasked instruction (vm=1). The equivalent
            masked instruction (vm=0) is reserved.
          - A trap on a vcompress instruction is always reported with a vstart of
            0. Executing a vcompress instruction with a non-zero vstart raises an
            illegal instruction exception.
          - 'vcompress.vm vd, vs2, vs1 # Compress into vd elements of vs2 where vs1
            is enabled'
          - Example use of vcompress instruction 8 7 6 5 4 3 2 1 0 Element number
            1 1 0 1 0 0 1 0 1 v0 8 7 6 5 4 3 2 1 0 v1 1 2 3 4 5 6 7 8 9 v2 vcompress.vm
            v2, v1, v0 1 2 3 4 8 7 5 2 0 v2
        "#_vector_instruction_listing":
          text:
          - vcompress
  vcpop.m:
    opcode:
    - vcpop.m
    - 31..26=0x10
    - vm
    - vs2
    - 19..15=0x10
    - 14..12=0x2
    - rd
    - 6..0=0x57
    opcode_group: v
    opcode_args: &32
    - vs2
    - rd
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_count_population_in_mask_vcpop_m"
    desc:
      v:
        "#_vector_count_population_in_mask_vcpop_m":
          text:
          - The vcpop.m instruction counts the number of mask elements of the active
            elements of the vector source mask register that have the value 1 and
            writes the result to a scalar x register.
          - The vcpop.m instruction writes x[rd] even if vl=0 (with the value 0, since
            no mask elements are active).
          - Traps on vcpop.m are always reported with a vstart of 0. The vcpop.m instruction
            will raise an illegal instruction exception if vstart is non-zero.
          - vcpop.m rd, vs2, vm
          - 'vcpop.m rd, vs2, v0.t # x[rd] = sum_i ( vs2.mask[i] && v0.mask[i] )'
    iss_code:
    - "// vmpopc rd, vs2, vm"
    - require(P.VU.vsew >= e8 && P.VU.vsew <= e64);
    - require_vector(true);
    - reg_t vl = P.VU.vl->read();
    - reg_t rs2_num = insn.rs2();
    - require(P.VU.vstart->read() == 0);
    - reg_t popcount = 0;
    - for (reg_t i=P.VU.vstart->read(); i<vl; ++i) {
    - const int midx = i / 32;
    - const int mpos = i % 32;
    - ''
    - bool vs2_lsb = ((P.VU.elt<uint32_t>(rs2_num, midx ) >> mpos) & 0x1) == 1;
    - if (insn.v_vm() == 1) {
    - popcount += vs2_lsb;
    - "} else {"
    - bool do_mask = (P.VU.elt<uint32_t>(0, midx) >> mpos) & 0x1;
    - popcount += (vs2_lsb && do_mask);
    - "}"
    - "}"
    - P.VU.vstart->write(0);
    - WRITE_RD(popcount);
  vdiv.vv:
    opcode:
    - vdiv.vv
    - 31..26=0x21
    - vm
    - vs2
    - vs1
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vdiv
  vdiv.vx:
    opcode:
    - vdiv.vx
    - 31..26=0x21
    - vm
    - vs2
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vdiv
  vdivu.vv:
    opcode:
    - vdivu.vv
    - 31..26=0x20
    - vm
    - vs2
    - vs1
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_integer_divide_instructions"
    desc:
      v:
        "#_vector_integer_divide_instructions":
          text:
          - "# Unsigned divide. vdivu.vv vd, vs2, vs1, vm # Vector-vector vdivu.vx
            vd, vs2, rs1, vm # vector-scalar # Signed divide vdiv.vv vd, vs2, vs1,
            vm # Vector-vector vdiv.vx vd, vs2, rs1, vm # vector-scalar # Unsigned
            remainder vremu.vv vd, vs2, vs1, vm # Vector-vector vremu.vx vd, vs2,
            rs1, vm # vector-scalar # Signed remainder vrem.vv vd, vs2, vs1, vm #
            Vector-vector vrem.vx vd, vs2, rs1, vm # vector-scalar"
        "#_vector_instruction_listing":
          text:
          - vdivu
  vdivu.vx:
    opcode:
    - vdivu.vx
    - 31..26=0x20
    - vm
    - vs2
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_integer_divide_instructions"
    desc:
      v:
        "#_vector_integer_divide_instructions":
          text:
          - "# Unsigned divide. vdivu.vv vd, vs2, vs1, vm # Vector-vector vdivu.vx
            vd, vs2, rs1, vm # vector-scalar # Signed divide vdiv.vv vd, vs2, vs1,
            vm # Vector-vector vdiv.vx vd, vs2, rs1, vm # vector-scalar # Unsigned
            remainder vremu.vv vd, vs2, vs1, vm # Vector-vector vremu.vx vd, vs2,
            rs1, vm # vector-scalar # Signed remainder vrem.vv vd, vs2, vs1, vm #
            Vector-vector vrem.vx vd, vs2, rs1, vm # vector-scalar"
        "#_vector_instruction_listing":
          text:
          - vdivu
  vfadd.vf:
    opcode:
    - vfadd.vf
    - 31..26=0x00
    - vm
    - vs2
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_single_width_floating_point_addsubtract_instructions"
    desc:
      v:
        "#_vector_single_width_floating_point_addsubtract_instructions":
          text:
          - "# Floating-point add vfadd.vv vd, vs2, vs1, vm # Vector-vector vfadd.vf
            vd, vs2, rs1, vm # vector-scalar # Floating-point subtract vfsub.vv vd,
            vs2, vs1, vm # Vector-vector vfsub.vf vd, vs2, rs1, vm # Vector-scalar
            vd[i] = vs2[i] - f[rs1] vfrsub.vf vd, vs2, rs1, vm # Scalar-vector vd[i]
            = f[rs1] - vs2[i]"
        "#_vector_instruction_listing":
          text:
          - vfadd
  vfadd.vv:
    opcode:
    - vfadd.vv
    - 31..26=0x00
    - vm
    - vs2
    - vs1
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_single_width_floating_point_addsubtract_instructions"
    desc:
      v:
        "#_vector_single_width_floating_point_addsubtract_instructions":
          text:
          - "# Floating-point add vfadd.vv vd, vs2, vs1, vm # Vector-vector vfadd.vf
            vd, vs2, rs1, vm # vector-scalar # Floating-point subtract vfsub.vv vd,
            vs2, vs1, vm # Vector-vector vfsub.vf vd, vs2, rs1, vm # Vector-scalar
            vd[i] = vs2[i] - f[rs1] vfrsub.vf vd, vs2, rs1, vm # Scalar-vector vd[i]
            = f[rs1] - vs2[i]"
        "#_vector_instruction_listing":
          text:
          - vfadd
  vfclass.v:
    opcode:
    - vfclass.v
    - 31..26=0x13
    - vm
    - vs2
    - 19..15=0x10
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: &31
    - vs2
    - vd
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_floating_point_classify_instruction"
    desc:
      v:
        "#_vector_floating_point_classify_instruction":
          text:
          - 'vfclass.v vd, vs2, vm # Vector-vector'
        "#_vector_instruction_listing":
          text:
          - vfclass.v
    iss_code:
    - "// vfclass.v vd, vs2, vm"
    - VI_VFP_V_LOOP
    - "({"
    - vd = f16(f16_classify(vs2));
    - "},"
    - "{"
    - vd = f32(f32_classify(vs2));
    - "},"
    - "{"
    - vd = f64(f64_classify(vs2));
    - "})"
  vfcvt.f.x.v:
    opcode:
    - vfcvt.f.x.v
    - 31..26=0x12
    - vm
    - vs2
    - 19..15=0x03
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *31
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_single_width_floating_pointinteger_type_convert_instructions"
    desc:
      v:
        "#_single_width_floating_pointinteger_type_convert_instructions":
          text:
          - 'vfcvt.xu.f.v vd, vs2, vm # Convert float to unsigned integer. vfcvt.x.f.v
            vd, vs2, vm # Convert float to signed integer. vfcvt.rtz.xu.f.v vd, vs2,
            vm # Convert float to unsigned integer, truncating. vfcvt.rtz.x.f.v vd,
            vs2, vm # Convert float to signed integer, truncating. vfcvt.f.xu.v vd,
            vs2, vm # Convert unsigned integer to float. vfcvt.f.x.v vd, vs2, vm #
            Convert signed integer to float.'
        "#_vector_instruction_listing":
          text:
          - vfcvt.xu.f.v
          - vfcvt.x.f.v
          - vfcvt.f.xu.v
          - vfcvt.f.x.v
          - vfcvt.rtz.xu.f.v
          - vfcvt.rtz.x.f.v
  vfcvt.f.xu.v:
    opcode:
    - vfcvt.f.xu.v
    - 31..26=0x12
    - vm
    - vs2
    - 19..15=0x02
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *31
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_single_width_floating_pointinteger_type_convert_instructions"
    desc:
      v:
        "#_single_width_floating_pointinteger_type_convert_instructions":
          text:
          - 'vfcvt.xu.f.v vd, vs2, vm # Convert float to unsigned integer. vfcvt.x.f.v
            vd, vs2, vm # Convert float to signed integer. vfcvt.rtz.xu.f.v vd, vs2,
            vm # Convert float to unsigned integer, truncating. vfcvt.rtz.x.f.v vd,
            vs2, vm # Convert float to signed integer, truncating. vfcvt.f.xu.v vd,
            vs2, vm # Convert unsigned integer to float. vfcvt.f.x.v vd, vs2, vm #
            Convert signed integer to float.'
        "#_vector_instruction_listing":
          text:
          - vfcvt.xu.f.v
          - vfcvt.x.f.v
          - vfcvt.f.xu.v
          - vfcvt.f.x.v
          - vfcvt.rtz.xu.f.v
          - vfcvt.rtz.x.f.v
  vfcvt.rtz.x.f.v:
    opcode:
    - vfcvt.rtz.x.f.v
    - 31..26=0x12
    - vm
    - vs2
    - 19..15=0x07
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *31
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_single_width_floating_pointinteger_type_convert_instructions"
    desc:
      v:
        "#_single_width_floating_pointinteger_type_convert_instructions":
          text:
          - 'vfcvt.xu.f.v vd, vs2, vm # Convert float to unsigned integer. vfcvt.x.f.v
            vd, vs2, vm # Convert float to signed integer. vfcvt.rtz.xu.f.v vd, vs2,
            vm # Convert float to unsigned integer, truncating. vfcvt.rtz.x.f.v vd,
            vs2, vm # Convert float to signed integer, truncating. vfcvt.f.xu.v vd,
            vs2, vm # Convert unsigned integer to float. vfcvt.f.x.v vd, vs2, vm #
            Convert signed integer to float.'
        "#_vector_instruction_listing":
          text:
          - vfcvt.xu.f.v
          - vfcvt.x.f.v
          - vfcvt.f.xu.v
          - vfcvt.f.x.v
          - vfcvt.rtz.xu.f.v
          - vfcvt.rtz.x.f.v
  vfcvt.rtz.xu.f.v:
    opcode:
    - vfcvt.rtz.xu.f.v
    - 31..26=0x12
    - vm
    - vs2
    - 19..15=0x06
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *31
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_single_width_floating_pointinteger_type_convert_instructions"
    desc:
      v:
        "#_single_width_floating_pointinteger_type_convert_instructions":
          text:
          - 'vfcvt.xu.f.v vd, vs2, vm # Convert float to unsigned integer. vfcvt.x.f.v
            vd, vs2, vm # Convert float to signed integer. vfcvt.rtz.xu.f.v vd, vs2,
            vm # Convert float to unsigned integer, truncating. vfcvt.rtz.x.f.v vd,
            vs2, vm # Convert float to signed integer, truncating. vfcvt.f.xu.v vd,
            vs2, vm # Convert unsigned integer to float. vfcvt.f.x.v vd, vs2, vm #
            Convert signed integer to float.'
        "#_vector_instruction_listing":
          text:
          - vfcvt.xu.f.v
          - vfcvt.x.f.v
          - vfcvt.f.xu.v
          - vfcvt.f.x.v
          - vfcvt.rtz.xu.f.v
          - vfcvt.rtz.x.f.v
  vfcvt.x.f.v:
    opcode:
    - vfcvt.x.f.v
    - 31..26=0x12
    - vm
    - vs2
    - 19..15=0x01
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *31
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_single_width_floating_pointinteger_type_convert_instructions"
    desc:
      v:
        "#_single_width_floating_pointinteger_type_convert_instructions":
          text:
          - 'vfcvt.xu.f.v vd, vs2, vm # Convert float to unsigned integer. vfcvt.x.f.v
            vd, vs2, vm # Convert float to signed integer. vfcvt.rtz.xu.f.v vd, vs2,
            vm # Convert float to unsigned integer, truncating. vfcvt.rtz.x.f.v vd,
            vs2, vm # Convert float to signed integer, truncating. vfcvt.f.xu.v vd,
            vs2, vm # Convert unsigned integer to float. vfcvt.f.x.v vd, vs2, vm #
            Convert signed integer to float.'
        "#_vector_instruction_listing":
          text:
          - vfcvt.xu.f.v
          - vfcvt.x.f.v
          - vfcvt.f.xu.v
          - vfcvt.f.x.v
          - vfcvt.rtz.xu.f.v
          - vfcvt.rtz.x.f.v
  vfcvt.xu.f.v:
    opcode:
    - vfcvt.xu.f.v
    - 31..26=0x12
    - vm
    - vs2
    - 19..15=0x00
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *31
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_single_width_floating_pointinteger_type_convert_instructions"
    desc:
      v:
        "#_single_width_floating_pointinteger_type_convert_instructions":
          text:
          - 'vfcvt.xu.f.v vd, vs2, vm # Convert float to unsigned integer. vfcvt.x.f.v
            vd, vs2, vm # Convert float to signed integer. vfcvt.rtz.xu.f.v vd, vs2,
            vm # Convert float to unsigned integer, truncating. vfcvt.rtz.x.f.v vd,
            vs2, vm # Convert float to signed integer, truncating. vfcvt.f.xu.v vd,
            vs2, vm # Convert unsigned integer to float. vfcvt.f.x.v vd, vs2, vm #
            Convert signed integer to float.'
        "#_vector_instruction_listing":
          text:
          - vfcvt.xu.f.v
          - vfcvt.x.f.v
          - vfcvt.f.xu.v
          - vfcvt.f.x.v
          - vfcvt.rtz.xu.f.v
          - vfcvt.rtz.x.f.v
  vfdiv.vf:
    opcode:
    - vfdiv.vf
    - 31..26=0x20
    - vm
    - vs2
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vfdiv
  vfdiv.vv:
    opcode:
    - vfdiv.vv
    - 31..26=0x20
    - vm
    - vs2
    - vs1
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vfdiv
  vfirst.m:
    opcode:
    - vfirst.m
    - 31..26=0x10
    - vm
    - vs2
    - 19..15=0x11
    - 14..12=0x2
    - rd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *32
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vfirst_find_first_set_mask_bit"
    desc:
      v:
        "#_vfirst_find_first_set_mask_bit":
          text:
          - The vfirst instruction finds the lowest-numbered active element of the
            source mask vector that has the value 1 and writes that element's index
            to a GPR. If no active element has the value 1, -1 is written to the GPR.
          - The vfirst.m instruction writes x[rd] even if vl=0 (with the value -1,
            since no mask elements are active).
          - Traps on vfirst are always reported with a vstart of 0. The vfirst instruction
            will raise an illegal instruction exception if vstart is non-zero.
          - vfirst.m rd, vs2, vm
        "#_vector_instruction_listing":
          text:
          - vfirst
    iss_code:
    - "// vmfirst rd, vs2"
    - require(P.VU.vsew >= e8 && P.VU.vsew <= e64);
    - require_vector(true);
    - reg_t vl = P.VU.vl->read();
    - reg_t rs2_num = insn.rs2();
    - require(P.VU.vstart->read() == 0);
    - reg_t pos = -1;
    - for (reg_t i=P.VU.vstart->read(); i < vl; ++i) {
    - VI_LOOP_ELEMENT_SKIP()
    - ''
    - bool vs2_lsb = ((P.VU.elt<uint64_t>(rs2_num, midx ) >> mpos) & 0x1) == 1;
    - if (vs2_lsb) {
    - pos = i;
    - break;
    - "}"
    - "}"
    - P.VU.vstart->write(0);
    - WRITE_RD(pos);
  vfmacc.vf:
    opcode:
    - vfmacc.vf
    - 31..26=0x2c
    - vm
    - vs2
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_single_width_floating_point_fused_multiply_add_instructions"
    desc:
      v:
        "#_vector_single_width_floating_point_fused_multiply_add_instructions":
          text:
          - "# FP multiply-accumulate, overwrites addend vfmacc.vv vd, vs1, vs2, vm
            # vd[i] = +(vs1[i] * vs2[i]) + vd[i] vfmacc.vf vd, rs1, vs2, vm # vd[i]
            = +(f[rs1] * vs2[i]) + vd[i] # FP negate-(multiply-accumulate), overwrites
            subtrahend vfnmacc.vv vd, vs1, vs2, vm # vd[i] = -(vs1[i] * vs2[i]) -
            vd[i] vfnmacc.vf vd, rs1, vs2, vm # vd[i] = -(f[rs1] * vs2[i]) - vd[i]
            # FP multiply-subtract-accumulator, overwrites subtrahend vfmsac.vv vd,
            vs1, vs2, vm # vd[i] = +(vs1[i] * vs2[i]) - vd[i] vfmsac.vf vd, rs1, vs2,
            vm # vd[i] = +(f[rs1] * vs2[i]) - vd[i] # FP negate-(multiply-subtract-accumulator),
            overwrites minuend vfnmsac.vv vd, vs1, vs2, vm # vd[i] = -(vs1[i] * vs2[i])
            + vd[i] vfnmsac.vf vd, rs1, vs2, vm # vd[i] = -(f[rs1] * vs2[i]) + vd[i]
            # FP multiply-add, overwrites multiplicand vfmadd.vv vd, vs1, vs2, vm
            # vd[i] = +(vs1[i] * vd[i]) + vs2[i] vfmadd.vf vd, rs1, vs2, vm # vd[i]
            = +(f[rs1] * vd[i]) + vs2[i] # FP negate-(multiply-add), overwrites multiplicand
            vfnmadd.vv vd, vs1, vs2, vm # vd[i] = -(vs1[i] * vd[i]) - vs2[i] vfnmadd.vf
            vd, rs1, vs2, vm # vd[i] = -(f[rs1] * vd[i]) - vs2[i] # FP multiply-sub,
            overwrites multiplicand vfmsub.vv vd, vs1, vs2, vm # vd[i] = +(vs1[i]
            * vd[i]) - vs2[i] vfmsub.vf vd, rs1, vs2, vm # vd[i] = +(f[rs1] * vd[i])
            - vs2[i] # FP negate-(multiply-sub), overwrites multiplicand vfnmsub.vv
            vd, vs1, vs2, vm # vd[i] = -(vs1[i] * vd[i]) + vs2[i] vfnmsub.vf vd, rs1,
            vs2, vm # vd[i] = -(f[rs1] * vd[i]) + vs2[i]"
        "#_vector_instruction_listing":
          text:
          - vfmacc
  vfmacc.vv:
    opcode:
    - vfmacc.vv
    - 31..26=0x2c
    - vm
    - vs2
    - vs1
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_single_width_floating_point_fused_multiply_add_instructions"
    desc:
      v:
        "#_vector_single_width_floating_point_fused_multiply_add_instructions":
          text:
          - "# FP multiply-accumulate, overwrites addend vfmacc.vv vd, vs1, vs2, vm
            # vd[i] = +(vs1[i] * vs2[i]) + vd[i] vfmacc.vf vd, rs1, vs2, vm # vd[i]
            = +(f[rs1] * vs2[i]) + vd[i] # FP negate-(multiply-accumulate), overwrites
            subtrahend vfnmacc.vv vd, vs1, vs2, vm # vd[i] = -(vs1[i] * vs2[i]) -
            vd[i] vfnmacc.vf vd, rs1, vs2, vm # vd[i] = -(f[rs1] * vs2[i]) - vd[i]
            # FP multiply-subtract-accumulator, overwrites subtrahend vfmsac.vv vd,
            vs1, vs2, vm # vd[i] = +(vs1[i] * vs2[i]) - vd[i] vfmsac.vf vd, rs1, vs2,
            vm # vd[i] = +(f[rs1] * vs2[i]) - vd[i] # FP negate-(multiply-subtract-accumulator),
            overwrites minuend vfnmsac.vv vd, vs1, vs2, vm # vd[i] = -(vs1[i] * vs2[i])
            + vd[i] vfnmsac.vf vd, rs1, vs2, vm # vd[i] = -(f[rs1] * vs2[i]) + vd[i]
            # FP multiply-add, overwrites multiplicand vfmadd.vv vd, vs1, vs2, vm
            # vd[i] = +(vs1[i] * vd[i]) + vs2[i] vfmadd.vf vd, rs1, vs2, vm # vd[i]
            = +(f[rs1] * vd[i]) + vs2[i] # FP negate-(multiply-add), overwrites multiplicand
            vfnmadd.vv vd, vs1, vs2, vm # vd[i] = -(vs1[i] * vd[i]) - vs2[i] vfnmadd.vf
            vd, rs1, vs2, vm # vd[i] = -(f[rs1] * vd[i]) - vs2[i] # FP multiply-sub,
            overwrites multiplicand vfmsub.vv vd, vs1, vs2, vm # vd[i] = +(vs1[i]
            * vd[i]) - vs2[i] vfmsub.vf vd, rs1, vs2, vm # vd[i] = +(f[rs1] * vd[i])
            - vs2[i] # FP negate-(multiply-sub), overwrites multiplicand vfnmsub.vv
            vd, vs1, vs2, vm # vd[i] = -(vs1[i] * vd[i]) + vs2[i] vfnmsub.vf vd, rs1,
            vs2, vm # vd[i] = -(f[rs1] * vd[i]) + vs2[i]"
        "#_vector_instruction_listing":
          text:
          - vfmacc
  vfmadd.vf:
    opcode:
    - vfmadd.vf
    - 31..26=0x28
    - vm
    - vs2
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vfmadd
  vfmadd.vv:
    opcode:
    - vfmadd.vv
    - 31..26=0x28
    - vm
    - vs2
    - vs1
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vfmadd
  vfmax.vf:
    opcode:
    - vfmax.vf
    - 31..26=0x06
    - vm
    - vs2
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vfmax
  vfmax.vv:
    opcode:
    - vfmax.vv
    - 31..26=0x06
    - vm
    - vs2
    - vs1
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vfmax
  vfmerge.vfm:
    opcode:
    - vfmerge.vfm
    - 31..26=0x17
    - 25=0
    - vs2
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_floating_point_merge_instruction"
    desc:
      v:
        "#_vector_floating_point_merge_instruction":
          text:
          - The vfmerge.vfm instruction is encoded as a masked instruction (vm=0).
            At elements where the mask value is zero, the first vector operand is
            copied to the destination element, otherwise a scalar floating-point register
            value is copied to the destination element.
          - 'vfmerge.vfm vd, vs2, rs1, v0 # vd[i] = v0.mask[i] ? f[rs1] : vs2[i]'
        "#_vector_instruction_listing":
          text:
          - vfmerge/vfmv
  vfmin.vf:
    opcode:
    - vfmin.vf
    - 31..26=0x04
    - vm
    - vs2
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_floating_point_minmax_instructions"
    desc:
      v:
        "#_vector_floating_point_minmax_instructions":
          text:
          - The vector floating-point vfmin and vfmax instructions have the same behavior
            as the corresponding scalar floating-point instructions in version 2.2
            of the RISC-V F/D/Q extension.
          - "# Floating-point minimum vfmin.vv vd, vs2, vs1, vm # Vector-vector vfmin.vf
            vd, vs2, rs1, vm # vector-scalar # Floating-point maximum vfmax.vv vd,
            vs2, vs1, vm # Vector-vector vfmax.vf vd, vs2, rs1, vm # vector-scalar"
        "#_vector_instruction_listing":
          text:
          - vfmin
  vfmin.vv:
    opcode:
    - vfmin.vv
    - 31..26=0x04
    - vm
    - vs2
    - vs1
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_floating_point_minmax_instructions"
    desc:
      v:
        "#_vector_floating_point_minmax_instructions":
          text:
          - The vector floating-point vfmin and vfmax instructions have the same behavior
            as the corresponding scalar floating-point instructions in version 2.2
            of the RISC-V F/D/Q extension.
          - "# Floating-point minimum vfmin.vv vd, vs2, vs1, vm # Vector-vector vfmin.vf
            vd, vs2, rs1, vm # vector-scalar # Floating-point maximum vfmax.vv vd,
            vs2, vs1, vm # Vector-vector vfmax.vf vd, vs2, rs1, vm # vector-scalar"
        "#_vector_instruction_listing":
          text:
          - vfmin
  vfmsac.vf:
    opcode:
    - vfmsac.vf
    - 31..26=0x2e
    - vm
    - vs2
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vfmsac
  vfmsac.vv:
    opcode:
    - vfmsac.vv
    - 31..26=0x2e
    - vm
    - vs2
    - vs1
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vfmsac
  vfmsub.vf:
    opcode:
    - vfmsub.vf
    - 31..26=0x2a
    - vm
    - vs2
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vfmsub
  vfmsub.vv:
    opcode:
    - vfmsub.vv
    - 31..26=0x2a
    - vm
    - vs2
    - vs1
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vfmsub
  vfmul.vf:
    opcode:
    - vfmul.vf
    - 31..26=0x24
    - vm
    - vs2
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_single_width_floating_point_multiplydivide_instructions"
    desc:
      v:
        "#_vector_single_width_floating_point_multiplydivide_instructions":
          text:
          - "# Floating-point multiply vfmul.vv vd, vs2, vs1, vm # Vector-vector vfmul.vf
            vd, vs2, rs1, vm # vector-scalar # Floating-point divide vfdiv.vv vd,
            vs2, vs1, vm # Vector-vector vfdiv.vf vd, vs2, rs1, vm # vector-scalar
            # Reverse floating-point divide vector = scalar / vector vfrdiv.vf vd,
            vs2, rs1, vm # scalar-vector, vd[i] = f[rs1]/vs2[i]"
        "#_vector_instruction_listing":
          text:
          - vfmul
  vfmul.vv:
    opcode:
    - vfmul.vv
    - 31..26=0x24
    - vm
    - vs2
    - vs1
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_single_width_floating_point_multiplydivide_instructions"
    desc:
      v:
        "#_vector_single_width_floating_point_multiplydivide_instructions":
          text:
          - "# Floating-point multiply vfmul.vv vd, vs2, vs1, vm # Vector-vector vfmul.vf
            vd, vs2, rs1, vm # vector-scalar # Floating-point divide vfdiv.vv vd,
            vs2, vs1, vm # Vector-vector vfdiv.vf vd, vs2, rs1, vm # vector-scalar
            # Reverse floating-point divide vector = scalar / vector vfrdiv.vf vd,
            vs2, rs1, vm # scalar-vector, vd[i] = f[rs1]/vs2[i]"
        "#_vector_instruction_listing":
          text:
          - vfmul
  vfmv.f.s:
    opcode:
    - vfmv.f.s
    - 31..26=0x10
    - 25=1
    - vs2
    - 19..15=0
    - 14..12=0x1
    - rd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *32
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_floating_point_move_instruction"
    desc:
      v:
        "#_vector_floating_point_move_instruction":
          text:
          - 'vfmv.v.f vd, rs1 # vd[i] = f[rs1]'
        "#_floating_point_scalar_move_instructions":
          text:
          - The vfmv.f.s instruction copies a single SEW-wide element from index 0
            of the source vector register to a destination scalar floating-point register.
          - The vfmv.s.f instruction copies the scalar floating-point register to
            element 0 of the destination vector register. The other elements in the
            destination vector register ( 0 < index < VLEN/SEW) are treated as tail
            elements using the current tail agnostic/undisturbed policy. If vstart
            >= vl, no operation is performed and the destination register is not updated.
          - The encodings corresponding to the masked versions (vm=0) of vfmv.f.s
            and vfmv.s.f are reserved.
          - 'vfmv.f.s rd, vs2 # f[rd] = vs2[0] (rs1=0) vfmv.s.f vd, rs1 # vd[0] =
            f[rs1] (vs2=0)'
        "#_vector_instruction_listing":
          text:
          - vfmv.s.f
          - vfmv.f.s
  vfmv.s.f:
    opcode:
    - vfmv.s.f
    - 31..26=0x10
    - 25=1
    - 24..20=0
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: &33
    - rs1
    - vd
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_floating_point_move_instruction"
    desc:
      v:
        "#_vector_floating_point_move_instruction":
          text:
          - 'vfmv.v.f vd, rs1 # vd[i] = f[rs1]'
        "#_floating_point_scalar_move_instructions":
          text:
          - The vfmv.f.s instruction copies a single SEW-wide element from index 0
            of the source vector register to a destination scalar floating-point register.
          - The vfmv.s.f instruction copies the scalar floating-point register to
            element 0 of the destination vector register. The other elements in the
            destination vector register ( 0 < index < VLEN/SEW) are treated as tail
            elements using the current tail agnostic/undisturbed policy. If vstart
            >= vl, no operation is performed and the destination register is not updated.
          - The encodings corresponding to the masked versions (vm=0) of vfmv.f.s
            and vfmv.s.f are reserved.
          - 'vfmv.f.s rd, vs2 # f[rd] = vs2[0] (rs1=0) vfmv.s.f vd, rs1 # vd[0] =
            f[rs1] (vs2=0)'
        "#_vector_instruction_listing":
          text:
          - vfmv.s.f
          - vfmv.f.s
  vfmv.v.f:
    opcode:
    - vfmv.v.f
    - 31..26=0x17
    - 25=1
    - 24..20=0
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *33
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_floating_point_move_instruction"
    desc:
      v:
        "#_vector_floating_point_move_instruction":
          text:
          - 'vfmv.v.f vd, rs1 # vd[i] = f[rs1]'
        "#_floating_point_scalar_move_instructions":
          text:
          - The vfmv.f.s instruction copies a single SEW-wide element from index 0
            of the source vector register to a destination scalar floating-point register.
          - The vfmv.s.f instruction copies the scalar floating-point register to
            element 0 of the destination vector register. The other elements in the
            destination vector register ( 0 < index < VLEN/SEW) are treated as tail
            elements using the current tail agnostic/undisturbed policy. If vstart
            >= vl, no operation is performed and the destination register is not updated.
          - The encodings corresponding to the masked versions (vm=0) of vfmv.f.s
            and vfmv.s.f are reserved.
          - 'vfmv.f.s rd, vs2 # f[rd] = vs2[0] (rs1=0) vfmv.s.f vd, rs1 # vd[0] =
            f[rs1] (vs2=0)'
        "#_vector_instruction_listing":
          text:
          - vfmv.s.f
          - vfmv.f.s
  vfncvt.f.f.w:
    opcode:
    - vfncvt.f.f.w
    - 31..26=0x12
    - vm
    - vs2
    - 19..15=0x14
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *31
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_narrowing_floating_pointinteger_type_convert_instructions"
    desc:
      v:
        "#_narrowing_floating_pointinteger_type_convert_instructions":
          text:
          - 'vfncvt.xu.f.w vd, vs2, vm # Convert double-width float to unsigned integer.
            vfncvt.x.f.w vd, vs2, vm # Convert double-width float to signed integer.
            vfncvt.rtz.xu.f.w vd, vs2, vm # Convert double-width float to unsigned
            integer, truncating. vfncvt.rtz.x.f.w vd, vs2, vm # Convert double-width
            float to signed integer, truncating. vfncvt.f.xu.w vd, vs2, vm # Convert
            double-width unsigned integer to float. vfncvt.f.x.w vd, vs2, vm # Convert
            double-width signed integer to float. vfncvt.f.f.w vd, vs2, vm # Convert
            double-width float to single-width float. vfncvt.rod.f.f.w vd, vs2, vm
            # Convert double-width float to single-width float, # rounding towards
            odd.'
        "#_vector_instruction_listing":
          text:
          - vfncvt.xu.f.w
          - vfncvt.x.f.w
          - vfncvt.f.xu.w
          - vfncvt.f.x.w
          - vfncvt.f.f.w
          - vfncvt.rod.f.f.w
          - vfncvt.rtz.xu.f.w
          - vfncvt.rtz.x.f.w
  vfncvt.f.x.w:
    opcode:
    - vfncvt.f.x.w
    - 31..26=0x12
    - vm
    - vs2
    - 19..15=0x13
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *31
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_narrowing_floating_pointinteger_type_convert_instructions"
    desc:
      v:
        "#_narrowing_floating_pointinteger_type_convert_instructions":
          text:
          - 'vfncvt.xu.f.w vd, vs2, vm # Convert double-width float to unsigned integer.
            vfncvt.x.f.w vd, vs2, vm # Convert double-width float to signed integer.
            vfncvt.rtz.xu.f.w vd, vs2, vm # Convert double-width float to unsigned
            integer, truncating. vfncvt.rtz.x.f.w vd, vs2, vm # Convert double-width
            float to signed integer, truncating. vfncvt.f.xu.w vd, vs2, vm # Convert
            double-width unsigned integer to float. vfncvt.f.x.w vd, vs2, vm # Convert
            double-width signed integer to float. vfncvt.f.f.w vd, vs2, vm # Convert
            double-width float to single-width float. vfncvt.rod.f.f.w vd, vs2, vm
            # Convert double-width float to single-width float, # rounding towards
            odd.'
        "#_vector_instruction_listing":
          text:
          - vfncvt.xu.f.w
          - vfncvt.x.f.w
          - vfncvt.f.xu.w
          - vfncvt.f.x.w
          - vfncvt.f.f.w
          - vfncvt.rod.f.f.w
          - vfncvt.rtz.xu.f.w
          - vfncvt.rtz.x.f.w
  vfncvt.f.xu.w:
    opcode:
    - vfncvt.f.xu.w
    - 31..26=0x12
    - vm
    - vs2
    - 19..15=0x12
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *31
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_narrowing_floating_pointinteger_type_convert_instructions"
    desc:
      v:
        "#_narrowing_floating_pointinteger_type_convert_instructions":
          text:
          - 'vfncvt.xu.f.w vd, vs2, vm # Convert double-width float to unsigned integer.
            vfncvt.x.f.w vd, vs2, vm # Convert double-width float to signed integer.
            vfncvt.rtz.xu.f.w vd, vs2, vm # Convert double-width float to unsigned
            integer, truncating. vfncvt.rtz.x.f.w vd, vs2, vm # Convert double-width
            float to signed integer, truncating. vfncvt.f.xu.w vd, vs2, vm # Convert
            double-width unsigned integer to float. vfncvt.f.x.w vd, vs2, vm # Convert
            double-width signed integer to float. vfncvt.f.f.w vd, vs2, vm # Convert
            double-width float to single-width float. vfncvt.rod.f.f.w vd, vs2, vm
            # Convert double-width float to single-width float, # rounding towards
            odd.'
        "#_vector_instruction_listing":
          text:
          - vfncvt.xu.f.w
          - vfncvt.x.f.w
          - vfncvt.f.xu.w
          - vfncvt.f.x.w
          - vfncvt.f.f.w
          - vfncvt.rod.f.f.w
          - vfncvt.rtz.xu.f.w
          - vfncvt.rtz.x.f.w
  vfncvt.rod.f.f.w:
    opcode:
    - vfncvt.rod.f.f.w
    - 31..26=0x12
    - vm
    - vs2
    - 19..15=0x15
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *31
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_narrowing_floating_pointinteger_type_convert_instructions"
    desc:
      v:
        "#_narrowing_floating_pointinteger_type_convert_instructions":
          text:
          - 'vfncvt.xu.f.w vd, vs2, vm # Convert double-width float to unsigned integer.
            vfncvt.x.f.w vd, vs2, vm # Convert double-width float to signed integer.
            vfncvt.rtz.xu.f.w vd, vs2, vm # Convert double-width float to unsigned
            integer, truncating. vfncvt.rtz.x.f.w vd, vs2, vm # Convert double-width
            float to signed integer, truncating. vfncvt.f.xu.w vd, vs2, vm # Convert
            double-width unsigned integer to float. vfncvt.f.x.w vd, vs2, vm # Convert
            double-width signed integer to float. vfncvt.f.f.w vd, vs2, vm # Convert
            double-width float to single-width float. vfncvt.rod.f.f.w vd, vs2, vm
            # Convert double-width float to single-width float, # rounding towards
            odd.'
        "#_vector_instruction_listing":
          text:
          - vfncvt.xu.f.w
          - vfncvt.x.f.w
          - vfncvt.f.xu.w
          - vfncvt.f.x.w
          - vfncvt.f.f.w
          - vfncvt.rod.f.f.w
          - vfncvt.rtz.xu.f.w
          - vfncvt.rtz.x.f.w
  vfncvt.rtz.x.f.w:
    opcode:
    - vfncvt.rtz.x.f.w
    - 31..26=0x12
    - vm
    - vs2
    - 19..15=0x17
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *31
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_narrowing_floating_pointinteger_type_convert_instructions"
    desc:
      v:
        "#_narrowing_floating_pointinteger_type_convert_instructions":
          text:
          - 'vfncvt.xu.f.w vd, vs2, vm # Convert double-width float to unsigned integer.
            vfncvt.x.f.w vd, vs2, vm # Convert double-width float to signed integer.
            vfncvt.rtz.xu.f.w vd, vs2, vm # Convert double-width float to unsigned
            integer, truncating. vfncvt.rtz.x.f.w vd, vs2, vm # Convert double-width
            float to signed integer, truncating. vfncvt.f.xu.w vd, vs2, vm # Convert
            double-width unsigned integer to float. vfncvt.f.x.w vd, vs2, vm # Convert
            double-width signed integer to float. vfncvt.f.f.w vd, vs2, vm # Convert
            double-width float to single-width float. vfncvt.rod.f.f.w vd, vs2, vm
            # Convert double-width float to single-width float, # rounding towards
            odd.'
        "#_vector_instruction_listing":
          text:
          - vfncvt.xu.f.w
          - vfncvt.x.f.w
          - vfncvt.f.xu.w
          - vfncvt.f.x.w
          - vfncvt.f.f.w
          - vfncvt.rod.f.f.w
          - vfncvt.rtz.xu.f.w
          - vfncvt.rtz.x.f.w
  vfncvt.rtz.xu.f.w:
    opcode:
    - vfncvt.rtz.xu.f.w
    - 31..26=0x12
    - vm
    - vs2
    - 19..15=0x16
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *31
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_narrowing_floating_pointinteger_type_convert_instructions"
    desc:
      v:
        "#_narrowing_floating_pointinteger_type_convert_instructions":
          text:
          - 'vfncvt.xu.f.w vd, vs2, vm # Convert double-width float to unsigned integer.
            vfncvt.x.f.w vd, vs2, vm # Convert double-width float to signed integer.
            vfncvt.rtz.xu.f.w vd, vs2, vm # Convert double-width float to unsigned
            integer, truncating. vfncvt.rtz.x.f.w vd, vs2, vm # Convert double-width
            float to signed integer, truncating. vfncvt.f.xu.w vd, vs2, vm # Convert
            double-width unsigned integer to float. vfncvt.f.x.w vd, vs2, vm # Convert
            double-width signed integer to float. vfncvt.f.f.w vd, vs2, vm # Convert
            double-width float to single-width float. vfncvt.rod.f.f.w vd, vs2, vm
            # Convert double-width float to single-width float, # rounding towards
            odd.'
        "#_vector_instruction_listing":
          text:
          - vfncvt.xu.f.w
          - vfncvt.x.f.w
          - vfncvt.f.xu.w
          - vfncvt.f.x.w
          - vfncvt.f.f.w
          - vfncvt.rod.f.f.w
          - vfncvt.rtz.xu.f.w
          - vfncvt.rtz.x.f.w
  vfncvt.x.f.w:
    opcode:
    - vfncvt.x.f.w
    - 31..26=0x12
    - vm
    - vs2
    - 19..15=0x11
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *31
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_narrowing_floating_pointinteger_type_convert_instructions"
    desc:
      v:
        "#_narrowing_floating_pointinteger_type_convert_instructions":
          text:
          - 'vfncvt.xu.f.w vd, vs2, vm # Convert double-width float to unsigned integer.
            vfncvt.x.f.w vd, vs2, vm # Convert double-width float to signed integer.
            vfncvt.rtz.xu.f.w vd, vs2, vm # Convert double-width float to unsigned
            integer, truncating. vfncvt.rtz.x.f.w vd, vs2, vm # Convert double-width
            float to signed integer, truncating. vfncvt.f.xu.w vd, vs2, vm # Convert
            double-width unsigned integer to float. vfncvt.f.x.w vd, vs2, vm # Convert
            double-width signed integer to float. vfncvt.f.f.w vd, vs2, vm # Convert
            double-width float to single-width float. vfncvt.rod.f.f.w vd, vs2, vm
            # Convert double-width float to single-width float, # rounding towards
            odd.'
        "#_vector_instruction_listing":
          text:
          - vfncvt.xu.f.w
          - vfncvt.x.f.w
          - vfncvt.f.xu.w
          - vfncvt.f.x.w
          - vfncvt.f.f.w
          - vfncvt.rod.f.f.w
          - vfncvt.rtz.xu.f.w
          - vfncvt.rtz.x.f.w
  vfncvt.xu.f.w:
    opcode:
    - vfncvt.xu.f.w
    - 31..26=0x12
    - vm
    - vs2
    - 19..15=0x10
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *31
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_narrowing_floating_pointinteger_type_convert_instructions"
    desc:
      v:
        "#_narrowing_floating_pointinteger_type_convert_instructions":
          text:
          - 'vfncvt.xu.f.w vd, vs2, vm # Convert double-width float to unsigned integer.
            vfncvt.x.f.w vd, vs2, vm # Convert double-width float to signed integer.
            vfncvt.rtz.xu.f.w vd, vs2, vm # Convert double-width float to unsigned
            integer, truncating. vfncvt.rtz.x.f.w vd, vs2, vm # Convert double-width
            float to signed integer, truncating. vfncvt.f.xu.w vd, vs2, vm # Convert
            double-width unsigned integer to float. vfncvt.f.x.w vd, vs2, vm # Convert
            double-width signed integer to float. vfncvt.f.f.w vd, vs2, vm # Convert
            double-width float to single-width float. vfncvt.rod.f.f.w vd, vs2, vm
            # Convert double-width float to single-width float, # rounding towards
            odd.'
        "#_vector_instruction_listing":
          text:
          - vfncvt.xu.f.w
          - vfncvt.x.f.w
          - vfncvt.f.xu.w
          - vfncvt.f.x.w
          - vfncvt.f.f.w
          - vfncvt.rod.f.f.w
          - vfncvt.rtz.xu.f.w
          - vfncvt.rtz.x.f.w
  vfnmacc.vf:
    opcode:
    - vfnmacc.vf
    - 31..26=0x2d
    - vm
    - vs2
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vfnmacc
  vfnmacc.vv:
    opcode:
    - vfnmacc.vv
    - 31..26=0x2d
    - vm
    - vs2
    - vs1
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vfnmacc
  vfnmadd.vf:
    opcode:
    - vfnmadd.vf
    - 31..26=0x29
    - vm
    - vs2
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vfnmadd
  vfnmadd.vv:
    opcode:
    - vfnmadd.vv
    - 31..26=0x29
    - vm
    - vs2
    - vs1
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vfnmadd
  vfnmsac.vf:
    opcode:
    - vfnmsac.vf
    - 31..26=0x2f
    - vm
    - vs2
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vfnmsac
  vfnmsac.vv:
    opcode:
    - vfnmsac.vv
    - 31..26=0x2f
    - vm
    - vs2
    - vs1
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vfnmsac
  vfnmsub.vf:
    opcode:
    - vfnmsub.vf
    - 31..26=0x2b
    - vm
    - vs2
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vfnmsub
  vfnmsub.vv:
    opcode:
    - vfnmsub.vv
    - 31..26=0x2b
    - vm
    - vs2
    - vs1
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vfnmsub
  vfrdiv.vf:
    opcode:
    - vfrdiv.vf
    - 31..26=0x21
    - vm
    - vs2
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vfrdiv
  vfrec7.v:
    opcode:
    - vfrec7.v
    - 31..26=0x13
    - vm
    - vs2
    - 19..15=0x05
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *31
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_floating_point_reciprocal_estimate_instruction"
    desc:
      v:
        "#_vector_floating_point_reciprocal_estimate_instruction":
          text:
          - Table 17. vfrec7.v common-case lookup table contents
          - "# Floating-point reciprocal estimate to 7 bits. vfrec7.v vd, vs2, vm"
        "#_vector_instruction_listing":
          text:
          - vfrec7.v
        "#_division_approximation_example":
          text:
          - "# v1 = v1 / v2 to almost 23 bits of precision. vfrec7.v v3, v2 # Estimate
            1/v2 li t0, 0x40000000 vmv.v.x v4, t0 # Splat 2.0 vfnmsac.vv v4, v2, v3
            # 2.0 - v2 * est(1/v2) vfmul.vv v3, v3, v4 # Better estimate of 1/v2 vmv.v.x
            v4, t0 # Splat 2.0 vfnmsac.vv v4, v2, v3 # 2.0 - v2 * est(1/v2) vfmul.vv
            v3, v3, v4 # Better estimate of 1/v2 vfmul.vv v1, v1, v3 # Estimate of
            v1/v2"
    iss_code:
    - "// vfclass.v vd, vs2, vm"
    - VI_VFP_V_LOOP
    - "({"
    - vd = f16_recip7(vs2);
    - "},"
    - "{"
    - vd = f32_recip7(vs2);
    - "},"
    - "{"
    - vd = f64_recip7(vs2);
    - "})"
  vfredmax.vs:
    opcode:
    - vfredmax.vs
    - 31..26=0x07
    - vm
    - vs2
    - vs1
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vfredmax
  vfredmin.vs:
    opcode:
    - vfredmin.vs
    - 31..26=0x05
    - vm
    - vs2
    - vs1
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vfredmin
  vfredosum.vs:
    opcode:
    - vfredosum.vs
    - 31..26=0x03
    - vm
    - vs2
    - vs1
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#sec-vector-float-reduce"
    desc:
      v:
        "#sec-vector-float-reduce":
          text:
          - "# Simple reductions. vfredosum.vs vd, vs2, vs1, vm # Ordered sum vfredusum.vs
            vd, vs2, vs1, vm # Unordered sum vfredmax.vs vd, vs2, vs1, vm # Maximum
            value vfredmin.vs vd, vs2, vs1, vm # Minimum value"
        "#_vector_ordered_single_width_floating_point_sum_reduction":
          text:
          - 'The vfredosum instruction must sum the floating-point values in element
            order, starting with the scalar in vs1[0]--that is, it performs the computation:'
        "#_vector_instruction_listing":
          text:
          - vfredosum
  vfredsum.vs:
    opcode:
    - vfredsum.vs
    - 31..26=0x01
    - vm
    - vs2
    - vs1
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: v_aliases
    opcode_args: *28
    pseudo_src: rv_v
    pseudo_op: vfredusum.vs
  vfredusum.vs:
    opcode:
    - vfredusum.vs
    - 31..26=0x01
    - vm
    - vs2
    - vs1
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_unordered_single_width_floating_point_sum_reduction"
    desc:
      v:
        "#_vector_unordered_single_width_floating_point_sum_reduction":
          text:
          - The unordered sum reduction instruction, vfredusum, provides an implementation
            more freedom in performing the reduction.
        "#_vector_instruction_listing":
          text:
          - vfredusum
  vfrsqrt7.v:
    opcode:
    - vfrsqrt7.v
    - 31..26=0x13
    - vm
    - vs2
    - 19..15=0x04
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *31
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_floating_point_reciprocal_square_root_estimate_instruction"
    desc:
      v:
        "#_vector_floating_point_reciprocal_square_root_estimate_instruction":
          text:
          - Table 16. vfrsqrt7.v common-case lookup table contents
          - "# Floating-point reciprocal square-root estimate to 7 bits. vfrsqrt7.v
            vd, vs2, vm"
        "#_vector_instruction_listing":
          text:
          - vfrsqrt7.v
    iss_code:
    - "// vfclass.v vd, vs2, vm"
    - VI_VFP_V_LOOP
    - "({"
    - vd = f16_rsqrte7(vs2);
    - "},"
    - "{"
    - vd = f32_rsqrte7(vs2);
    - "},"
    - "{"
    - vd = f64_rsqrte7(vs2);
    - "})"
  vfrsub.vf:
    opcode:
    - vfrsub.vf
    - 31..26=0x27
    - vm
    - vs2
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vfrsub
  vfsgnj.vf:
    opcode:
    - vfsgnj.vf
    - 31..26=0x08
    - vm
    - vs2
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_floating_point_sign_injection_instructions"
    desc:
      v:
        "#_vector_floating_point_sign_injection_instructions":
          text:
          - 'vfsgnj.vv vd, vs2, vs1, vm # Vector-vector vfsgnj.vf vd, vs2, rs1, vm
            # vector-scalar vfsgnjn.vv vd, vs2, vs1, vm # Vector-vector vfsgnjn.vf
            vd, vs2, rs1, vm # vector-scalar vfsgnjx.vv vd, vs2, vs1, vm # Vector-vector
            vfsgnjx.vf vd, vs2, rs1, vm # vector-scalar'
        "#_vector_instruction_listing":
          text:
          - vfsgnj
  vfsgnj.vv:
    opcode:
    - vfsgnj.vv
    - 31..26=0x08
    - vm
    - vs2
    - vs1
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_floating_point_sign_injection_instructions"
    desc:
      v:
        "#_vector_floating_point_sign_injection_instructions":
          text:
          - 'vfsgnj.vv vd, vs2, vs1, vm # Vector-vector vfsgnj.vf vd, vs2, rs1, vm
            # vector-scalar vfsgnjn.vv vd, vs2, vs1, vm # Vector-vector vfsgnjn.vf
            vd, vs2, rs1, vm # vector-scalar vfsgnjx.vv vd, vs2, vs1, vm # Vector-vector
            vfsgnjx.vf vd, vs2, rs1, vm # vector-scalar'
        "#_vector_instruction_listing":
          text:
          - vfsgnj
  vfsgnjn.vf:
    opcode:
    - vfsgnjn.vf
    - 31..26=0x09
    - vm
    - vs2
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vfsgnjn
  vfsgnjn.vv:
    opcode:
    - vfsgnjn.vv
    - 31..26=0x09
    - vm
    - vs2
    - vs1
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vfsgnjn
  vfsgnjx.vf:
    opcode:
    - vfsgnjx.vf
    - 31..26=0x0a
    - vm
    - vs2
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vfsgnjx
  vfsgnjx.vv:
    opcode:
    - vfsgnjx.vv
    - 31..26=0x0a
    - vm
    - vs2
    - vs1
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vfsgnjx
  vfslide1down.vf:
    opcode:
    - vfslide1down.vf
    - 31..26=0x0f
    - vm
    - vs2
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_slide1down_instruction"
    desc:
      v:
        "#_vector_slide1down_instruction":
          text:
          - The vfslide1down instruction is defined analogously, but sources its scalar
            argument from an f register.
        "#_vector_instruction_listing":
          text:
          - vfslide1down
  vfslide1up.vf:
    opcode:
    - vfslide1up.vf
    - 31..26=0x0e
    - vm
    - vs2
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_slide1up"
    desc:
      v:
        "#_vector_slide1up":
          text:
          - The vfslide1up instruction is defined analogously, but sources its scalar
            argument from an f register.
        "#_vector_instruction_listing":
          text:
          - vfslide1up
  vfsqrt.v:
    opcode:
    - vfsqrt.v
    - 31..26=0x13
    - vm
    - vs2
    - 19..15=0x00
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *31
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_floating_point_square_root_instruction"
    desc:
      v:
        "#_vector_floating_point_square_root_instruction":
          text:
          - "# Floating-point square root vfsqrt.v vd, vs2, vm # Vector-vector square
            root"
        "#_vector_instruction_listing":
          text:
          - vfsqrt.v
    iss_code:
    - "// vsqrt.v vd, vd2, vm"
    - VI_VFP_V_LOOP
    - "({"
    - vd = f16_sqrt(vs2);
    - "},"
    - "{"
    - vd = f32_sqrt(vs2);
    - "},"
    - "{"
    - vd = f64_sqrt(vs2);
    - "})"
  vfsub.vf:
    opcode:
    - vfsub.vf
    - 31..26=0x02
    - vm
    - vs2
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vfsub
  vfsub.vv:
    opcode:
    - vfsub.vv
    - 31..26=0x02
    - vm
    - vs2
    - vs1
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vfsub
  vfwadd.vf:
    opcode:
    - vfwadd.vf
    - 31..26=0x30
    - vm
    - vs2
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_widening_floating_point_addsubtract_instructions"
    desc:
      v:
        "#_vector_widening_floating_point_addsubtract_instructions":
          text:
          - "# Widening FP add/subtract, 2*SEW = SEW +/- SEW vfwadd.vv vd, vs2, vs1,
            vm # vector-vector vfwadd.vf vd, vs2, rs1, vm # vector-scalar vfwsub.vv
            vd, vs2, vs1, vm # vector-vector vfwsub.vf vd, vs2, rs1, vm # vector-scalar
            # Widening FP add/subtract, 2*SEW = 2*SEW +/- SEW vfwadd.wv vd, vs2, vs1,
            vm # vector-vector vfwadd.wf vd, vs2, rs1, vm # vector-scalar vfwsub.wv
            vd, vs2, vs1, vm # vector-vector vfwsub.wf vd, vs2, rs1, vm # vector-scalar"
        "#_vector_instruction_listing":
          text:
          - vfwadd
          - vfwadd.w
  vfwadd.vv:
    opcode:
    - vfwadd.vv
    - 31..26=0x30
    - vm
    - vs2
    - vs1
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_widening_floating_point_addsubtract_instructions"
    desc:
      v:
        "#_vector_widening_floating_point_addsubtract_instructions":
          text:
          - "# Widening FP add/subtract, 2*SEW = SEW +/- SEW vfwadd.vv vd, vs2, vs1,
            vm # vector-vector vfwadd.vf vd, vs2, rs1, vm # vector-scalar vfwsub.vv
            vd, vs2, vs1, vm # vector-vector vfwsub.vf vd, vs2, rs1, vm # vector-scalar
            # Widening FP add/subtract, 2*SEW = 2*SEW +/- SEW vfwadd.wv vd, vs2, vs1,
            vm # vector-vector vfwadd.wf vd, vs2, rs1, vm # vector-scalar vfwsub.wv
            vd, vs2, vs1, vm # vector-vector vfwsub.wf vd, vs2, rs1, vm # vector-scalar"
        "#_vector_instruction_listing":
          text:
          - vfwadd
          - vfwadd.w
  vfwadd.wf:
    opcode:
    - vfwadd.wf
    - 31..26=0x34
    - vm
    - vs2
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_widening_floating_point_addsubtract_instructions"
    desc:
      v:
        "#_vector_widening_floating_point_addsubtract_instructions":
          text:
          - "# Widening FP add/subtract, 2*SEW = SEW +/- SEW vfwadd.vv vd, vs2, vs1,
            vm # vector-vector vfwadd.vf vd, vs2, rs1, vm # vector-scalar vfwsub.vv
            vd, vs2, vs1, vm # vector-vector vfwsub.vf vd, vs2, rs1, vm # vector-scalar
            # Widening FP add/subtract, 2*SEW = 2*SEW +/- SEW vfwadd.wv vd, vs2, vs1,
            vm # vector-vector vfwadd.wf vd, vs2, rs1, vm # vector-scalar vfwsub.wv
            vd, vs2, vs1, vm # vector-vector vfwsub.wf vd, vs2, rs1, vm # vector-scalar"
        "#_vector_instruction_listing":
          text:
          - vfwadd
          - vfwadd.w
  vfwadd.wv:
    opcode:
    - vfwadd.wv
    - 31..26=0x34
    - vm
    - vs2
    - vs1
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_widening_floating_point_addsubtract_instructions"
    desc:
      v:
        "#_vector_widening_floating_point_addsubtract_instructions":
          text:
          - "# Widening FP add/subtract, 2*SEW = SEW +/- SEW vfwadd.vv vd, vs2, vs1,
            vm # vector-vector vfwadd.vf vd, vs2, rs1, vm # vector-scalar vfwsub.vv
            vd, vs2, vs1, vm # vector-vector vfwsub.vf vd, vs2, rs1, vm # vector-scalar
            # Widening FP add/subtract, 2*SEW = 2*SEW +/- SEW vfwadd.wv vd, vs2, vs1,
            vm # vector-vector vfwadd.wf vd, vs2, rs1, vm # vector-scalar vfwsub.wv
            vd, vs2, vs1, vm # vector-vector vfwsub.wf vd, vs2, rs1, vm # vector-scalar"
        "#_vector_instruction_listing":
          text:
          - vfwadd
          - vfwadd.w
  vfwcvt.f.f.v:
    opcode:
    - vfwcvt.f.f.v
    - 31..26=0x12
    - vm
    - vs2
    - 19..15=0x0C
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *31
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_widening_floating_pointinteger_type_convert_instructions"
    desc:
      v:
        "#_widening_floating_pointinteger_type_convert_instructions":
          text:
          - 'vfwcvt.xu.f.v vd, vs2, vm # Convert float to double-width unsigned integer.
            vfwcvt.x.f.v vd, vs2, vm # Convert float to double-width signed integer.
            vfwcvt.rtz.xu.f.v vd, vs2, vm # Convert float to double-width unsigned
            integer, truncating. vfwcvt.rtz.x.f.v vd, vs2, vm # Convert float to double-width
            signed integer, truncating. vfwcvt.f.xu.v vd, vs2, vm # Convert unsigned
            integer to double-width float. vfwcvt.f.x.v vd, vs2, vm # Convert signed
            integer to double-width float. vfwcvt.f.f.v vd, vs2, vm # Convert single-width
            float to double-width float.'
        "#_vector_instruction_listing":
          text:
          - vfwcvt.xu.f.v
          - vfwcvt.x.f.v
          - vfwcvt.f.xu.v
          - vfwcvt.f.x.v
          - vfwcvt.f.f.v
          - vfwcvt.rtz.xu.f.v
          - vfwcvt.rtz.x.f.v
  vfwcvt.f.x.v:
    opcode:
    - vfwcvt.f.x.v
    - 31..26=0x12
    - vm
    - vs2
    - 19..15=0x0B
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *31
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_widening_floating_pointinteger_type_convert_instructions"
    desc:
      v:
        "#_widening_floating_pointinteger_type_convert_instructions":
          text:
          - 'vfwcvt.xu.f.v vd, vs2, vm # Convert float to double-width unsigned integer.
            vfwcvt.x.f.v vd, vs2, vm # Convert float to double-width signed integer.
            vfwcvt.rtz.xu.f.v vd, vs2, vm # Convert float to double-width unsigned
            integer, truncating. vfwcvt.rtz.x.f.v vd, vs2, vm # Convert float to double-width
            signed integer, truncating. vfwcvt.f.xu.v vd, vs2, vm # Convert unsigned
            integer to double-width float. vfwcvt.f.x.v vd, vs2, vm # Convert signed
            integer to double-width float. vfwcvt.f.f.v vd, vs2, vm # Convert single-width
            float to double-width float.'
        "#_vector_instruction_listing":
          text:
          - vfwcvt.xu.f.v
          - vfwcvt.x.f.v
          - vfwcvt.f.xu.v
          - vfwcvt.f.x.v
          - vfwcvt.f.f.v
          - vfwcvt.rtz.xu.f.v
          - vfwcvt.rtz.x.f.v
  vfwcvt.f.xu.v:
    opcode:
    - vfwcvt.f.xu.v
    - 31..26=0x12
    - vm
    - vs2
    - 19..15=0x0A
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *31
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_widening_floating_pointinteger_type_convert_instructions"
    desc:
      v:
        "#_widening_floating_pointinteger_type_convert_instructions":
          text:
          - 'vfwcvt.xu.f.v vd, vs2, vm # Convert float to double-width unsigned integer.
            vfwcvt.x.f.v vd, vs2, vm # Convert float to double-width signed integer.
            vfwcvt.rtz.xu.f.v vd, vs2, vm # Convert float to double-width unsigned
            integer, truncating. vfwcvt.rtz.x.f.v vd, vs2, vm # Convert float to double-width
            signed integer, truncating. vfwcvt.f.xu.v vd, vs2, vm # Convert unsigned
            integer to double-width float. vfwcvt.f.x.v vd, vs2, vm # Convert signed
            integer to double-width float. vfwcvt.f.f.v vd, vs2, vm # Convert single-width
            float to double-width float.'
        "#_vector_instruction_listing":
          text:
          - vfwcvt.xu.f.v
          - vfwcvt.x.f.v
          - vfwcvt.f.xu.v
          - vfwcvt.f.x.v
          - vfwcvt.f.f.v
          - vfwcvt.rtz.xu.f.v
          - vfwcvt.rtz.x.f.v
  vfwcvt.rtz.x.f.v:
    opcode:
    - vfwcvt.rtz.x.f.v
    - 31..26=0x12
    - vm
    - vs2
    - 19..15=0x0F
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *31
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_widening_floating_pointinteger_type_convert_instructions"
    desc:
      v:
        "#_widening_floating_pointinteger_type_convert_instructions":
          text:
          - 'vfwcvt.xu.f.v vd, vs2, vm # Convert float to double-width unsigned integer.
            vfwcvt.x.f.v vd, vs2, vm # Convert float to double-width signed integer.
            vfwcvt.rtz.xu.f.v vd, vs2, vm # Convert float to double-width unsigned
            integer, truncating. vfwcvt.rtz.x.f.v vd, vs2, vm # Convert float to double-width
            signed integer, truncating. vfwcvt.f.xu.v vd, vs2, vm # Convert unsigned
            integer to double-width float. vfwcvt.f.x.v vd, vs2, vm # Convert signed
            integer to double-width float. vfwcvt.f.f.v vd, vs2, vm # Convert single-width
            float to double-width float.'
        "#_vector_instruction_listing":
          text:
          - vfwcvt.xu.f.v
          - vfwcvt.x.f.v
          - vfwcvt.f.xu.v
          - vfwcvt.f.x.v
          - vfwcvt.f.f.v
          - vfwcvt.rtz.xu.f.v
          - vfwcvt.rtz.x.f.v
  vfwcvt.rtz.xu.f.v:
    opcode:
    - vfwcvt.rtz.xu.f.v
    - 31..26=0x12
    - vm
    - vs2
    - 19..15=0x0E
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *31
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_widening_floating_pointinteger_type_convert_instructions"
    desc:
      v:
        "#_widening_floating_pointinteger_type_convert_instructions":
          text:
          - 'vfwcvt.xu.f.v vd, vs2, vm # Convert float to double-width unsigned integer.
            vfwcvt.x.f.v vd, vs2, vm # Convert float to double-width signed integer.
            vfwcvt.rtz.xu.f.v vd, vs2, vm # Convert float to double-width unsigned
            integer, truncating. vfwcvt.rtz.x.f.v vd, vs2, vm # Convert float to double-width
            signed integer, truncating. vfwcvt.f.xu.v vd, vs2, vm # Convert unsigned
            integer to double-width float. vfwcvt.f.x.v vd, vs2, vm # Convert signed
            integer to double-width float. vfwcvt.f.f.v vd, vs2, vm # Convert single-width
            float to double-width float.'
        "#_vector_instruction_listing":
          text:
          - vfwcvt.xu.f.v
          - vfwcvt.x.f.v
          - vfwcvt.f.xu.v
          - vfwcvt.f.x.v
          - vfwcvt.f.f.v
          - vfwcvt.rtz.xu.f.v
          - vfwcvt.rtz.x.f.v
  vfwcvt.x.f.v:
    opcode:
    - vfwcvt.x.f.v
    - 31..26=0x12
    - vm
    - vs2
    - 19..15=0x09
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *31
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_widening_floating_pointinteger_type_convert_instructions"
    desc:
      v:
        "#_widening_floating_pointinteger_type_convert_instructions":
          text:
          - 'vfwcvt.xu.f.v vd, vs2, vm # Convert float to double-width unsigned integer.
            vfwcvt.x.f.v vd, vs2, vm # Convert float to double-width signed integer.
            vfwcvt.rtz.xu.f.v vd, vs2, vm # Convert float to double-width unsigned
            integer, truncating. vfwcvt.rtz.x.f.v vd, vs2, vm # Convert float to double-width
            signed integer, truncating. vfwcvt.f.xu.v vd, vs2, vm # Convert unsigned
            integer to double-width float. vfwcvt.f.x.v vd, vs2, vm # Convert signed
            integer to double-width float. vfwcvt.f.f.v vd, vs2, vm # Convert single-width
            float to double-width float.'
        "#_vector_instruction_listing":
          text:
          - vfwcvt.xu.f.v
          - vfwcvt.x.f.v
          - vfwcvt.f.xu.v
          - vfwcvt.f.x.v
          - vfwcvt.f.f.v
          - vfwcvt.rtz.xu.f.v
          - vfwcvt.rtz.x.f.v
  vfwcvt.xu.f.v:
    opcode:
    - vfwcvt.xu.f.v
    - 31..26=0x12
    - vm
    - vs2
    - 19..15=0x08
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *31
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_widening_floating_pointinteger_type_convert_instructions"
    desc:
      v:
        "#_widening_floating_pointinteger_type_convert_instructions":
          text:
          - 'vfwcvt.xu.f.v vd, vs2, vm # Convert float to double-width unsigned integer.
            vfwcvt.x.f.v vd, vs2, vm # Convert float to double-width signed integer.
            vfwcvt.rtz.xu.f.v vd, vs2, vm # Convert float to double-width unsigned
            integer, truncating. vfwcvt.rtz.x.f.v vd, vs2, vm # Convert float to double-width
            signed integer, truncating. vfwcvt.f.xu.v vd, vs2, vm # Convert unsigned
            integer to double-width float. vfwcvt.f.x.v vd, vs2, vm # Convert signed
            integer to double-width float. vfwcvt.f.f.v vd, vs2, vm # Convert single-width
            float to double-width float.'
        "#_vector_instruction_listing":
          text:
          - vfwcvt.xu.f.v
          - vfwcvt.x.f.v
          - vfwcvt.f.xu.v
          - vfwcvt.f.x.v
          - vfwcvt.f.f.v
          - vfwcvt.rtz.xu.f.v
          - vfwcvt.rtz.x.f.v
  vfwmacc.vf:
    opcode:
    - vfwmacc.vf
    - 31..26=0x3c
    - vm
    - vs2
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_widening_floating_point_fused_multiply_add_instructions"
    desc:
      v:
        "#_vector_widening_floating_point_fused_multiply_add_instructions":
          text:
          - "# FP widening multiply-accumulate, overwrites addend vfwmacc.vv vd, vs1,
            vs2, vm # vd[i] = +(vs1[i] * vs2[i]) + vd[i] vfwmacc.vf vd, rs1, vs2,
            vm # vd[i] = +(f[rs1] * vs2[i]) + vd[i] # FP widening negate-(multiply-accumulate),
            overwrites addend vfwnmacc.vv vd, vs1, vs2, vm # vd[i] = -(vs1[i] * vs2[i])
            - vd[i] vfwnmacc.vf vd, rs1, vs2, vm # vd[i] = -(f[rs1] * vs2[i]) - vd[i]
            # FP widening multiply-subtract-accumulator, overwrites addend vfwmsac.vv
            vd, vs1, vs2, vm # vd[i] = +(vs1[i] * vs2[i]) - vd[i] vfwmsac.vf vd, rs1,
            vs2, vm # vd[i] = +(f[rs1] * vs2[i]) - vd[i] # FP widening negate-(multiply-subtract-accumulator),
            overwrites addend vfwnmsac.vv vd, vs1, vs2, vm # vd[i] = -(vs1[i] * vs2[i])
            + vd[i] vfwnmsac.vf vd, rs1, vs2, vm # vd[i] = -(f[rs1] * vs2[i]) + vd[i]"
        "#_vector_instruction_listing":
          text:
          - vfwmacc
  vfwmacc.vv:
    opcode:
    - vfwmacc.vv
    - 31..26=0x3c
    - vm
    - vs2
    - vs1
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_widening_floating_point_fused_multiply_add_instructions"
    desc:
      v:
        "#_vector_widening_floating_point_fused_multiply_add_instructions":
          text:
          - "# FP widening multiply-accumulate, overwrites addend vfwmacc.vv vd, vs1,
            vs2, vm # vd[i] = +(vs1[i] * vs2[i]) + vd[i] vfwmacc.vf vd, rs1, vs2,
            vm # vd[i] = +(f[rs1] * vs2[i]) + vd[i] # FP widening negate-(multiply-accumulate),
            overwrites addend vfwnmacc.vv vd, vs1, vs2, vm # vd[i] = -(vs1[i] * vs2[i])
            - vd[i] vfwnmacc.vf vd, rs1, vs2, vm # vd[i] = -(f[rs1] * vs2[i]) - vd[i]
            # FP widening multiply-subtract-accumulator, overwrites addend vfwmsac.vv
            vd, vs1, vs2, vm # vd[i] = +(vs1[i] * vs2[i]) - vd[i] vfwmsac.vf vd, rs1,
            vs2, vm # vd[i] = +(f[rs1] * vs2[i]) - vd[i] # FP widening negate-(multiply-subtract-accumulator),
            overwrites addend vfwnmsac.vv vd, vs1, vs2, vm # vd[i] = -(vs1[i] * vs2[i])
            + vd[i] vfwnmsac.vf vd, rs1, vs2, vm # vd[i] = -(f[rs1] * vs2[i]) + vd[i]"
        "#_vector_instruction_listing":
          text:
          - vfwmacc
  vfwmsac.vf:
    opcode:
    - vfwmsac.vf
    - 31..26=0x3e
    - vm
    - vs2
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vfwmsac
  vfwmsac.vv:
    opcode:
    - vfwmsac.vv
    - 31..26=0x3e
    - vm
    - vs2
    - vs1
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vfwmsac
  vfwmul.vf:
    opcode:
    - vfwmul.vf
    - 31..26=0x38
    - vm
    - vs2
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_widening_floating_point_multiply"
    desc:
      v:
        "#_vector_widening_floating_point_multiply":
          text:
          - "# Widening floating-point multiply vfwmul.vv vd, vs2, vs1, vm # vector-vector
            vfwmul.vf vd, vs2, rs1, vm # vector-scalar"
        "#_vector_instruction_listing":
          text:
          - vfwmul
  vfwmul.vv:
    opcode:
    - vfwmul.vv
    - 31..26=0x38
    - vm
    - vs2
    - vs1
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_widening_floating_point_multiply"
    desc:
      v:
        "#_vector_widening_floating_point_multiply":
          text:
          - "# Widening floating-point multiply vfwmul.vv vd, vs2, vs1, vm # vector-vector
            vfwmul.vf vd, vs2, rs1, vm # vector-scalar"
        "#_vector_instruction_listing":
          text:
          - vfwmul
  vfwnmacc.vf:
    opcode:
    - vfwnmacc.vf
    - 31..26=0x3d
    - vm
    - vs2
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vfwnmacc
  vfwnmacc.vv:
    opcode:
    - vfwnmacc.vv
    - 31..26=0x3d
    - vm
    - vs2
    - vs1
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vfwnmacc
  vfwnmsac.vf:
    opcode:
    - vfwnmsac.vf
    - 31..26=0x3f
    - vm
    - vs2
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vfwnmsac
  vfwnmsac.vv:
    opcode:
    - vfwnmsac.vv
    - 31..26=0x3f
    - vm
    - vs2
    - vs1
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vfwnmsac
  vfwredosum.vs:
    opcode:
    - vfwredosum.vs
    - 31..26=0x33
    - vm
    - vs2
    - vs1
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#sec-vector-float-reduce-widen"
    desc:
      v:
        "#sec-vector-float-reduce-widen":
          text:
          - "# Simple reductions. vfwredosum.vs vd, vs2, vs1, vm # Ordered sum vfwredusum.vs
            vd, vs2, vs1, vm # Unordered sum"
        "#_vector_instruction_listing":
          text:
          - vfwredosum
  vfwredsum.vs:
    opcode:
    - vfwredsum.vs
    - 31..26=0x31
    - vm
    - vs2
    - vs1
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: v_aliases
    opcode_args: *28
    pseudo_src: rv_v
    pseudo_op: vfwredusum.vs
  vfwredusum.vs:
    opcode:
    - vfwredusum.vs
    - 31..26=0x31
    - vm
    - vs2
    - vs1
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vfwredusum
  vfwsub.vf:
    opcode:
    - vfwsub.vf
    - 31..26=0x32
    - vm
    - vs2
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vfwsub
          - vfwsub.w
  vfwsub.vv:
    opcode:
    - vfwsub.vv
    - 31..26=0x32
    - vm
    - vs2
    - vs1
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vfwsub
          - vfwsub.w
  vfwsub.wf:
    opcode:
    - vfwsub.wf
    - 31..26=0x36
    - vm
    - vs2
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vfwsub
          - vfwsub.w
  vfwsub.wv:
    opcode:
    - vfwsub.wv
    - 31..26=0x36
    - vm
    - vs2
    - vs1
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vfwsub
          - vfwsub.w
  vid.v:
    opcode:
    - vid.v
    - 31..26=0x14
    - vm
    - 24..20=0
    - 19..15=0x11
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: &56
    - vd
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_element_index_instruction"
    desc:
      v:
        "#_vector_element_index_instruction":
          text:
          - The vid.v instruction writes each element's index to the destination vector
            register group, from 0 to vl-1.
          - 'vid.v vd, vm # Write element ID to destination.'
        "#_synthesizing_vdecompress":
          text:
          - 'Desired functionality of ''vdecompress'' 7 6 5 4 3 2 1 0 # vid e d c
            b a # packed vector of 5 elements 1 0 0 1 1 1 0 1 # mask vector of 8 elements
            p q r s t u v w # destination register before vdecompress e q r d c b
            v a # result of vdecompress'
        "#_vector_instruction_listing":
          text:
          - vid
    iss_code:
    - "// vmpopc rd, vs2, vm"
    - require(P.VU.vsew >= e8 && P.VU.vsew <= e64);
    - require_vector(true);
    - reg_t sew = P.VU.vsew;
    - reg_t rd_num = insn.rd();
    - require_align(rd_num, P.VU.vflmul);
    - require_vm;
    - ''
    - for (reg_t i = P.VU.vstart->read() ; i < P.VU.vl->read(); ++i) {
    - VI_LOOP_ELEMENT_SKIP();
    - ''
    - switch (sew) {
    - 'case e8:'
    - P.VU.elt<uint8_t>(rd_num, i, true) = i;
    - break;
    - 'case e16:'
    - P.VU.elt<uint16_t>(rd_num, i, true) = i;
    - break;
    - 'case e32:'
    - P.VU.elt<uint32_t>(rd_num, i, true) = i;
    - break;
    - 'default:'
    - P.VU.elt<uint64_t>(rd_num, i, true) = i;
    - break;
    - "}"
    - "}"
    - ''
    - P.VU.vstart->write(0);
  viota.m:
    opcode:
    - viota.m
    - 31..26=0x14
    - vm
    - vs2
    - 19..15=0x10
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *31
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_iota_instruction"
    desc:
      v:
        "#_vector_iota_instruction":
          text:
          - The viota.m instruction reads a source vector mask register and writes
            to each element of the destination vector register group the sum of all
            the bits of elements in the mask register whose index is less than the
            element, e.g., a parallel prefix sum of the mask values.
          - Traps on viota.m are always reported with a vstart of 0, and execution
            is always restarted from the beginning when resuming after a trap handler.
            An illegal instruction exception is raised if vstart is non-zero.
          - The viota.m instruction can be combined with memory scatter instructions
            (indexed stores) to perform vector compress functions.
          - 'viota.m vd, vs2, vm # Example 7 6 5 4 3 2 1 0 Element number 1 0 0 1
            0 0 0 1 v2 contents viota.m v4, v2 # Unmasked 2 2 2 1 1 1 1 0 v4 result
            1 1 1 0 1 0 1 1 v0 contents 1 0 0 1 0 0 0 1 v2 contents 2 3 4 5 6 7 8
            9 v4 contents viota.m v4, v2, v0.t # Masked, vtype.vma=0 1 1 1 5 1 7 1
            0 v4 results'
        "#_synthesizing_vdecompress":
          text:
          - "# v0 holds mask # v1 holds packed data # v11 holds input expanded vector
            and result viota.m v10, v0 # Calc iota from mask in v0 vrgather.vv v11,
            v1, v10, v0.t # Expand into destination"
          - 'p q r s t u v w # v11 destination register e d c b a # v1 source vector
            1 0 0 1 1 1 0 1 # v0 mask vector 4 4 4 3 2 1 1 0 # v10 result of viota.m
            e q r d c b v a # v11 destination after vrgather using viota.m under mask'
        "#_vector_instruction_listing":
          text:
          - viota
    iss_code:
    - "// vmpopc rd, vs2, vm"
    - require(P.VU.vsew >= e8 && P.VU.vsew <= e64);
    - require_vector(true);
    - reg_t vl = P.VU.vl->read();
    - reg_t sew = P.VU.vsew;
    - reg_t rd_num = insn.rd();
    - reg_t rs2_num = insn.rs2();
    - require(P.VU.vstart->read() == 0);
    - require_vm;
    - require_align(rd_num, P.VU.vflmul);
    - require_noover(rd_num, P.VU.vflmul, rs2_num, 1);
    - ''
    - int cnt = 0;
    - for (reg_t i = 0; i < vl; ++i) {
    - const int midx = i / 64;
    - const int mpos = i % 64;
    - ''
    - bool vs2_lsb = ((P.VU.elt<uint64_t>(rs2_num, midx) >> mpos) & 0x1) == 1;
    - bool do_mask = (P.VU.elt<uint64_t>(0, midx) >> mpos) & 0x1;
    - ''
    - bool has_one = false;
    - if (insn.v_vm() == 1 || (insn.v_vm() == 0 && do_mask)) {
    - if (vs2_lsb) {
    - has_one = true;
    - "}"
    - "}"
    - ''
    - bool use_ori = (insn.v_vm() == 0) && !do_mask;
    - switch (sew) {
    - 'case e8:'
    - P.VU.elt<uint8_t>(rd_num, i, true) = use_ori ?
    - 'P.VU.elt<uint8_t>(rd_num, i) : cnt;'
    - break;
    - 'case e16:'
    - P.VU.elt<uint16_t>(rd_num, i, true) = use_ori ?
    - 'P.VU.elt<uint16_t>(rd_num, i) : cnt;'
    - break;
    - 'case e32:'
    - P.VU.elt<uint32_t>(rd_num, i, true) = use_ori ?
    - 'P.VU.elt<uint32_t>(rd_num, i) : cnt;'
    - break;
    - 'default:'
    - P.VU.elt<uint64_t>(rd_num, i, true) = use_ori ?
    - 'P.VU.elt<uint64_t>(rd_num, i) : cnt;'
    - break;
    - "}"
    - ''
    - if (has_one) {
    - cnt++;
    - "}"
    - "}"
    - ''
  vl1r.v:
    opcode:
    - vl1r.v
    - 31..29=0
    - 28=0
    - 27..26=0
    - 25=1
    - 24..20=0x08
    - rs1
    - 14..12=0x0
    - vd
    - 6..0=0x07
    opcode_group: v_aliases
    opcode_args: *33
    pseudo_src: rv_v
    pseudo_op: vl1re8.v
  vl1re16.v:
    opcode:
    - vl1re16.v
    - 31..29=0
    - 28=0
    - 27..26=0
    - 25=1
    - 24..20=0x08
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x07
    opcode_group: v
    opcode_args: *33
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
    iss_code:
    - "// vl1re16.v vd, (rs1)"
    - VI_LD_WHOLE(uint16);
  vl1re32.v:
    opcode:
    - vl1re32.v
    - 31..29=0
    - 28=0
    - 27..26=0
    - 25=1
    - 24..20=0x08
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x07
    opcode_group: v
    opcode_args: *33
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
    iss_code:
    - "// vl1re32.v vd, (rs1)"
    - VI_LD_WHOLE(uint32);
  vl1re64.v:
    opcode:
    - vl1re64.v
    - 31..29=0
    - 28=0
    - 27..26=0
    - 25=1
    - 24..20=0x08
    - rs1
    - 14..12=0x7
    - vd
    - 6..0=0x07
    opcode_group: v
    opcode_args: *33
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
    iss_code:
    - "// vl1re64.v vd, (rs1)"
    - VI_LD_WHOLE(uint64);
  vl1re8.v:
    opcode:
    - vl1re8.v
    - 31..29=0
    - 28=0
    - 27..26=0
    - 25=1
    - 24..20=0x08
    - rs1
    - 14..12=0x0
    - vd
    - 6..0=0x07
    opcode_group: v
    opcode_args: *33
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_loadstore_whole_register_instructions"
    desc:
      v:
        "#_vector_loadstore_whole_register_instructions":
          text:
          - "# Format of whole register load and store instructions. vl1r.v v3, (a0)
            # Pseudoinstruction equal to vl1re8.v vl1re8.v v3, (a0) # Load v3 with
            VLEN/8 bytes held at address in a0 vl1re16.v v3, (a0) # Load v3 with VLEN/16
            halfwords held at address in a0 vl1re32.v v3, (a0) # Load v3 with VLEN/32
            words held at address in a0 vl1re64.v v3, (a0) # Load v3 with VLEN/64
            doublewords held at address in a0 vl2r.v v2, (a0) # Pseudoinstruction
            equal to vl2re8.v v2, (a0) vl2re8.v v2, (a0) # Load v2-v3 with 2*VLEN/8
            bytes from address in a0 vl2re16.v v2, (a0) # Load v2-v3 with 2*VLEN/16
            halfwords held at address in a0 vl2re32.v v2, (a0) # Load v2-v3 with 2*VLEN/32
            words held at address in a0 vl2re64.v v2, (a0) # Load v2-v3 with 2*VLEN/64
            doublewords held at address in a0 vl4r.v v4, (a0) # Pseudoinstruction
            equal to vl4re8.v vl4re8.v v4, (a0) # Load v4-v7 with 4*VLEN/8 bytes from
            address in a0 vl4re16.v v4, (a0) vl4re32.v v4, (a0) vl4re64.v v4, (a0)
            vl8r.v v8, (a0) # Pseudoinstruction equal to vl8re8.v vl8re8.v v8, (a0)
            # Load v8-v15 with 8*VLEN/8 bytes from address in a0 vl8re16.v v8, (a0)
            vl8re32.v v8, (a0) vl8re64.v v8, (a0) vs1r.v v3, (a1) # Store v3 to address
            in a1 vs2r.v v2, (a1) # Store v2-v3 to address in a1 vs4r.v v4, (a1) #
            Store v4-v7 to address in a1 vs8r.v v8, (a1) # Store v8-v15 to address
            in a1"
    iss_code:
    - "// vl1re8.v vd, (rs1)"
    - VI_LD_WHOLE(uint8);
  vl2r.v:
    opcode:
    - vl2r.v
    - 31..29=1
    - 28=0
    - 27..26=0
    - 25=1
    - 24..20=0x08
    - rs1
    - 14..12=0x0
    - vd
    - 6..0=0x07
    opcode_group: v_aliases
    opcode_args: *33
    pseudo_src: rv_v
    pseudo_op: vl2re8.v
  vl2re16.v:
    opcode:
    - vl2re16.v
    - 31..29=1
    - 28=0
    - 27..26=0
    - 25=1
    - 24..20=0x08
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x07
    opcode_group: v
    opcode_args: *33
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
    iss_code:
    - "// vl2e16.v vd, (rs1)"
    - VI_LD_WHOLE(uint16);
  vl2re32.v:
    opcode:
    - vl2re32.v
    - 31..29=1
    - 28=0
    - 27..26=0
    - 25=1
    - 24..20=0x08
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x07
    opcode_group: v
    opcode_args: *33
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
    iss_code:
    - "// vl2re32.v vd, (rs1)"
    - VI_LD_WHOLE(uint32);
  vl2re64.v:
    opcode:
    - vl2re64.v
    - 31..29=1
    - 28=0
    - 27..26=0
    - 25=1
    - 24..20=0x08
    - rs1
    - 14..12=0x7
    - vd
    - 6..0=0x07
    opcode_group: v
    opcode_args: *33
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
    iss_code:
    - "// vl2re64.v vd, (rs1)"
    - VI_LD_WHOLE(uint64);
  vl2re8.v:
    opcode:
    - vl2re8.v
    - 31..29=1
    - 28=0
    - 27..26=0
    - 25=1
    - 24..20=0x08
    - rs1
    - 14..12=0x0
    - vd
    - 6..0=0x07
    opcode_group: v
    opcode_args: *33
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
    iss_code:
    - "// vl2re8.v vd, (rs1)"
    - VI_LD_WHOLE(uint8);
  vl4r.v:
    opcode:
    - vl4r.v
    - 31..29=3
    - 28=0
    - 27..26=0
    - 25=1
    - 24..20=0x08
    - rs1
    - 14..12=0x0
    - vd
    - 6..0=0x07
    opcode_group: v_aliases
    opcode_args: *33
    pseudo_src: rv_v
    pseudo_op: vl4re8.v
  vl4re16.v:
    opcode:
    - vl4re16.v
    - 31..29=3
    - 28=0
    - 27..26=0
    - 25=1
    - 24..20=0x08
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x07
    opcode_group: v
    opcode_args: *33
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
    iss_code:
    - "// vl4re16.v vd, (rs1)"
    - VI_LD_WHOLE(uint16);
  vl4re32.v:
    opcode:
    - vl4re32.v
    - 31..29=3
    - 28=0
    - 27..26=0
    - 25=1
    - 24..20=0x08
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x07
    opcode_group: v
    opcode_args: *33
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
    iss_code:
    - "// vl4re32.v vd, (rs1)"
    - VI_LD_WHOLE(uint32);
  vl4re64.v:
    opcode:
    - vl4re64.v
    - 31..29=3
    - 28=0
    - 27..26=0
    - 25=1
    - 24..20=0x08
    - rs1
    - 14..12=0x7
    - vd
    - 6..0=0x07
    opcode_group: v
    opcode_args: *33
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
    iss_code:
    - "// vl4re64.v vd, (rs1)"
    - VI_LD_WHOLE(uint64);
  vl4re8.v:
    opcode:
    - vl4re8.v
    - 31..29=3
    - 28=0
    - 27..26=0
    - 25=1
    - 24..20=0x08
    - rs1
    - 14..12=0x0
    - vd
    - 6..0=0x07
    opcode_group: v
    opcode_args: *33
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
    iss_code:
    - "// vl4re8.v vd, (rs1)"
    - VI_LD_WHOLE(uint8);
  vl8r.v:
    opcode:
    - vl8r.v
    - 31..29=7
    - 28=0
    - 27..26=0
    - 25=1
    - 24..20=0x08
    - rs1
    - 14..12=0x0
    - vd
    - 6..0=0x07
    opcode_group: v_aliases
    opcode_args: *33
    pseudo_src: rv_v
    pseudo_op: vl8re8.v
  vl8re16.v:
    opcode:
    - vl8re16.v
    - 31..29=7
    - 28=0
    - 27..26=0
    - 25=1
    - 24..20=0x08
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x07
    opcode_group: v
    opcode_args: *33
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
    iss_code:
    - "// vl8re16.v vd, (rs1)"
    - VI_LD_WHOLE(uint16);
  vl8re32.v:
    opcode:
    - vl8re32.v
    - 31..29=7
    - 28=0
    - 27..26=0
    - 25=1
    - 24..20=0x08
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x07
    opcode_group: v
    opcode_args: *33
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
    iss_code:
    - "// vl8re32.v vd, (rs1)"
    - VI_LD_WHOLE(uint32);
  vl8re64.v:
    opcode:
    - vl8re64.v
    - 31..29=7
    - 28=0
    - 27..26=0
    - 25=1
    - 24..20=0x08
    - rs1
    - 14..12=0x7
    - vd
    - 6..0=0x07
    opcode_group: v
    opcode_args: *33
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
    iss_code:
    - "// vl8re64.v vd, (rs1)"
    - VI_LD_WHOLE(uint64);
  vl8re8.v:
    opcode:
    - vl8re8.v
    - 31..29=7
    - 28=0
    - 27..26=0
    - 25=1
    - 24..20=0x08
    - rs1
    - 14..12=0x0
    - vd
    - 6..0=0x07
    opcode_group: v
    opcode_args: *33
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
    iss_code:
    - "// vl8re8.v vd, (rs1)"
    - VI_LD_WHOLE(uint8);
  vle1.v:
    opcode:
    - vle1.v
    - 31..28=0
    - 27..26=0
    - 25=1
    - 24..20=0xb
    - rs1
    - 14..12=0x0
    - vd
    - 6..0=0x07
    opcode_group: v_aliases
    opcode_args: *33
    pseudo_src: rv_v
    pseudo_op: vlm.v
  vle1024.v:
    opcode:
    - vle1024.v
    - nf
    - 28=1
    - 27..26=0
    - vm
    - 24..20=0
    - rs1
    - 14..12=0x7
    - vd
    - 6..0=0x07
    opcode_group: v
    opcode_args: *33
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
  vle1024ff.v:
    opcode:
    - vle1024ff.v
    - nf
    - 28=1
    - 27..26=0
    - vm
    - 24..20=0x10
    - rs1
    - 14..12=0x7
    - vd
    - 6..0=0x07
    opcode_group: v
    opcode_args: *33
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
  vle128.v:
    opcode:
    - vle128.v
    - nf
    - 28=1
    - 27..26=0
    - vm
    - 24..20=0
    - rs1
    - 14..12=0x0
    - vd
    - 6..0=0x07
    opcode_group: v
    opcode_args: *33
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
  vle128ff.v:
    opcode:
    - vle128ff.v
    - nf
    - 28=1
    - 27..26=0
    - vm
    - 24..20=0x10
    - rs1
    - 14..12=0x0
    - vd
    - 6..0=0x07
    opcode_group: v
    opcode_args: *33
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
  vle16.v:
    opcode:
    - vle16.v
    - nf
    - 28=0
    - 27..26=0
    - vm
    - 24..20=0
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x07
    opcode_group: v
    opcode_args: *33
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
    iss_code:
    - "// vle16.v and vlseg[2-8]e16.v"
    - VI_LD(0, (i * nf + fn), int16, false);
  vle16ff.v:
    opcode:
    - vle16ff.v
    - nf
    - 28=0
    - 27..26=0
    - vm
    - 24..20=0x10
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x07
    opcode_group: v
    opcode_args: *33
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
    iss_code:
    - "// vle16ff.v and vlseg[2-8]e16ff.v"
    - VI_LDST_FF(int16);
  vle256.v:
    opcode:
    - vle256.v
    - nf
    - 28=1
    - 27..26=0
    - vm
    - 24..20=0
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x07
    opcode_group: v
    opcode_args: *33
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
  vle256ff.v:
    opcode:
    - vle256ff.v
    - nf
    - 28=1
    - 27..26=0
    - vm
    - 24..20=0x10
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x07
    opcode_group: v
    opcode_args: *33
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
  vle32.v:
    opcode:
    - vle32.v
    - nf
    - 28=0
    - 27..26=0
    - vm
    - 24..20=0
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x07
    opcode_group: v
    opcode_args: *33
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
    iss_code:
    - "// vle32.v and vlseg[2-8]e32.v"
    - VI_LD(0, (i * nf + fn), int32, false);
  vle32ff.v:
    opcode:
    - vle32ff.v
    - nf
    - 28=0
    - 27..26=0
    - vm
    - 24..20=0x10
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x07
    opcode_group: v
    opcode_args: *33
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
    iss_code:
    - "// vle32ff.v and vlseg[2-8]e32ff.v"
    - VI_LDST_FF(int32);
  vle512.v:
    opcode:
    - vle512.v
    - nf
    - 28=1
    - 27..26=0
    - vm
    - 24..20=0
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x07
    opcode_group: v
    opcode_args: *33
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
  vle512ff.v:
    opcode:
    - vle512ff.v
    - nf
    - 28=1
    - 27..26=0
    - vm
    - 24..20=0x10
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x07
    opcode_group: v
    opcode_args: *33
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
  vle64.v:
    opcode:
    - vle64.v
    - nf
    - 28=0
    - 27..26=0
    - vm
    - 24..20=0
    - rs1
    - 14..12=0x7
    - vd
    - 6..0=0x07
    opcode_group: v
    opcode_args: *33
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
    iss_code:
    - "// vle64.v and vlseg[2-8]e64.v"
    - VI_LD(0, (i * nf + fn), int64, false);
  vle64ff.v:
    opcode:
    - vle64ff.v
    - nf
    - 28=0
    - 27..26=0
    - vm
    - 24..20=0x10
    - rs1
    - 14..12=0x7
    - vd
    - 6..0=0x07
    opcode_group: v
    opcode_args: *33
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
    iss_code:
    - "// vle64ff.v and vlseg[2-8]e64ff.v"
    - VI_LDST_FF(int64);
  vle8.v:
    opcode:
    - vle8.v
    - nf
    - 28=0
    - 27..26=0
    - vm
    - 24..20=0
    - rs1
    - 14..12=0x0
    - vd
    - 6..0=0x07
    opcode_group: v
    opcode_args: *33
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_unit_stride_instructions"
    desc:
      v:
        "#_vector_unit_stride_instructions":
          text:
          - "# Vector unit-stride loads and stores # vd destination, rs1 base address,
            vm is mask encoding (v0.t or <missing>) vle8.v vd, (rs1), vm # 8-bit unit-stride
            load vle16.v vd, (rs1), vm # 16-bit unit-stride load vle32.v vd, (rs1),
            vm # 32-bit unit-stride load vle64.v vd, (rs1), vm # 64-bit unit-stride
            load # vs3 store data, rs1 base address, vm is mask encoding (v0.t or
            <missing>) vse8.v vs3, (rs1), vm # 8-bit unit-stride store vse16.v vs3,
            (rs1), vm # 16-bit unit-stride store vse32.v vs3, (rs1), vm # 32-bit unit-stride
            store vse64.v vs3, (rs1), vm # 64-bit unit-stride store"
    iss_code:
    - "// vle8.v and vlseg[2-8]e8.v"
    - VI_LD(0, (i * nf + fn), int8, false);
  vle8ff.v:
    opcode:
    - vle8ff.v
    - nf
    - 28=0
    - 27..26=0
    - vm
    - 24..20=0x10
    - rs1
    - 14..12=0x0
    - vd
    - 6..0=0x07
    opcode_group: v
    opcode_args: *33
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_unit_stride_fault_only_first_loads"
    desc:
      v:
        "#_unit_stride_fault_only_first_loads":
          text:
          - "# Vector unit-stride fault-only-first loads # vd destination, rs1 base
            address, vm is mask encoding (v0.t or <missing>) vle8ff.v vd, (rs1), vm
            # 8-bit unit-stride fault-only-first load vle16ff.v vd, (rs1), vm # 16-bit
            unit-stride fault-only-first load vle32ff.v vd, (rs1), vm # 32-bit unit-stride
            fault-only-first load vle64ff.v vd, (rs1), vm # 64-bit unit-stride fault-only-first
            load"
    iss_code:
    - "// vle8ff.v and vlseg[2-8]e8ff.v"
    - VI_LDST_FF(int8);
  vlm.v:
    opcode:
    - vlm.v
    - 31..28=0
    - 27..26=0
    - 25=1
    - 24..20=0xb
    - rs1
    - 14..12=0x0
    - vd
    - 6..0=0x07
    opcode_group: v
    opcode_args: *33
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_unit_stride_instructions"
    desc:
      v:
        "#_vector_unit_stride_instructions":
          text:
          - vlm.v and vsm.v are encoded with the same width[2:0]=0 encoding as vle8.v
            and vse8.v, but are distinguished by different lumop and sumop encodings.
            Since vlm.v and vsm.v operate as byte loads and stores, vstart is in units
            of bytes for these instructions.
          - "# Vector unit-stride mask load vlm.v vd, (rs1) # Load byte vector of
            length ceil(vl/8) # Vector unit-stride mask store vsm.v vs3, (rs1) # Store
            byte vector of length ceil(vl/8)"
    iss_code:
    - "// vle1.v and vlseg[2-8]e8.v"
    - VI_LD(0, (i * nf + fn), int8, true);
  vloxei1024.v:
    opcode:
    - vloxei1024.v
    - nf
    - 28=1
    - 27..26=3
    - vm
    - vs2
    - rs1
    - 14..12=0x7
    - vd
    - 6..0=0x07
    opcode_group: v
    opcode_args: *29
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
  vloxei128.v:
    opcode:
    - vloxei128.v
    - nf
    - 28=1
    - 27..26=3
    - vm
    - vs2
    - rs1
    - 14..12=0x0
    - vd
    - 6..0=0x07
    opcode_group: v
    opcode_args: *29
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
  vloxei16.v:
    opcode:
    - vloxei16.v
    - nf
    - 28=0
    - 27..26=3
    - vm
    - vs2
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x07
    opcode_group: v
    opcode_args: *29
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
    iss_code:
    - "// vlxei16.v and vlxseg[2-8]e16.v"
    - VI_LD_INDEX(e16, true);
  vloxei256.v:
    opcode:
    - vloxei256.v
    - nf
    - 28=1
    - 27..26=3
    - vm
    - vs2
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x07
    opcode_group: v
    opcode_args: *29
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
  vloxei32.v:
    opcode:
    - vloxei32.v
    - nf
    - 28=0
    - 27..26=3
    - vm
    - vs2
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x07
    opcode_group: v
    opcode_args: *29
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
    iss_code:
    - "// vlxe32.v and vlxseg[2-8]ei32.v"
    - VI_LD_INDEX(e32, true);
  vloxei512.v:
    opcode:
    - vloxei512.v
    - nf
    - 28=1
    - 27..26=3
    - vm
    - vs2
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x07
    opcode_group: v
    opcode_args: *29
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
  vloxei64.v:
    opcode:
    - vloxei64.v
    - nf
    - 28=0
    - 27..26=3
    - vm
    - vs2
    - rs1
    - 14..12=0x7
    - vd
    - 6..0=0x07
    opcode_group: v
    opcode_args: *29
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
    iss_code:
    - "// vlxei64.v and vlxseg[2-8]ei64.v"
    - VI_LD_INDEX(e64, true);
    - ''
  vloxei8.v:
    opcode:
    - vloxei8.v
    - nf
    - 28=0
    - 27..26=3
    - vm
    - vs2
    - rs1
    - 14..12=0x0
    - vd
    - 6..0=0x07
    opcode_group: v
    opcode_args: *29
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
    iss_code:
    - "// vlxei8.v and vlxseg[2-8]ei8.v"
    - VI_LD_INDEX(e8, true);
  vlse1024.v:
    opcode:
    - vlse1024.v
    - nf
    - 28=1
    - 27..26=2
    - vm
    - rs2
    - rs1
    - 14..12=0x7
    - vd
    - 6..0=0x07
    opcode_group: v
    opcode_args: &34
    - rs2
    - rs1
    - vd
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
  vlse128.v:
    opcode:
    - vlse128.v
    - nf
    - 28=1
    - 27..26=2
    - vm
    - rs2
    - rs1
    - 14..12=0x0
    - vd
    - 6..0=0x07
    opcode_group: v
    opcode_args: *34
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
  vlse16.v:
    opcode:
    - vlse16.v
    - nf
    - 28=0
    - 27..26=2
    - vm
    - rs2
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x07
    opcode_group: v
    opcode_args: *34
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
    iss_code:
    - "// vlse16.v and vlsseg[2-8]e16.v"
    - VI_LD(i * RS2, fn, int16, false);
  vlse256.v:
    opcode:
    - vlse256.v
    - nf
    - 28=1
    - 27..26=2
    - vm
    - rs2
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x07
    opcode_group: v
    opcode_args: *34
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
  vlse32.v:
    opcode:
    - vlse32.v
    - nf
    - 28=0
    - 27..26=2
    - vm
    - rs2
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x07
    opcode_group: v
    opcode_args: *34
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
    iss_code:
    - "// vlse32.v and vlsseg[2-8]e32.v"
    - VI_LD(i * RS2, fn, int32, false);
  vlse512.v:
    opcode:
    - vlse512.v
    - nf
    - 28=1
    - 27..26=2
    - vm
    - rs2
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x07
    opcode_group: v
    opcode_args: *34
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
  vlse64.v:
    opcode:
    - vlse64.v
    - nf
    - 28=0
    - 27..26=2
    - vm
    - rs2
    - rs1
    - 14..12=0x7
    - vd
    - 6..0=0x07
    opcode_group: v
    opcode_args: *34
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
    iss_code:
    - "// vlse64.v and vlsseg[2-8]e64.v"
    - VI_LD(i * RS2, fn, int64, false);
  vlse8.v:
    opcode:
    - vlse8.v
    - nf
    - 28=0
    - 27..26=2
    - vm
    - rs2
    - rs1
    - 14..12=0x0
    - vd
    - 6..0=0x07
    opcode_group: v
    opcode_args: *34
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_strided_instructions"
    desc:
      v:
        "#_vector_strided_instructions":
          text:
          - "# Vector strided loads and stores # vd destination, rs1 base address,
            rs2 byte stride vlse8.v vd, (rs1), rs2, vm # 8-bit strided load vlse16.v
            vd, (rs1), rs2, vm # 16-bit strided load vlse32.v vd, (rs1), rs2, vm #
            32-bit strided load vlse64.v vd, (rs1), rs2, vm # 64-bit strided load
            # vs3 store data, rs1 base address, rs2 byte stride vsse8.v vs3, (rs1),
            rs2, vm # 8-bit strided store vsse16.v vs3, (rs1), rs2, vm # 16-bit strided
            store vsse32.v vs3, (rs1), rs2, vm # 32-bit strided store vsse64.v vs3,
            (rs1), rs2, vm # 64-bit strided store"
    iss_code:
    - "// vlse8.v and vlsseg[2-8]e8.v"
    - VI_LD(i * RS2, fn, int8, false);
  vluxei1024.v:
    opcode:
    - vluxei1024.v
    - nf
    - 28=1
    - 27..26=1
    - vm
    - vs2
    - rs1
    - 14..12=0x7
    - vd
    - 6..0=0x07
    opcode_group: v
    opcode_args: *29
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
  vluxei128.v:
    opcode:
    - vluxei128.v
    - nf
    - 28=1
    - 27..26=1
    - vm
    - vs2
    - rs1
    - 14..12=0x0
    - vd
    - 6..0=0x07
    opcode_group: v
    opcode_args: *29
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
  vluxei16.v:
    opcode:
    - vluxei16.v
    - nf
    - 28=0
    - 27..26=1
    - vm
    - vs2
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x07
    opcode_group: v
    opcode_args: *29
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
    iss_code:
    - "// vlxei16.v and vlxseg[2-8]e16.v"
    - VI_LD_INDEX(e16, true);
  vluxei256.v:
    opcode:
    - vluxei256.v
    - nf
    - 28=1
    - 27..26=1
    - vm
    - vs2
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x07
    opcode_group: v
    opcode_args: *29
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
  vluxei32.v:
    opcode:
    - vluxei32.v
    - nf
    - 28=0
    - 27..26=1
    - vm
    - vs2
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x07
    opcode_group: v
    opcode_args: *29
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
    iss_code:
    - "// vlxe32.v and vlxseg[2-8]ei32.v"
    - VI_LD_INDEX(e32, true);
  vluxei512.v:
    opcode:
    - vluxei512.v
    - nf
    - 28=1
    - 27..26=1
    - vm
    - vs2
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x07
    opcode_group: v
    opcode_args: *29
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
  vluxei64.v:
    opcode:
    - vluxei64.v
    - nf
    - 28=0
    - 27..26=1
    - vm
    - vs2
    - rs1
    - 14..12=0x7
    - vd
    - 6..0=0x07
    opcode_group: v
    opcode_args: *29
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
    iss_code:
    - "// vlxei64.v and vlxseg[2-8]ei64.v"
    - VI_LD_INDEX(e64, true);
    - ''
  vluxei8.v:
    opcode:
    - vluxei8.v
    - nf
    - 28=0
    - 27..26=1
    - vm
    - vs2
    - rs1
    - 14..12=0x0
    - vd
    - 6..0=0x07
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_indexed_instructions"
    desc:
      v:
        "#_vector_indexed_instructions":
          text:
          - "# Vector indexed loads and stores # Vector indexed-unordered load instructions
            # vd destination, rs1 base address, vs2 byte offsets vluxei8.v vd, (rs1),
            vs2, vm # unordered 8-bit indexed load of SEW data vluxei16.v vd, (rs1),
            vs2, vm # unordered 16-bit indexed load of SEW data vluxei32.v vd, (rs1),
            vs2, vm # unordered 32-bit indexed load of SEW data vluxei64.v vd, (rs1),
            vs2, vm # unordered 64-bit indexed load of SEW data # Vector indexed-ordered
            load instructions # vd destination, rs1 base address, vs2 byte offsets
            vloxei8.v vd, (rs1), vs2, vm # ordered 8-bit indexed load of SEW data
            vloxei16.v vd, (rs1), vs2, vm # ordered 16-bit indexed load of SEW data
            vloxei32.v vd, (rs1), vs2, vm # ordered 32-bit indexed load of SEW data
            vloxei64.v vd, (rs1), vs2, vm # ordered 64-bit indexed load of SEW data
            # Vector indexed-unordered store instructions # vs3 store data, rs1 base
            address, vs2 byte offsets vsuxei8.v vs3, (rs1), vs2, vm # unordered 8-bit
            indexed store of SEW data vsuxei16.v vs3, (rs1), vs2, vm # unordered 16-bit
            indexed store of SEW data vsuxei32.v vs3, (rs1), vs2, vm # unordered 32-bit
            indexed store of SEW data vsuxei64.v vs3, (rs1), vs2, vm # unordered 64-bit
            indexed store of SEW data # Vector indexed-ordered store instructions
            # vs3 store data, rs1 base address, vs2 byte offsets vsoxei8.v vs3, (rs1),
            vs2, vm # ordered 8-bit indexed store of SEW data vsoxei16.v vs3, (rs1),
            vs2, vm # ordered 16-bit indexed store of SEW data vsoxei32.v vs3, (rs1),
            vs2, vm # ordered 32-bit indexed store of SEW data vsoxei64.v vs3, (rs1),
            vs2, vm # ordered 64-bit indexed store of SEW data"
    iss_code:
    - "// vlxei8.v and vlxseg[2-8]ei8.v"
    - VI_LD_INDEX(e8, true);
  vmacc.vv:
    opcode:
    - vmacc.vv
    - 31..26=0x2d
    - vm
    - vs2
    - vs1
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_single_width_integer_multiply_add_instructions"
    desc:
      v:
        "#_vector_single_width_integer_multiply_add_instructions":
          text:
          - The integer multiply-add instructions are destructive and are provided
            in two forms, one that overwrites the addend or minuend (vmacc, vnmsac)
            and one that overwrites the first multiplicand (vmadd, vnmsub).
          - "# Integer multiply-add, overwrite addend vmacc.vv vd, vs1, vs2, vm #
            vd[i] = +(vs1[i] * vs2[i]) + vd[i] vmacc.vx vd, rs1, vs2, vm # vd[i] =
            +(x[rs1] * vs2[i]) + vd[i] # Integer multiply-sub, overwrite minuend vnmsac.vv
            vd, vs1, vs2, vm # vd[i] = -(vs1[i] * vs2[i]) + vd[i] vnmsac.vx vd, rs1,
            vs2, vm # vd[i] = -(x[rs1] * vs2[i]) + vd[i] # Integer multiply-add, overwrite
            multiplicand vmadd.vv vd, vs1, vs2, vm # vd[i] = (vs1[i] * vd[i]) + vs2[i]
            vmadd.vx vd, rs1, vs2, vm # vd[i] = (x[rs1] * vd[i]) + vs2[i] # Integer
            multiply-sub, overwrite multiplicand vnmsub.vv vd, vs1, vs2, vm # vd[i]
            = -(vs1[i] * vd[i]) + vs2[i] vnmsub.vx vd, rs1, vs2, vm # vd[i] = -(x[rs1]
            * vd[i]) + vs2[i]"
        "#_vector_instruction_listing":
          text:
          - vmacc
  vmacc.vx:
    opcode:
    - vmacc.vx
    - 31..26=0x2d
    - vm
    - vs2
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_single_width_integer_multiply_add_instructions"
    desc:
      v:
        "#_vector_single_width_integer_multiply_add_instructions":
          text:
          - The integer multiply-add instructions are destructive and are provided
            in two forms, one that overwrites the addend or minuend (vmacc, vnmsac)
            and one that overwrites the first multiplicand (vmadd, vnmsub).
          - "# Integer multiply-add, overwrite addend vmacc.vv vd, vs1, vs2, vm #
            vd[i] = +(vs1[i] * vs2[i]) + vd[i] vmacc.vx vd, rs1, vs2, vm # vd[i] =
            +(x[rs1] * vs2[i]) + vd[i] # Integer multiply-sub, overwrite minuend vnmsac.vv
            vd, vs1, vs2, vm # vd[i] = -(vs1[i] * vs2[i]) + vd[i] vnmsac.vx vd, rs1,
            vs2, vm # vd[i] = -(x[rs1] * vs2[i]) + vd[i] # Integer multiply-add, overwrite
            multiplicand vmadd.vv vd, vs1, vs2, vm # vd[i] = (vs1[i] * vd[i]) + vs2[i]
            vmadd.vx vd, rs1, vs2, vm # vd[i] = (x[rs1] * vd[i]) + vs2[i] # Integer
            multiply-sub, overwrite multiplicand vnmsub.vv vd, vs1, vs2, vm # vd[i]
            = -(vs1[i] * vd[i]) + vs2[i] vnmsub.vx vd, rs1, vs2, vm # vd[i] = -(x[rs1]
            * vd[i]) + vs2[i]"
        "#_vector_instruction_listing":
          text:
          - vmacc
  vmadc.vi:
    opcode:
    - vmadc.vi
    - 31..26=0x11
    - 25=1
    - vs2
    - simm5
    - 14..12=0x3
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *30
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_integer_add_with_carry_subtract_with_borrow_instructions"
    desc:
      v:
        "#_vector_integer_add_with_carry_subtract_with_borrow_instructions":
          text:
          - vmadc and vmsbc add or subtract the source operands, optionally add the
            carry-in or subtract the borrow-in if masked (vm=0), and write the result
            back to mask register vd. If unmasked (vm=1), there is no carry-in or
            borrow-in. These instructions operate on and write back all body elements,
            even if masked. Because these instructions produce a mask value, they
            always operate with a tail-agnostic policy.
          - "# Example multi-word arithmetic sequence, accumulating into v4 vmadc.vvm
            v1, v4, v8, v0 # Get carry into temp register v1 vadc.vvm v4, v4, v8,
            v0 # Calc new sum vmmv.m v0, v1 # Move temp carry into v0 for next word"
        "#_vector_instruction_listing":
          text:
          - vmadc
  vmadc.vim:
    opcode:
    - vmadc.vim
    - 31..26=0x11
    - 25=0
    - vs2
    - simm5
    - 14..12=0x3
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *30
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_integer_add_with_carry_subtract_with_borrow_instructions"
    desc:
      v:
        "#_vector_integer_add_with_carry_subtract_with_borrow_instructions":
          text:
          - vmadc and vmsbc add or subtract the source operands, optionally add the
            carry-in or subtract the borrow-in if masked (vm=0), and write the result
            back to mask register vd. If unmasked (vm=1), there is no carry-in or
            borrow-in. These instructions operate on and write back all body elements,
            even if masked. Because these instructions produce a mask value, they
            always operate with a tail-agnostic policy.
          - "# Example multi-word arithmetic sequence, accumulating into v4 vmadc.vvm
            v1, v4, v8, v0 # Get carry into temp register v1 vadc.vvm v4, v4, v8,
            v0 # Calc new sum vmmv.m v0, v1 # Move temp carry into v0 for next word"
        "#_vector_instruction_listing":
          text:
          - vmadc
  vmadc.vv:
    opcode:
    - vmadc.vv
    - 31..26=0x11
    - 25=1
    - vs2
    - vs1
    - 14..12=0x0
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_integer_add_with_carry_subtract_with_borrow_instructions"
    desc:
      v:
        "#_vector_integer_add_with_carry_subtract_with_borrow_instructions":
          text:
          - vmadc and vmsbc add or subtract the source operands, optionally add the
            carry-in or subtract the borrow-in if masked (vm=0), and write the result
            back to mask register vd. If unmasked (vm=1), there is no carry-in or
            borrow-in. These instructions operate on and write back all body elements,
            even if masked. Because these instructions produce a mask value, they
            always operate with a tail-agnostic policy.
          - "# Example multi-word arithmetic sequence, accumulating into v4 vmadc.vvm
            v1, v4, v8, v0 # Get carry into temp register v1 vadc.vvm v4, v4, v8,
            v0 # Calc new sum vmmv.m v0, v1 # Move temp carry into v0 for next word"
        "#_vector_instruction_listing":
          text:
          - vmadc
  vmadc.vvm:
    opcode:
    - vmadc.vvm
    - 31..26=0x11
    - 25=0
    - vs2
    - vs1
    - 14..12=0x0
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_integer_add_with_carry_subtract_with_borrow_instructions"
    desc:
      v:
        "#_vector_integer_add_with_carry_subtract_with_borrow_instructions":
          text:
          - vmadc and vmsbc add or subtract the source operands, optionally add the
            carry-in or subtract the borrow-in if masked (vm=0), and write the result
            back to mask register vd. If unmasked (vm=1), there is no carry-in or
            borrow-in. These instructions operate on and write back all body elements,
            even if masked. Because these instructions produce a mask value, they
            always operate with a tail-agnostic policy.
          - "# Example multi-word arithmetic sequence, accumulating into v4 vmadc.vvm
            v1, v4, v8, v0 # Get carry into temp register v1 vadc.vvm v4, v4, v8,
            v0 # Calc new sum vmmv.m v0, v1 # Move temp carry into v0 for next word"
        "#_vector_instruction_listing":
          text:
          - vmadc
  vmadc.vx:
    opcode:
    - vmadc.vx
    - 31..26=0x11
    - 25=1
    - vs2
    - rs1
    - 14..12=0x4
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_integer_add_with_carry_subtract_with_borrow_instructions"
    desc:
      v:
        "#_vector_integer_add_with_carry_subtract_with_borrow_instructions":
          text:
          - vmadc and vmsbc add or subtract the source operands, optionally add the
            carry-in or subtract the borrow-in if masked (vm=0), and write the result
            back to mask register vd. If unmasked (vm=1), there is no carry-in or
            borrow-in. These instructions operate on and write back all body elements,
            even if masked. Because these instructions produce a mask value, they
            always operate with a tail-agnostic policy.
          - "# Example multi-word arithmetic sequence, accumulating into v4 vmadc.vvm
            v1, v4, v8, v0 # Get carry into temp register v1 vadc.vvm v4, v4, v8,
            v0 # Calc new sum vmmv.m v0, v1 # Move temp carry into v0 for next word"
        "#_vector_instruction_listing":
          text:
          - vmadc
  vmadc.vxm:
    opcode:
    - vmadc.vxm
    - 31..26=0x11
    - 25=0
    - vs2
    - rs1
    - 14..12=0x4
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_integer_add_with_carry_subtract_with_borrow_instructions"
    desc:
      v:
        "#_vector_integer_add_with_carry_subtract_with_borrow_instructions":
          text:
          - vmadc and vmsbc add or subtract the source operands, optionally add the
            carry-in or subtract the borrow-in if masked (vm=0), and write the result
            back to mask register vd. If unmasked (vm=1), there is no carry-in or
            borrow-in. These instructions operate on and write back all body elements,
            even if masked. Because these instructions produce a mask value, they
            always operate with a tail-agnostic policy.
          - "# Example multi-word arithmetic sequence, accumulating into v4 vmadc.vvm
            v1, v4, v8, v0 # Get carry into temp register v1 vadc.vvm v4, v4, v8,
            v0 # Calc new sum vmmv.m v0, v1 # Move temp carry into v0 for next word"
        "#_vector_instruction_listing":
          text:
          - vmadc
  vmadd.vv:
    opcode:
    - vmadd.vv
    - 31..26=0x29
    - vm
    - vs2
    - vs1
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vmadd
  vmadd.vx:
    opcode:
    - vmadd.vx
    - 31..26=0x29
    - vm
    - vs2
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vmadd
  vmand.mm:
    opcode:
    - vmand.mm
    - 31..26=0x19
    - 25=1
    - vs2
    - vs1
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#sec-mask-register-logical"
    desc:
      v:
        "#sec-mask-register-logical":
          text:
          - vmand.mm vd, src1, src2
          - vmand.mm vd, src2, src2
          - vmand.mm vd, src1, src1
          - 'vmand.mm vd, vs2, vs1 # vd.mask[i] = vs2.mask[i] && vs1.mask[i] vmnand.mm
            vd, vs2, vs1 # vd.mask[i] = !(vs2.mask[i] && vs1.mask[i]) vmandn.mm vd,
            vs2, vs1 # vd.mask[i] = vs2.mask[i] && !vs1.mask[i] vmxor.mm vd, vs2,
            vs1 # vd.mask[i] = vs2.mask[i] ^^ vs1.mask[i] vmor.mm vd, vs2, vs1 # vd.mask[i]
            = vs2.mask[i] || vs1.mask[i] vmnor.mm vd, vs2, vs1 # vd.mask[i] = !(vs2.mask[i]
            || vs1.mask[i]) vmorn.mm vd, vs2, vs1 # vd.mask[i] = vs2.mask[i] || !vs1.mask[i]
            vmxnor.mm vd, vs2, vs1 # vd.mask[i] = !(vs2.mask[i] ^^ vs1.mask[i])'
          - 'vmmv.m vd, vs => vmand.mm vd, vs, vs # Copy mask register vmclr.m vd
            => vmxor.mm vd, vd, vd # Clear mask register vmset.m vd => vmxnor.mm vd,
            vd, vd # Set mask register vmnot.m vd, vs => vmnand.mm vd, vs, vs # Invert
            bits'
        "#_vector_instruction_listing":
          text:
          - vmand
  vmandn.mm:
    opcode:
    - vmandn.mm
    - 31..26=0x18
    - 25=1
    - vs2
    - vs1
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#sec-mask-register-logical"
    desc:
      v:
        "#sec-mask-register-logical":
          text:
          - vmandn.mm vd, src2, src1
          - vmandn.mm vd, src1, src2
  vmandnot.mm:
    opcode:
    - vmandnot.mm
    - 31..26=0x18
    - vm
    - vs2
    - vs1
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: v_aliases
    opcode_args: *28
    pseudo_src: rv_v
    pseudo_op: vmandn.mm
  vmax.vv:
    opcode:
    - vmax.vv
    - 31..26=0x07
    - vm
    - vs2
    - vs1
    - 14..12=0x0
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vmax
  vmax.vx:
    opcode:
    - vmax.vx
    - 31..26=0x07
    - vm
    - vs2
    - rs1
    - 14..12=0x4
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vmax
  vmaxu.vv:
    opcode:
    - vmaxu.vv
    - 31..26=0x06
    - vm
    - vs2
    - vs1
    - 14..12=0x0
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vmaxu
  vmaxu.vx:
    opcode:
    - vmaxu.vx
    - 31..26=0x06
    - vm
    - vs2
    - rs1
    - 14..12=0x4
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vmaxu
  vmerge.vim:
    opcode:
    - vmerge.vim
    - 31..26=0x17
    - 25=0
    - vs2
    - simm5
    - 14..12=0x3
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *30
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_integer_merge_instructions"
    desc:
      v:
        "#_vector_integer_merge_instructions":
          text:
          - The vmerge instructions are encoded as masked instructions (vm=0). The
            instructions combine two sources as follows. At elements where the mask
            value is zero, the first operand is copied to the destination element,
            otherwise the second operand is copied to the destination element. The
            first operand is always a vector register group specified by vs2. The
            second operand is a vector register group specified by vs1 or a scalar
            x register specified by rs1 or a 5-bit sign-extended immediate.
          - 'vmerge.vvm vd, vs2, vs1, v0 # vd[i] = v0.mask[i] ? vs1[i] : vs2[i] vmerge.vxm
            vd, vs2, rs1, v0 # vd[i] = v0.mask[i] ? x[rs1] : vs2[i] vmerge.vim vd,
            vs2, imm, v0 # vd[i] = v0.mask[i] ? imm : vs2[i]'
        "#_vector_instruction_listing":
          text:
          - vmerge/vmv
  vmerge.vvm:
    opcode:
    - vmerge.vvm
    - 31..26=0x17
    - 25=0
    - vs2
    - vs1
    - 14..12=0x0
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_integer_merge_instructions"
    desc:
      v:
        "#_vector_integer_merge_instructions":
          text:
          - The vmerge instructions are encoded as masked instructions (vm=0). The
            instructions combine two sources as follows. At elements where the mask
            value is zero, the first operand is copied to the destination element,
            otherwise the second operand is copied to the destination element. The
            first operand is always a vector register group specified by vs2. The
            second operand is a vector register group specified by vs1 or a scalar
            x register specified by rs1 or a 5-bit sign-extended immediate.
          - 'vmerge.vvm vd, vs2, vs1, v0 # vd[i] = v0.mask[i] ? vs1[i] : vs2[i] vmerge.vxm
            vd, vs2, rs1, v0 # vd[i] = v0.mask[i] ? x[rs1] : vs2[i] vmerge.vim vd,
            vs2, imm, v0 # vd[i] = v0.mask[i] ? imm : vs2[i]'
        "#_vector_instruction_listing":
          text:
          - vmerge/vmv
  vmerge.vxm:
    opcode:
    - vmerge.vxm
    - 31..26=0x17
    - 25=0
    - vs2
    - rs1
    - 14..12=0x4
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_integer_merge_instructions"
    desc:
      v:
        "#_vector_integer_merge_instructions":
          text:
          - The vmerge instructions are encoded as masked instructions (vm=0). The
            instructions combine two sources as follows. At elements where the mask
            value is zero, the first operand is copied to the destination element,
            otherwise the second operand is copied to the destination element. The
            first operand is always a vector register group specified by vs2. The
            second operand is a vector register group specified by vs1 or a scalar
            x register specified by rs1 or a 5-bit sign-extended immediate.
          - 'vmerge.vvm vd, vs2, vs1, v0 # vd[i] = v0.mask[i] ? vs1[i] : vs2[i] vmerge.vxm
            vd, vs2, rs1, v0 # vd[i] = v0.mask[i] ? x[rs1] : vs2[i] vmerge.vim vd,
            vs2, imm, v0 # vd[i] = v0.mask[i] ? imm : vs2[i]'
        "#_vector_instruction_listing":
          text:
          - vmerge/vmv
  vmfeq.vf:
    opcode:
    - vmfeq.vf
    - 31..26=0x18
    - vm
    - vs2
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_floating_point_compare_instructions"
    desc:
      v:
        "#_vector_floating_point_compare_instructions":
          text:
          - The compare instructions follow the semantics of the scalar floating-point
            compare instructions. vmfeq and vmfne raise the invalid operation exception
            only on signaling NaN inputs. vmflt, vmfle, vmfgt, and vmfge raise the
            invalid operation exception on both signaling and quiet NaN inputs. vmfne
            writes 1 to the destination element when either operand is NaN, whereas
            the other compares write 0 when either operand is NaN.
          - "# Compare equal vmfeq.vv vd, vs2, vs1, vm # Vector-vector vmfeq.vf vd,
            vs2, rs1, vm # vector-scalar # Compare not equal vmfne.vv vd, vs2, vs1,
            vm # Vector-vector vmfne.vf vd, vs2, rs1, vm # vector-scalar # Compare
            less than vmflt.vv vd, vs2, vs1, vm # Vector-vector vmflt.vf vd, vs2,
            rs1, vm # vector-scalar # Compare less than or equal vmfle.vv vd, vs2,
            vs1, vm # Vector-vector vmfle.vf vd, vs2, rs1, vm # vector-scalar # Compare
            greater than vmfgt.vf vd, vs2, rs1, vm # vector-scalar # Compare greater
            than or equal vmfge.vf vd, vs2, rs1, vm # vector-scalar"
          - "# Example of implementing isgreater() vmfeq.vv v0, va, va # Only set
            where A is not NaN. vmfeq.vv v1, vb, vb # Only set where B is not NaN.
            vmand.mm v0, v0, v1 # Only set where A and B are ordered, vmfgt.vv v0,
            va, vb, v0.t # so only set flags on ordered values."
        "#_vector_instruction_listing":
          text:
          - vmfeq
  vmfeq.vv:
    opcode:
    - vmfeq.vv
    - 31..26=0x18
    - vm
    - vs2
    - vs1
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_floating_point_compare_instructions"
    desc:
      v:
        "#_vector_floating_point_compare_instructions":
          text:
          - The compare instructions follow the semantics of the scalar floating-point
            compare instructions. vmfeq and vmfne raise the invalid operation exception
            only on signaling NaN inputs. vmflt, vmfle, vmfgt, and vmfge raise the
            invalid operation exception on both signaling and quiet NaN inputs. vmfne
            writes 1 to the destination element when either operand is NaN, whereas
            the other compares write 0 when either operand is NaN.
          - "# Compare equal vmfeq.vv vd, vs2, vs1, vm # Vector-vector vmfeq.vf vd,
            vs2, rs1, vm # vector-scalar # Compare not equal vmfne.vv vd, vs2, vs1,
            vm # Vector-vector vmfne.vf vd, vs2, rs1, vm # vector-scalar # Compare
            less than vmflt.vv vd, vs2, vs1, vm # Vector-vector vmflt.vf vd, vs2,
            rs1, vm # vector-scalar # Compare less than or equal vmfle.vv vd, vs2,
            vs1, vm # Vector-vector vmfle.vf vd, vs2, rs1, vm # vector-scalar # Compare
            greater than vmfgt.vf vd, vs2, rs1, vm # vector-scalar # Compare greater
            than or equal vmfge.vf vd, vs2, rs1, vm # vector-scalar"
          - "# Example of implementing isgreater() vmfeq.vv v0, va, va # Only set
            where A is not NaN. vmfeq.vv v1, vb, vb # Only set where B is not NaN.
            vmand.mm v0, v0, v1 # Only set where A and B are ordered, vmfgt.vv v0,
            va, vb, v0.t # so only set flags on ordered values."
        "#_vector_instruction_listing":
          text:
          - vmfeq
  vmfge.vf:
    opcode:
    - vmfge.vf
    - 31..26=0x1f
    - vm
    - vs2
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vmfge
  vmfgt.vf:
    opcode:
    - vmfgt.vf
    - 31..26=0x1d
    - vm
    - vs2
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vmfgt
  vmfle.vf:
    opcode:
    - vmfle.vf
    - 31..26=0x19
    - vm
    - vs2
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vmfle
  vmfle.vv:
    opcode:
    - vmfle.vv
    - 31..26=0x19
    - vm
    - vs2
    - vs1
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vmfle
  vmflt.vf:
    opcode:
    - vmflt.vf
    - 31..26=0x1b
    - vm
    - vs2
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_floating_point_compare_instructions"
    desc:
      v:
        "#_vector_floating_point_compare_instructions":
          text:
          - Comparison Assembler Mapping Assembler pseudoinstruction va < vb vmflt.vv
            vd, va, vb, vm va <= vb vmfle.vv vd, va, vb, vm va > vb vmflt.vv vd, vb,
            va, vm vmfgt.vv vd, va, vb, vm va >= vb vmfle.vv vd, vb, va, vm vmfge.vv
            vd, va, vb, vm va < f vmflt.vf vd, va, f, vm va <= f vmfle.vf vd, va,
            f, vm va > f vmfgt.vf vd, va, f, vm va >= f vmfge.vf vd, va, f, vm va,
            vb vector register groups f scalar floating-point register
        "#_vector_instruction_listing":
          text:
          - vmflt
  vmflt.vv:
    opcode:
    - vmflt.vv
    - 31..26=0x1b
    - vm
    - vs2
    - vs1
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_floating_point_compare_instructions"
    desc:
      v:
        "#_vector_floating_point_compare_instructions":
          text:
          - Comparison Assembler Mapping Assembler pseudoinstruction va < vb vmflt.vv
            vd, va, vb, vm va <= vb vmfle.vv vd, va, vb, vm va > vb vmflt.vv vd, vb,
            va, vm vmfgt.vv vd, va, vb, vm va >= vb vmfle.vv vd, vb, va, vm vmfge.vv
            vd, va, vb, vm va < f vmflt.vf vd, va, f, vm va <= f vmfle.vf vd, va,
            f, vm va > f vmfgt.vf vd, va, f, vm va >= f vmfge.vf vd, va, f, vm va,
            vb vector register groups f scalar floating-point register
        "#_vector_instruction_listing":
          text:
          - vmflt
  vmfne.vf:
    opcode:
    - vmfne.vf
    - 31..26=0x1c
    - vm
    - vs2
    - rs1
    - 14..12=0x5
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vmfne
        "#_square_root_approximation_example":
          text:
          - "# v1 = sqrt(v1) to almost 23 bits of precision. fmv.w.x ft0, x0 # Mask
            off zero inputs vmfne.vf v0, v1, ft0 # to avoid div by zero vfrsqrt7.v
            v2, v1, v0.t # Estimate 1/sqrt(x) vmfne.vf v0, v2, ft0, v0.t # Additionally
            mask off +inf inputs li t0, 0xbf000000 fmv.w.x ft0, t0 # -0.5 vfmul.vf
            v3, v1, ft0, v0.t # -0.5 * x vfmul.vv v4, v2, v2, v0.t # est * est li
            t0, 0x3fc00000 vmv.v.x v5, t0, v0.t # Splat 1.5 vfmadd.vv v4, v3, v5,
            v0.t # 1.5 - 0.5 * x * est * est vfmul.vv v1, v1, v4, v0.t # estimate
            to 14 bits vfmul.vv v4, v1, v1, v0.t # est * est vfmadd.vv v4, v3, v5,
            v0.t # 1.5 - 0.5 * x * est * est vfmul.vv v1, v1, v4, v0.t # estimate
            to 23 bits"
  vmfne.vv:
    opcode:
    - vmfne.vv
    - 31..26=0x1c
    - vm
    - vs2
    - vs1
    - 14..12=0x1
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vmfne
        "#_square_root_approximation_example":
          text:
          - "# v1 = sqrt(v1) to almost 23 bits of precision. fmv.w.x ft0, x0 # Mask
            off zero inputs vmfne.vf v0, v1, ft0 # to avoid div by zero vfrsqrt7.v
            v2, v1, v0.t # Estimate 1/sqrt(x) vmfne.vf v0, v2, ft0, v0.t # Additionally
            mask off +inf inputs li t0, 0xbf000000 fmv.w.x ft0, t0 # -0.5 vfmul.vf
            v3, v1, ft0, v0.t # -0.5 * x vfmul.vv v4, v2, v2, v0.t # est * est li
            t0, 0x3fc00000 vmv.v.x v5, t0, v0.t # Splat 1.5 vfmadd.vv v4, v3, v5,
            v0.t # 1.5 - 0.5 * x * est * est vfmul.vv v1, v1, v4, v0.t # estimate
            to 14 bits vfmul.vv v4, v1, v1, v0.t # est * est vfmadd.vv v4, v3, v5,
            v0.t # 1.5 - 0.5 * x * est * est vfmul.vv v1, v1, v4, v0.t # estimate
            to 23 bits"
  vmin.vv:
    opcode:
    - vmin.vv
    - 31..26=0x05
    - vm
    - vs2
    - vs1
    - 14..12=0x0
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vmin
  vmin.vx:
    opcode:
    - vmin.vx
    - 31..26=0x05
    - vm
    - vs2
    - rs1
    - 14..12=0x4
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vmin
  vminu.vv:
    opcode:
    - vminu.vv
    - 31..26=0x04
    - vm
    - vs2
    - vs1
    - 14..12=0x0
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_integer_minmax_instructions"
    desc:
      v:
        "#_vector_integer_minmax_instructions":
          text:
          - "# Unsigned minimum vminu.vv vd, vs2, vs1, vm # Vector-vector vminu.vx
            vd, vs2, rs1, vm # vector-scalar # Signed minimum vmin.vv vd, vs2, vs1,
            vm # Vector-vector vmin.vx vd, vs2, rs1, vm # vector-scalar # Unsigned
            maximum vmaxu.vv vd, vs2, vs1, vm # Vector-vector vmaxu.vx vd, vs2, rs1,
            vm # vector-scalar # Signed maximum vmax.vv vd, vs2, vs1, vm # Vector-vector
            vmax.vx vd, vs2, rs1, vm # vector-scalar"
        "#_vector_instruction_listing":
          text:
          - vminu
  vminu.vx:
    opcode:
    - vminu.vx
    - 31..26=0x04
    - vm
    - vs2
    - rs1
    - 14..12=0x4
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_integer_minmax_instructions"
    desc:
      v:
        "#_vector_integer_minmax_instructions":
          text:
          - "# Unsigned minimum vminu.vv vd, vs2, vs1, vm # Vector-vector vminu.vx
            vd, vs2, rs1, vm # vector-scalar # Signed minimum vmin.vv vd, vs2, vs1,
            vm # Vector-vector vmin.vx vd, vs2, rs1, vm # vector-scalar # Unsigned
            maximum vmaxu.vv vd, vs2, vs1, vm # Vector-vector vmaxu.vx vd, vs2, rs1,
            vm # vector-scalar # Signed maximum vmax.vv vd, vs2, vs1, vm # Vector-vector
            vmax.vx vd, vs2, rs1, vm # vector-scalar"
        "#_vector_instruction_listing":
          text:
          - vminu
  vmnand.mm:
    opcode:
    - vmnand.mm
    - 31..26=0x1d
    - 25=1
    - vs2
    - vs1
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#sec-mask-register-logical"
    desc:
      v:
        "#sec-mask-register-logical":
          text:
          - vmnand.mm vd, src1, src1
          - vmnand.mm vd, src2, src2
          - vmnand.mm vd, src1, src2
        "#_vector_instruction_listing":
          text:
          - vmnand
  vmnor.mm:
    opcode:
    - vmnor.mm
    - 31..26=0x1e
    - 25=1
    - vs2
    - vs1
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#sec-mask-register-logical"
    desc:
      v:
        "#sec-mask-register-logical":
          text:
          - vmnor.mm vd, src1, src2
        "#_vector_instruction_listing":
          text:
          - vmnor
  vmor.mm:
    opcode:
    - vmor.mm
    - 31..26=0x1a
    - 25=1
    - vs2
    - vs1
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vmor
  vmorn.mm:
    opcode:
    - vmorn.mm
    - 31..26=0x1c
    - 25=1
    - vs2
    - vs1
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#sec-mask-register-logical"
    desc:
      v:
        "#sec-mask-register-logical":
          text:
          - vmorn.mm vd, src2, src1
          - vmorn.mm vd, src1, src2
  vmornot.mm:
    opcode:
    - vmornot.mm
    - 31..26=0x1c
    - vm
    - vs2
    - vs1
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: v_aliases
    opcode_args: *28
    pseudo_src: rv_v
    pseudo_op: vmorn.mm
  vmsbc.vv:
    opcode:
    - vmsbc.vv
    - 31..26=0x13
    - 25=1
    - vs2
    - vs1
    - 14..12=0x0
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_integer_add_with_carry_subtract_with_borrow_instructions"
    desc:
      v:
        "#_vector_integer_add_with_carry_subtract_with_borrow_instructions":
          text:
          - For vmsbc, the borrow is defined to be 1 iff the difference, prior to
            truncation, is negative.
        "#_vector_instruction_listing":
          text:
          - vmsbc
  vmsbc.vvm:
    opcode:
    - vmsbc.vvm
    - 31..26=0x13
    - 25=0
    - vs2
    - vs1
    - 14..12=0x0
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_integer_add_with_carry_subtract_with_borrow_instructions"
    desc:
      v:
        "#_vector_integer_add_with_carry_subtract_with_borrow_instructions":
          text:
          - For vmsbc, the borrow is defined to be 1 iff the difference, prior to
            truncation, is negative.
        "#_vector_instruction_listing":
          text:
          - vmsbc
  vmsbc.vx:
    opcode:
    - vmsbc.vx
    - 31..26=0x13
    - 25=1
    - vs2
    - rs1
    - 14..12=0x4
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_integer_add_with_carry_subtract_with_borrow_instructions"
    desc:
      v:
        "#_vector_integer_add_with_carry_subtract_with_borrow_instructions":
          text:
          - For vmsbc, the borrow is defined to be 1 iff the difference, prior to
            truncation, is negative.
        "#_vector_instruction_listing":
          text:
          - vmsbc
  vmsbc.vxm:
    opcode:
    - vmsbc.vxm
    - 31..26=0x13
    - 25=0
    - vs2
    - rs1
    - 14..12=0x4
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_integer_add_with_carry_subtract_with_borrow_instructions"
    desc:
      v:
        "#_vector_integer_add_with_carry_subtract_with_borrow_instructions":
          text:
          - For vmsbc, the borrow is defined to be 1 iff the difference, prior to
            truncation, is negative.
        "#_vector_instruction_listing":
          text:
          - vmsbc
  vmsbf.m:
    opcode:
    - vmsbf.m
    - 31..26=0x14
    - vm
    - vs2
    - 19..15=0x01
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *31
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#sec-agnostic"
    desc:
      v:
        "#sec-agnostic":
          text:
          - In addition, except for mask load instructions, any element in the tail
            of a mask result can also be written with the value the mask-producing
            operation would have calculated with vl=VLMAX. Furthermore, for mask-logical
            instructions and vmsbf.m, vmsif.m, vmsof.m mask-manipulation instructions,
            any element in the tail of the result can be written with the value the
            mask-producing operation would have calculated with vl=VLEN, SEW=8, and
            LMUL=8 (i.e., all bits of the mask register can be overwritten).
        "#_vmsbf_m_set_before_first_mask_bit":
          text:
          - The vmsbf.m instruction takes a mask register as input and writes results
            to a mask register. The instruction writes a 1 to all active mask elements
            before the first active source element that is a 1, then writes a 0 to
            that element and all following active elements. If there is no set bit
            in the active elements of the source vector, then all active elements
            in the destination are written with a 1.
          - Traps on vmsbf.m are always reported with a vstart of 0. The vmsbf instruction
            will raise an illegal instruction exception if vstart is non-zero.
          - 'vmsbf.m vd, vs2, vm # Example 7 6 5 4 3 2 1 0 Element number 1 0 0 1
            0 1 0 0 v3 contents vmsbf.m v2, v3 0 0 0 0 0 0 1 1 v2 contents 1 0 0 1
            0 1 0 1 v3 contents vmsbf.m v2, v3 0 0 0 0 0 0 0 0 v2 0 0 0 0 0 0 0 0
            v3 contents vmsbf.m v2, v3 1 1 1 1 1 1 1 1 v2 1 1 0 0 0 0 1 1 v0 vcontents
            1 0 0 1 0 1 0 0 v3 contents vmsbf.m v2, v3, v0.t 0 1 x x x x 1 1 v2 contents'
        "#_vector_instruction_listing":
          text:
          - vmsbf
    iss_code:
    - "// vmsbf.m vd, vs2, vm"
    - require(P.VU.vsew >= e8 && P.VU.vsew <= e64);
    - require_vector(true);
    - require(P.VU.vstart->read() == 0);
    - require_vm;
    - require(insn.rd() != insn.rs2());
    - ''
    - reg_t vl = P.VU.vl->read();
    - reg_t rd_num = insn.rd();
    - reg_t rs2_num = insn.rs2();
    - ''
    - bool has_one = false;
    - for (reg_t i = P.VU.vstart->read(); i < vl; ++i) {
    - const int midx = i / 64;
    - const int mpos = i % 64;
    - const uint64_t mmask = UINT64_C(1) << mpos; \
    - ''
    - bool vs2_lsb = ((P.VU.elt<uint64_t>(rs2_num, midx) >> mpos) & 0x1) == 1;
    - bool do_mask = (P.VU.elt<uint64_t>(0, midx) >> mpos) & 0x1;
    - ''
    - ''
    - if (insn.v_vm() == 1 || (insn.v_vm() == 0 && do_mask)) {
    - auto &vd = P.VU.elt<uint64_t>(rd_num, midx, true);
    - uint64_t res = 0;
    - if (!has_one && !vs2_lsb) {
    - res = 1;
    - "} else if (!has_one && vs2_lsb) {"
    - has_one = true;
    - "}"
    - vd = (vd & ~mmask) | ((res << mpos) & mmask);
    - "}"
    - "}"
  vmseq.vi:
    opcode:
    - vmseq.vi
    - 31..26=0x18
    - vm
    - vs2
    - simm5
    - 14..12=0x3
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *30
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_integer_compare_instructions"
    desc:
      v:
        "#_vector_integer_compare_instructions":
          text:
          - "# Set if equal vmseq.vv vd, vs2, vs1, vm # Vector-vector vmseq.vx vd,
            vs2, rs1, vm # vector-scalar vmseq.vi vd, vs2, imm, vm # vector-immediate
            # Set if not equal vmsne.vv vd, vs2, vs1, vm # Vector-vector vmsne.vx
            vd, vs2, rs1, vm # vector-scalar vmsne.vi vd, vs2, imm, vm # vector-immediate
            # Set if less than, unsigned vmsltu.vv vd, vs2, vs1, vm # Vector-vector
            vmsltu.vx vd, vs2, rs1, vm # Vector-scalar # Set if less than, signed
            vmslt.vv vd, vs2, vs1, vm # Vector-vector vmslt.vx vd, vs2, rs1, vm #
            vector-scalar # Set if less than or equal, unsigned vmsleu.vv vd, vs2,
            vs1, vm # Vector-vector vmsleu.vx vd, vs2, rs1, vm # vector-scalar vmsleu.vi
            vd, vs2, imm, vm # Vector-immediate # Set if less than or equal, signed
            vmsle.vv vd, vs2, vs1, vm # Vector-vector vmsle.vx vd, vs2, rs1, vm #
            vector-scalar vmsle.vi vd, vs2, imm, vm # vector-immediate # Set if greater
            than, unsigned vmsgtu.vx vd, vs2, rs1, vm # Vector-scalar vmsgtu.vi vd,
            vs2, imm, vm # Vector-immediate # Set if greater than, signed vmsgt.vx
            vd, vs2, rs1, vm # Vector-scalar vmsgt.vi vd, vs2, imm, vm # Vector-immediate
            # Following two instructions are not provided directly # Set if greater
            than or equal, unsigned # vmsgeu.vx vd, vs2, rs1, vm # Vector-scalar #
            Set if greater than or equal, signed # vmsge.vx vd, vs2, rs1, vm # Vector-scalar"
        "#_vector_instruction_listing":
          text:
          - vmseq
  vmseq.vv:
    opcode:
    - vmseq.vv
    - 31..26=0x18
    - vm
    - vs2
    - vs1
    - 14..12=0x0
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_integer_compare_instructions"
    desc:
      v:
        "#_vector_integer_compare_instructions":
          text:
          - "# Set if equal vmseq.vv vd, vs2, vs1, vm # Vector-vector vmseq.vx vd,
            vs2, rs1, vm # vector-scalar vmseq.vi vd, vs2, imm, vm # vector-immediate
            # Set if not equal vmsne.vv vd, vs2, vs1, vm # Vector-vector vmsne.vx
            vd, vs2, rs1, vm # vector-scalar vmsne.vi vd, vs2, imm, vm # vector-immediate
            # Set if less than, unsigned vmsltu.vv vd, vs2, vs1, vm # Vector-vector
            vmsltu.vx vd, vs2, rs1, vm # Vector-scalar # Set if less than, signed
            vmslt.vv vd, vs2, vs1, vm # Vector-vector vmslt.vx vd, vs2, rs1, vm #
            vector-scalar # Set if less than or equal, unsigned vmsleu.vv vd, vs2,
            vs1, vm # Vector-vector vmsleu.vx vd, vs2, rs1, vm # vector-scalar vmsleu.vi
            vd, vs2, imm, vm # Vector-immediate # Set if less than or equal, signed
            vmsle.vv vd, vs2, vs1, vm # Vector-vector vmsle.vx vd, vs2, rs1, vm #
            vector-scalar vmsle.vi vd, vs2, imm, vm # vector-immediate # Set if greater
            than, unsigned vmsgtu.vx vd, vs2, rs1, vm # Vector-scalar vmsgtu.vi vd,
            vs2, imm, vm # Vector-immediate # Set if greater than, signed vmsgt.vx
            vd, vs2, rs1, vm # Vector-scalar vmsgt.vi vd, vs2, imm, vm # Vector-immediate
            # Following two instructions are not provided directly # Set if greater
            than or equal, unsigned # vmsgeu.vx vd, vs2, rs1, vm # Vector-scalar #
            Set if greater than or equal, signed # vmsge.vx vd, vs2, rs1, vm # Vector-scalar"
        "#_vector_instruction_listing":
          text:
          - vmseq
  vmseq.vx:
    opcode:
    - vmseq.vx
    - 31..26=0x18
    - vm
    - vs2
    - rs1
    - 14..12=0x4
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_integer_compare_instructions"
    desc:
      v:
        "#_vector_integer_compare_instructions":
          text:
          - "# Set if equal vmseq.vv vd, vs2, vs1, vm # Vector-vector vmseq.vx vd,
            vs2, rs1, vm # vector-scalar vmseq.vi vd, vs2, imm, vm # vector-immediate
            # Set if not equal vmsne.vv vd, vs2, vs1, vm # Vector-vector vmsne.vx
            vd, vs2, rs1, vm # vector-scalar vmsne.vi vd, vs2, imm, vm # vector-immediate
            # Set if less than, unsigned vmsltu.vv vd, vs2, vs1, vm # Vector-vector
            vmsltu.vx vd, vs2, rs1, vm # Vector-scalar # Set if less than, signed
            vmslt.vv vd, vs2, vs1, vm # Vector-vector vmslt.vx vd, vs2, rs1, vm #
            vector-scalar # Set if less than or equal, unsigned vmsleu.vv vd, vs2,
            vs1, vm # Vector-vector vmsleu.vx vd, vs2, rs1, vm # vector-scalar vmsleu.vi
            vd, vs2, imm, vm # Vector-immediate # Set if less than or equal, signed
            vmsle.vv vd, vs2, vs1, vm # Vector-vector vmsle.vx vd, vs2, rs1, vm #
            vector-scalar vmsle.vi vd, vs2, imm, vm # vector-immediate # Set if greater
            than, unsigned vmsgtu.vx vd, vs2, rs1, vm # Vector-scalar vmsgtu.vi vd,
            vs2, imm, vm # Vector-immediate # Set if greater than, signed vmsgt.vx
            vd, vs2, rs1, vm # Vector-scalar vmsgt.vi vd, vs2, imm, vm # Vector-immediate
            # Following two instructions are not provided directly # Set if greater
            than or equal, unsigned # vmsgeu.vx vd, vs2, rs1, vm # Vector-scalar #
            Set if greater than or equal, signed # vmsge.vx vd, vs2, rs1, vm # Vector-scalar"
        "#_vector_instruction_listing":
          text:
          - vmseq
  vmsgt.vi:
    opcode:
    - vmsgt.vi
    - 31..26=0x1f
    - vm
    - vs2
    - simm5
    - 14..12=0x3
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *30
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_integer_compare_instructions"
    desc:
      v:
        "#_vector_integer_compare_instructions":
          text:
          - Similarly, vmsge{u}.vi is not provided and the compare is implemented
            using vmsgt{u}.vi with the immediate decremented by one. The resulting
            effective vmsge.vi range is -15 to 16, and the resulting effective vmsgeu.vi
            range is 1 to 16 (Note, vmsgeu.vi with immediate 0 is not useful as it
            is always true).
          - The vmsge{u}.vx operation can be synthesized by reducing the value of
            x by 1 and using the vmsgt{u}.vx instruction, when it is known that this
            will not underflow the representation in x.
          - Sequences to synthesize `vmsge{u}.vx` instruction va >= x, x > minimum
            addi t0, x, -1; vmsgt{u}.vx vd, va, t0, vm
        "#_vector_instruction_listing":
          text:
          - vmsgt
  vmsgt.vx:
    opcode:
    - vmsgt.vx
    - 31..26=0x1f
    - vm
    - vs2
    - rs1
    - 14..12=0x4
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_integer_compare_instructions"
    desc:
      v:
        "#_vector_integer_compare_instructions":
          text:
          - Similarly, vmsge{u}.vi is not provided and the compare is implemented
            using vmsgt{u}.vi with the immediate decremented by one. The resulting
            effective vmsge.vi range is -15 to 16, and the resulting effective vmsgeu.vi
            range is 1 to 16 (Note, vmsgeu.vi with immediate 0 is not useful as it
            is always true).
          - The vmsge{u}.vx operation can be synthesized by reducing the value of
            x by 1 and using the vmsgt{u}.vx instruction, when it is known that this
            will not underflow the representation in x.
          - Sequences to synthesize `vmsge{u}.vx` instruction va >= x, x > minimum
            addi t0, x, -1; vmsgt{u}.vx vd, va, t0, vm
        "#_vector_instruction_listing":
          text:
          - vmsgt
  vmsgtu.vi:
    opcode:
    - vmsgtu.vi
    - 31..26=0x1e
    - vm
    - vs2
    - simm5
    - 14..12=0x3
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *30
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vmsgtu
  vmsgtu.vx:
    opcode:
    - vmsgtu.vx
    - 31..26=0x1e
    - vm
    - vs2
    - rs1
    - 14..12=0x4
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vmsgtu
  vmsif.m:
    opcode:
    - vmsif.m
    - 31..26=0x14
    - vm
    - vs2
    - 19..15=0x03
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *31
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vmsif_m_set_including_first_mask_bit"
    desc:
      v:
        "#_vmsif_m_set_including_first_mask_bit":
          text:
          - Traps on vmsif.m are always reported with a vstart of 0. The vmsif instruction
            will raise an illegal instruction exception if vstart is non-zero.
          - 'vmsif.m vd, vs2, vm # Example 7 6 5 4 3 2 1 0 Element number 1 0 0 1
            0 1 0 0 v3 contents vmsif.m v2, v3 0 0 0 0 0 1 1 1 v2 contents 1 0 0 1
            0 1 0 1 v3 contents vmsif.m v2, v3 0 0 0 0 0 0 0 1 v2 1 1 0 0 0 0 1 1
            v0 vcontents 1 0 0 1 0 1 0 0 v3 contents vmsif.m v2, v3, v0.t 1 1 x x
            x x 1 1 v2 contents'
        "#_vector_instruction_listing":
          text:
          - vmsif
    iss_code:
    - "// vmsif.m rd, vs2, vm"
    - require(P.VU.vsew >= e8 && P.VU.vsew <= e64);
    - require_vector(true);
    - require(P.VU.vstart->read() == 0);
    - require_vm;
    - require(insn.rd() != insn.rs2());
    - ''
    - reg_t vl = P.VU.vl->read();
    - reg_t rd_num = insn.rd();
    - reg_t rs2_num = insn.rs2();
    - ''
    - bool has_one = false;
    - for (reg_t i = P.VU.vstart->read(); i < vl; ++i) {
    - const int midx = i / 64;
    - const int mpos = i % 64;
    - const uint64_t mmask = UINT64_C(1) << mpos; \
    - ''
    - bool vs2_lsb = ((P.VU.elt<uint64_t>(rs2_num, midx ) >> mpos) & 0x1) == 1;
    - bool do_mask = (P.VU.elt<uint64_t>(0, midx) >> mpos) & 0x1;
    - ''
    - if (insn.v_vm() == 1 || (insn.v_vm() == 0 && do_mask)) {
    - auto &vd = P.VU.elt<uint64_t>(rd_num, midx, true);
    - uint64_t res = 0;
    - if (!has_one && !vs2_lsb) {
    - res = 1;
    - "} else if (!has_one && vs2_lsb) {"
    - has_one = true;
    - res = 1;
    - "}"
    - vd = (vd & ~mmask) | ((res << mpos) & mmask);
    - "}"
    - "}"
  vmsle.vi:
    opcode:
    - vmsle.vi
    - 31..26=0x1d
    - vm
    - vs2
    - simm5
    - 14..12=0x3
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *30
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vmsle
  vmsle.vv:
    opcode:
    - vmsle.vv
    - 31..26=0x1d
    - vm
    - vs2
    - vs1
    - 14..12=0x0
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vmsle
  vmsle.vx:
    opcode:
    - vmsle.vx
    - 31..26=0x1d
    - vm
    - vs2
    - rs1
    - 14..12=0x4
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vmsle
  vmsleu.vi:
    opcode:
    - vmsleu.vi
    - 31..26=0x1c
    - vm
    - vs2
    - simm5
    - 14..12=0x3
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *30
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vmsleu
  vmsleu.vv:
    opcode:
    - vmsleu.vv
    - 31..26=0x1c
    - vm
    - vs2
    - vs1
    - 14..12=0x0
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vmsleu
  vmsleu.vx:
    opcode:
    - vmsleu.vx
    - 31..26=0x1c
    - vm
    - vs2
    - rs1
    - 14..12=0x4
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vmsleu
  vmslt.vv:
    opcode:
    - vmslt.vv
    - 31..26=0x1b
    - vm
    - vs2
    - vs1
    - 14..12=0x0
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_integer_compare_instructions"
    desc:
      v:
        "#_vector_integer_compare_instructions":
          text:
          - Comparison Assembler Mapping Assembler Pseudoinstruction va < vb vmslt{u}.vv
            vd, va, vb, vm va <= vb vmsle{u}.vv vd, va, vb, vm va > vb vmslt{u}.vv
            vd, vb, va, vm vmsgt{u}.vv vd, va, vb, vm va >= vb vmsle{u}.vv vd, vb,
            va, vm vmsge{u}.vv vd, va, vb, vm va < x vmslt{u}.vx vd, va, x, vm va
            <= x vmsle{u}.vx vd, va, x, vm va > x vmsgt{u}.vx vd, va, x, vm va >=
            x see below va < i vmsle{u}.vi vd, va, i-1, vm vmslt{u}.vi vd, va, i,
            vm va <= i vmsle{u}.vi vd, va, i, vm va > i vmsgt{u}.vi vd, va, i, vm
            va >= i vmsgt{u}.vi vd, va, i-1, vm vmsge{u}.vi vd, va, i, vm va, vb vector
            register groups x scalar integer register i immediate
          - 'unmasked va >= x pseudoinstruction: vmsge{u}.vx vd, va, x expansion:
            vmslt{u}.vx vd, va, x; vmnand.mm vd, vd, vd masked va >= x, vd != v0 pseudoinstruction:
            vmsge{u}.vx vd, va, x, v0.t expansion: vmslt{u}.vx vd, va, x, v0.t; vmxor.mm
            vd, vd, v0 masked va >= x, vd == v0 pseudoinstruction: vmsge{u}.vx vd,
            va, x, v0.t, vt expansion: vmslt{u}.vx vt, va, x; vmandn.mm vd, vd, vt
            masked va >= x, any vd pseudoinstruction: vmsge{u}.vx vd, va, x, v0.t,
            vt expansion: vmslt{u}.vx vt, va, x; vmandn.mm vt, v0, vt; vmandn.mm vd,
            vd, v0; vmor.mm vd, vt, vd The vt argument to the pseudoinstruction must
            name a temporary vector register that is not same as vd and which will
            be clobbered by the pseudoinstruction'
          - "# (a < b) && (b < c) in two instructions when mask-undisturbed vmslt.vv
            v0, va, vb # All body elements written vmslt.vv v0, vb, vc, v0.t # Only
            update at set mask"
        "#_vector_instruction_listing":
          text:
          - vmslt
  vmslt.vx:
    opcode:
    - vmslt.vx
    - 31..26=0x1b
    - vm
    - vs2
    - rs1
    - 14..12=0x4
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_integer_compare_instructions"
    desc:
      v:
        "#_vector_integer_compare_instructions":
          text:
          - Comparison Assembler Mapping Assembler Pseudoinstruction va < vb vmslt{u}.vv
            vd, va, vb, vm va <= vb vmsle{u}.vv vd, va, vb, vm va > vb vmslt{u}.vv
            vd, vb, va, vm vmsgt{u}.vv vd, va, vb, vm va >= vb vmsle{u}.vv vd, vb,
            va, vm vmsge{u}.vv vd, va, vb, vm va < x vmslt{u}.vx vd, va, x, vm va
            <= x vmsle{u}.vx vd, va, x, vm va > x vmsgt{u}.vx vd, va, x, vm va >=
            x see below va < i vmsle{u}.vi vd, va, i-1, vm vmslt{u}.vi vd, va, i,
            vm va <= i vmsle{u}.vi vd, va, i, vm va > i vmsgt{u}.vi vd, va, i, vm
            va >= i vmsgt{u}.vi vd, va, i-1, vm vmsge{u}.vi vd, va, i, vm va, vb vector
            register groups x scalar integer register i immediate
          - 'unmasked va >= x pseudoinstruction: vmsge{u}.vx vd, va, x expansion:
            vmslt{u}.vx vd, va, x; vmnand.mm vd, vd, vd masked va >= x, vd != v0 pseudoinstruction:
            vmsge{u}.vx vd, va, x, v0.t expansion: vmslt{u}.vx vd, va, x, v0.t; vmxor.mm
            vd, vd, v0 masked va >= x, vd == v0 pseudoinstruction: vmsge{u}.vx vd,
            va, x, v0.t, vt expansion: vmslt{u}.vx vt, va, x; vmandn.mm vd, vd, vt
            masked va >= x, any vd pseudoinstruction: vmsge{u}.vx vd, va, x, v0.t,
            vt expansion: vmslt{u}.vx vt, va, x; vmandn.mm vt, v0, vt; vmandn.mm vd,
            vd, v0; vmor.mm vd, vt, vd The vt argument to the pseudoinstruction must
            name a temporary vector register that is not same as vd and which will
            be clobbered by the pseudoinstruction'
          - "# (a < b) && (b < c) in two instructions when mask-undisturbed vmslt.vv
            v0, va, vb # All body elements written vmslt.vv v0, vb, vc, v0.t # Only
            update at set mask"
        "#_vector_instruction_listing":
          text:
          - vmslt
  vmsltu.vv:
    opcode:
    - vmsltu.vv
    - 31..26=0x1a
    - vm
    - vs2
    - vs1
    - 14..12=0x0
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vmsltu
  vmsltu.vx:
    opcode:
    - vmsltu.vx
    - 31..26=0x1a
    - vm
    - vs2
    - rs1
    - 14..12=0x4
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vmsltu
  vmsne.vi:
    opcode:
    - vmsne.vi
    - 31..26=0x19
    - vm
    - vs2
    - simm5
    - 14..12=0x3
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *30
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vmsne
  vmsne.vv:
    opcode:
    - vmsne.vv
    - 31..26=0x19
    - vm
    - vs2
    - vs1
    - 14..12=0x0
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vmsne
  vmsne.vx:
    opcode:
    - vmsne.vx
    - 31..26=0x19
    - vm
    - vs2
    - rs1
    - 14..12=0x4
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vmsne
  vmsof.m:
    opcode:
    - vmsof.m
    - 31..26=0x14
    - vm
    - vs2
    - 19..15=0x02
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *31
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vmsof_m_set_only_first_mask_bit"
    desc:
      v:
        "#_vmsof_m_set_only_first_mask_bit":
          text:
          - Traps on vmsof.m are always reported with a vstart of 0. The vmsof instruction
            will raise an illegal instruction exception if vstart is non-zero.
          - 'vmsof.m vd, vs2, vm # Example 7 6 5 4 3 2 1 0 Element number 1 0 0 1
            0 1 0 0 v3 contents vmsof.m v2, v3 0 0 0 0 0 1 0 0 v2 contents 1 0 0 1
            0 1 0 1 v3 contents vmsof.m v2, v3 0 0 0 0 0 0 0 1 v2 1 1 0 0 0 0 1 1
            v0 vcontents 1 1 0 1 0 1 0 0 v3 contents vmsof.m v2, v3, v0.t 0 1 x x
            x x 0 0 v2 contents'
        "#_vector_instruction_listing":
          text:
          - vmsof
    iss_code:
    - "// vmsof.m rd, vs2, vm"
    - require(P.VU.vsew >= e8 && P.VU.vsew <= e64);
    - require_vector(true);
    - require(P.VU.vstart->read() == 0);
    - require_vm;
    - require(insn.rd() != insn.rs2());
    - ''
    - reg_t vl = P.VU.vl->read();
    - reg_t rd_num = insn.rd();
    - reg_t rs2_num = insn.rs2();
    - ''
    - bool has_one = false;
    - for (reg_t i = P.VU.vstart->read() ; i < vl; ++i) {
    - const int midx = i / 64;
    - const int mpos = i % 64;
    - const uint64_t mmask = UINT64_C(1) << mpos; \
    - ''
    - bool vs2_lsb = ((P.VU.elt<uint64_t>(rs2_num, midx ) >> mpos) & 0x1) == 1;
    - bool do_mask = (P.VU.elt<uint64_t>(0, midx) >> mpos) & 0x1;
    - ''
    - if (insn.v_vm() == 1 || (insn.v_vm() == 0 && do_mask)) {
    - uint64_t &vd = P.VU.elt<uint64_t>(rd_num, midx, true);
    - uint64_t res = 0;
    - if (!has_one && vs2_lsb) {
    - has_one = true;
    - res = 1;
    - "}"
    - vd = (vd & ~mmask) | ((res << mpos) & mmask);
    - "}"
    - "}"
  vmul.vv:
    opcode:
    - vmul.vv
    - 31..26=0x25
    - vm
    - vs2
    - vs1
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_single_width_integer_multiply_instructions"
    desc:
      v:
        "#_vector_single_width_integer_multiply_instructions":
          text:
          - "# Signed multiply, returning low bits of product vmul.vv vd, vs2, vs1,
            vm # Vector-vector vmul.vx vd, vs2, rs1, vm # vector-scalar # Signed multiply,
            returning high bits of product vmulh.vv vd, vs2, vs1, vm # Vector-vector
            vmulh.vx vd, vs2, rs1, vm # vector-scalar # Unsigned multiply, returning
            high bits of product vmulhu.vv vd, vs2, vs1, vm # Vector-vector vmulhu.vx
            vd, vs2, rs1, vm # vector-scalar # Signed(vs2)-Unsigned multiply, returning
            high bits of product vmulhsu.vv vd, vs2, vs1, vm # Vector-vector vmulhsu.vx
            vd, vs2, rs1, vm # vector-scalar"
        "#_vector_instruction_listing":
          text:
          - vmul
  vmul.vx:
    opcode:
    - vmul.vx
    - 31..26=0x25
    - vm
    - vs2
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_single_width_integer_multiply_instructions"
    desc:
      v:
        "#_vector_single_width_integer_multiply_instructions":
          text:
          - "# Signed multiply, returning low bits of product vmul.vv vd, vs2, vs1,
            vm # Vector-vector vmul.vx vd, vs2, rs1, vm # vector-scalar # Signed multiply,
            returning high bits of product vmulh.vv vd, vs2, vs1, vm # Vector-vector
            vmulh.vx vd, vs2, rs1, vm # vector-scalar # Unsigned multiply, returning
            high bits of product vmulhu.vv vd, vs2, vs1, vm # Vector-vector vmulhu.vx
            vd, vs2, rs1, vm # vector-scalar # Signed(vs2)-Unsigned multiply, returning
            high bits of product vmulhsu.vv vd, vs2, vs1, vm # Vector-vector vmulhsu.vx
            vd, vs2, rs1, vm # vector-scalar"
        "#_vector_instruction_listing":
          text:
          - vmul
  vmulh.vv:
    opcode:
    - vmulh.vv
    - 31..26=0x27
    - vm
    - vs2
    - vs1
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_zve_vector_extensions_for_embedded_processors"
    desc:
      v:
        "#_zve_vector_extensions_for_embedded_processors":
          text:
          - All Zve* extensions support all vector integer instructions (Section Vector
            Integer Arithmetic Instructions ), except that the vmulh integer multiply
            variants that return the high word of the product (vmulh.vv, vmulh.vx,
            vmulhu.vv, vmulhu.vx, vmulhsu.vv, vmulhsu.vx) are not included for EEW=64
            in Zve64*.
        "#_vector_instruction_listing":
          text:
          - vmulh
  vmulh.vx:
    opcode:
    - vmulh.vx
    - 31..26=0x27
    - vm
    - vs2
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_zve_vector_extensions_for_embedded_processors"
    desc:
      v:
        "#_zve_vector_extensions_for_embedded_processors":
          text:
          - All Zve* extensions support all vector integer instructions (Section Vector
            Integer Arithmetic Instructions ), except that the vmulh integer multiply
            variants that return the high word of the product (vmulh.vv, vmulh.vx,
            vmulhu.vv, vmulhu.vx, vmulhsu.vv, vmulhsu.vx) are not included for EEW=64
            in Zve64*.
        "#_vector_instruction_listing":
          text:
          - vmulh
  vmulhsu.vv:
    opcode:
    - vmulhsu.vv
    - 31..26=0x26
    - vm
    - vs2
    - vs1
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vmulhsu
  vmulhsu.vx:
    opcode:
    - vmulhsu.vx
    - 31..26=0x26
    - vm
    - vs2
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vmulhsu
  vmulhu.vv:
    opcode:
    - vmulhu.vv
    - 31..26=0x24
    - vm
    - vs2
    - vs1
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vmulhu
  vmulhu.vx:
    opcode:
    - vmulhu.vx
    - 31..26=0x24
    - vm
    - vs2
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vmulhu
  vmv.s.x:
    opcode:
    - vmv.s.x
    - 31..26=0x10
    - 25=1
    - 24..20=0
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *33
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_integer_move_instructions"
    desc:
      v:
        "#_vector_integer_move_instructions":
          text:
          - The vector integer move instructions copy a source operand to a vector
            register group. The vmv.v.v variant copies a vector register group, whereas
            the vmv.v.x and vmv.v.i variants splat a scalar register or immediate
            to all active elements of the destination vector register group. These
            instructions are encoded as unmasked instructions (vm=1). The first operand
            specifier (vs2) must contain v0, and any other vector register number
            in vs2 is reserved.
          - The form vmv.v.v vd, vd, which leaves body elements unchanged, can be
            used to indicate that the register will next be used with an EEW equal
            to SEW.
          - 'vmv.v.v vd, vs1 # vd[i] = vs1[i] vmv.v.x vd, rs1 # vd[i] = x[rs1] vmv.v.i
            vd, imm # vd[i] = imm'
        "#_integer_scalar_move_instructions":
          text:
          - The vmv.x.s instruction copies a single SEW-wide element from index 0
            of the source vector register to a destination integer register. If SEW
            > XLEN, the least-significant XLEN bits are transferred and the upper
            SEW-XLEN bits are ignored. If SEW < XLEN, the value is sign-extended to
            XLEN bits.
          - The vmv.s.x instruction copies the scalar integer register to element
            0 of the destination vector register. If SEW < XLEN, the least-significant
            bits are copied and the upper XLEN-SEW bits are ignored. If SEW > XLEN,
            the value is sign-extended to SEW bits. The other elements in the destination
            vector register ( 0 < index < VLEN/SEW) are treated as tail elements using
            the current tail agnostic/undisturbed policy. If vstart >= vl, no operation
            is performed and the destination register is not updated.
          - The encodings corresponding to the masked versions (vm=0) of vmv.x.s and
            vmv.s.x are reserved.
          - 'vmv.x.s rd, vs2 # x[rd] = vs2[0] (vs1=0) vmv.s.x vd, rs1 # vd[0] = x[rs1]
            (vs2=0)'
        "#_whole_vector_register_move":
          text:
          - The vmv<nr>r.v instructions copy whole vector registers (i.e., all VLEN
            bits) and can copy whole vector register groups. The nr value in the opcode
            is the number of individual vector registers, NREG, to copy. The instructions
            operate as if EEW=SEW, EMUL = NREG, effective length evl= EMUL * VLEN/SEW.
          - 'vmv<nr>r.v vd, vs2 # General form vmv1r.v v1, v2 # Copy v1=v2 vmv2r.v
            v10, v12 # Copy v10=v12; v11=v13 vmv4r.v v4, v8 # Copy v4=v8; v5=v9; v6=v10;
            v7=v11 vmv8r.v v0, v8 # Copy v0=v8; v1=v9; ...; v7=v15'
        "#_vector_instruction_listing":
          text:
          - vmv<nr>r
          - vmv.s.x
          - vmv.x.s
  vmv.v.i:
    opcode:
    - vmv.v.i
    - 31..26=0x17
    - 25=1
    - 24..20=0
    - simm5
    - 14..12=0x3
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: &45
    - simm5
    - vd
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_integer_move_instructions"
    desc:
      v:
        "#_vector_integer_move_instructions":
          text:
          - The vector integer move instructions copy a source operand to a vector
            register group. The vmv.v.v variant copies a vector register group, whereas
            the vmv.v.x and vmv.v.i variants splat a scalar register or immediate
            to all active elements of the destination vector register group. These
            instructions are encoded as unmasked instructions (vm=1). The first operand
            specifier (vs2) must contain v0, and any other vector register number
            in vs2 is reserved.
          - The form vmv.v.v vd, vd, which leaves body elements unchanged, can be
            used to indicate that the register will next be used with an EEW equal
            to SEW.
          - 'vmv.v.v vd, vs1 # vd[i] = vs1[i] vmv.v.x vd, rs1 # vd[i] = x[rs1] vmv.v.i
            vd, imm # vd[i] = imm'
        "#_integer_scalar_move_instructions":
          text:
          - The vmv.x.s instruction copies a single SEW-wide element from index 0
            of the source vector register to a destination integer register. If SEW
            > XLEN, the least-significant XLEN bits are transferred and the upper
            SEW-XLEN bits are ignored. If SEW < XLEN, the value is sign-extended to
            XLEN bits.
          - The vmv.s.x instruction copies the scalar integer register to element
            0 of the destination vector register. If SEW < XLEN, the least-significant
            bits are copied and the upper XLEN-SEW bits are ignored. If SEW > XLEN,
            the value is sign-extended to SEW bits. The other elements in the destination
            vector register ( 0 < index < VLEN/SEW) are treated as tail elements using
            the current tail agnostic/undisturbed policy. If vstart >= vl, no operation
            is performed and the destination register is not updated.
          - The encodings corresponding to the masked versions (vm=0) of vmv.x.s and
            vmv.s.x are reserved.
          - 'vmv.x.s rd, vs2 # x[rd] = vs2[0] (vs1=0) vmv.s.x vd, rs1 # vd[0] = x[rs1]
            (vs2=0)'
        "#_whole_vector_register_move":
          text:
          - The vmv<nr>r.v instructions copy whole vector registers (i.e., all VLEN
            bits) and can copy whole vector register groups. The nr value in the opcode
            is the number of individual vector registers, NREG, to copy. The instructions
            operate as if EEW=SEW, EMUL = NREG, effective length evl= EMUL * VLEN/SEW.
          - 'vmv<nr>r.v vd, vs2 # General form vmv1r.v v1, v2 # Copy v1=v2 vmv2r.v
            v10, v12 # Copy v10=v12; v11=v13 vmv4r.v v4, v8 # Copy v4=v8; v5=v9; v6=v10;
            v7=v11 vmv8r.v v0, v8 # Copy v0=v8; v1=v9; ...; v7=v15'
        "#_vector_instruction_listing":
          text:
          - vmv<nr>r
          - vmv.s.x
          - vmv.x.s
  vmv.v.v:
    opcode:
    - vmv.v.v
    - 31..26=0x17
    - 25=1
    - 24..20=0
    - vs1
    - 14..12=0x0
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: &55
    - vs1
    - vd
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_integer_move_instructions"
    desc:
      v:
        "#_vector_integer_move_instructions":
          text:
          - The vector integer move instructions copy a source operand to a vector
            register group. The vmv.v.v variant copies a vector register group, whereas
            the vmv.v.x and vmv.v.i variants splat a scalar register or immediate
            to all active elements of the destination vector register group. These
            instructions are encoded as unmasked instructions (vm=1). The first operand
            specifier (vs2) must contain v0, and any other vector register number
            in vs2 is reserved.
          - The form vmv.v.v vd, vd, which leaves body elements unchanged, can be
            used to indicate that the register will next be used with an EEW equal
            to SEW.
          - 'vmv.v.v vd, vs1 # vd[i] = vs1[i] vmv.v.x vd, rs1 # vd[i] = x[rs1] vmv.v.i
            vd, imm # vd[i] = imm'
        "#_integer_scalar_move_instructions":
          text:
          - The vmv.x.s instruction copies a single SEW-wide element from index 0
            of the source vector register to a destination integer register. If SEW
            > XLEN, the least-significant XLEN bits are transferred and the upper
            SEW-XLEN bits are ignored. If SEW < XLEN, the value is sign-extended to
            XLEN bits.
          - The vmv.s.x instruction copies the scalar integer register to element
            0 of the destination vector register. If SEW < XLEN, the least-significant
            bits are copied and the upper XLEN-SEW bits are ignored. If SEW > XLEN,
            the value is sign-extended to SEW bits. The other elements in the destination
            vector register ( 0 < index < VLEN/SEW) are treated as tail elements using
            the current tail agnostic/undisturbed policy. If vstart >= vl, no operation
            is performed and the destination register is not updated.
          - The encodings corresponding to the masked versions (vm=0) of vmv.x.s and
            vmv.s.x are reserved.
          - 'vmv.x.s rd, vs2 # x[rd] = vs2[0] (vs1=0) vmv.s.x vd, rs1 # vd[0] = x[rs1]
            (vs2=0)'
        "#_whole_vector_register_move":
          text:
          - The vmv<nr>r.v instructions copy whole vector registers (i.e., all VLEN
            bits) and can copy whole vector register groups. The nr value in the opcode
            is the number of individual vector registers, NREG, to copy. The instructions
            operate as if EEW=SEW, EMUL = NREG, effective length evl= EMUL * VLEN/SEW.
          - 'vmv<nr>r.v vd, vs2 # General form vmv1r.v v1, v2 # Copy v1=v2 vmv2r.v
            v10, v12 # Copy v10=v12; v11=v13 vmv4r.v v4, v8 # Copy v4=v8; v5=v9; v6=v10;
            v7=v11 vmv8r.v v0, v8 # Copy v0=v8; v1=v9; ...; v7=v15'
        "#_vector_instruction_listing":
          text:
          - vmv<nr>r
          - vmv.s.x
          - vmv.x.s
  vmv.v.x:
    opcode:
    - vmv.v.x
    - 31..26=0x17
    - 25=1
    - 24..20=0
    - rs1
    - 14..12=0x4
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *33
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_integer_move_instructions"
    desc:
      v:
        "#_vector_integer_move_instructions":
          text:
          - The vector integer move instructions copy a source operand to a vector
            register group. The vmv.v.v variant copies a vector register group, whereas
            the vmv.v.x and vmv.v.i variants splat a scalar register or immediate
            to all active elements of the destination vector register group. These
            instructions are encoded as unmasked instructions (vm=1). The first operand
            specifier (vs2) must contain v0, and any other vector register number
            in vs2 is reserved.
          - The form vmv.v.v vd, vd, which leaves body elements unchanged, can be
            used to indicate that the register will next be used with an EEW equal
            to SEW.
          - 'vmv.v.v vd, vs1 # vd[i] = vs1[i] vmv.v.x vd, rs1 # vd[i] = x[rs1] vmv.v.i
            vd, imm # vd[i] = imm'
        "#_integer_scalar_move_instructions":
          text:
          - The vmv.x.s instruction copies a single SEW-wide element from index 0
            of the source vector register to a destination integer register. If SEW
            > XLEN, the least-significant XLEN bits are transferred and the upper
            SEW-XLEN bits are ignored. If SEW < XLEN, the value is sign-extended to
            XLEN bits.
          - The vmv.s.x instruction copies the scalar integer register to element
            0 of the destination vector register. If SEW < XLEN, the least-significant
            bits are copied and the upper XLEN-SEW bits are ignored. If SEW > XLEN,
            the value is sign-extended to SEW bits. The other elements in the destination
            vector register ( 0 < index < VLEN/SEW) are treated as tail elements using
            the current tail agnostic/undisturbed policy. If vstart >= vl, no operation
            is performed and the destination register is not updated.
          - The encodings corresponding to the masked versions (vm=0) of vmv.x.s and
            vmv.s.x are reserved.
          - 'vmv.x.s rd, vs2 # x[rd] = vs2[0] (vs1=0) vmv.s.x vd, rs1 # vd[0] = x[rs1]
            (vs2=0)'
        "#_whole_vector_register_move":
          text:
          - The vmv<nr>r.v instructions copy whole vector registers (i.e., all VLEN
            bits) and can copy whole vector register groups. The nr value in the opcode
            is the number of individual vector registers, NREG, to copy. The instructions
            operate as if EEW=SEW, EMUL = NREG, effective length evl= EMUL * VLEN/SEW.
          - 'vmv<nr>r.v vd, vs2 # General form vmv1r.v v1, v2 # Copy v1=v2 vmv2r.v
            v10, v12 # Copy v10=v12; v11=v13 vmv4r.v v4, v8 # Copy v4=v8; v5=v9; v6=v10;
            v7=v11 vmv8r.v v0, v8 # Copy v0=v8; v1=v9; ...; v7=v15'
        "#_vector_instruction_listing":
          text:
          - vmv<nr>r
          - vmv.s.x
          - vmv.x.s
  vmv.x.s:
    opcode:
    - vmv.x.s
    - 31..26=0x10
    - 25=1
    - vs2
    - 19..15=0
    - 14..12=0x2
    - rd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *32
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_integer_move_instructions"
    desc:
      v:
        "#_vector_integer_move_instructions":
          text:
          - The vector integer move instructions copy a source operand to a vector
            register group. The vmv.v.v variant copies a vector register group, whereas
            the vmv.v.x and vmv.v.i variants splat a scalar register or immediate
            to all active elements of the destination vector register group. These
            instructions are encoded as unmasked instructions (vm=1). The first operand
            specifier (vs2) must contain v0, and any other vector register number
            in vs2 is reserved.
          - The form vmv.v.v vd, vd, which leaves body elements unchanged, can be
            used to indicate that the register will next be used with an EEW equal
            to SEW.
          - 'vmv.v.v vd, vs1 # vd[i] = vs1[i] vmv.v.x vd, rs1 # vd[i] = x[rs1] vmv.v.i
            vd, imm # vd[i] = imm'
        "#_integer_scalar_move_instructions":
          text:
          - The vmv.x.s instruction copies a single SEW-wide element from index 0
            of the source vector register to a destination integer register. If SEW
            > XLEN, the least-significant XLEN bits are transferred and the upper
            SEW-XLEN bits are ignored. If SEW < XLEN, the value is sign-extended to
            XLEN bits.
          - The vmv.s.x instruction copies the scalar integer register to element
            0 of the destination vector register. If SEW < XLEN, the least-significant
            bits are copied and the upper XLEN-SEW bits are ignored. If SEW > XLEN,
            the value is sign-extended to SEW bits. The other elements in the destination
            vector register ( 0 < index < VLEN/SEW) are treated as tail elements using
            the current tail agnostic/undisturbed policy. If vstart >= vl, no operation
            is performed and the destination register is not updated.
          - The encodings corresponding to the masked versions (vm=0) of vmv.x.s and
            vmv.s.x are reserved.
          - 'vmv.x.s rd, vs2 # x[rd] = vs2[0] (vs1=0) vmv.s.x vd, rs1 # vd[0] = x[rs1]
            (vs2=0)'
        "#_whole_vector_register_move":
          text:
          - The vmv<nr>r.v instructions copy whole vector registers (i.e., all VLEN
            bits) and can copy whole vector register groups. The nr value in the opcode
            is the number of individual vector registers, NREG, to copy. The instructions
            operate as if EEW=SEW, EMUL = NREG, effective length evl= EMUL * VLEN/SEW.
          - 'vmv<nr>r.v vd, vs2 # General form vmv1r.v v1, v2 # Copy v1=v2 vmv2r.v
            v10, v12 # Copy v10=v12; v11=v13 vmv4r.v v4, v8 # Copy v4=v8; v5=v9; v6=v10;
            v7=v11 vmv8r.v v0, v8 # Copy v0=v8; v1=v9; ...; v7=v15'
        "#_vector_instruction_listing":
          text:
          - vmv<nr>r
          - vmv.s.x
          - vmv.x.s
  vmv1r.v:
    opcode:
    - vmv1r.v
    - 31..26=0x27
    - 25=1
    - vs2
    - 19..15=0
    - 14..12=0x3
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *31
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
    iss_code:
    - "// vmv1r.v vd, vs2"
    - '#include "vmvnfr_v.h"'
  vmv2r.v:
    opcode:
    - vmv2r.v
    - 31..26=0x27
    - 25=1
    - vs2
    - 19..15=1
    - 14..12=0x3
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *31
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
    iss_code:
    - "// vmv2r.v vd, vs2"
    - '#include "vmvnfr_v.h"'
  vmv4r.v:
    opcode:
    - vmv4r.v
    - 31..26=0x27
    - 25=1
    - vs2
    - 19..15=3
    - 14..12=0x3
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *31
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
    iss_code:
    - "// vmv4r.v vd, vs2"
    - '#include "vmvnfr_v.h"'
  vmv8r.v:
    opcode:
    - vmv8r.v
    - 31..26=0x27
    - 25=1
    - vs2
    - 19..15=7
    - 14..12=0x3
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *31
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
    iss_code:
    - "// vmv8r.v vd, vs2"
    - '#include "vmvnfr_v.h"'
  vmxnor.mm:
    opcode:
    - vmxnor.mm
    - 31..26=0x1f
    - 25=1
    - vs2
    - vs1
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#sec-mask-register-logical"
    desc:
      v:
        "#sec-mask-register-logical":
          text:
          - vmxnor.mm vd, src1, src2
          - vmxnor.mm vd, vd, vd
        "#_vector_instruction_listing":
          text:
          - vmxnor
  vmxor.mm:
    opcode:
    - vmxor.mm
    - 31..26=0x1b
    - 25=1
    - vs2
    - vs1
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#sec-mask-register-logical"
    desc:
      v:
        "#sec-mask-register-logical":
          text:
          - vmxor.mm vd, vd, vd
          - vmxor.mm vd, src1, src2
        "#_vector_instruction_listing":
          text:
          - vmxor
  vnclip.wi:
    opcode:
    - vnclip.wi
    - 31..26=0x2f
    - vm
    - vs2
    - simm5
    - 14..12=0x3
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *30
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_narrowing_fixed_point_clip_instructions"
    desc:
      v:
        "#_vector_narrowing_fixed_point_clip_instructions":
          text:
          - The vnclip instructions are used to pack a fixed-point value into a narrower
            destination. The instructions support rounding, scaling, and saturation
            into the final destination format. The source data is in the vector register
            group specified by vs2. The scaling shift amount value can come from a
            vector register group vs1, a scalar integer register rs1, or a zero-extended
            5-bit immediate. The low lg2(2*SEW) bits of the vector or scalar shift-amount
            value (e.g., the low 6 bits for a SEW=64-bit to SEW=32-bit narrowing operation)
            are used to control the right shift amount, which provides the scaling.
          - For vnclip, the shifted rounded source value is treated as a signed integer
            and saturates if the result would overflow the destination viewed as a
            signed integer.
        "#_vector_instruction_listing":
          text:
          - vnclip
  vnclip.wv:
    opcode:
    - vnclip.wv
    - 31..26=0x2f
    - vm
    - vs2
    - vs1
    - 14..12=0x0
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_narrowing_fixed_point_clip_instructions"
    desc:
      v:
        "#_vector_narrowing_fixed_point_clip_instructions":
          text:
          - The vnclip instructions are used to pack a fixed-point value into a narrower
            destination. The instructions support rounding, scaling, and saturation
            into the final destination format. The source data is in the vector register
            group specified by vs2. The scaling shift amount value can come from a
            vector register group vs1, a scalar integer register rs1, or a zero-extended
            5-bit immediate. The low lg2(2*SEW) bits of the vector or scalar shift-amount
            value (e.g., the low 6 bits for a SEW=64-bit to SEW=32-bit narrowing operation)
            are used to control the right shift amount, which provides the scaling.
          - For vnclip, the shifted rounded source value is treated as a signed integer
            and saturates if the result would overflow the destination viewed as a
            signed integer.
        "#_vector_instruction_listing":
          text:
          - vnclip
  vnclip.wx:
    opcode:
    - vnclip.wx
    - 31..26=0x2f
    - vm
    - vs2
    - rs1
    - 14..12=0x4
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_narrowing_fixed_point_clip_instructions"
    desc:
      v:
        "#_vector_narrowing_fixed_point_clip_instructions":
          text:
          - The vnclip instructions are used to pack a fixed-point value into a narrower
            destination. The instructions support rounding, scaling, and saturation
            into the final destination format. The source data is in the vector register
            group specified by vs2. The scaling shift amount value can come from a
            vector register group vs1, a scalar integer register rs1, or a zero-extended
            5-bit immediate. The low lg2(2*SEW) bits of the vector or scalar shift-amount
            value (e.g., the low 6 bits for a SEW=64-bit to SEW=32-bit narrowing operation)
            are used to control the right shift amount, which provides the scaling.
          - For vnclip, the shifted rounded source value is treated as a signed integer
            and saturates if the result would overflow the destination viewed as a
            signed integer.
        "#_vector_instruction_listing":
          text:
          - vnclip
  vnclipu.wi:
    opcode:
    - vnclipu.wi
    - 31..26=0x2e
    - vm
    - vs2
    - simm5
    - 14..12=0x3
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *30
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_narrowing_fixed_point_clip_instructions"
    desc:
      v:
        "#_vector_narrowing_fixed_point_clip_instructions":
          text:
          - For vnclipu/vnclip, the rounding mode is specified in the vxrm CSR. Rounding
            occurs around the least-significant bit of the destination and before
            saturation.
          - For vnclipu, the shifted rounded source value is treated as an unsigned
            integer and saturates if the result would overflow the destination viewed
            as an unsigned integer.
          - "# Narrowing unsigned clip # SEW 2*SEW SEW vnclipu.wv vd, vs2, vs1, vm
            # vd[i] = clip(roundoff_unsigned(vs2[i], vs1[i])) vnclipu.wx vd, vs2,
            rs1, vm # vd[i] = clip(roundoff_unsigned(vs2[i], x[rs1])) vnclipu.wi vd,
            vs2, uimm, vm # vd[i] = clip(roundoff_unsigned(vs2[i], uimm)) # Narrowing
            signed clip vnclip.wv vd, vs2, vs1, vm # vd[i] = clip(roundoff_signed(vs2[i],
            vs1[i])) vnclip.wx vd, vs2, rs1, vm # vd[i] = clip(roundoff_signed(vs2[i],
            x[rs1])) vnclip.wi vd, vs2, uimm, vm # vd[i] = clip(roundoff_signed(vs2[i],
            uimm))"
        "#_vector_instruction_listing":
          text:
          - vnclipu
  vnclipu.wv:
    opcode:
    - vnclipu.wv
    - 31..26=0x2e
    - vm
    - vs2
    - vs1
    - 14..12=0x0
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_narrowing_fixed_point_clip_instructions"
    desc:
      v:
        "#_vector_narrowing_fixed_point_clip_instructions":
          text:
          - For vnclipu/vnclip, the rounding mode is specified in the vxrm CSR. Rounding
            occurs around the least-significant bit of the destination and before
            saturation.
          - For vnclipu, the shifted rounded source value is treated as an unsigned
            integer and saturates if the result would overflow the destination viewed
            as an unsigned integer.
          - "# Narrowing unsigned clip # SEW 2*SEW SEW vnclipu.wv vd, vs2, vs1, vm
            # vd[i] = clip(roundoff_unsigned(vs2[i], vs1[i])) vnclipu.wx vd, vs2,
            rs1, vm # vd[i] = clip(roundoff_unsigned(vs2[i], x[rs1])) vnclipu.wi vd,
            vs2, uimm, vm # vd[i] = clip(roundoff_unsigned(vs2[i], uimm)) # Narrowing
            signed clip vnclip.wv vd, vs2, vs1, vm # vd[i] = clip(roundoff_signed(vs2[i],
            vs1[i])) vnclip.wx vd, vs2, rs1, vm # vd[i] = clip(roundoff_signed(vs2[i],
            x[rs1])) vnclip.wi vd, vs2, uimm, vm # vd[i] = clip(roundoff_signed(vs2[i],
            uimm))"
        "#_vector_instruction_listing":
          text:
          - vnclipu
  vnclipu.wx:
    opcode:
    - vnclipu.wx
    - 31..26=0x2e
    - vm
    - vs2
    - rs1
    - 14..12=0x4
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_narrowing_fixed_point_clip_instructions"
    desc:
      v:
        "#_vector_narrowing_fixed_point_clip_instructions":
          text:
          - For vnclipu/vnclip, the rounding mode is specified in the vxrm CSR. Rounding
            occurs around the least-significant bit of the destination and before
            saturation.
          - For vnclipu, the shifted rounded source value is treated as an unsigned
            integer and saturates if the result would overflow the destination viewed
            as an unsigned integer.
          - "# Narrowing unsigned clip # SEW 2*SEW SEW vnclipu.wv vd, vs2, vs1, vm
            # vd[i] = clip(roundoff_unsigned(vs2[i], vs1[i])) vnclipu.wx vd, vs2,
            rs1, vm # vd[i] = clip(roundoff_unsigned(vs2[i], x[rs1])) vnclipu.wi vd,
            vs2, uimm, vm # vd[i] = clip(roundoff_unsigned(vs2[i], uimm)) # Narrowing
            signed clip vnclip.wv vd, vs2, vs1, vm # vd[i] = clip(roundoff_signed(vs2[i],
            vs1[i])) vnclip.wx vd, vs2, rs1, vm # vd[i] = clip(roundoff_signed(vs2[i],
            x[rs1])) vnclip.wi vd, vs2, uimm, vm # vd[i] = clip(roundoff_signed(vs2[i],
            uimm))"
        "#_vector_instruction_listing":
          text:
          - vnclipu
  vnmsac.vv:
    opcode:
    - vnmsac.vv
    - 31..26=0x2f
    - vm
    - vs2
    - vs1
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vnmsac
  vnmsac.vx:
    opcode:
    - vnmsac.vx
    - 31..26=0x2f
    - vm
    - vs2
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vnmsac
  vnmsub.vv:
    opcode:
    - vnmsub.vv
    - 31..26=0x2b
    - vm
    - vs2
    - vs1
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vnmsub
  vnmsub.vx:
    opcode:
    - vnmsub.vx
    - 31..26=0x2b
    - vm
    - vs2
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vnmsub
  vnsra.wi:
    opcode:
    - vnsra.wi
    - 31..26=0x2d
    - vm
    - vs2
    - simm5
    - 14..12=0x3
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *30
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#sec-narrowing"
    desc:
      v:
        "#sec-narrowing":
          text:
          - A vn* prefix on the opcode is used to distinguish these instructions in
            the assembler, or a vfn* prefix for narrowing floating-point opcodes.
            The double-width source vector register group is signified by a w in the
            source operand suffix (e.g., vnsra.wv)
        "#_vector_instruction_listing":
          text:
          - vnsra
  vnsra.wv:
    opcode:
    - vnsra.wv
    - 31..26=0x2d
    - vm
    - vs2
    - vs1
    - 14..12=0x0
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#sec-narrowing"
    desc:
      v:
        "#sec-narrowing":
          text:
          - A vn* prefix on the opcode is used to distinguish these instructions in
            the assembler, or a vfn* prefix for narrowing floating-point opcodes.
            The double-width source vector register group is signified by a w in the
            source operand suffix (e.g., vnsra.wv)
        "#_vector_instruction_listing":
          text:
          - vnsra
  vnsra.wx:
    opcode:
    - vnsra.wx
    - 31..26=0x2d
    - vm
    - vs2
    - rs1
    - 14..12=0x4
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#sec-narrowing"
    desc:
      v:
        "#sec-narrowing":
          text:
          - A vn* prefix on the opcode is used to distinguish these instructions in
            the assembler, or a vfn* prefix for narrowing floating-point opcodes.
            The double-width source vector register group is signified by a w in the
            source operand suffix (e.g., vnsra.wv)
        "#_vector_instruction_listing":
          text:
          - vnsra
  vnsrl.wi:
    opcode:
    - vnsrl.wi
    - 31..26=0x2c
    - vm
    - vs2
    - simm5
    - 14..12=0x3
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *30
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#sec-vec-operands"
    desc:
      v:
        "#sec-vec-operands":
          text:
          - The destination EEW is smaller than the source EEW and the overlap is
            in the lowest-numbered part of the source register group (e.g., when LMUL=1,
            vnsrl.wi v0, v0, 3 is legal, but a destination of v1 is not).
        "#_vector_narrowing_integer_right_shift_instructions":
          text:
          - "# Narrowing shift right logical, SEW = (2*SEW) >> SEW vnsrl.wv vd, vs2,
            vs1, vm # vector-vector vnsrl.wx vd, vs2, rs1, vm # vector-scalar vnsrl.wi
            vd, vs2, uimm, vm # vector-immediate # Narrowing shift right arithmetic,
            SEW = (2*SEW) >> SEW vnsra.wv vd, vs2, vs1, vm # vector-vector vnsra.wx
            vd, vs2, rs1, vm # vector-scalar vnsra.wi vd, vs2, uimm, vm # vector-immediate"
        "#_vector_instruction_listing":
          text:
          - vnsrl
  vnsrl.wv:
    opcode:
    - vnsrl.wv
    - 31..26=0x2c
    - vm
    - vs2
    - vs1
    - 14..12=0x0
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#sec-vec-operands"
    desc:
      v:
        "#sec-vec-operands":
          text:
          - The destination EEW is smaller than the source EEW and the overlap is
            in the lowest-numbered part of the source register group (e.g., when LMUL=1,
            vnsrl.wi v0, v0, 3 is legal, but a destination of v1 is not).
        "#_vector_narrowing_integer_right_shift_instructions":
          text:
          - "# Narrowing shift right logical, SEW = (2*SEW) >> SEW vnsrl.wv vd, vs2,
            vs1, vm # vector-vector vnsrl.wx vd, vs2, rs1, vm # vector-scalar vnsrl.wi
            vd, vs2, uimm, vm # vector-immediate # Narrowing shift right arithmetic,
            SEW = (2*SEW) >> SEW vnsra.wv vd, vs2, vs1, vm # vector-vector vnsra.wx
            vd, vs2, rs1, vm # vector-scalar vnsra.wi vd, vs2, uimm, vm # vector-immediate"
        "#_vector_instruction_listing":
          text:
          - vnsrl
  vnsrl.wx:
    opcode:
    - vnsrl.wx
    - 31..26=0x2c
    - vm
    - vs2
    - rs1
    - 14..12=0x4
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#sec-vec-operands"
    desc:
      v:
        "#sec-vec-operands":
          text:
          - The destination EEW is smaller than the source EEW and the overlap is
            in the lowest-numbered part of the source register group (e.g., when LMUL=1,
            vnsrl.wi v0, v0, 3 is legal, but a destination of v1 is not).
        "#_vector_narrowing_integer_right_shift_instructions":
          text:
          - "# Narrowing shift right logical, SEW = (2*SEW) >> SEW vnsrl.wv vd, vs2,
            vs1, vm # vector-vector vnsrl.wx vd, vs2, rs1, vm # vector-scalar vnsrl.wi
            vd, vs2, uimm, vm # vector-immediate # Narrowing shift right arithmetic,
            SEW = (2*SEW) >> SEW vnsra.wv vd, vs2, vs1, vm # vector-vector vnsra.wx
            vd, vs2, rs1, vm # vector-scalar vnsra.wi vd, vs2, uimm, vm # vector-immediate"
        "#_vector_instruction_listing":
          text:
          - vnsrl
  vor.vi:
    opcode:
    - vor.vi
    - 31..26=0x0a
    - vm
    - vs2
    - simm5
    - 14..12=0x3
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *30
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vor
  vor.vv:
    opcode:
    - vor.vv
    - 31..26=0x0a
    - vm
    - vs2
    - vs1
    - 14..12=0x0
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vor
  vor.vx:
    opcode:
    - vor.vx
    - 31..26=0x0a
    - vm
    - vs2
    - rs1
    - 14..12=0x4
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vor
  vpopc.m:
    opcode:
    - vpopc.m
    - 31..26=0x10
    - vm
    - vs2
    - 19..15=0x10
    - 14..12=0x2
    - rd
    - 6..0=0x57
    opcode_group: v_aliases
    opcode_args: *32
    pseudo_src: rv_v
    pseudo_op: vcpop.m
  vredand.vs:
    opcode:
    - vredand.vs
    - 31..26=0x01
    - vm
    - vs2
    - vs1
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vredand
  vredmax.vs:
    opcode:
    - vredmax.vs
    - 31..26=0x07
    - vm
    - vs2
    - vs1
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vredmax
  vredmaxu.vs:
    opcode:
    - vredmaxu.vs
    - 31..26=0x06
    - vm
    - vs2
    - vs1
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vredmaxu
  vredmin.vs:
    opcode:
    - vredmin.vs
    - 31..26=0x05
    - vm
    - vs2
    - vs1
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vredmin
  vredminu.vs:
    opcode:
    - vredminu.vs
    - 31..26=0x04
    - vm
    - vs2
    - vs1
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vredminu
  vredor.vs:
    opcode:
    - vredor.vs
    - 31..26=0x02
    - vm
    - vs2
    - vs1
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vredor
  vredsum.vs:
    opcode:
    - vredsum.vs
    - 31..26=0x00
    - vm
    - vs2
    - vs1
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#sec-vector-integer-reduce"
    desc:
      v:
        "#sec-vector-integer-reduce":
          text:
          - "# Simple reductions, where [*] denotes all active elements: vredsum.vs
            vd, vs2, vs1, vm # vd[0] = sum( vs1[0] , vs2[*] ) vredmaxu.vs vd, vs2,
            vs1, vm # vd[0] = maxu( vs1[0] , vs2[*] ) vredmax.vs vd, vs2, vs1, vm
            # vd[0] = max( vs1[0] , vs2[*] ) vredminu.vs vd, vs2, vs1, vm # vd[0]
            = minu( vs1[0] , vs2[*] ) vredmin.vs vd, vs2, vs1, vm # vd[0] = min( vs1[0]
            , vs2[*] ) vredand.vs vd, vs2, vs1, vm # vd[0] = and( vs1[0] , vs2[*]
            ) vredor.vs vd, vs2, vs1, vm # vd[0] = or( vs1[0] , vs2[*] ) vredxor.vs
            vd, vs2, vs1, vm # vd[0] = xor( vs1[0] , vs2[*] )"
        "#_vector_instruction_listing":
          text:
          - vredsum
  vredxor.vs:
    opcode:
    - vredxor.vs
    - 31..26=0x03
    - vm
    - vs2
    - vs1
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vredxor
  vrem.vv:
    opcode:
    - vrem.vv
    - 31..26=0x23
    - vm
    - vs2
    - vs1
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vrem
  vrem.vx:
    opcode:
    - vrem.vx
    - 31..26=0x23
    - vm
    - vs2
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vrem
  vremu.vv:
    opcode:
    - vremu.vv
    - 31..26=0x22
    - vm
    - vs2
    - vs1
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vremu
  vremu.vx:
    opcode:
    - vremu.vx
    - 31..26=0x22
    - vm
    - vs2
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vremu
  vrgather.vi:
    opcode:
    - vrgather.vi
    - 31..26=0x0c
    - vm
    - vs2
    - simm5
    - 14..12=0x3
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *30
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_register_gather_instructions"
    desc:
      v:
        "#_vector_register_gather_instructions":
          text:
          - The vrgather.vv form uses SEW/LMUL for both the data and indices. The
            vrgatherei16.vv form uses SEW/LMUL for the data in vs2 but EEW=16 and
            EMUL = (16/SEW)*LMUL for the indices in vs1.
          - For any vrgather instruction, the destination vector register group cannot
            overlap with the source vector register groups, otherwise the instruction
            encoding is reserved.
          - 'vrgather.vv vd, vs2, vs1, vm # vd[i] = (vs1[i] >= VLMAX) ? 0 : vs2[vs1[i]];
            vrgatherei16.vv vd, vs2, vs1, vm # vd[i] = (vs1[i] >= VLMAX) ? 0 : vs2[vs1[i]];'
          - 'vrgather.vx vd, vs2, rs1, vm # vd[i] = (x[rs1] >= VLMAX) ? 0 : vs2[x[rs1]]
            vrgather.vi vd, vs2, uimm, vm # vd[i] = (uimm >= VLMAX) ? 0 : vs2[uimm]'
        "#_synthesizing_vdecompress":
          text:
          - 'There is no inverse vdecompress provided, as this operation can be readily
            synthesized using iota and a masked vrgather:'
        "#_vector_instruction_listing":
          text:
          - vrgather
  vrgather.vv:
    opcode:
    - vrgather.vv
    - 31..26=0x0c
    - vm
    - vs2
    - vs1
    - 14..12=0x0
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_register_gather_instructions"
    desc:
      v:
        "#_vector_register_gather_instructions":
          text:
          - The vrgather.vv form uses SEW/LMUL for both the data and indices. The
            vrgatherei16.vv form uses SEW/LMUL for the data in vs2 but EEW=16 and
            EMUL = (16/SEW)*LMUL for the indices in vs1.
          - For any vrgather instruction, the destination vector register group cannot
            overlap with the source vector register groups, otherwise the instruction
            encoding is reserved.
          - 'vrgather.vv vd, vs2, vs1, vm # vd[i] = (vs1[i] >= VLMAX) ? 0 : vs2[vs1[i]];
            vrgatherei16.vv vd, vs2, vs1, vm # vd[i] = (vs1[i] >= VLMAX) ? 0 : vs2[vs1[i]];'
          - 'vrgather.vx vd, vs2, rs1, vm # vd[i] = (x[rs1] >= VLMAX) ? 0 : vs2[x[rs1]]
            vrgather.vi vd, vs2, uimm, vm # vd[i] = (uimm >= VLMAX) ? 0 : vs2[uimm]'
        "#_synthesizing_vdecompress":
          text:
          - 'There is no inverse vdecompress provided, as this operation can be readily
            synthesized using iota and a masked vrgather:'
        "#_vector_instruction_listing":
          text:
          - vrgather
  vrgather.vx:
    opcode:
    - vrgather.vx
    - 31..26=0x0c
    - vm
    - vs2
    - rs1
    - 14..12=0x4
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_register_gather_instructions"
    desc:
      v:
        "#_vector_register_gather_instructions":
          text:
          - The vrgather.vv form uses SEW/LMUL for both the data and indices. The
            vrgatherei16.vv form uses SEW/LMUL for the data in vs2 but EEW=16 and
            EMUL = (16/SEW)*LMUL for the indices in vs1.
          - For any vrgather instruction, the destination vector register group cannot
            overlap with the source vector register groups, otherwise the instruction
            encoding is reserved.
          - 'vrgather.vv vd, vs2, vs1, vm # vd[i] = (vs1[i] >= VLMAX) ? 0 : vs2[vs1[i]];
            vrgatherei16.vv vd, vs2, vs1, vm # vd[i] = (vs1[i] >= VLMAX) ? 0 : vs2[vs1[i]];'
          - 'vrgather.vx vd, vs2, rs1, vm # vd[i] = (x[rs1] >= VLMAX) ? 0 : vs2[x[rs1]]
            vrgather.vi vd, vs2, uimm, vm # vd[i] = (uimm >= VLMAX) ? 0 : vs2[uimm]'
        "#_synthesizing_vdecompress":
          text:
          - 'There is no inverse vdecompress provided, as this operation can be readily
            synthesized using iota and a masked vrgather:'
        "#_vector_instruction_listing":
          text:
          - vrgather
  vrgatherei16.vv:
    opcode:
    - vrgatherei16.vv
    - 31..26=0x0e
    - vm
    - vs2
    - vs1
    - 14..12=0x0
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vrgatherei16
  vrsub.vi:
    opcode:
    - vrsub.vi
    - 31..26=0x03
    - vm
    - vs2
    - simm5
    - 14..12=0x3
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *30
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vrsub
  vrsub.vx:
    opcode:
    - vrsub.vx
    - 31..26=0x03
    - vm
    - vs2
    - rs1
    - 14..12=0x4
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vrsub
  vs1r.v:
    opcode:
    - vs1r.v
    - 31..29=0
    - 28=0
    - 27..26=0
    - 25=1
    - 24..20=0x08
    - rs1
    - 14..12=0x0
    - vs3
    - 6..0=0x27
    opcode_group: v
    opcode_args: &35
    - rs1
    - vs3
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
    iss_code:
    - "// vs1r.v vs3, (rs1)"
    - VI_ST_WHOLE
  vs2r.v:
    opcode:
    - vs2r.v
    - 31..29=1
    - 28=0
    - 27..26=0
    - 25=1
    - 24..20=0x08
    - rs1
    - 14..12=0x0
    - vs3
    - 6..0=0x27
    opcode_group: v
    opcode_args: *35
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
    iss_code:
    - "// vs2r.v vs3, (rs1)"
    - VI_ST_WHOLE
  vs4r.v:
    opcode:
    - vs4r.v
    - 31..29=3
    - 28=0
    - 27..26=0
    - 25=1
    - 24..20=0x08
    - rs1
    - 14..12=0x0
    - vs3
    - 6..0=0x27
    opcode_group: v
    opcode_args: *35
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
    iss_code:
    - "// vs4r.v vs3, (rs1)"
    - VI_ST_WHOLE
  vs8r.v:
    opcode:
    - vs8r.v
    - 31..29=7
    - 28=0
    - 27..26=0
    - 25=1
    - 24..20=0x08
    - rs1
    - 14..12=0x0
    - vs3
    - 6..0=0x27
    opcode_group: v
    opcode_args: *35
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
    iss_code:
    - "// vs8r.v vs3, (rs1)"
    - VI_ST_WHOLE
  vsadd.vi:
    opcode:
    - vsadd.vi
    - 31..26=0x21
    - vm
    - vs2
    - simm5
    - 14..12=0x3
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *30
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vsadd
  vsadd.vv:
    opcode:
    - vsadd.vv
    - 31..26=0x21
    - vm
    - vs2
    - vs1
    - 14..12=0x0
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vsadd
  vsadd.vx:
    opcode:
    - vsadd.vx
    - 31..26=0x21
    - vm
    - vs2
    - rs1
    - 14..12=0x4
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vsadd
  vsaddu.vi:
    opcode:
    - vsaddu.vi
    - 31..26=0x20
    - vm
    - vs2
    - simm5
    - 14..12=0x3
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *30
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_single_width_saturating_add_and_subtract"
    desc:
      v:
        "#_vector_single_width_saturating_add_and_subtract":
          text:
          - "# Saturating adds of unsigned integers. vsaddu.vv vd, vs2, vs1, vm #
            Vector-vector vsaddu.vx vd, vs2, rs1, vm # vector-scalar vsaddu.vi vd,
            vs2, imm, vm # vector-immediate # Saturating adds of signed integers.
            vsadd.vv vd, vs2, vs1, vm # Vector-vector vsadd.vx vd, vs2, rs1, vm #
            vector-scalar vsadd.vi vd, vs2, imm, vm # vector-immediate # Saturating
            subtract of unsigned integers. vssubu.vv vd, vs2, vs1, vm # Vector-vector
            vssubu.vx vd, vs2, rs1, vm # vector-scalar # Saturating subtract of signed
            integers. vssub.vv vd, vs2, vs1, vm # Vector-vector vssub.vx vd, vs2,
            rs1, vm # vector-scalar"
        "#_vector_instruction_listing":
          text:
          - vsaddu
  vsaddu.vv:
    opcode:
    - vsaddu.vv
    - 31..26=0x20
    - vm
    - vs2
    - vs1
    - 14..12=0x0
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_single_width_saturating_add_and_subtract"
    desc:
      v:
        "#_vector_single_width_saturating_add_and_subtract":
          text:
          - "# Saturating adds of unsigned integers. vsaddu.vv vd, vs2, vs1, vm #
            Vector-vector vsaddu.vx vd, vs2, rs1, vm # vector-scalar vsaddu.vi vd,
            vs2, imm, vm # vector-immediate # Saturating adds of signed integers.
            vsadd.vv vd, vs2, vs1, vm # Vector-vector vsadd.vx vd, vs2, rs1, vm #
            vector-scalar vsadd.vi vd, vs2, imm, vm # vector-immediate # Saturating
            subtract of unsigned integers. vssubu.vv vd, vs2, vs1, vm # Vector-vector
            vssubu.vx vd, vs2, rs1, vm # vector-scalar # Saturating subtract of signed
            integers. vssub.vv vd, vs2, vs1, vm # Vector-vector vssub.vx vd, vs2,
            rs1, vm # vector-scalar"
        "#_vector_instruction_listing":
          text:
          - vsaddu
  vsaddu.vx:
    opcode:
    - vsaddu.vx
    - 31..26=0x20
    - vm
    - vs2
    - rs1
    - 14..12=0x4
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_single_width_saturating_add_and_subtract"
    desc:
      v:
        "#_vector_single_width_saturating_add_and_subtract":
          text:
          - "# Saturating adds of unsigned integers. vsaddu.vv vd, vs2, vs1, vm #
            Vector-vector vsaddu.vx vd, vs2, rs1, vm # vector-scalar vsaddu.vi vd,
            vs2, imm, vm # vector-immediate # Saturating adds of signed integers.
            vsadd.vv vd, vs2, vs1, vm # Vector-vector vsadd.vx vd, vs2, rs1, vm #
            vector-scalar vsadd.vi vd, vs2, imm, vm # vector-immediate # Saturating
            subtract of unsigned integers. vssubu.vv vd, vs2, vs1, vm # Vector-vector
            vssubu.vx vd, vs2, rs1, vm # vector-scalar # Saturating subtract of signed
            integers. vssub.vv vd, vs2, vs1, vm # Vector-vector vssub.vx vd, vs2,
            rs1, vm # vector-scalar"
        "#_vector_instruction_listing":
          text:
          - vsaddu
  vsbc.vvm:
    opcode:
    - vsbc.vvm
    - 31..26=0x12
    - 25=0
    - vs2
    - vs1
    - 14..12=0x0
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_integer_add_with_carry_subtract_with_borrow_instructions"
    desc:
      v:
        "#_vector_integer_add_with_carry_subtract_with_borrow_instructions":
          text:
          - The subtract with borrow instruction vsbc performs the equivalent function
            to support long word arithmetic for subtraction. There are no subtract
            with immediate instructions.
          - "# Produce difference with borrow. # vd[i] = vs2[i] - vs1[i] - v0.mask[i]
            vsbc.vvm vd, vs2, vs1, v0 # Vector-vector # vd[i] = vs2[i] - x[rs1] -
            v0.mask[i] vsbc.vxm vd, vs2, rs1, v0 # Vector-scalar # Produce borrow
            out in mask register format # vd.mask[i] = borrow_out(vs2[i] - vs1[i]
            - v0.mask[i]) vmsbc.vvm vd, vs2, vs1, v0 # Vector-vector # vd.mask[i]
            = borrow_out(vs2[i] - x[rs1] - v0.mask[i]) vmsbc.vxm vd, vs2, rs1, v0
            # Vector-scalar # vd.mask[i] = borrow_out(vs2[i] - vs1[i]) vmsbc.vv vd,
            vs2, vs1 # Vector-vector, no borrow-in # vd.mask[i] = borrow_out(vs2[i]
            - x[rs1]) vmsbc.vx vd, vs2, rs1 # Vector-scalar, no borrow-in"
        "#_vector_instruction_listing":
          text:
          - vsbc
  vsbc.vxm:
    opcode:
    - vsbc.vxm
    - 31..26=0x12
    - 25=0
    - vs2
    - rs1
    - 14..12=0x4
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_integer_add_with_carry_subtract_with_borrow_instructions"
    desc:
      v:
        "#_vector_integer_add_with_carry_subtract_with_borrow_instructions":
          text:
          - The subtract with borrow instruction vsbc performs the equivalent function
            to support long word arithmetic for subtraction. There are no subtract
            with immediate instructions.
          - "# Produce difference with borrow. # vd[i] = vs2[i] - vs1[i] - v0.mask[i]
            vsbc.vvm vd, vs2, vs1, v0 # Vector-vector # vd[i] = vs2[i] - x[rs1] -
            v0.mask[i] vsbc.vxm vd, vs2, rs1, v0 # Vector-scalar # Produce borrow
            out in mask register format # vd.mask[i] = borrow_out(vs2[i] - vs1[i]
            - v0.mask[i]) vmsbc.vvm vd, vs2, vs1, v0 # Vector-vector # vd.mask[i]
            = borrow_out(vs2[i] - x[rs1] - v0.mask[i]) vmsbc.vxm vd, vs2, rs1, v0
            # Vector-scalar # vd.mask[i] = borrow_out(vs2[i] - vs1[i]) vmsbc.vv vd,
            vs2, vs1 # Vector-vector, no borrow-in # vd.mask[i] = borrow_out(vs2[i]
            - x[rs1]) vmsbc.vx vd, vs2, rs1 # Vector-scalar, no borrow-in"
        "#_vector_instruction_listing":
          text:
          - vsbc
  vse1.v:
    opcode:
    - vse1.v
    - 31..28=0
    - 27..26=0
    - 25=1
    - 24..20=0xb
    - rs1
    - 14..12=0x0
    - vs3
    - 6..0=0x27
    opcode_group: v_aliases
    opcode_args: *35
    pseudo_src: rv_v
    pseudo_op: vsm.v
  vse1024.v:
    opcode:
    - vse1024.v
    - nf
    - 28=1
    - 27..26=0
    - vm
    - 24..20=0
    - rs1
    - 14..12=0x7
    - vs3
    - 6..0=0x27
    opcode_group: v
    opcode_args: *35
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
  vse128.v:
    opcode:
    - vse128.v
    - nf
    - 28=1
    - 27..26=0
    - vm
    - 24..20=0
    - rs1
    - 14..12=0x0
    - vs3
    - 6..0=0x27
    opcode_group: v
    opcode_args: *35
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
  vse16.v:
    opcode:
    - vse16.v
    - nf
    - 28=0
    - 27..26=0
    - vm
    - 24..20=0
    - rs1
    - 14..12=0x5
    - vs3
    - 6..0=0x27
    opcode_group: v
    opcode_args: *35
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
    iss_code:
    - "// vse16.v and vsseg[2-8]e16.v"
    - VI_ST(0, (i * nf + fn), uint16, false);
  vse256.v:
    opcode:
    - vse256.v
    - nf
    - 28=1
    - 27..26=0
    - vm
    - 24..20=0
    - rs1
    - 14..12=0x5
    - vs3
    - 6..0=0x27
    opcode_group: v
    opcode_args: *35
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
  vse32.v:
    opcode:
    - vse32.v
    - nf
    - 28=0
    - 27..26=0
    - vm
    - 24..20=0
    - rs1
    - 14..12=0x6
    - vs3
    - 6..0=0x27
    opcode_group: v
    opcode_args: *35
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
    iss_code:
    - "// vse32.v and vsseg[2-8]e32.v"
    - VI_ST(0, (i * nf + fn), uint32, false);
  vse512.v:
    opcode:
    - vse512.v
    - nf
    - 28=1
    - 27..26=0
    - vm
    - 24..20=0
    - rs1
    - 14..12=0x6
    - vs3
    - 6..0=0x27
    opcode_group: v
    opcode_args: *35
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
  vse64.v:
    opcode:
    - vse64.v
    - nf
    - 28=0
    - 27..26=0
    - vm
    - 24..20=0
    - rs1
    - 14..12=0x7
    - vs3
    - 6..0=0x27
    opcode_group: v
    opcode_args: *35
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
    iss_code:
    - "// vse64.v and vsseg[2-8]e64.v"
    - VI_ST(0, (i * nf + fn), uint64, false);
  vse8.v:
    opcode:
    - vse8.v
    - nf
    - 28=0
    - 27..26=0
    - vm
    - 24..20=0
    - rs1
    - 14..12=0x0
    - vs3
    - 6..0=0x27
    opcode_group: v
    opcode_args: *35
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
    iss_code:
    - "// vse8.v and vsseg[2-8]e8.v"
    - VI_ST(0, (i * nf + fn), uint8, false);
  vsetivli:
    opcode:
    - vsetivli
    - 31=1
    - 30=1
    - zimm10
    - zimm
    - 14..12=0x7
    - rd
    - 6..0=0x57
    opcode_group: v
    opcode_args: &54
    - zimm10
    - zimm
    - rd
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_formats"
    desc:
      v:
        "#_vector_instruction_formats":
          text:
          - "{reg: [ {bits: 7, name: 0x57, attr: 'vsetivli'}, {bits: 5, name: 'rd',
            type: 4}, {bits: 3, name: 7}, {bits: 5, name: 'uimm[4:0]', type: 5}, {bits:
            10, name: 'zimm[9:0]', type: 5}, {bits: 1, name: '1'}, {bits: 1, name:
            '1'}, ]}"
        "#sec-vector-config":
          text:
          - "{reg: [ {bits: 7, name: 0x57, attr: 'vsetivli'}, {bits: 5, name: 'rd',
            type: 4}, {bits: 3, name: 7}, {bits: 5, name: 'uimm[4:0]', type: 5}, {bits:
            10, name: 'zimm[9:0]', type: 5}, {bits: 1, name: '1'}, {bits: 1, name:
            '1'}, ]}"
        "#_avl_encoding":
          text:
          - For the vsetivli instruction, the AVL is encoded as a 5-bit zero-extended
            immediate (0--31) in the rs1 field.
    iss_code:
    - require_vector_novtype(false);
    - WRITE_RD(P.VU.set_vl(insn.rd(), -1, insn.rs1(), insn.v_zimm10()));
  vsetvl:
    opcode:
    - vsetvl
    - 31=1
    - 30..25=0x0
    - rs2
    - rs1
    - 14..12=0x7
    - rd
    - 6..0=0x57
    opcode_group: v
    opcode_args: &44
    - rs2
    - rs1
    - rd
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_state_of_vector_extension_at_reset"
    desc:
      v:
        "#_state_of_vector_extension_at_reset":
          text:
          - The vector extension must have a consistent state at reset. In particular,
            vtype and vl must have values that can be read and then restored with
            a single vsetvl instruction.
        "#_vector_instruction_formats":
          text:
          - "{reg: [ {bits: 7, name: 0x57, attr: 'vsetvl'}, {bits: 5, name: 'rd',
            type: 4}, {bits: 3, name: 7}, {bits: 5, name: 'rs1', type: 4}, {bits:
            5, name: 'rs2', type: 4}, {bits: 6, name: 0x1000}, {bits: 1, name: 1},
            ]}"
        "#sec-vector-config":
          text:
          - "{reg: [ {bits: 7, name: 0x57, attr: 'vsetvl'}, {bits: 5, name: 'rd',
            type: 4}, {bits: 3, name: 7}, {bits: 5, name: 'rs1', type: 4}, {bits:
            5, name: 'rs2', type: 4}, {bits: 6, name: 0x1000}, {bits: 1, name: 1},
            ]}"
        "#_vtype_encoding":
          text:
          - The vsetvl variant operates similarly to vsetvli except that it takes
            a vtype value from rs2 and can be used for context restore.
    iss_code:
    - require_vector_novtype(false);
    - WRITE_RD(P.VU.set_vl(insn.rd(), insn.rs1(), RS1, RS2));
  vsetvli:
    opcode:
    - vsetvli
    - 31=0
    - zimm11
    - rs1
    - 14..12=0x7
    - rd
    - 6..0=0x57
    opcode_group: v
    opcode_args: &43
    - zimm11
    - rs1
    - rd
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#sec-agnostic"
    desc:
      v:
        "#sec-agnostic":
          text:
          - 'The assembly syntax adds two mandatory flags to the vsetvli instruction:'
          - 'ta # Tail agnostic tu # Tail undisturbed ma # Mask agnostic mu # Mask
            undisturbed vsetvli t0, a0, e32, m4, ta, ma # Tail agnostic, mask agnostic
            vsetvli t0, a0, e32, m4, tu, ma # Tail undisturbed, mask agnostic vsetvli
            t0, a0, e32, m4, ta, mu # Tail agnostic, mask undisturbed vsetvli t0,
            a0, e32, m4, tu, mu # Tail undisturbed, mask undisturbed'
        "#_vector_instruction_formats":
          text:
          - "{reg: [ {bits: 7, name: 0x57, attr: 'vsetvli'}, {bits: 5, name: 'rd',
            type: 4}, {bits: 3, name: 7}, {bits: 5, name: 'rs1', type: 4}, {bits:
            11, name: 'zimm[10:0]', type: 5}, {bits: 1, name: '0'}, ]}"
        "#sec-vector-config":
          text:
          - 'vsetvli rd, rs1, vtypei # rd = new vl, rs1 = AVL, vtypei = new vtype
            setting vsetivli rd, uimm, vtypei # rd = new vl, uimm = AVL, vtypei =
            new vtype setting vsetvl rd, rs1, rs2 # rd = new vl, rs1 = AVL, rs2 =
            new vtype value'
          - "{reg: [ {bits: 7, name: 0x57, attr: 'vsetvli'}, {bits: 5, name: 'rd',
            type: 4}, {bits: 3, name: 7}, {bits: 5, name: 'rs1', type: 4}, {bits:
            11, name: 'zimm[10:0]', type: 5}, {bits: 1, name: '0'}, ]}"
        "#_vtype_encoding":
          text:
          - The new vtype setting is encoded in the immediate fields of vsetvli and
            vsetivli, and in the rs2 register for vsetvl.
          - 'Suggested assembler names used for vset{i}vli vtypei immediate e8 # SEW=8b
            e16 # SEW=16b e32 # SEW=32b e64 # SEW=64b mf8 # LMUL=1/8 mf4 # LMUL=1/4
            mf2 # LMUL=1/2 m1 # LMUL=1, assumed if m setting absent m2 # LMUL=2 m4
            # LMUL=4 m8 # LMUL=8 Examples: vsetvli t0, a0, e8 # SEW= 8, LMUL=1 vsetvli
            t0, a0, e8, m2 # SEW= 8, LMUL=2 vsetvli t0, a0, e32, mf2 # SEW=32, LMUL=1/2'
        "#_avl_encoding":
          text:
          - 'The new vector length setting is based on AVL, which for vsetvli and
            vsetvl is encoded in the rs1 and rd fields as follows:'
          - Table 8. AVL used in vsetvli and vsetvl instructions
        "#example-stripmine-sew":
          text:
          - "# Example: Load 16-bit values, widen multiply to 32b, shift 32b result
            # right by 3, store 32b values. # On entry: # a0 holds the total number
            of elements to process # a1 holds the address of the source array # a2
            holds the address of the destination array loop: vsetvli a3, a0, e16,
            m4, ta, ma # vtype = 16-bit integer vectors; # also update a3 with vl
            (# of elements this iteration) vle16.v v4, (a1) # Get 16b vector slli
            t1, a3, 1 # Multiply # elements this iteration by 2 bytes/source element
            add a1, a1, t1 # Bump pointer vwmul.vx v8, v4, x10 # Widening multiply
            into 32b in <v8--v15> vsetvli x0, x0, e32, m8, ta, ma # Operate on 32b
            values vsrl.vi v8, v8, 3 vse32.v v8, (a2) # Store vector of 32b elements
            slli t1, a3, 2 # Multiply # elements this iteration by 4 bytes/destination
            element add a2, a2, t1 # Bump pointer sub a0, a0, a3 # Decrement count
            by vl bnez a0, loop # Any more?"
        "#_unit_stride_fault_only_first_loads":
          text:
          - 'strlen example using unit-stride fault-only-first instruction # size_t
            strlen(const char *str) # a0 holds *str strlen: mv a3, a0 # Save start
            loop: vsetvli a1, x0, e8, m8, ta, ma # Vector of bytes of maximum length
            vle8ff.v v8, (a3) # Load bytes csrr a1, vl # Get bytes read vmseq.vi v0,
            v8, 0 # Set v0[i] where v8[i] = 0 vfirst.m a2, v0 # Find first set bit
            add a3, a3, a1 # Bump pointer bltz a2, loop # Not found? add a0, a0, a1
            # Sum start + bump add a3, a3, a2 # Add index sub a0, a3, a0 # Subtract
            start address+bump ret'
        "#_vector_unit_stride_segment_loads_and_stores":
          text:
          - "# Example 1 # Memory structure holds packed RGB pixels (24-bit data structure,
            8bpp) vsetvli a1, t0, e8, ta, ma vlseg3e8.v v8, (a0), vm # v8 holds the
            red pixels # v9 holds the green pixels # v10 holds the blue pixels # Example
            2 # Memory structure holds complex values, 32b for real and 32b for imaginary
            vsetvli a1, t0, e32, ta, ma vlseg2e32.v v8, (a0), vm # v8 holds real #
            v9 holds imaginary"
        "#_vector_strided_segment_loads_and_stores":
          text:
          - "# Format vlsseg<nf>e<eew>.v vd, (rs1), rs2, vm # Strided segment loads
            vssseg<nf>e<eew>.v vs3, (rs1), rs2, vm # Strided segment stores # Examples
            vsetvli a1, t0, e8, ta, ma vlsseg3e8.v v4, (x5), x6 # Load bytes at addresses
            x5+i*x6 into v4[i], # and bytes at addresses x5+i*x6+1 into v5[i], # and
            bytes at addresses x5+i*x6+2 into v6[i]. # Examples vsetvli a1, t0, e32,
            ta, ma vssseg2e32.v v2, (x5), x6 # Store words from v2[i] to address x5+i*x6
            # and words from v3[i] to address x5+i*x6+4"
        "#_vector_indexed_segment_loads_and_stores":
          text:
          - "# Format vluxseg<nf>ei<eew>.v vd, (rs1), vs2, vm # Indexed-unordered
            segment loads vloxseg<nf>ei<eew>.v vd, (rs1), vs2, vm # Indexed-ordered
            segment loads vsuxseg<nf>ei<eew>.v vs3, (rs1), vs2, vm # Indexed-unordered
            segment stores vsoxseg<nf>ei<eew>.v vs3, (rs1), vs2, vm # Indexed-ordered
            segment stores # Examples vsetvli a1, t0, e8, ta, ma vluxseg3ei32.v v4,
            (x5), v3 # Load bytes at addresses x5+v3[i] into v4[i], # and bytes at
            addresses x5+v3[i]+1 into v5[i], # and bytes at addresses x5+v3[i]+2 into
            v6[i]. # Examples vsetvli a1, t0, e32, ta, ma vsuxseg2ei32.v v2, (x5),
            v5 # Store words from v2[i] to address x5+v5[i] # and words from v3[i]
            to address x5+v5[i]+4"
        "#_vector_loadstore_whole_register_instructions":
          text:
          - 'csrr t0, vl # Save current vl (potentially not needed) vsetvli t1, x0,
            e8, m8 # Maximum VLMAX vlm.v v0, (a0) # Load mask register vsetvli x0,
            t0, <new type> # Restore vl (potentially already present)'
        "#_example_using_vector_mask_instructions":
          text:
          - "# char* strcpy(char *dst, const char* src) strcpy: mv a2, a0 # Copy dst
            li t0, -1 # Infinite AVL loop: vsetvli x0, t0, e8, m8, ta, ma # Max length
            vectors of bytes vle8ff.v v8, (a1) # Get src bytes csrr t1, vl # Get number
            of bytes fetched vmseq.vi v1, v8, 0 # Flag zero bytes vfirst.m a3, v1
            # Zero found? add a1, a1, t1 # Bump pointer vmsif.m v0, v1 # Set mask
            up to and including zero byte. vse8.v v8, (a2), v0.t # Write out bytes
            add a2, a2, t1 # Bump pointer bltz a3, loop # Zero byte not found, so
            loop ret"
          - "# char* strncpy(char *dst, const char* src, size_t n) strncpy: mv a3,
            a0 # Copy dst loop: vsetvli x0, a2, e8, m8, ta, ma # Vectors of bytes.
            vle8ff.v v8, (a1) # Get src bytes vmseq.vi v1, v8, 0 # Flag zero bytes
            csrr t1, vl # Get number of bytes fetched vfirst.m a4, v1 # Zero found?
            vmsbf.m v0, v1 # Set mask up to before zero byte. vse8.v v8, (a3), v0.t
            # Write out non-zero bytes bgez a4, zero_tail # Zero remaining bytes.
            sub a2, a2, t1 # Decrement count. add a3, a3, t1 # Bump dest pointer add
            a1, a1, t1 # Bump src pointer bnez a2, loop # Anymore? ret zero_tail:
            sub a2, a2, a4 # Subtract count on non-zero bytes. add a3, a3, a4 # Advance
            past non-zero bytes. vsetvli t1, a2, e8, m8, ta, ma # Vectors of bytes.
            vmv.v.i v0, 0 # Splat zero. zero_loop: vse8.v v0, (a3) # Store zero. sub
            a2, a2, t1 # Decrement count. add a3, a3, t1 # Bump pointer vsetvli t1,
            a2, e8, m8, ta, ma # Vectors of bytes. bnez a2, zero_loop # Anymore? ret"
        "#_vector_iota_instruction":
          text:
          - "# Compact non-zero elements from input memory array to output memory
            array # # size_t compact_non_zero(size_t n, const int* in, int* out) #
            { # size_t i; # size_t count = 0; # int *p = out; # # for (i=0; i<n; i++)
            # { # const int v = *in++; # if (v != 0) # *p++ = v; # } # # return (size_t)
            (p - out); # } # # a0 = n # a1 = &in # a2 = &out compact_non_zero: li
            a6, 0 # Clear count of non-zero elements loop: vsetvli a5, a0, e32, m8,
            ta, ma # 32-bit integers vle32.v v8, (a1) # Load input vector sub a0,
            a0, a5 # Decrement number done slli a5, a5, 2 # Multiply by four bytes
            vmsne.vi v0, v8, 0 # Locate non-zero values add a1, a1, a5 # Bump input
            pointer vcpop.m a5, v0 # Count number of elements set in v0 viota.m v16,
            v0 # Get destination offsets of active elements add a6, a6, a5 # Accumulate
            number of elements vsll.vi v16, v16, 2, v0.t # Multiply offsets by four
            bytes slli a5, a5, 2 # Multiply number of non-zero elements by four bytes
            vsuxei32.v v8, (a2), v16, v0.t # Scatter using scaled viota results under
            mask add a2, a2, a5 # Bump output pointer bnez a0, loop # Any more? mv
            a0, a6 # Return count ret"
        "#_zve_vector_extensions_for_embedded_processors":
          text:
          - All Zve* extensions support the vector configuration instructions (Section
            Configuration-Setting Instructions (vsetvli/vsetivli/vsetvl) ).
        "#_v_vector_extension_for_application_processors":
          text:
          - The V extension supports the vector configuration instructions (Section
            Configuration-Setting Instructions (vsetvli/vsetivli/vsetvl) ).
        "#_vector_vector_add_example":
          text:
          - "# vector-vector add routine of 32-bit integers # void vvaddint32(size_t
            n, const int*x, const int*y, int*z) # { for (size_t i=0; i<n; i++) { z[i]=x[i]+y[i];
            } } # # a0 = n, a1 = x, a2 = y, a3 = z # Non-vector instructions are indented
            vvaddint32: vsetvli t0, a0, e32, ta, ma # Set vector length based on 32-bit
            vectors vle32.v v0, (a1) # Get first vector sub a0, a0, t0 # Decrement
            number done slli t0, t0, 2 # Multiply number done by 4 bytes add a1, a1,
            t0 # Bump pointer vle32.v v1, (a2) # Get second vector add a2, a2, t0
            # Bump pointer vadd.vv v2, v0, v1 # Sum vectors vse32.v v2, (a3) # Store
            result add a3, a3, t0 # Bump pointer bnez a0, vvaddint32 # Loop back ret
            # Finished"
        "#_example_with_mixed_width_mask_and_compute":
          text:
          - "# Code using one width for predicate and different width for masked #
            compute. # int8_t a[]; int32_t b[], c[]; # for (i=0; i<n; i++) { b[i]
            = (a[i] < 5) ? c[i] : 1; } # # Mixed-width code that keeps SEW/LMUL=8
            loop: vsetvli a4, a0, e8, m1, ta, ma # Byte vector for predicate calc
            vle8.v v1, (a1) # Load a[i] add a1, a1, a4 # Bump pointer. vmslt.vi v0,
            v1, 5 # a[i] < 5? vsetvli x0, a0, e32, m4, ta, mu # Vector of 32-bit values.
            sub a0, a0, a4 # Decrement count vmv.v.i v4, 1 # Splat immediate to destination
            vle32.v v4, (a3), v0.t # Load requested elements of C, others undisturbed
            sll t1, a4, 2 add a3, a3, t1 # Bump pointer. vse32.v v4, (a2) # Store
            b[i]. add a2, a2, t1 # Bump pointer. bnez a0, loop # Any more?"
        "#_memcpy_example":
          text:
          - "# void *memcpy(void* dest, const void* src, size_t n) # a0=dest, a1=src,
            a2=n # memcpy: mv a3, a0 # Copy destination loop: vsetvli t0, a2, e8,
            m8, ta, ma # Vectors of 8b vle8.v v0, (a1) # Load bytes add a1, a1, t0
            # Bump pointer sub a2, a2, t0 # Decrement count vse8.v v0, (a3) # Store
            bytes add a3, a3, t0 # Bump pointer bnez a2, loop # Any more? ret # Return"
        "#_conditional_example":
          text:
          - "# (int16) z[i] = ((int8) x[i] < 5) ? (int16) a[i] : (int16) b[i]; # loop:
            vsetvli t0, a0, e8, m1, ta, ma # Use 8b elements. vle8.v v0, (a1) # Get
            x[i] sub a0, a0, t0 # Decrement element count add a1, a1, t0 # x[i] Bump
            pointer vmslt.vi v0, v0, 5 # Set mask in v0 vsetvli t0, a0, e16, m2, ta,
            mu # Use 16b elements. slli t0, t0, 1 # Multiply by 2 bytes vle16.v v2,
            (a2), v0.t # z[i] = a[i] case vmnot.m v0, v0 # Invert v0 add a2, a2, t0
            # a[i] bump pointer vle16.v v2, (a3), v0.t # z[i] = b[i] case add a3,
            a3, t0 # b[i] bump pointer vse16.v v2, (a4) # Store z add a4, a4, t0 #
            z[i] bump pointer bnez a0, loop"
        "#_saxpy_example":
          text:
          - "# void # saxpy(size_t n, const float a, const float *x, float *y) # {
            # size_t i; # for (i=0; i<n; i++) # y[i] = a * x[i] + y[i]; # } # # register
            arguments: # a0 n # fa0 a # a1 x # a2 y saxpy: vsetvli a4, a0, e32, m8,
            ta, ma vle32.v v0, (a1) sub a0, a0, a4 slli a4, a4, 2 add a1, a1, a4 vle32.v
            v8, (a2) vfmacc.vf v8, fa0, v0 vse32.v v8, (a2) add a2, a2, a4 bnez a0,
            saxpy ret"
        "#_sgemm_example":
          text:
          - "# RV64IDV system # # void # sgemm_nn(size_t n, # size_t m, # size_t k,
            # const float*a, // m * k matrix # size_t lda, # const float*b, // k *
            n matrix # size_t ldb, # float*c, // m * n matrix # size_t ldc) # # c
            += a*b (alpha=1, no transpose on input matrices) # matrices stored in
            C row-major order #define n a0 #define m a1 #define k a2 #define ap a3
            #define astride a4 #define bp a5 #define bstride a6 #define cp a7 #define
            cstride t0 #define kt t1 #define nt t2 #define bnp t3 #define cnp t4 #define
            akp t5 #define bkp s0 #define nvl s1 #define ccp s2 #define amp s3 # Use
            args as additional temporaries #define ft12 fa0 #define ft13 fa1 #define
            ft14 fa2 #define ft15 fa3 # This version holds a 16*VLMAX block of C matrix
            in vector registers # in inner loop, but otherwise does not cache or TLB
            tiling. sgemm_nn: addi sp, sp, -FRAMESIZE sd s0, OFFSET(sp) sd s1, OFFSET(sp)
            sd s2, OFFSET(sp) # Check for zero size matrices beqz n, exit beqz m,
            exit beqz k, exit # Convert elements strides to byte strides. ld cstride,
            OFFSET(sp) # Get arg from stack frame slli astride, astride, 2 slli bstride,
            bstride, 2 slli cstride, cstride, 2 slti t6, m, 16 bnez t6, end_rows c_row_loop:
            # Loop across rows of C blocks mv nt, n # Initialize n counter for next
            row of C blocks mv bnp, bp # Initialize B n-loop pointer to start mv cnp,
            cp # Initialize C n-loop pointer c_col_loop: # Loop across one row of
            C blocks vsetvli nvl, nt, e32, ta, ma # 32-bit vectors, LMUL=1 mv akp,
            ap # reset pointer into A to beginning mv bkp, bnp # step to next column
            in B matrix # Initalize current C submatrix block from memory. vle32.v
            v0, (cnp); add ccp, cnp, cstride; vle32.v v1, (ccp); add ccp, ccp, cstride;
            vle32.v v2, (ccp); add ccp, ccp, cstride; vle32.v v3, (ccp); add ccp,
            ccp, cstride; vle32.v v4, (ccp); add ccp, ccp, cstride; vle32.v v5, (ccp);
            add ccp, ccp, cstride; vle32.v v6, (ccp); add ccp, ccp, cstride; vle32.v
            v7, (ccp); add ccp, ccp, cstride; vle32.v v8, (ccp); add ccp, ccp, cstride;
            vle32.v v9, (ccp); add ccp, ccp, cstride; vle32.v v10, (ccp); add ccp,
            ccp, cstride; vle32.v v11, (ccp); add ccp, ccp, cstride; vle32.v v12,
            (ccp); add ccp, ccp, cstride; vle32.v v13, (ccp); add ccp, ccp, cstride;
            vle32.v v14, (ccp); add ccp, ccp, cstride; vle32.v v15, (ccp) mv kt, k
            # Initialize inner loop counter # Inner loop scheduled assuming 4-clock
            occupancy of vfmacc instruction and single-issue pipeline # Software pipeline
            loads flw ft0, (akp); add amp, akp, astride; flw ft1, (amp); add amp,
            amp, astride; flw ft2, (amp); add amp, amp, astride; flw ft3, (amp); add
            amp, amp, astride; # Get vector from B matrix vle32.v v16, (bkp) # Loop
            on inner dimension for current C block k_loop: vfmacc.vf v0, ft0, v16
            add bkp, bkp, bstride flw ft4, (amp) add amp, amp, astride vfmacc.vf v1,
            ft1, v16 addi kt, kt, -1 # Decrement k counter flw ft5, (amp) add amp,
            amp, astride vfmacc.vf v2, ft2, v16 flw ft6, (amp) add amp, amp, astride
            flw ft7, (amp) vfmacc.vf v3, ft3, v16 add amp, amp, astride flw ft8, (amp)
            add amp, amp, astride vfmacc.vf v4, ft4, v16 flw ft9, (amp) add amp, amp,
            astride vfmacc.vf v5, ft5, v16 flw ft10, (amp) add amp, amp, astride vfmacc.vf
            v6, ft6, v16 flw ft11, (amp) add amp, amp, astride vfmacc.vf v7, ft7,
            v16 flw ft12, (amp) add amp, amp, astride vfmacc.vf v8, ft8, v16 flw ft13,
            (amp) add amp, amp, astride vfmacc.vf v9, ft9, v16 flw ft14, (amp) add
            amp, amp, astride vfmacc.vf v10, ft10, v16 flw ft15, (amp) add amp, amp,
            astride addi akp, akp, 4 # Move to next column of a vfmacc.vf v11, ft11,
            v16 beqz kt, 1f # Don't load past end of matrix flw ft0, (akp) add amp,
            akp, astride 1: vfmacc.vf v12, ft12, v16 beqz kt, 1f flw ft1, (amp) add
            amp, amp, astride 1: vfmacc.vf v13, ft13, v16 beqz kt, 1f flw ft2, (amp)
            add amp, amp, astride 1: vfmacc.vf v14, ft14, v16 beqz kt, 1f # Exit out
            of loop flw ft3, (amp) add amp, amp, astride vfmacc.vf v15, ft15, v16
            vle32.v v16, (bkp) # Get next vector from B matrix, overlap loads with
            jump stalls j k_loop 1: vfmacc.vf v15, ft15, v16 # Save C matrix block
            back to memory vse32.v v0, (cnp); add ccp, cnp, cstride; vse32.v v1, (ccp);
            add ccp, ccp, cstride; vse32.v v2, (ccp); add ccp, ccp, cstride; vse32.v
            v3, (ccp); add ccp, ccp, cstride; vse32.v v4, (ccp); add ccp, ccp, cstride;
            vse32.v v5, (ccp); add ccp, ccp, cstride; vse32.v v6, (ccp); add ccp,
            ccp, cstride; vse32.v v7, (ccp); add ccp, ccp, cstride; vse32.v v8, (ccp);
            add ccp, ccp, cstride; vse32.v v9, (ccp); add ccp, ccp, cstride; vse32.v
            v10, (ccp); add ccp, ccp, cstride; vse32.v v11, (ccp); add ccp, ccp, cstride;
            vse32.v v12, (ccp); add ccp, ccp, cstride; vse32.v v13, (ccp); add ccp,
            ccp, cstride; vse32.v v14, (ccp); add ccp, ccp, cstride; vse32.v v15,
            (ccp) # Following tail instructions should be scheduled earlier in free
            slots during C block save. # Leaving here for clarity. # Bump pointers
            for loop across blocks in one row slli t6, nvl, 2 add cnp, cnp, t6 # Move
            C block pointer over add bnp, bnp, t6 # Move B block pointer over sub
            nt, nt, nvl # Decrement element count in n dimension bnez nt, c_col_loop
            # Any more to do? # Move to next set of rows addi m, m, -16 # Did 16 rows
            above slli t6, astride, 4 # Multiply astride by 16 add ap, ap, t6 # Move
            A matrix pointer down 16 rows slli t6, cstride, 4 # Multiply cstride by
            16 add cp, cp, t6 # Move C matrix pointer down 16 rows slti t6, m, 16
            beqz t6, c_row_loop # Handle end of matrix with fewer than 16 rows. #
            Can use smaller versions of above decreasing in powers-of-2 depending
            on code-size concerns. end_rows: # Not done. exit: ld s0, OFFSET(sp) ld
            s1, OFFSET(sp) ld s2, OFFSET(sp) addi sp, sp, FRAMESIZE ret"
        "#_c_standard_library_strcmp_example":
          text:
          - "# int strcmp(const char *src1, const char* src2) strcmp: ## Using LMUL=2,
            but same register names work for larger LMULs li t1, 0 # Initial pointer
            bump loop: vsetvli t0, x0, e8, m2, ta, ma # Max length vectors of bytes
            add a0, a0, t1 # Bump src1 pointer vle8ff.v v8, (a0) # Get src1 bytes
            add a1, a1, t1 # Bump src2 pointer vle8ff.v v16, (a1) # Get src2 bytes
            vmseq.vi v0, v8, 0 # Flag zero bytes in src1 vmsne.vv v1, v8, v16 # Flag
            if src1 != src2 vmor.mm v0, v0, v1 # Combine exit conditions vfirst.m
            a2, v0 # ==0 or != ? csrr t1, vl # Get number of bytes fetched bltz a2,
            loop # Loop if all same and no zero byte add a0, a0, a2 # Get src1 element
            address lbu a3, (a0) # Get src1 byte from memory add a1, a1, a2 # Get
            src2 element address lbu a4, (a1) # Get src2 byte from memory sub a0,
            a3, a4 # Return value. ret"
        "#_fractional_lmul_example":
          text:
          - ".LBB0_4: # %vector.body # =>This Inner Loop Header: Depth=1 add s9, a2,
            s6 vsetvli s1, zero, e8,m1,ta,mu vle8.v v25, (s9) add s1, a3, s6 vle8.v
            v26, (s1) vadd.vv v25, v26, v25 add s1, a1, s6 vse8.v v25, (s1) add s9,
            a5, s10 vsetvli s1, zero, e64,m8,ta,mu vle64.v v8, (s9) add s1, a6, s10
            vle64.v v16, (s1) add s1, a7, s10 vle64.v v24, (s1) add s1, s3, s10 vle64.v
            v0, (s1) sd a0, -112(s0) ld a0, -128(s0) vs8r.v v0, (a0) # Spill LMUL=8
            add s9, t6, s10 add s11, t5, s10 add ra, t2, s10 add s1, t3, s10 vle64.v
            v0, (s9) ld s9, -136(s0) vs8r.v v0, (s9) # Spill LMUL=8 vle64.v v0, (s11)
            ld s9, -144(s0) vs8r.v v0, (s9) # Spill LMUL=8 vle64.v v0, (ra) ld s9,
            -160(s0) vs8r.v v0, (s9) # Spill LMUL=8 vle64.v v0, (s1) ld s1, -152(s0)
            vs8r.v v0, (s1) # Spill LMUL=8 vadd.vv v16, v16, v8 ld s1, -128(s0) vl8r.v
            v8, (s1) # Reload LMUL=8 vadd.vv v8, v8, v24 ld s1, -136(s0) vl8r.v v24,
            (s1) # Reload LMUL=8 ld s1, -144(s0) vl8r.v v0, (s1) # Reload LMUL=8 vadd.vv
            v24, v0, v24 ld s1, -128(s0) vs8r.v v24, (s1) # Spill LMUL=8 ld s1, -152(s0)
            vl8r.v v0, (s1) # Reload LMUL=8 ld s1, -160(s0) vl8r.v v24, (s1) # Reload
            LMUL=8 vadd.vv v0, v0, v24 add s1, a4, s10 vse64.v v16, (s1) add s1, s2,
            s10 vse64.v v8, (s1) vadd.vv v8, v8, v16 add s1, t4, s10 ld s9, -128(s0)
            vl8r.v v16, (s9) # Reload LMUL=8 vse64.v v16, (s1) add s9, t0, s10 vadd.vv
            v8, v8, v16 vle64.v v16, (s9) add s1, t1, s10 vse64.v v0, (s1) vadd.vv
            v8, v8, v0 vsll.vi v16, v16, 1 vadd.vv v8, v8, v16 vse64.v v8, (s9) add
            s6, s6, s7 add s10, s10, s8 bne s6, s4, .LBB0_4"
          - ".LBB0_4: # %vector.body # =>This Inner Loop Header: Depth=1 add s9, a2,
            s6 vsetvli s1, zero, e8,mf2,ta,mu // LMUL=1/2 ! vle8.v v25, (s9) add s1,
            a3, s6 vle8.v v26, (s1) vadd.vv v25, v26, v25 add s1, a1, s6 vse8.v v25,
            (s1) add s9, a5, s10 vsetvli s1, zero, e64,m4,ta,mu // LMUL=4 vle64.v
            v28, (s9) add s1, a6, s10 vle64.v v8, (s1) vadd.vv v28, v8, v28 add s1,
            a7, s10 vle64.v v8, (s1) add s1, s3, s10 vle64.v v12, (s1) add s1, t6,
            s10 vle64.v v16, (s1) add s1, t5, s10 vle64.v v20, (s1) add s1, a4, s10
            vse64.v v28, (s1) vadd.vv v8, v12, v8 vadd.vv v12, v20, v16 add s1, t2,
            s10 vle64.v v16, (s1) add s1, t3, s10 vle64.v v20, (s1) add s1, s2, s10
            vse64.v v8, (s1) add s9, t4, s10 vadd.vv v16, v20, v16 add s11, t0, s10
            vle64.v v20, (s11) vse64.v v12, (s9) add s1, t1, s10 vse64.v v16, (s1)
            vsll.vi v20, v20, 1 vadd.vv v28, v8, v28 vadd.vv v28, v28, v12 vadd.vv
            v28, v28, v16 vadd.vv v28, v28, v20 vse64.v v28, (s11) add s6, s6, s7
            add s10, s10, s8 bne s6, s4, .LBB0_4"
    iss_code:
    - require_vector_novtype(false);
    - WRITE_RD(P.VU.set_vl(insn.rd(), insn.rs1(), RS1, insn.v_zimm11()));
  vsext.vf2:
    opcode:
    - vsext.vf2
    - 31..26=0x12
    - vm
    - vs2
    - 19..15=7
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *31
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vsext.vf8
          - vsext.vf4
          - vsext.vf2
  vsext.vf4:
    opcode:
    - vsext.vf4
    - 31..26=0x12
    - vm
    - vs2
    - 19..15=5
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *31
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vsext.vf8
          - vsext.vf4
          - vsext.vf2
  vsext.vf8:
    opcode:
    - vsext.vf8
    - 31..26=0x12
    - vm
    - vs2
    - 19..15=3
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *31
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vsext.vf8
          - vsext.vf4
          - vsext.vf2
  vslide1down.vx:
    opcode:
    - vslide1down.vx
    - 31..26=0x0f
    - vm
    - vs2
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_slide1down_instruction"
    desc:
      v:
        "#_vector_slide1down_instruction":
          text:
          - The vslide1down instruction copies the first vl-1 active elements values
            from index i+1 in the source vector register group to index i in the destination
            vector register group.
          - The vslide1down instruction places the x register argument at location
            vl-1 in the destination vector register, provided that element vl-1 is
            active, otherwise the destination element is unchanged. If XLEN < SEW,
            the value is sign-extended to SEW bits. If XLEN > SEW, the least-significant
            bits are copied over and the high SEW-XLEN bits are ignored.
          - 'vslide1down.vx vd, vs2, rs1, vm # vd[i] = vs2[i+1], vd[vl-1]=x[rs1] vfslide1down.vf
            vd, vs2, rs1, vm # vd[i] = vs2[i+1], vd[vl-1]=f[rs1]'
          - vslide1down behavior i < vstart unchanged vstart <= i < vl-1 vd[i] = vs2[i+1]
            if v0.mask[i] enabled vstart <= i = vl-1 vd[vl-1] = x[rs1] if v0.mask[i]
            enabled vl <= i < VLMAX Follow tail policy
        "#_vector_instruction_listing":
          text:
          - vslide1down
  vslide1up.vx:
    opcode:
    - vslide1up.vx
    - 31..26=0x0e
    - vm
    - vs2
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_slide1up"
    desc:
      v:
        "#_vector_slide1up":
          text:
          - The vslide1up instruction places the x register argument at location 0
            of the destination vector register group, provided that element 0 is active,
            otherwise the destination element update follows the current mask agnostic/undisturbed
            policy. If XLEN < SEW, the value is sign-extended to SEW bits. If XLEN
            > SEW, the least-significant bits are copied over and the high SEW-XLEN
            bits are ignored.
          - The vslide1up instruction requires that the destination vector register
            group does not overlap the source vector register group. Otherwise, the
            instruction encoding is reserved.
          - 'vslide1up.vx vd, vs2, rs1, vm # vd[0]=x[rs1], vd[i+1] = vs2[i] vfslide1up.vf
            vd, vs2, rs1, vm # vd[0]=f[rs1], vd[i+1] = vs2[i]'
          - vslide1up behavior i < vstart unchanged 0 = i = vstart vd[i] = x[rs1]
            if v0.mask[i] enabled max(vstart, 1) <= i < vl vd[i] = vs2[i-1] if v0.mask[i]
            enabled vl <= i < VLMAX Follow tail policy
        "#_vector_instruction_listing":
          text:
          - vslide1up
  vslidedown.vi:
    opcode:
    - vslidedown.vi
    - 31..26=0x0f
    - vm
    - vs2
    - simm5
    - 14..12=0x3
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *30
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_slidedown_instructions"
    desc:
      v:
        "#_vector_slidedown_instructions":
          text:
          - For vslidedown, the value in vl specifies the maximum number of destination
            elements that are written. The remaining elements past vl are handled
            according to the current tail policy (Section Vector Tail Agnostic and
            Vector Mask Agnostic vta and vma ).
          - 'vslidedown.vx vd, vs2, rs1, vm # vd[i] = vs2[i+rs1] vslidedown.vi vd,
            vs2, uimm, vm # vd[i] = vs2[i+uimm]'
          - vslidedown behavior for source elements for element i in slide 0 <= i+OFFSET
            < VLMAX src[i] = vs2[i+OFFSET] VLMAX <= i+OFFSET src[i] = 0 vslidedown
            behavior for destination element i in slide 0 < i < vstart Unchanged vstart
            <= i < vl vd[i] = src[i] if v0.mask[i] enabled vl <= i < VLMAX Follow
            tail policy
        "#_vector_instruction_listing":
          text:
          - vslidedown
  vslidedown.vx:
    opcode:
    - vslidedown.vx
    - 31..26=0x0f
    - vm
    - vs2
    - rs1
    - 14..12=0x4
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_slidedown_instructions"
    desc:
      v:
        "#_vector_slidedown_instructions":
          text:
          - For vslidedown, the value in vl specifies the maximum number of destination
            elements that are written. The remaining elements past vl are handled
            according to the current tail policy (Section Vector Tail Agnostic and
            Vector Mask Agnostic vta and vma ).
          - 'vslidedown.vx vd, vs2, rs1, vm # vd[i] = vs2[i+rs1] vslidedown.vi vd,
            vs2, uimm, vm # vd[i] = vs2[i+uimm]'
          - vslidedown behavior for source elements for element i in slide 0 <= i+OFFSET
            < VLMAX src[i] = vs2[i+OFFSET] VLMAX <= i+OFFSET src[i] = 0 vslidedown
            behavior for destination element i in slide 0 < i < vstart Unchanged vstart
            <= i < vl vd[i] = src[i] if v0.mask[i] enabled vl <= i < VLMAX Follow
            tail policy
        "#_vector_instruction_listing":
          text:
          - vslidedown
  vslideup.vi:
    opcode:
    - vslideup.vi
    - 31..26=0x0e
    - vm
    - vs2
    - simm5
    - 14..12=0x3
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *30
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_slide_instructions"
    desc:
      v:
        "#_vector_slide_instructions":
          text:
          - For all of the vslideup, vslidedown, v[f]slide1up, and v[f]slide1down
            instructions, if vstart >= vl, the instruction performs no operation and
            leaves the destination vector register unchanged.
        "#_vector_slideup_instructions":
          text:
          - For vslideup, the value in vl specifies the maximum number of destination
            elements that are written. The start index (OFFSET) for the destination
            can be either specified using an unsigned integer in the x register specified
            by rs1, or a 5-bit immediate, zero-extended to XLEN bits. If XLEN > SEW,
            OFFSET is not truncated to SEW bits. Destination elements OFFSET through
            vl-1 are written if unmasked and if OFFSET < vl.
          - The destination vector register group for vslideup cannot overlap the
            source vector register group, otherwise the instruction encoding is reserved.
          - 'vslideup.vx vd, vs2, rs1, vm # vd[i+rs1] = vs2[i] vslideup.vi vd, vs2,
            uimm, vm # vd[i+uimm] = vs2[i]'
          - vslideup behavior for destination elements OFFSET is amount to slideup,
            either from x register or a 5-bit immediate 0 < i < max(vstart, OFFSET)
            Unchanged max(vstart, OFFSET) <= i < vl vd[i] = vs2[i-OFFSET] if v0.mask[i]
            enabled vl <= i < VLMAX Follow tail policy
        "#_vector_instruction_listing":
          text:
          - vslideup
  vslideup.vx:
    opcode:
    - vslideup.vx
    - 31..26=0x0e
    - vm
    - vs2
    - rs1
    - 14..12=0x4
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_slide_instructions"
    desc:
      v:
        "#_vector_slide_instructions":
          text:
          - For all of the vslideup, vslidedown, v[f]slide1up, and v[f]slide1down
            instructions, if vstart >= vl, the instruction performs no operation and
            leaves the destination vector register unchanged.
        "#_vector_slideup_instructions":
          text:
          - For vslideup, the value in vl specifies the maximum number of destination
            elements that are written. The start index (OFFSET) for the destination
            can be either specified using an unsigned integer in the x register specified
            by rs1, or a 5-bit immediate, zero-extended to XLEN bits. If XLEN > SEW,
            OFFSET is not truncated to SEW bits. Destination elements OFFSET through
            vl-1 are written if unmasked and if OFFSET < vl.
          - The destination vector register group for vslideup cannot overlap the
            source vector register group, otherwise the instruction encoding is reserved.
          - 'vslideup.vx vd, vs2, rs1, vm # vd[i+rs1] = vs2[i] vslideup.vi vd, vs2,
            uimm, vm # vd[i+uimm] = vs2[i]'
          - vslideup behavior for destination elements OFFSET is amount to slideup,
            either from x register or a 5-bit immediate 0 < i < max(vstart, OFFSET)
            Unchanged max(vstart, OFFSET) <= i < vl vd[i] = vs2[i-OFFSET] if v0.mask[i]
            enabled vl <= i < VLMAX Follow tail policy
        "#_vector_instruction_listing":
          text:
          - vslideup
  vsll.vi:
    opcode:
    - vsll.vi
    - 31..26=0x25
    - vm
    - vs2
    - simm5
    - 14..12=0x3
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *30
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_single_width_shift_instructions"
    desc:
      v:
        "#_vector_single_width_shift_instructions":
          text:
          - "# Bit shift operations vsll.vv vd, vs2, vs1, vm # Vector-vector vsll.vx
            vd, vs2, rs1, vm # vector-scalar vsll.vi vd, vs2, uimm, vm # vector-immediate
            vsrl.vv vd, vs2, vs1, vm # Vector-vector vsrl.vx vd, vs2, rs1, vm # vector-scalar
            vsrl.vi vd, vs2, uimm, vm # vector-immediate vsra.vv vd, vs2, vs1, vm
            # Vector-vector vsra.vx vd, vs2, rs1, vm # vector-scalar vsra.vi vd, vs2,
            uimm, vm # vector-immediate"
        "#_vector_instruction_listing":
          text:
          - vsll
  vsll.vv:
    opcode:
    - vsll.vv
    - 31..26=0x25
    - vm
    - vs2
    - vs1
    - 14..12=0x0
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_single_width_shift_instructions"
    desc:
      v:
        "#_vector_single_width_shift_instructions":
          text:
          - "# Bit shift operations vsll.vv vd, vs2, vs1, vm # Vector-vector vsll.vx
            vd, vs2, rs1, vm # vector-scalar vsll.vi vd, vs2, uimm, vm # vector-immediate
            vsrl.vv vd, vs2, vs1, vm # Vector-vector vsrl.vx vd, vs2, rs1, vm # vector-scalar
            vsrl.vi vd, vs2, uimm, vm # vector-immediate vsra.vv vd, vs2, vs1, vm
            # Vector-vector vsra.vx vd, vs2, rs1, vm # vector-scalar vsra.vi vd, vs2,
            uimm, vm # vector-immediate"
        "#_vector_instruction_listing":
          text:
          - vsll
  vsll.vx:
    opcode:
    - vsll.vx
    - 31..26=0x25
    - vm
    - vs2
    - rs1
    - 14..12=0x4
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_single_width_shift_instructions"
    desc:
      v:
        "#_vector_single_width_shift_instructions":
          text:
          - "# Bit shift operations vsll.vv vd, vs2, vs1, vm # Vector-vector vsll.vx
            vd, vs2, rs1, vm # vector-scalar vsll.vi vd, vs2, uimm, vm # vector-immediate
            vsrl.vv vd, vs2, vs1, vm # Vector-vector vsrl.vx vd, vs2, rs1, vm # vector-scalar
            vsrl.vi vd, vs2, uimm, vm # vector-immediate vsra.vv vd, vs2, vs1, vm
            # Vector-vector vsra.vx vd, vs2, rs1, vm # vector-scalar vsra.vi vd, vs2,
            uimm, vm # vector-immediate"
        "#_vector_instruction_listing":
          text:
          - vsll
  vsm.v:
    opcode:
    - vsm.v
    - 31..28=0
    - 27..26=0
    - 25=1
    - 24..20=0xb
    - rs1
    - 14..12=0x0
    - vs3
    - 6..0=0x27
    opcode_group: v
    opcode_args: *35
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
    iss_code:
    - "// vse1.v"
    - VI_ST(0, (i * nf + fn), uint8, true);
  vsmul.vv:
    opcode:
    - vsmul.vv
    - 31..26=0x27
    - vm
    - vs2
    - vs1
    - 14..12=0x0
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_single_width_fractional_multiply_with_rounding_and_saturation"
    desc:
      v:
        "#_vector_single_width_fractional_multiply_with_rounding_and_saturation":
          text:
          - "# Signed saturating and rounding fractional multiply # See vxrm description
            for rounding calculation vsmul.vv vd, vs2, vs1, vm # vd[i] = clip(roundoff_signed(vs2[i]*vs1[i],
            SEW-1)) vsmul.vx vd, vs2, rs1, vm # vd[i] = clip(roundoff_signed(vs2[i]*x[rs1],
            SEW-1))"
        "#_zve_vector_extensions_for_embedded_processors":
          text:
          - All Zve* extensions support all vector fixed-point arithmetic instructions
            ( Vector Fixed-Point Arithmetic Instructions ), except that vsmul.vv and
            vsmul.vx are not supported for EEW=64 in Zve64*.
        "#_vector_instruction_listing":
          text:
          - vsmul
  vsmul.vx:
    opcode:
    - vsmul.vx
    - 31..26=0x27
    - vm
    - vs2
    - rs1
    - 14..12=0x4
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_single_width_fractional_multiply_with_rounding_and_saturation"
    desc:
      v:
        "#_vector_single_width_fractional_multiply_with_rounding_and_saturation":
          text:
          - "# Signed saturating and rounding fractional multiply # See vxrm description
            for rounding calculation vsmul.vv vd, vs2, vs1, vm # vd[i] = clip(roundoff_signed(vs2[i]*vs1[i],
            SEW-1)) vsmul.vx vd, vs2, rs1, vm # vd[i] = clip(roundoff_signed(vs2[i]*x[rs1],
            SEW-1))"
        "#_zve_vector_extensions_for_embedded_processors":
          text:
          - All Zve* extensions support all vector fixed-point arithmetic instructions
            ( Vector Fixed-Point Arithmetic Instructions ), except that vsmul.vv and
            vsmul.vx are not supported for EEW=64 in Zve64*.
        "#_vector_instruction_listing":
          text:
          - vsmul
  vsoxei1024.v:
    opcode:
    - vsoxei1024.v
    - nf
    - 28=1
    - 27..26=3
    - vm
    - vs2
    - rs1
    - 14..12=0x7
    - vs3
    - 6..0=0x27
    opcode_group: v
    opcode_args: &36
    - vs2
    - rs1
    - vs3
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
  vsoxei128.v:
    opcode:
    - vsoxei128.v
    - nf
    - 28=1
    - 27..26=3
    - vm
    - vs2
    - rs1
    - 14..12=0x0
    - vs3
    - 6..0=0x27
    opcode_group: v
    opcode_args: *36
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
  vsoxei16.v:
    opcode:
    - vsoxei16.v
    - nf
    - 28=0
    - 27..26=3
    - vm
    - vs2
    - rs1
    - 14..12=0x5
    - vs3
    - 6..0=0x27
    opcode_group: v
    opcode_args: *36
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
    iss_code:
    - "// vsxei16.v and vsxseg[2-8]ei16.v"
    - VI_ST_INDEX(e16, true);
  vsoxei256.v:
    opcode:
    - vsoxei256.v
    - nf
    - 28=1
    - 27..26=3
    - vm
    - vs2
    - rs1
    - 14..12=0x5
    - vs3
    - 6..0=0x27
    opcode_group: v
    opcode_args: *36
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
  vsoxei32.v:
    opcode:
    - vsoxei32.v
    - nf
    - 28=0
    - 27..26=3
    - vm
    - vs2
    - rs1
    - 14..12=0x6
    - vs3
    - 6..0=0x27
    opcode_group: v
    opcode_args: *36
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
    iss_code:
    - "// vsxei32.v and vsxseg[2-8]ei32.v"
    - VI_ST_INDEX(e32, true);
  vsoxei512.v:
    opcode:
    - vsoxei512.v
    - nf
    - 28=1
    - 27..26=3
    - vm
    - vs2
    - rs1
    - 14..12=0x6
    - vs3
    - 6..0=0x27
    opcode_group: v
    opcode_args: *36
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
  vsoxei64.v:
    opcode:
    - vsoxei64.v
    - nf
    - 28=0
    - 27..26=3
    - vm
    - vs2
    - rs1
    - 14..12=0x7
    - vs3
    - 6..0=0x27
    opcode_group: v
    opcode_args: *36
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
    iss_code:
    - "// vsxei64.v and vsxseg[2-8]ei64.v"
    - VI_ST_INDEX(e64, true);
  vsoxei8.v:
    opcode:
    - vsoxei8.v
    - nf
    - 28=0
    - 27..26=3
    - vm
    - vs2
    - rs1
    - 14..12=0x0
    - vs3
    - 6..0=0x27
    opcode_group: v
    opcode_args: *36
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
    iss_code:
    - "// vsxei8.v and vsxseg[2-8]ei8.v"
    - VI_ST_INDEX(e8, true);
  vsra.vi:
    opcode:
    - vsra.vi
    - 31..26=0x29
    - vm
    - vs2
    - simm5
    - 14..12=0x3
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *30
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vsra
  vsra.vv:
    opcode:
    - vsra.vv
    - 31..26=0x29
    - vm
    - vs2
    - vs1
    - 14..12=0x0
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vsra
  vsra.vx:
    opcode:
    - vsra.vx
    - 31..26=0x29
    - vm
    - vs2
    - rs1
    - 14..12=0x4
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vsra
  vsrl.vi:
    opcode:
    - vsrl.vi
    - 31..26=0x28
    - vm
    - vs2
    - simm5
    - 14..12=0x3
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *30
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vsrl
  vsrl.vv:
    opcode:
    - vsrl.vv
    - 31..26=0x28
    - vm
    - vs2
    - vs1
    - 14..12=0x0
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vsrl
  vsrl.vx:
    opcode:
    - vsrl.vx
    - 31..26=0x28
    - vm
    - vs2
    - rs1
    - 14..12=0x4
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vsrl
  vsse1024.v:
    opcode:
    - vsse1024.v
    - nf
    - 28=1
    - 27..26=2
    - vm
    - rs2
    - rs1
    - 14..12=0x7
    - vs3
    - 6..0=0x27
    opcode_group: v
    opcode_args: &37
    - rs2
    - rs1
    - vs3
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
  vsse128.v:
    opcode:
    - vsse128.v
    - nf
    - 28=1
    - 27..26=2
    - vm
    - rs2
    - rs1
    - 14..12=0x0
    - vs3
    - 6..0=0x27
    opcode_group: v
    opcode_args: *37
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
  vsse16.v:
    opcode:
    - vsse16.v
    - nf
    - 28=0
    - 27..26=2
    - vm
    - rs2
    - rs1
    - 14..12=0x5
    - vs3
    - 6..0=0x27
    opcode_group: v
    opcode_args: *37
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
    iss_code:
    - "// vsse16v and vssseg[2-8]e16.v"
    - VI_ST(i * RS2, fn, uint16, false);
  vsse256.v:
    opcode:
    - vsse256.v
    - nf
    - 28=1
    - 27..26=2
    - vm
    - rs2
    - rs1
    - 14..12=0x5
    - vs3
    - 6..0=0x27
    opcode_group: v
    opcode_args: *37
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
  vsse32.v:
    opcode:
    - vsse32.v
    - nf
    - 28=0
    - 27..26=2
    - vm
    - rs2
    - rs1
    - 14..12=0x6
    - vs3
    - 6..0=0x27
    opcode_group: v
    opcode_args: *37
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
    iss_code:
    - "// vsse32.v and vssseg[2-8]e32.v"
    - VI_ST(i * RS2, fn, uint32, false);
  vsse512.v:
    opcode:
    - vsse512.v
    - nf
    - 28=1
    - 27..26=2
    - vm
    - rs2
    - rs1
    - 14..12=0x6
    - vs3
    - 6..0=0x27
    opcode_group: v
    opcode_args: *37
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
  vsse64.v:
    opcode:
    - vsse64.v
    - nf
    - 28=0
    - 27..26=2
    - vm
    - rs2
    - rs1
    - 14..12=0x7
    - vs3
    - 6..0=0x27
    opcode_group: v
    opcode_args: *37
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
    iss_code:
    - "// vsse64.v and vssseg[2-8]e64.v"
    - VI_ST(i * RS2, fn, uint64, false);
  vsse8.v:
    opcode:
    - vsse8.v
    - nf
    - 28=0
    - 27..26=2
    - vm
    - rs2
    - rs1
    - 14..12=0x0
    - vs3
    - 6..0=0x27
    opcode_group: v
    opcode_args: *37
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
    iss_code:
    - "// vsse8.v and vssseg[2-8]e8.v"
    - VI_ST(i * RS2, fn, uint8, false);
  vssra.vi:
    opcode:
    - vssra.vi
    - 31..26=0x2b
    - vm
    - vs2
    - simm5
    - 14..12=0x3
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *30
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vssra
  vssra.vv:
    opcode:
    - vssra.vv
    - 31..26=0x2b
    - vm
    - vs2
    - vs1
    - 14..12=0x0
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vssra
  vssra.vx:
    opcode:
    - vssra.vx
    - 31..26=0x2b
    - vm
    - vs2
    - rs1
    - 14..12=0x4
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vssra
  vssrl.vi:
    opcode:
    - vssrl.vi
    - 31..26=0x2a
    - vm
    - vs2
    - simm5
    - 14..12=0x3
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *30
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_single_width_scaling_shift_instructions"
    desc:
      v:
        "#_vector_single_width_scaling_shift_instructions":
          text:
          - These instructions shift the input value right, and round off the shifted
            out bits according to vxrm. The scaling right shifts have both zero-extending
            (vssrl) and sign-extending (vssra) forms. The data to be shifted is in
            the vector register group specified by vs2 and the shift amount value
            can come from a vector register group vs1, a scalar integer register rs1,
            or a zero-extended 5-bit immediate. Only the low lg2(SEW) bits of the
            shift-amount value are used to control the shift amount.
          - "# Scaling shift right logical vssrl.vv vd, vs2, vs1, vm # vd[i] = roundoff_unsigned(vs2[i],
            vs1[i]) vssrl.vx vd, vs2, rs1, vm # vd[i] = roundoff_unsigned(vs2[i],
            x[rs1]) vssrl.vi vd, vs2, uimm, vm # vd[i] = roundoff_unsigned(vs2[i],
            uimm) # Scaling shift right arithmetic vssra.vv vd, vs2, vs1, vm # vd[i]
            = roundoff_signed(vs2[i],vs1[i]) vssra.vx vd, vs2, rs1, vm # vd[i] = roundoff_signed(vs2[i],
            x[rs1]) vssra.vi vd, vs2, uimm, vm # vd[i] = roundoff_signed(vs2[i], uimm)"
        "#_vector_instruction_listing":
          text:
          - vssrl
  vssrl.vv:
    opcode:
    - vssrl.vv
    - 31..26=0x2a
    - vm
    - vs2
    - vs1
    - 14..12=0x0
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_single_width_scaling_shift_instructions"
    desc:
      v:
        "#_vector_single_width_scaling_shift_instructions":
          text:
          - These instructions shift the input value right, and round off the shifted
            out bits according to vxrm. The scaling right shifts have both zero-extending
            (vssrl) and sign-extending (vssra) forms. The data to be shifted is in
            the vector register group specified by vs2 and the shift amount value
            can come from a vector register group vs1, a scalar integer register rs1,
            or a zero-extended 5-bit immediate. Only the low lg2(SEW) bits of the
            shift-amount value are used to control the shift amount.
          - "# Scaling shift right logical vssrl.vv vd, vs2, vs1, vm # vd[i] = roundoff_unsigned(vs2[i],
            vs1[i]) vssrl.vx vd, vs2, rs1, vm # vd[i] = roundoff_unsigned(vs2[i],
            x[rs1]) vssrl.vi vd, vs2, uimm, vm # vd[i] = roundoff_unsigned(vs2[i],
            uimm) # Scaling shift right arithmetic vssra.vv vd, vs2, vs1, vm # vd[i]
            = roundoff_signed(vs2[i],vs1[i]) vssra.vx vd, vs2, rs1, vm # vd[i] = roundoff_signed(vs2[i],
            x[rs1]) vssra.vi vd, vs2, uimm, vm # vd[i] = roundoff_signed(vs2[i], uimm)"
        "#_vector_instruction_listing":
          text:
          - vssrl
  vssrl.vx:
    opcode:
    - vssrl.vx
    - 31..26=0x2a
    - vm
    - vs2
    - rs1
    - 14..12=0x4
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_single_width_scaling_shift_instructions"
    desc:
      v:
        "#_vector_single_width_scaling_shift_instructions":
          text:
          - These instructions shift the input value right, and round off the shifted
            out bits according to vxrm. The scaling right shifts have both zero-extending
            (vssrl) and sign-extending (vssra) forms. The data to be shifted is in
            the vector register group specified by vs2 and the shift amount value
            can come from a vector register group vs1, a scalar integer register rs1,
            or a zero-extended 5-bit immediate. Only the low lg2(SEW) bits of the
            shift-amount value are used to control the shift amount.
          - "# Scaling shift right logical vssrl.vv vd, vs2, vs1, vm # vd[i] = roundoff_unsigned(vs2[i],
            vs1[i]) vssrl.vx vd, vs2, rs1, vm # vd[i] = roundoff_unsigned(vs2[i],
            x[rs1]) vssrl.vi vd, vs2, uimm, vm # vd[i] = roundoff_unsigned(vs2[i],
            uimm) # Scaling shift right arithmetic vssra.vv vd, vs2, vs1, vm # vd[i]
            = roundoff_signed(vs2[i],vs1[i]) vssra.vx vd, vs2, rs1, vm # vd[i] = roundoff_signed(vs2[i],
            x[rs1]) vssra.vi vd, vs2, uimm, vm # vd[i] = roundoff_signed(vs2[i], uimm)"
        "#_vector_instruction_listing":
          text:
          - vssrl
  vssub.vv:
    opcode:
    - vssub.vv
    - 31..26=0x23
    - vm
    - vs2
    - vs1
    - 14..12=0x0
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vssub
  vssub.vx:
    opcode:
    - vssub.vx
    - 31..26=0x23
    - vm
    - vs2
    - rs1
    - 14..12=0x4
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vssub
  vssubu.vv:
    opcode:
    - vssubu.vv
    - 31..26=0x22
    - vm
    - vs2
    - vs1
    - 14..12=0x0
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vssubu
  vssubu.vx:
    opcode:
    - vssubu.vx
    - 31..26=0x22
    - vm
    - vs2
    - rs1
    - 14..12=0x4
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vssubu
  vsub.vv:
    opcode:
    - vsub.vv
    - 31..26=0x02
    - vm
    - vs2
    - vs1
    - 14..12=0x0
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vsub
  vsub.vx:
    opcode:
    - vsub.vx
    - 31..26=0x02
    - vm
    - vs2
    - rs1
    - 14..12=0x4
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vsub
  vsuxei1024.v:
    opcode:
    - vsuxei1024.v
    - nf
    - 28=1
    - 27..26=1
    - vm
    - vs2
    - rs1
    - 14..12=0x7
    - vs3
    - 6..0=0x27
    opcode_group: v
    opcode_args: *36
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
  vsuxei128.v:
    opcode:
    - vsuxei128.v
    - nf
    - 28=1
    - 27..26=1
    - vm
    - vs2
    - rs1
    - 14..12=0x0
    - vs3
    - 6..0=0x27
    opcode_group: v
    opcode_args: *36
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
  vsuxei16.v:
    opcode:
    - vsuxei16.v
    - nf
    - 28=0
    - 27..26=1
    - vm
    - vs2
    - rs1
    - 14..12=0x5
    - vs3
    - 6..0=0x27
    opcode_group: v
    opcode_args: *36
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
    iss_code:
    - "// vsuxe16.v"
    - VI_ST_INDEX(e16, true);
  vsuxei256.v:
    opcode:
    - vsuxei256.v
    - nf
    - 28=1
    - 27..26=1
    - vm
    - vs2
    - rs1
    - 14..12=0x5
    - vs3
    - 6..0=0x27
    opcode_group: v
    opcode_args: *36
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
  vsuxei32.v:
    opcode:
    - vsuxei32.v
    - nf
    - 28=0
    - 27..26=1
    - vm
    - vs2
    - rs1
    - 14..12=0x6
    - vs3
    - 6..0=0x27
    opcode_group: v
    opcode_args: *36
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
    iss_code:
    - "// vsuxe32.v"
    - VI_ST_INDEX(e32, true);
  vsuxei512.v:
    opcode:
    - vsuxei512.v
    - nf
    - 28=1
    - 27..26=1
    - vm
    - vs2
    - rs1
    - 14..12=0x6
    - vs3
    - 6..0=0x27
    opcode_group: v
    opcode_args: *36
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
  vsuxei64.v:
    opcode:
    - vsuxei64.v
    - nf
    - 28=0
    - 27..26=1
    - vm
    - vs2
    - rs1
    - 14..12=0x7
    - vs3
    - 6..0=0x27
    opcode_group: v
    opcode_args: *36
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
    iss_code:
    - "// vsuxe64.v"
    - VI_ST_INDEX(e64, true);
  vsuxei8.v:
    opcode:
    - vsuxei8.v
    - nf
    - 28=0
    - 27..26=1
    - vm
    - vs2
    - rs1
    - 14..12=0x0
    - vs3
    - 6..0=0x27
    opcode_group: v
    opcode_args: *36
    main_desc: v
    main_id: "#_introduction"
    desc:
      v:
        "#_introduction":
          text: []
    iss_code:
    - "// vsuxe8.v"
    - VI_ST_INDEX(e8, true);
  vwadd.vv:
    opcode:
    - vwadd.vv
    - 31..26=0x31
    - vm
    - vs2
    - vs1
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vwadd
          - vwadd.w
  vwadd.vx:
    opcode:
    - vwadd.vx
    - 31..26=0x31
    - vm
    - vs2
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vwadd
          - vwadd.w
  vwadd.wv:
    opcode:
    - vwadd.wv
    - 31..26=0x35
    - vm
    - vs2
    - vs1
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vwadd
          - vwadd.w
  vwadd.wx:
    opcode:
    - vwadd.wx
    - 31..26=0x35
    - vm
    - vs2
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vwadd
          - vwadd.w
  vwaddu.vv:
    opcode:
    - vwaddu.vv
    - 31..26=0x30
    - vm
    - vs2
    - vs1
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_widening_integer_addsubtract"
    desc:
      v:
        "#_vector_widening_integer_addsubtract":
          text:
          - "# Widening unsigned integer add/subtract, 2*SEW = SEW +/- SEW vwaddu.vv
            vd, vs2, vs1, vm # vector-vector vwaddu.vx vd, vs2, rs1, vm # vector-scalar
            vwsubu.vv vd, vs2, vs1, vm # vector-vector vwsubu.vx vd, vs2, rs1, vm
            # vector-scalar # Widening signed integer add/subtract, 2*SEW = SEW +/-
            SEW vwadd.vv vd, vs2, vs1, vm # vector-vector vwadd.vx vd, vs2, rs1, vm
            # vector-scalar vwsub.vv vd, vs2, vs1, vm # vector-vector vwsub.vx vd,
            vs2, rs1, vm # vector-scalar # Widening unsigned integer add/subtract,
            2*SEW = 2*SEW +/- SEW vwaddu.wv vd, vs2, vs1, vm # vector-vector vwaddu.wx
            vd, vs2, rs1, vm # vector-scalar vwsubu.wv vd, vs2, vs1, vm # vector-vector
            vwsubu.wx vd, vs2, rs1, vm # vector-scalar # Widening signed integer add/subtract,
            2*SEW = 2*SEW +/- SEW vwadd.wv vd, vs2, vs1, vm # vector-vector vwadd.wx
            vd, vs2, rs1, vm # vector-scalar vwsub.wv vd, vs2, vs1, vm # vector-vector
            vwsub.wx vd, vs2, rs1, vm # vector-scalar"
        "#_vector_instruction_listing":
          text:
          - vwaddu
          - vwaddu.w
  vwaddu.vx:
    opcode:
    - vwaddu.vx
    - 31..26=0x30
    - vm
    - vs2
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_widening_integer_addsubtract"
    desc:
      v:
        "#_vector_widening_integer_addsubtract":
          text:
          - "# Widening unsigned integer add/subtract, 2*SEW = SEW +/- SEW vwaddu.vv
            vd, vs2, vs1, vm # vector-vector vwaddu.vx vd, vs2, rs1, vm # vector-scalar
            vwsubu.vv vd, vs2, vs1, vm # vector-vector vwsubu.vx vd, vs2, rs1, vm
            # vector-scalar # Widening signed integer add/subtract, 2*SEW = SEW +/-
            SEW vwadd.vv vd, vs2, vs1, vm # vector-vector vwadd.vx vd, vs2, rs1, vm
            # vector-scalar vwsub.vv vd, vs2, vs1, vm # vector-vector vwsub.vx vd,
            vs2, rs1, vm # vector-scalar # Widening unsigned integer add/subtract,
            2*SEW = 2*SEW +/- SEW vwaddu.wv vd, vs2, vs1, vm # vector-vector vwaddu.wx
            vd, vs2, rs1, vm # vector-scalar vwsubu.wv vd, vs2, vs1, vm # vector-vector
            vwsubu.wx vd, vs2, rs1, vm # vector-scalar # Widening signed integer add/subtract,
            2*SEW = 2*SEW +/- SEW vwadd.wv vd, vs2, vs1, vm # vector-vector vwadd.wx
            vd, vs2, rs1, vm # vector-scalar vwsub.wv vd, vs2, vs1, vm # vector-vector
            vwsub.wx vd, vs2, rs1, vm # vector-scalar"
        "#_vector_instruction_listing":
          text:
          - vwaddu
          - vwaddu.w
  vwaddu.wv:
    opcode:
    - vwaddu.wv
    - 31..26=0x34
    - vm
    - vs2
    - vs1
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_widening_integer_addsubtract"
    desc:
      v:
        "#_vector_widening_integer_addsubtract":
          text:
          - "# Widening unsigned integer add/subtract, 2*SEW = SEW +/- SEW vwaddu.vv
            vd, vs2, vs1, vm # vector-vector vwaddu.vx vd, vs2, rs1, vm # vector-scalar
            vwsubu.vv vd, vs2, vs1, vm # vector-vector vwsubu.vx vd, vs2, rs1, vm
            # vector-scalar # Widening signed integer add/subtract, 2*SEW = SEW +/-
            SEW vwadd.vv vd, vs2, vs1, vm # vector-vector vwadd.vx vd, vs2, rs1, vm
            # vector-scalar vwsub.vv vd, vs2, vs1, vm # vector-vector vwsub.vx vd,
            vs2, rs1, vm # vector-scalar # Widening unsigned integer add/subtract,
            2*SEW = 2*SEW +/- SEW vwaddu.wv vd, vs2, vs1, vm # vector-vector vwaddu.wx
            vd, vs2, rs1, vm # vector-scalar vwsubu.wv vd, vs2, vs1, vm # vector-vector
            vwsubu.wx vd, vs2, rs1, vm # vector-scalar # Widening signed integer add/subtract,
            2*SEW = 2*SEW +/- SEW vwadd.wv vd, vs2, vs1, vm # vector-vector vwadd.wx
            vd, vs2, rs1, vm # vector-scalar vwsub.wv vd, vs2, vs1, vm # vector-vector
            vwsub.wx vd, vs2, rs1, vm # vector-scalar"
        "#_vector_instruction_listing":
          text:
          - vwaddu
          - vwaddu.w
  vwaddu.wx:
    opcode:
    - vwaddu.wx
    - 31..26=0x34
    - vm
    - vs2
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_widening_integer_addsubtract"
    desc:
      v:
        "#_vector_widening_integer_addsubtract":
          text:
          - "# Widening unsigned integer add/subtract, 2*SEW = SEW +/- SEW vwaddu.vv
            vd, vs2, vs1, vm # vector-vector vwaddu.vx vd, vs2, rs1, vm # vector-scalar
            vwsubu.vv vd, vs2, vs1, vm # vector-vector vwsubu.vx vd, vs2, rs1, vm
            # vector-scalar # Widening signed integer add/subtract, 2*SEW = SEW +/-
            SEW vwadd.vv vd, vs2, vs1, vm # vector-vector vwadd.vx vd, vs2, rs1, vm
            # vector-scalar vwsub.vv vd, vs2, vs1, vm # vector-vector vwsub.vx vd,
            vs2, rs1, vm # vector-scalar # Widening unsigned integer add/subtract,
            2*SEW = 2*SEW +/- SEW vwaddu.wv vd, vs2, vs1, vm # vector-vector vwaddu.wx
            vd, vs2, rs1, vm # vector-scalar vwsubu.wv vd, vs2, vs1, vm # vector-vector
            vwsubu.wx vd, vs2, rs1, vm # vector-scalar # Widening signed integer add/subtract,
            2*SEW = 2*SEW +/- SEW vwadd.wv vd, vs2, vs1, vm # vector-vector vwadd.wx
            vd, vs2, rs1, vm # vector-scalar vwsub.wv vd, vs2, vs1, vm # vector-vector
            vwsub.wx vd, vs2, rs1, vm # vector-scalar"
        "#_vector_instruction_listing":
          text:
          - vwaddu
          - vwaddu.w
  vwmacc.vv:
    opcode:
    - vwmacc.vv
    - 31..26=0x3d
    - vm
    - vs2
    - vs1
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vwmacc
  vwmacc.vx:
    opcode:
    - vwmacc.vx
    - 31..26=0x3d
    - vm
    - vs2
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vwmacc
  vwmaccsu.vv:
    opcode:
    - vwmaccsu.vv
    - 31..26=0x3f
    - vm
    - vs2
    - vs1
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vwmaccsu
  vwmaccsu.vx:
    opcode:
    - vwmaccsu.vx
    - 31..26=0x3f
    - vm
    - vs2
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vwmaccsu
  vwmaccu.vv:
    opcode:
    - vwmaccu.vv
    - 31..26=0x3c
    - vm
    - vs2
    - vs1
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_widening_integer_multiply_add_instructions"
    desc:
      v:
        "#_vector_widening_integer_multiply_add_instructions":
          text:
          - "# Widening unsigned-integer multiply-add, overwrite addend vwmaccu.vv
            vd, vs1, vs2, vm # vd[i] = +(vs1[i] * vs2[i]) + vd[i] vwmaccu.vx vd, rs1,
            vs2, vm # vd[i] = +(x[rs1] * vs2[i]) + vd[i] # Widening signed-integer
            multiply-add, overwrite addend vwmacc.vv vd, vs1, vs2, vm # vd[i] = +(vs1[i]
            * vs2[i]) + vd[i] vwmacc.vx vd, rs1, vs2, vm # vd[i] = +(x[rs1] * vs2[i])
            + vd[i] # Widening signed-unsigned-integer multiply-add, overwrite addend
            vwmaccsu.vv vd, vs1, vs2, vm # vd[i] = +(signed(vs1[i]) * unsigned(vs2[i]))
            + vd[i] vwmaccsu.vx vd, rs1, vs2, vm # vd[i] = +(signed(x[rs1]) * unsigned(vs2[i]))
            + vd[i] # Widening unsigned-signed-integer multiply-add, overwrite addend
            vwmaccus.vx vd, rs1, vs2, vm # vd[i] = +(unsigned(x[rs1]) * signed(vs2[i]))
            + vd[i]"
        "#_vector_instruction_listing":
          text:
          - vwmaccu
  vwmaccu.vx:
    opcode:
    - vwmaccu.vx
    - 31..26=0x3c
    - vm
    - vs2
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_widening_integer_multiply_add_instructions"
    desc:
      v:
        "#_vector_widening_integer_multiply_add_instructions":
          text:
          - "# Widening unsigned-integer multiply-add, overwrite addend vwmaccu.vv
            vd, vs1, vs2, vm # vd[i] = +(vs1[i] * vs2[i]) + vd[i] vwmaccu.vx vd, rs1,
            vs2, vm # vd[i] = +(x[rs1] * vs2[i]) + vd[i] # Widening signed-integer
            multiply-add, overwrite addend vwmacc.vv vd, vs1, vs2, vm # vd[i] = +(vs1[i]
            * vs2[i]) + vd[i] vwmacc.vx vd, rs1, vs2, vm # vd[i] = +(x[rs1] * vs2[i])
            + vd[i] # Widening signed-unsigned-integer multiply-add, overwrite addend
            vwmaccsu.vv vd, vs1, vs2, vm # vd[i] = +(signed(vs1[i]) * unsigned(vs2[i]))
            + vd[i] vwmaccsu.vx vd, rs1, vs2, vm # vd[i] = +(signed(x[rs1]) * unsigned(vs2[i]))
            + vd[i] # Widening unsigned-signed-integer multiply-add, overwrite addend
            vwmaccus.vx vd, rs1, vs2, vm # vd[i] = +(unsigned(x[rs1]) * signed(vs2[i]))
            + vd[i]"
        "#_vector_instruction_listing":
          text:
          - vwmaccu
  vwmaccus.vx:
    opcode:
    - vwmaccus.vx
    - 31..26=0x3e
    - vm
    - vs2
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vwmaccus
  vwmul.vv:
    opcode:
    - vwmul.vv
    - 31..26=0x3b
    - vm
    - vs2
    - vs1
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_widening_integer_multiply_instructions"
    desc:
      v:
        "#_vector_widening_integer_multiply_instructions":
          text:
          - "# Widening signed-integer multiply vwmul.vv vd, vs2, vs1, vm # vector-vector
            vwmul.vx vd, vs2, rs1, vm # vector-scalar # Widening unsigned-integer
            multiply vwmulu.vv vd, vs2, vs1, vm # vector-vector vwmulu.vx vd, vs2,
            rs1, vm # vector-scalar # Widening signed(vs2)-unsigned integer multiply
            vwmulsu.vv vd, vs2, vs1, vm # vector-vector vwmulsu.vx vd, vs2, rs1, vm
            # vector-scalar"
        "#_vector_instruction_listing":
          text:
          - vwmul
  vwmul.vx:
    opcode:
    - vwmul.vx
    - 31..26=0x3b
    - vm
    - vs2
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_widening_integer_multiply_instructions"
    desc:
      v:
        "#_vector_widening_integer_multiply_instructions":
          text:
          - "# Widening signed-integer multiply vwmul.vv vd, vs2, vs1, vm # vector-vector
            vwmul.vx vd, vs2, rs1, vm # vector-scalar # Widening unsigned-integer
            multiply vwmulu.vv vd, vs2, vs1, vm # vector-vector vwmulu.vx vd, vs2,
            rs1, vm # vector-scalar # Widening signed(vs2)-unsigned integer multiply
            vwmulsu.vv vd, vs2, vs1, vm # vector-vector vwmulsu.vx vd, vs2, rs1, vm
            # vector-scalar"
        "#_vector_instruction_listing":
          text:
          - vwmul
  vwmulsu.vv:
    opcode:
    - vwmulsu.vv
    - 31..26=0x3a
    - vm
    - vs2
    - vs1
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vwmulsu
  vwmulsu.vx:
    opcode:
    - vwmulsu.vx
    - 31..26=0x3a
    - vm
    - vs2
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vwmulsu
  vwmulu.vv:
    opcode:
    - vwmulu.vv
    - 31..26=0x38
    - vm
    - vs2
    - vs1
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vwmulu
  vwmulu.vx:
    opcode:
    - vwmulu.vx
    - 31..26=0x38
    - vm
    - vs2
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vwmulu
  vwredsum.vs:
    opcode:
    - vwredsum.vs
    - 31..26=0x31
    - vm
    - vs2
    - vs1
    - 14..12=0x0
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#sec-vector-integer-reduce-widen"
    desc:
      v:
        "#sec-vector-integer-reduce-widen":
          text:
          - The vwredsum.vs instruction sign-extends the SEW-wide vector elements
            before summing them.
        "#_vector_instruction_listing":
          text:
          - vwredsum
  vwredsumu.vs:
    opcode:
    - vwredsumu.vs
    - 31..26=0x30
    - vm
    - vs2
    - vs1
    - 14..12=0x0
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#sec-vector-integer-reduce-widen"
    desc:
      v:
        "#sec-vector-integer-reduce-widen":
          text:
          - The unsigned vwredsumu.vs instruction zero-extends the SEW-wide vector
            elements before summing them, then adds the 2*SEW-width scalar element,
            and stores the result in a 2*SEW-width scalar element.
          - For both vwredsumu.vs and vwredsum.vs, overflows wrap around.
          - "# Unsigned sum reduction into double-width accumulator vwredsumu.vs vd,
            vs2, vs1, vm # 2*SEW = 2*SEW + sum(zero-extend(SEW)) # Signed sum reduction
            into double-width accumulator vwredsum.vs vd, vs2, vs1, vm # 2*SEW = 2*SEW
            + sum(sign-extend(SEW))"
        "#_vector_instruction_listing":
          text:
          - vwredsumu
  vwsub.vv:
    opcode:
    - vwsub.vv
    - 31..26=0x33
    - vm
    - vs2
    - vs1
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vwsub
          - vwsub.w
  vwsub.vx:
    opcode:
    - vwsub.vx
    - 31..26=0x33
    - vm
    - vs2
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vwsub
          - vwsub.w
  vwsub.wv:
    opcode:
    - vwsub.wv
    - 31..26=0x37
    - vm
    - vs2
    - vs1
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vwsub
          - vwsub.w
  vwsub.wx:
    opcode:
    - vwsub.wx
    - 31..26=0x37
    - vm
    - vs2
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vwsub
          - vwsub.w
  vwsubu.vv:
    opcode:
    - vwsubu.vv
    - 31..26=0x32
    - vm
    - vs2
    - vs1
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vwsubu
          - vwsubu.w
  vwsubu.vx:
    opcode:
    - vwsubu.vx
    - 31..26=0x32
    - vm
    - vs2
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vwsubu
          - vwsubu.w
  vwsubu.wv:
    opcode:
    - vwsubu.wv
    - 31..26=0x36
    - vm
    - vs2
    - vs1
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vwsubu
          - vwsubu.w
  vwsubu.wx:
    opcode:
    - vwsubu.wx
    - 31..26=0x36
    - vm
    - vs2
    - rs1
    - 14..12=0x6
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vwsubu
          - vwsubu.w
  vxor.vi:
    opcode:
    - vxor.vi
    - 31..26=0x0b
    - vm
    - vs2
    - simm5
    - 14..12=0x3
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *30
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vxor
  vxor.vv:
    opcode:
    - vxor.vv
    - 31..26=0x0b
    - vm
    - vs2
    - vs1
    - 14..12=0x0
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *28
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vxor
  vxor.vx:
    opcode:
    - vxor.vx
    - 31..26=0x0b
    - vm
    - vs2
    - rs1
    - 14..12=0x4
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *29
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#_vector_instruction_listing"
    desc:
      v:
        "#_vector_instruction_listing":
          text:
          - vxor
  vzext.vf2:
    opcode:
    - vzext.vf2
    - 31..26=0x12
    - vm
    - vs2
    - 19..15=6
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *31
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#sec-vec-operands"
    desc:
      v:
        "#sec-vec-operands":
          text:
          - The destination EEW is greater than the source EEW, the source EMUL is
            at least 1, and the overlap is in the highest-numbered part of the destination
            register group (e.g., when LMUL=8, vzext.vf4 v0, v6 is legal, but a source
            of v0, v2, or v4 is not).
        "#_vector_integer_extension":
          text:
          - 'vzext.vf2 vd, vs2, vm # Zero-extend SEW/2 source to SEW destination vsext.vf2
            vd, vs2, vm # Sign-extend SEW/2 source to SEW destination vzext.vf4 vd,
            vs2, vm # Zero-extend SEW/4 source to SEW destination vsext.vf4 vd, vs2,
            vm # Sign-extend SEW/4 source to SEW destination vzext.vf8 vd, vs2, vm
            # Zero-extend SEW/8 source to SEW destination vsext.vf8 vd, vs2, vm #
            Sign-extend SEW/8 source to SEW destination'
        "#_vector_instruction_listing":
          text:
          - vzext.vf8
          - vzext.vf4
          - vzext.vf2
  vzext.vf4:
    opcode:
    - vzext.vf4
    - 31..26=0x12
    - vm
    - vs2
    - 19..15=4
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *31
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#sec-vec-operands"
    desc:
      v:
        "#sec-vec-operands":
          text:
          - The destination EEW is greater than the source EEW, the source EMUL is
            at least 1, and the overlap is in the highest-numbered part of the destination
            register group (e.g., when LMUL=8, vzext.vf4 v0, v6 is legal, but a source
            of v0, v2, or v4 is not).
        "#_vector_integer_extension":
          text:
          - 'vzext.vf2 vd, vs2, vm # Zero-extend SEW/2 source to SEW destination vsext.vf2
            vd, vs2, vm # Sign-extend SEW/2 source to SEW destination vzext.vf4 vd,
            vs2, vm # Zero-extend SEW/4 source to SEW destination vsext.vf4 vd, vs2,
            vm # Sign-extend SEW/4 source to SEW destination vzext.vf8 vd, vs2, vm
            # Zero-extend SEW/8 source to SEW destination vsext.vf8 vd, vs2, vm #
            Sign-extend SEW/8 source to SEW destination'
        "#_vector_instruction_listing":
          text:
          - vzext.vf8
          - vzext.vf4
          - vzext.vf2
  vzext.vf8:
    opcode:
    - vzext.vf8
    - 31..26=0x12
    - vm
    - vs2
    - 19..15=2
    - 14..12=0x2
    - vd
    - 6..0=0x57
    opcode_group: v
    opcode_args: *31
    main_url_base: "/riscv-v-spec/v1.0//v-spec.html"
    main_desc: v
    main_id: "#sec-vec-operands"
    desc:
      v:
        "#sec-vec-operands":
          text:
          - The destination EEW is greater than the source EEW, the source EMUL is
            at least 1, and the overlap is in the highest-numbered part of the destination
            register group (e.g., when LMUL=8, vzext.vf4 v0, v6 is legal, but a source
            of v0, v2, or v4 is not).
        "#_vector_integer_extension":
          text:
          - 'vzext.vf2 vd, vs2, vm # Zero-extend SEW/2 source to SEW destination vsext.vf2
            vd, vs2, vm # Sign-extend SEW/2 source to SEW destination vzext.vf4 vd,
            vs2, vm # Zero-extend SEW/4 source to SEW destination vsext.vf4 vd, vs2,
            vm # Sign-extend SEW/4 source to SEW destination vzext.vf8 vd, vs2, vm
            # Zero-extend SEW/8 source to SEW destination vsext.vf8 vd, vs2, vm #
            Sign-extend SEW/8 source to SEW destination'
        "#_vector_instruction_listing":
          text:
          - vzext.vf8
          - vzext.vf4
          - vzext.vf2
  wfi:
    opcode:
    - wfi
    - 11..7=0
    - 19..15=0
    - 31..20=0x105
    - 14..12=0
    - 6..2=0x1C
    - 1..0=3
    opcode_group: system
    opcode_args: *18
    main_url_base: "/riscv-priv-isa-manual/Priv-v1.12/machine.html"
    main_desc: machine
    main_id: "#virt-control"
    desc:
      machine:
        "#virt-control":
          text:
          - field that supports intercepting the WFI instruction (see Section 1.3.3
            ). When TW=0, the WFI instruction may execute in lower privilege modes
            when not prevented for some other reason. When TW=1, then if WFI is executed
            in any less-privileged mode, and it does not complete within an implementation-specific,
            bounded time limit, the WFI instruction causes an illegal instruction
            exception. The time limit may always be 0, in which case WFI always causes
            an illegal instruction exception in less-privileged modes when TW=1. TW
            is read-only 0 when there are no modes less privileged than M.
          - Trapping the WFI instruction can trigger a world switch to another guest
            OS, rather than wastefully idling in the current guest.
          - When S-mode is implemented, then executing WFI in U-mode causes an illegal
            instruction exception, unless it completes within an implementation-specific,
            bounded time limit. A future revision of this specification might add
            a feature that allows S-mode to selectively permit WFI in U-mode. Such
            a feature would only be active when TW=0.
        "#wfi":
          text:
          - The Wait for Interrupt instruction (WFI) provides a hint to the implementation
            that the current hart can be stalled until an interrupt might need servicing.
            Execution of the WFI instruction can also be used to inform the hardware
            platform that suitable interrupts should preferentially be routed to this
            hart. WFI is available in all privileged modes, and optionally available
            to U-mode. This instruction may raise an illegal instruction exception
            when TW=1 in mstatus, as described in Section 1.1.6.5 .
          - The following instruction takes the interrupt trap so that a simple return
            from the trap handler will execute code after the WFI instruction.
          - The purpose of the WFI instruction is to provide a hint to the implementation,
            and so a legal implementation is to simply implement WFI as a NOP.
          - If the implementation does not stall the hart on execution of the instruction,
            then the interrupt will be taken on some instruction in the idle loop
            containing the WFI, and on a simple return from the handler, the idle
            loop will resume execution.
          - The WFI instruction can also be executed when interrupts are disabled.
            The operation of WFI must be unaffected by the global interrupt bits in
            mstatus (MIE and SIE) and the delegation register mideleg (i.e., the hart
            must resume if a locally enabled interrupt becomes pending, even if it
            has been delegated to a less-privileged mode), but should honor the individual
            interrupt enables (e.g, MTIE) (i.e., implementations should avoid resuming
            the hart if the interrupt is pending but not individually enabled). WFI
            is also required to resume execution for locally enabled interrupts pending
            at any privilege level, regardless of the global interrupt enable at each
            privilege level.
          - If the event that causes the hart to resume execution does not cause an
            interrupt to be taken, execution will resume at pc + 4, and software must
            determine what action to take, including looping back to repeat the WFI
            if there was no actionable event.
          - By allowing wakeup when interrupts are disabled, an alternate entry point
            to an interrupt handler can be called that does not require saving the
            current context, as the current context can be saved or discarded before
            the WFI is executed.
          - As implementations are free to implement WFI as a NOP, software must explicitly
            check for any relevant pending but disabled interrupts in the code following
            an WFI, and should loop back to the WFI if no suitable interrupt was detected.
            The mip or sip registers can be interrogated to determine the presence
            of any interrupt in machine or supervisor mode respectively.
          - The operation of WFI is unaffected by the delegation register settings.
          - WFI is defined so that an implementation can trap into a higher privilege
            mode, either immediately on encountering the WFI or after some interval
            to initiate a machine-mode transition to a lower power state, for example.
      hypervisor:
        "#hypervisor-status-register-hstatus":
          text:
          - The hstatus fields VTSR, VTW, and VTVM are defined analogously to the
            mstatus fields TSR, TW, and TVM, but affect execution only in VS-mode,
            and cause virtual instruction exceptions instead of illegal instruction
            exceptions. When VTSR=1, an attempt in VS-mode to execute SRET raises
            a virtual instruction exception. When VTW=1 (and assuming mstatus.TW=0),
            an attempt in VS-mode to execute WFI raises a virtual instruction exception
            if the WFI does not complete within an implementation-specific, bounded
            time limit. When VTVM=1, an attempt in VS-mode to execute SFENCE.VMA or
            SINVAL.VMA or to access CSR satp raises a virtual instruction exception.
        "#trap-cause-codes":
          text:
          - in VU-mode, attempts to execute WFI when mstatus.TW=0, or to execute a
            supervisor instruction (SRET or SFENCE);
          - in VS-mode, attempts to execute WFI when hstatus.VTW=1 and mstatus.TW=0,
            unless the instruction completes within an implementation-specific, bounded
            time;
    iss_code:
    - if (STATE.v && STATE.prv == PRV_U) {
    - require_novirt();
    - "} else if (get_field(STATE.mstatus->read(), MSTATUS_TW)) {"
    - require_privilege(PRV_M);
    - "} else if (STATE.v) { // VS-mode"
    - if (get_field(STATE.hstatus->read(), HSTATUS_VTW))
    - require_novirt();
    - "} else if (p->extension_enabled('S')) {"
    - "// When S-mode is implemented, then executing WFI in"
    - "// U-mode causes an illegal instruction exception."
    - require_privilege(PRV_S);
    - "}"
    - wfi();
  wrs.nto:
    opcode:
    - wrs.nto
    - 31..20=0x00D
    - 19..7=0
    - 6..2=0x1C
    - 1..0=3
    opcode_group: zawrs
    opcode_args: *18
  wrs.sto:
    opcode:
    - wrs.sto
    - 31..20=0x01D
    - 19..7=0
    - 6..2=0x1C
    - 1..0=3
    opcode_group: zawrs
    opcode_args: *18
  xnor:
    opcode:
    - xnor
    - rd
    - rs1
    - rs2
    - 31..25=32
    - 14..12=4
    - 6..2=0x0C
    - 1..0=3
    opcode_group: zbb
    opcode_args: *1
    iss_code:
    - require_either_extension(EXT_ZBB, EXT_ZBKB);
    - WRITE_RD(RS1 ^ ~RS2);
  xor:
    opcode:
    - xor
    - rd
    - rs1
    - rs2
    - 31..25=0
    - 14..12=4
    - 6..2=0x0C
    - 1..0=3
    opcode_group: i
    opcode_args: *1
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/rv32.html"
    main_desc: rv32
    main_id: "#integer-register-register-operations"
    desc:
      rv32:
        "#integer-register-immediate-instructions":
          text:
          - ANDI, ORI, XORI are logical operations that perform bitwise AND, OR, and
            XOR on register rs1 and the sign-extended 12-bit immediate and place the
            result in rd. Note, XORI rd, rs1, -1 performs a bitwise logical inversion
            of register rs1 (assembler pseudoinstruction NOT rd, rs).
        "#integer-register-register-operations":
          text:
          - ADD performs the addition of rs1 and rs2. SUB performs the subtraction
            of rs2 from rs1. Overflows are ignored and the low XLEN bits of results
            are written to the destination rd. SLT and SLTU perform signed and unsigned
            compares respectively, writing 1 to rd if rs1 < rs2, 0 otherwise. Note,
            SLTU rd, x0, rs2 sets rd to 1 if rs2 is not equal to zero, otherwise sets
            rd to zero (assembler pseudoinstruction SNEZ rd, rs). AND, OR, and XOR
            perform bitwise logical operations.
      a:
        "#sec:amo":
          text:
          - The operations supported are swap, integer add, bitwise AND, bitwise OR,
            bitwise XOR, and signed and unsigned integer maximum and minimum. Without
            ordering constraints, these AMOs can be used to implement parallel reduction
            operations, where typically the return value would be discarded by writing
            to x0.
      f:
        "#single-precision-floating-point-conversion-and-move-instructions":
          text:
          - Floating-point to floating-point sign-injection instructions, FSGNJ.S,
            FSGNJN.S, and FSGNJX.S, produce a result that takes all bits except the
            sign bit from rs1. For FSGNJ, the result's sign bit is rs2's sign bit;
            for FSGNJN, the result's sign bit is the opposite of rs2's sign bit; and
            for FSGNJX, the sign bit is the XOR of the sign bits of rs1 and rs2. Sign-injection
            instructions do not set floating-point exception flags, nor do they canonicalize
            NaNs. Note, FSGNJ.S rx, ry, ry moves ry to rx (assembler pseudoinstruction
            FMV.S rx, ry); FSGNJN.S rx, ry, ry moves the negation of ry to rx (assembler
            pseudoinstruction FNEG.S rx, ry); and FSGNJX.S rx, ry, ry moves the absolute
            value of ry to rx (assembler pseudoinstruction FABS.S rx, ry).
      c:
        "#integer-register-register-operations":
          text:
          - C.XOR computes the bitwise XOR of the values in registers rd' and rs2',
            then writes the result to register rd'. C.XOR expands into xor rd', rd',
            rs2'.
    iss_code:
    - WRITE_RD(RS1 ^ RS2);
  xori:
    opcode:
    - xori
    - rd
    - rs1
    - imm12
    - 14..12=4
    - 6..2=0x04
    - 1..0=3
    opcode_group: i
    opcode_args: *2
    main_url_base: "/riscv-user-isa-manual/Priv-v1.12/rv32.html"
    main_desc: rv32
    main_id: "#integer-register-immediate-instructions"
    desc:
      rv32:
        "#integer-register-immediate-instructions":
          text:
          - ANDI, ORI, XORI are logical operations that perform bitwise AND, OR, and
            XOR on register rs1 and the sign-extended 12-bit immediate and place the
            result in rd. Note, XORI rd, rs1, -1 performs a bitwise logical inversion
            of register rs1 (assembler pseudoinstruction NOT rd, rs).
    iss_code:
    - WRITE_RD(insn.i_imm() ^ RS1);
  zext.b:
    opcode:
    - zext.b
    - rd
    - rs
    opcode_group: psuedo
    opcode_args:
    - rd
    - rs
    psuedo_to_base:
    - andi rd, rs, 255
  zext.h:
    opcode:
    - zext.h
    - rd
    - rs1
    - 31..25=0x04
    - 24..20=0
    - 14..12=0x4
    - 6..2=0xE
    - 1..0=0x3
    opcode_group: zbb
    opcode_args: *3
    pseudo_src: rv64_zbe
    pseudo_op: packw
  zext.w:
    opcode:
    - zext.w
    - rd
    - rs
    opcode_group: psuedo
    opcode_args:
    - rd
    - rs
    psuedo_to_base:
    - slli rd, rs, XLEN - 32
    - srli rd, rd, XLEN - 32
  zip:
    opcode:
    - zip
    - rd
    - rs1
    - 31..25=4
    - 24..20=15
    - 14..12=1
    - 6..2=4
    - 1..0=3
    opcode_group: zks
    opcode_args: *3
    pseudo_src: rv64_zbp
    pseudo_op: shfli
groups:
  a:
  - amoadd.d
  - amoand.d
  - amomax.d
  - amomaxu.d
  - amomin.d
  - amominu.d
  - amoor.d
  - amoswap.d
  - amoxor.d
  - lr.d
  - sc.d
  c:
  - c.addiw
  - c.addw
  - c.ld
  - c.ldsp
  - c.sd
  - c.sdsp
  - c.slli
  - c.srai
  - c.srli
  - c.subw
  c_d:
  - c.fld
  - c.fldsp
  - c.fsd
  - c.fsdsp
  c_f:
  - c.flw
  - c.flwsp
  - c.fsw
  - c.fswsp
  d:
  - fcvt.d.l
  - fcvt.d.lu
  - fcvt.l.d
  - fcvt.lu.d
  - fmv.d.x
  - fmv.x.d
  d_zfh:
  - fcvt.d.h
  - fcvt.h.d
  f:
  - fcvt.l.s
  - fcvt.lu.s
  - fcvt.s.l
  - fcvt.s.lu
  h:
  - hlv.d
  - hlv.wu
  - hsv.d
  i:
  - addiw
  - addw
  - ld
  - lwu
  - sd
  - slli
  - slliw
  - sllw
  - srai
  - sraiw
  - sraw
  - srli
  - srliw
  - srlw
  - subw
  m:
  - divuw
  - divw
  - mulw
  - remuw
  - remw
  q:
  - fcvt.l.q
  - fcvt.lu.q
  - fcvt.q.l
  - fcvt.q.lu
  q_zfh:
  - fcvt.h.q
  - fcvt.q.h
  s:
  - sfence.vma
  - sret
  sdext:
  - dret
  svinval:
  - hinval.gvma
  - hinval.vvma
  - sfence.inval.ir
  - sfence.w.inval
  - sinval.vma
  system:
  - mret
  - wfi
  v:
  - vaadd.vv
  - vaadd.vx
  - vaaddu.vv
  - vaaddu.vx
  - vadc.vim
  - vadc.vvm
  - vadc.vxm
  - vadd.vi
  - vadd.vv
  - vadd.vx
  - vamoaddei16.v
  - vamoaddei32.v
  - vamoaddei64.v
  - vamoaddei8.v
  - vamoandei16.v
  - vamoandei32.v
  - vamoandei64.v
  - vamoandei8.v
  - vamomaxei16.v
  - vamomaxei32.v
  - vamomaxei64.v
  - vamomaxei8.v
  - vamomaxuei16.v
  - vamomaxuei32.v
  - vamomaxuei64.v
  - vamomaxuei8.v
  - vamominei16.v
  - vamominei32.v
  - vamominei64.v
  - vamominei8.v
  - vamominuei16.v
  - vamominuei32.v
  - vamominuei64.v
  - vamominuei8.v
  - vamoorei16.v
  - vamoorei32.v
  - vamoorei64.v
  - vamoorei8.v
  - vamoswapei16.v
  - vamoswapei32.v
  - vamoswapei64.v
  - vamoswapei8.v
  - vamoxorei16.v
  - vamoxorei32.v
  - vamoxorei64.v
  - vamoxorei8.v
  - vand.vi
  - vand.vv
  - vand.vx
  - vasub.vv
  - vasub.vx
  - vasubu.vv
  - vasubu.vx
  - vcompress.vm
  - vcpop.m
  - vdiv.vv
  - vdiv.vx
  - vdivu.vv
  - vdivu.vx
  - vfadd.vf
  - vfadd.vv
  - vfclass.v
  - vfcvt.f.x.v
  - vfcvt.f.xu.v
  - vfcvt.rtz.x.f.v
  - vfcvt.rtz.xu.f.v
  - vfcvt.x.f.v
  - vfcvt.xu.f.v
  - vfdiv.vf
  - vfdiv.vv
  - vfirst.m
  - vfmacc.vf
  - vfmacc.vv
  - vfmadd.vf
  - vfmadd.vv
  - vfmax.vf
  - vfmax.vv
  - vfmerge.vfm
  - vfmin.vf
  - vfmin.vv
  - vfmsac.vf
  - vfmsac.vv
  - vfmsub.vf
  - vfmsub.vv
  - vfmul.vf
  - vfmul.vv
  - vfmv.f.s
  - vfmv.s.f
  - vfmv.v.f
  - vfncvt.f.f.w
  - vfncvt.f.x.w
  - vfncvt.f.xu.w
  - vfncvt.rod.f.f.w
  - vfncvt.rtz.x.f.w
  - vfncvt.rtz.xu.f.w
  - vfncvt.x.f.w
  - vfncvt.xu.f.w
  - vfnmacc.vf
  - vfnmacc.vv
  - vfnmadd.vf
  - vfnmadd.vv
  - vfnmsac.vf
  - vfnmsac.vv
  - vfnmsub.vf
  - vfnmsub.vv
  - vfrdiv.vf
  - vfrec7.v
  - vfredmax.vs
  - vfredmin.vs
  - vfredosum.vs
  - vfredusum.vs
  - vfrsqrt7.v
  - vfrsub.vf
  - vfsgnj.vf
  - vfsgnj.vv
  - vfsgnjn.vf
  - vfsgnjn.vv
  - vfsgnjx.vf
  - vfsgnjx.vv
  - vfslide1down.vf
  - vfslide1up.vf
  - vfsqrt.v
  - vfsub.vf
  - vfsub.vv
  - vfwadd.vf
  - vfwadd.vv
  - vfwadd.wf
  - vfwadd.wv
  - vfwcvt.f.f.v
  - vfwcvt.f.x.v
  - vfwcvt.f.xu.v
  - vfwcvt.rtz.x.f.v
  - vfwcvt.rtz.xu.f.v
  - vfwcvt.x.f.v
  - vfwcvt.xu.f.v
  - vfwmacc.vf
  - vfwmacc.vv
  - vfwmsac.vf
  - vfwmsac.vv
  - vfwmul.vf
  - vfwmul.vv
  - vfwnmacc.vf
  - vfwnmacc.vv
  - vfwnmsac.vf
  - vfwnmsac.vv
  - vfwredosum.vs
  - vfwredusum.vs
  - vfwsub.vf
  - vfwsub.vv
  - vfwsub.wf
  - vfwsub.wv
  - vid.v
  - viota.m
  - vl1re16.v
  - vl1re32.v
  - vl1re64.v
  - vl1re8.v
  - vl2re16.v
  - vl2re32.v
  - vl2re64.v
  - vl2re8.v
  - vl4re16.v
  - vl4re32.v
  - vl4re64.v
  - vl4re8.v
  - vl8re16.v
  - vl8re32.v
  - vl8re64.v
  - vl8re8.v
  - vle1024.v
  - vle1024ff.v
  - vle128.v
  - vle128ff.v
  - vle16.v
  - vle16ff.v
  - vle256.v
  - vle256ff.v
  - vle32.v
  - vle32ff.v
  - vle512.v
  - vle512ff.v
  - vle64.v
  - vle64ff.v
  - vle8.v
  - vle8ff.v
  - vlm.v
  - vloxei1024.v
  - vloxei128.v
  - vloxei16.v
  - vloxei256.v
  - vloxei32.v
  - vloxei512.v
  - vloxei64.v
  - vloxei8.v
  - vlse1024.v
  - vlse128.v
  - vlse16.v
  - vlse256.v
  - vlse32.v
  - vlse512.v
  - vlse64.v
  - vlse8.v
  - vluxei1024.v
  - vluxei128.v
  - vluxei16.v
  - vluxei256.v
  - vluxei32.v
  - vluxei512.v
  - vluxei64.v
  - vluxei8.v
  - vmacc.vv
  - vmacc.vx
  - vmadc.vi
  - vmadc.vim
  - vmadc.vv
  - vmadc.vvm
  - vmadc.vx
  - vmadc.vxm
  - vmadd.vv
  - vmadd.vx
  - vmand.mm
  - vmandn.mm
  - vmax.vv
  - vmax.vx
  - vmaxu.vv
  - vmaxu.vx
  - vmerge.vim
  - vmerge.vvm
  - vmerge.vxm
  - vmfeq.vf
  - vmfeq.vv
  - vmfge.vf
  - vmfgt.vf
  - vmfle.vf
  - vmfle.vv
  - vmflt.vf
  - vmflt.vv
  - vmfne.vf
  - vmfne.vv
  - vmin.vv
  - vmin.vx
  - vminu.vv
  - vminu.vx
  - vmnand.mm
  - vmnor.mm
  - vmor.mm
  - vmorn.mm
  - vmsbc.vv
  - vmsbc.vvm
  - vmsbc.vx
  - vmsbc.vxm
  - vmsbf.m
  - vmseq.vi
  - vmseq.vv
  - vmseq.vx
  - vmsgt.vi
  - vmsgt.vx
  - vmsgtu.vi
  - vmsgtu.vx
  - vmsif.m
  - vmsle.vi
  - vmsle.vv
  - vmsle.vx
  - vmsleu.vi
  - vmsleu.vv
  - vmsleu.vx
  - vmslt.vv
  - vmslt.vx
  - vmsltu.vv
  - vmsltu.vx
  - vmsne.vi
  - vmsne.vv
  - vmsne.vx
  - vmsof.m
  - vmul.vv
  - vmul.vx
  - vmulh.vv
  - vmulh.vx
  - vmulhsu.vv
  - vmulhsu.vx
  - vmulhu.vv
  - vmulhu.vx
  - vmv.s.x
  - vmv.v.i
  - vmv.v.v
  - vmv.v.x
  - vmv.x.s
  - vmv1r.v
  - vmv2r.v
  - vmv4r.v
  - vmv8r.v
  - vmxnor.mm
  - vmxor.mm
  - vnclip.wi
  - vnclip.wv
  - vnclip.wx
  - vnclipu.wi
  - vnclipu.wv
  - vnclipu.wx
  - vnmsac.vv
  - vnmsac.vx
  - vnmsub.vv
  - vnmsub.vx
  - vnsra.wi
  - vnsra.wv
  - vnsra.wx
  - vnsrl.wi
  - vnsrl.wv
  - vnsrl.wx
  - vor.vi
  - vor.vv
  - vor.vx
  - vredand.vs
  - vredmax.vs
  - vredmaxu.vs
  - vredmin.vs
  - vredminu.vs
  - vredor.vs
  - vredsum.vs
  - vredxor.vs
  - vrem.vv
  - vrem.vx
  - vremu.vv
  - vremu.vx
  - vrgather.vi
  - vrgather.vv
  - vrgather.vx
  - vrgatherei16.vv
  - vrsub.vi
  - vrsub.vx
  - vs1r.v
  - vs2r.v
  - vs4r.v
  - vs8r.v
  - vsadd.vi
  - vsadd.vv
  - vsadd.vx
  - vsaddu.vi
  - vsaddu.vv
  - vsaddu.vx
  - vsbc.vvm
  - vsbc.vxm
  - vse1024.v
  - vse128.v
  - vse16.v
  - vse256.v
  - vse32.v
  - vse512.v
  - vse64.v
  - vse8.v
  - vsetivli
  - vsetvl
  - vsetvli
  - vsext.vf2
  - vsext.vf4
  - vsext.vf8
  - vslide1down.vx
  - vslide1up.vx
  - vslidedown.vi
  - vslidedown.vx
  - vslideup.vi
  - vslideup.vx
  - vsll.vi
  - vsll.vv
  - vsll.vx
  - vsm.v
  - vsmul.vv
  - vsmul.vx
  - vsoxei1024.v
  - vsoxei128.v
  - vsoxei16.v
  - vsoxei256.v
  - vsoxei32.v
  - vsoxei512.v
  - vsoxei64.v
  - vsoxei8.v
  - vsra.vi
  - vsra.vv
  - vsra.vx
  - vsrl.vi
  - vsrl.vv
  - vsrl.vx
  - vsse1024.v
  - vsse128.v
  - vsse16.v
  - vsse256.v
  - vsse32.v
  - vsse512.v
  - vsse64.v
  - vsse8.v
  - vssra.vi
  - vssra.vv
  - vssra.vx
  - vssrl.vi
  - vssrl.vv
  - vssrl.vx
  - vssub.vv
  - vssub.vx
  - vssubu.vv
  - vssubu.vx
  - vsub.vv
  - vsub.vx
  - vsuxei1024.v
  - vsuxei128.v
  - vsuxei16.v
  - vsuxei256.v
  - vsuxei32.v
  - vsuxei512.v
  - vsuxei64.v
  - vsuxei8.v
  - vwadd.vv
  - vwadd.vx
  - vwadd.wv
  - vwadd.wx
  - vwaddu.vv
  - vwaddu.vx
  - vwaddu.wv
  - vwaddu.wx
  - vwmacc.vv
  - vwmacc.vx
  - vwmaccsu.vv
  - vwmaccsu.vx
  - vwmaccu.vv
  - vwmaccu.vx
  - vwmaccus.vx
  - vwmul.vv
  - vwmul.vx
  - vwmulsu.vv
  - vwmulsu.vx
  - vwmulu.vv
  - vwmulu.vx
  - vwredsum.vs
  - vwredsumu.vs
  - vwsub.vv
  - vwsub.vx
  - vwsub.wv
  - vwsub.wx
  - vwsubu.vv
  - vwsubu.vx
  - vwsubu.wv
  - vwsubu.wx
  - vxor.vi
  - vxor.vv
  - vxor.vx
  - vzext.vf2
  - vzext.vf4
  - vzext.vf8
  v_aliases:
  - vfredsum.vs
  - vfwredsum.vs
  - vl1r.v
  - vl2r.v
  - vl4r.v
  - vl8r.v
  - vle1.v
  - vmandnot.mm
  - vmornot.mm
  - vpopc.m
  - vse1.v
  zawrs:
  - wrs.nto
  - wrs.sto
  zba:
  - add.uw
  - sh1add.uw
  - sh2add.uw
  - sh3add.uw
  - slli.uw
  zbb:
  - clzw
  - cpopw
  - ctzw
  - rev8
  - rolw
  - rori
  - roriw
  - rorw
  - zext.h
  zbc:
  - clmul
  - clmulh
  - clmulr
  zbkb:
  - rev8
  zbkc: []
  zbkx: []
  zbs:
  - bclri
  - bexti
  - binvi
  - bseti
  zcb:
  - c.zext.w
  zcmp:
  - cm.mva01s
  - cm.mvsa01
  - cm.pop
  - cm.popret
  - cm.popretz
  - cm.push
  zcmt:
  - cm.jalt
  zfh:
  - fcvt.h.l
  - fcvt.h.lu
  - fcvt.l.h
  - fcvt.lu.h
  zicbo:
  - cbo.clean
  - cbo.flush
  - cbo.inval
  - cbo.zero
  - prefetch.i
  - prefetch.r
  - prefetch.w
  zicsr:
  - csrrc
  - csrrci
  - csrrs
  - csrrsi
  - csrrw
  - csrrwi
  - frcsr
  - frflags
  - frrm
  - fscsr
  - fsflags
  - fsflagsi
  - fsrm
  - fsrmi
  - rdcycle
  - rdcycleh
  - rdinstret
  - rdinstreth
  - rdtime
  - rdtimeh
  zifencei:
  - fence.i
  zk:
  - rev8
  zkn:
  - rev8
  zknd:
  - aes64ds
  - aes64dsm
  - aes64im
  - aes64ks1i
  - aes64ks2
  zkne:
  - aes64es
  - aes64esm
  zknh:
  - sha512sig0
  - sha512sig1
  - sha512sum0
  - sha512sum1
  zks:
  - rev8
  zksed:
  - sm4ed
  - sm4ks
  zksh:
  - sm3p0
  - sm3p1
sections:
  a:
    "#sec:amo":
    - amoadd.d
    - amoadd.w
    - amoand.d
    - amoand.w
    - amomax.d
    - amomax.w
    - amomaxu.d
    - amomaxu.w
    - amomin.d
    - amomin.w
    - amominu.d
    - amominu.w
    - amoor.d
    - amoor.w
    - amoswap.d
    - amoswap.w
    - amoxor.d
    - amoxor.w
    "#sec:lrsc":
    - lr.d
    - lr.w
    - sc.d
    - sc.w
  b: {}
  c:
    "#compressed":
    - c.slli_rv32
    - c.srai_rv32
    - c.srli_rv32
    "#control-transfer-instructions":
    - c.beqz
    - c.bnez
    - c.j
    - c.jal
    "#integer-constant-generation-instructions":
    - c.addi16sp
    - c.li
    - c.lui
    "#integer-register-immediate-operations":
    - c.addi
    - c.addi4spn
    - c.addiw
    - c.andi
    - c.slli
    - c.srai
    - c.srli
    "#integer-register-register-operations":
    - c.add
    - c.addw
    - c.and
    - c.ebreak
    - c.jalr
    - c.jr
    - c.mv
    - c.or
    - c.sub
    - c.subw
    - c.xor
    "#nop-instruction":
    - c.nop
    "#register-based-loads-and-stores":
    - c.fld
    - c.flw
    - c.fsd
    - c.fsw
    - c.ld
    - c.lw
    - c.sd
    - c.sw
    "#stack-pointer-based-loads-and-stores":
    - c.fldsp
    - c.flwsp
    - c.fsdsp
    - c.fswsp
    - c.ldsp
    - c.lwsp
    - c.sdsp
    - c.swsp
  counters:
    "#zicntr-standard-extension-for-base-counters-and-timers":
    - rdcycle
    - rdcycleh
    - rdinstret
    - rdinstreth
    - rdtime
    - rdtimeh
  csr:
    "#csr-instructions":
    - csrc
    - csrci
    - csrr
    - csrrc
    - csrrci
    - csrrs
    - csrrsi
    - csrrw
    - csrrwi
    - csrs
    - csrsi
    - csrw
    - csrwi
  custom: {}
  d:
    "#double-precision-floating-point-classify-instruction":
    - fclass.d
    "#double-precision-floating-point-conversion-and-move-instructions":
    - fcvt.d.l
    - fcvt.d.lu
    - fcvt.d.s
    - fcvt.d.w
    - fcvt.d.wu
    - fcvt.l.d
    - fcvt.lu.d
    - fcvt.s.d
    - fcvt.w.d
    - fcvt.wu.d
    - fmv.d
    - fmv.x.d
    - fsgnj.d
    - fsgnjn.d
    - fsgnjx.d
    "#fld_fsd":
    - fld
    - fsd
    "#sec:single-float-compute":
    - fadd.d
    - fdiv.d
    - fmadd.d
    - fmax.d
    - fmin.d
    - fmsub.d
    - fmul.d
    - fnmadd.d
    - fnmsub.d
    - fsqrt.d
    - fsub.d
    "#single-precision-floating-point-compare-instructions":
    - feq.d
    - fle.d
    - flt.d
    "#single-precision-floating-point-conversion-and-move-instructions":
    - fabs.d
    - fmv.d.x
    - fneg.d
  f:
    "#floating-point-control-and-status-register":
    - frcsr
    - frflags
    - frrm
    - fscsr
    - fsflags
    - fsrm
    "#sec:single-float-compute":
    - fadd.s
    - fdiv.s
    - fmadd.s
    - fmax.s
    - fmin.s
    - fmsub.s
    - fmul.s
    - fnmadd.s
    - fnmsub.s
    - fsqrt.s
    - fsub.s
    "#single-precision-floating-point-classify-instruction":
    - fclass.s
    "#single-precision-floating-point-compare-instructions":
    - feq.s
    - fle.s
    - flt.s
    "#single-precision-floating-point-conversion-and-move-instructions":
    - fabs.s
    - fcvt.l.s
    - fcvt.lu.s
    - fcvt.s.l
    - fcvt.s.lu
    - fcvt.s.w
    - fcvt.s.wu
    - fcvt.w.s
    - fcvt.wu.s
    - fmv.s
    - fmv.w.x
    - fmv.x.s
    - fmv.x.w
    - fneg.s
    - fsgnj.s
    - fsgnjn.s
    - fsgnjx.s
    - neg
    "#single-precision-load-and-store-instructions":
    - flw
    - fsw
  hypervisor:
    "#hypervisor-virtual-machine-load-and-store-instructions":
    - hlv.b
    - hlv.bu
    - hlv.d
    - hlv.h
    - hlv.hu
    - hlv.w
    - hlv.wu
    - hlvx.hu
    - hlvx.wu
    - hsv.b
    - hsv.d
    - hsv.h
    - hsv.w
  j: {}
  m:
    "#division-operations":
    - div
    - divu
    - divuw
    - divw
    - rem
    - remu
    - remuw
    - remw
    "#multiplication-operations":
    - mul
    - mulh
    - mulhsu
    - mulhu
    - mulw
  machine:
    "#privstack":
    - mret
    - sret
    "#virt-control":
    - sinval.vma
    - wfi
  p: {}
  q:
    "#quad-precision-convert-and-move-instructions":
    - fcvt.d.q
    - fcvt.l.q
    - fcvt.lu.q
    - fcvt.q.d
    - fcvt.q.l
    - fcvt.q.lu
    - fcvt.q.s
    - fcvt.q.w
    - fcvt.q.wu
    - fcvt.s.q
    - fcvt.w.q
    - fcvt.wu.q
    - fsgnj.q
    - fsgnjn.q
    - fsgnjx.q
    "#quad-precision-floating-point-classify-instruction":
    - fclass.q
    "#quad-precision-load-and-store-instructions":
    - flq
    - fsq
    "#sec:single-float-compute":
    - fadd.q
    - fdiv.q
    - fmadd.q
    - fmax.q
    - fmin.q
    - fmsub.q
    - fmul.q
    - fnmadd.q
    - fnmsub.q
    - fsqrt.q
    - fsub.q
    "#single-precision-floating-point-compare-instructions":
    - feq.q
    - fle.q
    - flt.q
  rv128: {}
  rv32:
    "#conditional-branches":
    - beq
    - bge
    - bgeu
    - bgt
    - bgtu
    - ble
    - bleu
    - blt
    - bltu
    - bne
    "#environment-call-and-breakpoints":
    - sbreak
    - scall
    "#immediate-encoding-variants":
    - j
    "#integer-register-immediate-instructions":
    - addi
    - andi
    - auipc
    - jal
    - jalr
    - lui
    - mv
    - not
    - ori
    - seqz
    - slli
    - slti
    - sltiu
    - srai
    - srli
    - xori
    "#integer-register-register-operations":
    - add
    - and
    - or
    - sll
    - slt
    - sltu
    - snez
    - sra
    - srl
    - sub
    - xor
    "#nop-instruction":
    - nop
    "#rv32":
    - ebreak
    - ecall
    - fence
    "#sec:rv32:ldst":
    - lb
    - lbu
    - lh
    - lhu
    - lw
    - sb
    - sh
    - sw
  rv32e: {}
  rv64:
    "#integer-register-immediate-instructions":
    - addiw
    - ld
    - sext.w
    - slliw
    - sraiw
    - srliw
    "#integer-register-register-operations":
    - addw
    - sllw
    - sraw
    - srlw
    - subw
    "#load-and-store-instructions":
    - lwu
    - sd
  rvwmo:
    "#ch:memorymodel":
    - sfence.vma
  supervisor:
    "#svinval":
    - hfence.gvma
    - hfence.vvma
    - hinval.gvma
    - hinval.vvma
    - sfence.inval.ir
    - sfence.w.inval
  v:
    "#_introduction":
    - vamoaddei16.v
    - vamoaddei32.v
    - vamoaddei64.v
    - vamoaddei8.v
    - vamoandei16.v
    - vamoandei32.v
    - vamoandei64.v
    - vamoandei8.v
    - vamomaxei16.v
    - vamomaxei32.v
    - vamomaxei64.v
    - vamomaxei8.v
    - vamomaxuei16.v
    - vamomaxuei32.v
    - vamomaxuei64.v
    - vamomaxuei8.v
    - vamominei16.v
    - vamominei32.v
    - vamominei64.v
    - vamominei8.v
    - vamominuei16.v
    - vamominuei32.v
    - vamominuei64.v
    - vamominuei8.v
    - vamoorei16.v
    - vamoorei32.v
    - vamoorei64.v
    - vamoorei8.v
    - vamoswapei16.v
    - vamoswapei32.v
    - vamoswapei64.v
    - vamoswapei8.v
    - vamoxorei16.v
    - vamoxorei32.v
    - vamoxorei64.v
    - vamoxorei8.v
    - vl1re16.v
    - vl1re32.v
    - vl1re64.v
    - vl2re16.v
    - vl2re32.v
    - vl2re64.v
    - vl2re8.v
    - vl4re16.v
    - vl4re32.v
    - vl4re64.v
    - vl4re8.v
    - vl8re16.v
    - vl8re32.v
    - vl8re64.v
    - vl8re8.v
    - vle1024.v
    - vle1024ff.v
    - vle128.v
    - vle128ff.v
    - vle16.v
    - vle16ff.v
    - vle256.v
    - vle256ff.v
    - vle32.v
    - vle32ff.v
    - vle512.v
    - vle512ff.v
    - vle64.v
    - vle64ff.v
    - vloxei1024.v
    - vloxei128.v
    - vloxei16.v
    - vloxei256.v
    - vloxei32.v
    - vloxei512.v
    - vloxei64.v
    - vloxei8.v
    - vlse1024.v
    - vlse128.v
    - vlse16.v
    - vlse256.v
    - vlse32.v
    - vlse512.v
    - vlse64.v
    - vluxei1024.v
    - vluxei128.v
    - vluxei16.v
    - vluxei256.v
    - vluxei32.v
    - vluxei512.v
    - vluxei64.v
    - vmv1r.v
    - vmv2r.v
    - vmv4r.v
    - vmv8r.v
    - vs1r.v
    - vs2r.v
    - vs4r.v
    - vs8r.v
    - vse1024.v
    - vse128.v
    - vse16.v
    - vse256.v
    - vse32.v
    - vse512.v
    - vse64.v
    - vse8.v
    - vsm.v
    - vsoxei1024.v
    - vsoxei128.v
    - vsoxei16.v
    - vsoxei256.v
    - vsoxei32.v
    - vsoxei512.v
    - vsoxei64.v
    - vsoxei8.v
    - vsse1024.v
    - vsse128.v
    - vsse16.v
    - vsse256.v
    - vsse32.v
    - vsse512.v
    - vsse64.v
    - vsse8.v
    - vsuxei1024.v
    - vsuxei128.v
    - vsuxei16.v
    - vsuxei256.v
    - vsuxei32.v
    - vsuxei512.v
    - vsuxei64.v
    - vsuxei8.v
    "#_narrowing_floating_pointinteger_type_convert_instructions":
    - vfncvt.f.f.w
    - vfncvt.f.x.w
    - vfncvt.f.xu.w
    - vfncvt.rod.f.f.w
    - vfncvt.rtz.x.f.w
    - vfncvt.rtz.xu.f.w
    - vfncvt.x.f.w
    - vfncvt.xu.f.w
    "#_single_width_floating_pointinteger_type_convert_instructions":
    - vfcvt.f.x.v
    - vfcvt.f.xu.v
    - vfcvt.rtz.x.f.v
    - vfcvt.rtz.xu.f.v
    - vfcvt.x.f.v
    - vfcvt.xu.f.v
    "#_state_of_vector_extension_at_reset":
    - vsetvl
    "#_unit_stride_fault_only_first_loads":
    - vle8ff.v
    "#_vector_bitwise_logical_instructions":
    - vand.vi
    - vand.vv
    - vand.vx
    "#_vector_compress_instruction":
    - vcompress.vm
    "#_vector_count_population_in_mask_vcpop_m":
    - vcpop.m
    "#_vector_element_index_instruction":
    - vid.v
    "#_vector_floating_point_classify_instruction":
    - vfclass.v
    "#_vector_floating_point_compare_instructions":
    - vmfeq.vf
    - vmfeq.vv
    - vmflt.vf
    - vmflt.vv
    "#_vector_floating_point_merge_instruction":
    - vfmerge.vfm
    "#_vector_floating_point_minmax_instructions":
    - vfmin.vf
    - vfmin.vv
    "#_vector_floating_point_move_instruction":
    - vfmv.f.s
    - vfmv.s.f
    - vfmv.v.f
    "#_vector_floating_point_reciprocal_estimate_instruction":
    - vfrec7.v
    "#_vector_floating_point_reciprocal_square_root_estimate_instruction":
    - vfrsqrt7.v
    "#_vector_floating_point_sign_injection_instructions":
    - vfsgnj.vf
    - vfsgnj.vv
    "#_vector_floating_point_square_root_instruction":
    - vfsqrt.v
    "#_vector_indexed_instructions":
    - vluxei8.v
    "#_vector_instruction_formats":
    - vsetivli
    "#_vector_instruction_listing":
    - vaadd.vv
    - vaadd.vx
    - vasub.vv
    - vasub.vx
    - vasubu.vv
    - vasubu.vx
    - vdiv.vv
    - vdiv.vx
    - vfdiv.vf
    - vfdiv.vv
    - vfmadd.vf
    - vfmadd.vv
    - vfmax.vf
    - vfmax.vv
    - vfmsac.vf
    - vfmsac.vv
    - vfmsub.vf
    - vfmsub.vv
    - vfnmacc.vf
    - vfnmacc.vv
    - vfnmadd.vf
    - vfnmadd.vv
    - vfnmsac.vf
    - vfnmsac.vv
    - vfnmsub.vf
    - vfnmsub.vv
    - vfrdiv.vf
    - vfredmax.vs
    - vfredmin.vs
    - vfrsub.vf
    - vfsgnjn.vf
    - vfsgnjn.vv
    - vfsgnjx.vf
    - vfsgnjx.vv
    - vfsub.vf
    - vfsub.vv
    - vfwmsac.vf
    - vfwmsac.vv
    - vfwnmacc.vf
    - vfwnmacc.vv
    - vfwnmsac.vf
    - vfwnmsac.vv
    - vfwredusum.vs
    - vfwsub.vf
    - vfwsub.vv
    - vfwsub.wf
    - vfwsub.wv
    - vmadd.vv
    - vmadd.vx
    - vmax.vv
    - vmax.vx
    - vmaxu.vv
    - vmaxu.vx
    - vmfge.vf
    - vmfgt.vf
    - vmfle.vf
    - vmfle.vv
    - vmfne.vf
    - vmfne.vv
    - vmin.vv
    - vmin.vx
    - vmor.mm
    - vmsgtu.vi
    - vmsgtu.vx
    - vmsle.vi
    - vmsle.vv
    - vmsle.vx
    - vmsleu.vi
    - vmsleu.vv
    - vmsleu.vx
    - vmsltu.vv
    - vmsltu.vx
    - vmsne.vi
    - vmsne.vv
    - vmsne.vx
    - vmulhsu.vv
    - vmulhsu.vx
    - vmulhu.vv
    - vmulhu.vx
    - vnmsac.vv
    - vnmsac.vx
    - vnmsub.vv
    - vnmsub.vx
    - vor.vi
    - vor.vv
    - vor.vx
    - vredand.vs
    - vredmax.vs
    - vredmaxu.vs
    - vredmin.vs
    - vredminu.vs
    - vredor.vs
    - vredxor.vs
    - vrem.vv
    - vrem.vx
    - vremu.vv
    - vremu.vx
    - vrgatherei16.vv
    - vrsub.vi
    - vrsub.vx
    - vsadd.vi
    - vsadd.vv
    - vsadd.vx
    - vsext.vf2
    - vsext.vf4
    - vsext.vf8
    - vsra.vi
    - vsra.vv
    - vsra.vx
    - vsrl.vi
    - vsrl.vv
    - vsrl.vx
    - vssra.vi
    - vssra.vv
    - vssra.vx
    - vssub.vv
    - vssub.vx
    - vssubu.vv
    - vssubu.vx
    - vsub.vv
    - vsub.vx
    - vwadd.vv
    - vwadd.vx
    - vwadd.wv
    - vwadd.wx
    - vwmacc.vv
    - vwmacc.vx
    - vwmaccsu.vv
    - vwmaccsu.vx
    - vwmaccus.vx
    - vwmulsu.vv
    - vwmulsu.vx
    - vwmulu.vv
    - vwmulu.vx
    - vwsub.vv
    - vwsub.vx
    - vwsub.wv
    - vwsub.wx
    - vwsubu.vv
    - vwsubu.vx
    - vwsubu.wv
    - vwsubu.wx
    - vxor.vi
    - vxor.vv
    - vxor.vx
    "#_vector_integer_add_with_carry_subtract_with_borrow_instructions":
    - vadc.vim
    - vadc.vvm
    - vadc.vxm
    - vmadc.vi
    - vmadc.vim
    - vmadc.vv
    - vmadc.vvm
    - vmadc.vx
    - vmadc.vxm
    - vmsbc.vv
    - vmsbc.vvm
    - vmsbc.vx
    - vmsbc.vxm
    - vsbc.vvm
    - vsbc.vxm
    "#_vector_integer_compare_instructions":
    - vmseq.vi
    - vmseq.vv
    - vmseq.vx
    - vmsgt.vi
    - vmsgt.vx
    - vmslt.vv
    - vmslt.vx
    "#_vector_integer_divide_instructions":
    - vdivu.vv
    - vdivu.vx
    "#_vector_integer_merge_instructions":
    - vmerge.vim
    - vmerge.vvm
    - vmerge.vxm
    "#_vector_integer_minmax_instructions":
    - vminu.vv
    - vminu.vx
    "#_vector_integer_move_instructions":
    - vmv.s.x
    - vmv.v.i
    - vmv.v.v
    - vmv.v.x
    - vmv.x.s
    "#_vector_iota_instruction":
    - viota.m
    "#_vector_loadstore_whole_register_instructions":
    - vl1re8.v
    "#_vector_narrowing_fixed_point_clip_instructions":
    - vnclip.wi
    - vnclip.wv
    - vnclip.wx
    - vnclipu.wi
    - vnclipu.wv
    - vnclipu.wx
    "#_vector_register_gather_instructions":
    - vrgather.vi
    - vrgather.vv
    - vrgather.vx
    "#_vector_register_grouping_vlmul20":
    - min
    "#_vector_single_width_averaging_add_and_subtract":
    - vaaddu.vv
    - vaaddu.vx
    "#_vector_single_width_floating_point_addsubtract_instructions":
    - vfadd.vf
    - vfadd.vv
    "#_vector_single_width_floating_point_fused_multiply_add_instructions":
    - vfmacc.vf
    - vfmacc.vv
    "#_vector_single_width_floating_point_multiplydivide_instructions":
    - vfmul.vf
    - vfmul.vv
    "#_vector_single_width_fractional_multiply_with_rounding_and_saturation":
    - vsmul.vv
    - vsmul.vx
    "#_vector_single_width_integer_add_and_subtract":
    - vadd.vi
    - vadd.vv
    - vadd.vx
    "#_vector_single_width_integer_multiply_add_instructions":
    - vmacc.vv
    - vmacc.vx
    "#_vector_single_width_integer_multiply_instructions":
    - vmul.vv
    - vmul.vx
    "#_vector_single_width_saturating_add_and_subtract":
    - vsaddu.vi
    - vsaddu.vv
    - vsaddu.vx
    "#_vector_single_width_scaling_shift_instructions":
    - vssrl.vi
    - vssrl.vv
    - vssrl.vx
    "#_vector_single_width_shift_instructions":
    - vsll.vi
    - vsll.vv
    - vsll.vx
    "#_vector_slide1down_instruction":
    - vfslide1down.vf
    - vslide1down.vx
    "#_vector_slide1up":
    - vfslide1up.vf
    - vslide1up.vx
    "#_vector_slide_instructions":
    - vslideup.vi
    - vslideup.vx
    "#_vector_slidedown_instructions":
    - vslidedown.vi
    - vslidedown.vx
    "#_vector_strided_instructions":
    - vlse8.v
    "#_vector_unit_stride_instructions":
    - vle8.v
    - vlm.v
    "#_vector_unordered_single_width_floating_point_sum_reduction":
    - vfredusum.vs
    "#_vector_widening_floating_point_addsubtract_instructions":
    - vfwadd.vf
    - vfwadd.vv
    - vfwadd.wf
    - vfwadd.wv
    "#_vector_widening_floating_point_fused_multiply_add_instructions":
    - vfwmacc.vf
    - vfwmacc.vv
    "#_vector_widening_floating_point_multiply":
    - vfwmul.vf
    - vfwmul.vv
    "#_vector_widening_integer_addsubtract":
    - vwaddu.vv
    - vwaddu.vx
    - vwaddu.wv
    - vwaddu.wx
    "#_vector_widening_integer_multiply_add_instructions":
    - vwmaccu.vv
    - vwmaccu.vx
    "#_vector_widening_integer_multiply_instructions":
    - vwmul.vv
    - vwmul.vx
    "#_vfirst_find_first_set_mask_bit":
    - vfirst.m
    "#_vmsif_m_set_including_first_mask_bit":
    - vmsif.m
    "#_vmsof_m_set_only_first_mask_bit":
    - vmsof.m
    "#_widening_floating_pointinteger_type_convert_instructions":
    - vfwcvt.f.f.v
    - vfwcvt.f.x.v
    - vfwcvt.f.xu.v
    - vfwcvt.rtz.x.f.v
    - vfwcvt.rtz.xu.f.v
    - vfwcvt.x.f.v
    - vfwcvt.xu.f.v
    "#_zve_vector_extensions_for_embedded_processors":
    - vmulh.vv
    - vmulh.vx
    "#sec-agnostic":
    - vmsbf.m
    - vsetvli
    "#sec-mask-register-logical":
    - vmand.mm
    - vmandn.mm
    - vmnand.mm
    - vmnor.mm
    - vmorn.mm
    - vmxnor.mm
    - vmxor.mm
    "#sec-narrowing":
    - vnsra.wi
    - vnsra.wv
    - vnsra.wx
    "#sec-vec-operands":
    - vnsrl.wi
    - vnsrl.wv
    - vnsrl.wx
    - vzext.vf2
    - vzext.vf4
    - vzext.vf8
    "#sec-vector-float-reduce":
    - vfredosum.vs
    "#sec-vector-float-reduce-widen":
    - vfwredosum.vs
    "#sec-vector-integer-reduce":
    - vredsum.vs
    "#sec-vector-integer-reduce-widen":
    - vwredsum.vs
    - vwredsumu.vs
  zam: {}
  zfh:
    "#half-precision-convert-and-move-instructions":
    - fcvt.d.h
    - fcvt.h.d
    - fcvt.h.l
    - fcvt.h.lu
    - fcvt.h.q
    - fcvt.h.s
    - fcvt.h.w
    - fcvt.h.wu
    - fcvt.l.h
    - fcvt.lu.h
    - fcvt.q.h
    - fcvt.s.h
    - fcvt.w.h
    - fcvt.wu.h
    - fmv.h.x
    - fmv.x.h
    - fsgnj.h
    - fsgnjn.h
    - fsgnjx.h
    "#half-precision-floating-point-classify-instruction":
    - fclass.h
    "#half-precision-load-and-store-instructions":
    - flh
    - fsh
  zfinx: {}
  zifencei: {}
  zihintpause:
    "#chap:zihintpause":
    - pause
  ztso: {}
sections_labels:
  a:
    '':
      headers: []
      url: "/riscv-user-isa-manual/Priv-v1.12/a.html"
    "#atomics":
      headers:
      - 9 "A" Standard Extension for Atomic Instructions, Version 2.1
      url: "/riscv-user-isa-manual/Priv-v1.12/a.html#atomics"
    "#sec:amo":
      headers:
      - 9 "A" Standard Extension for Atomic Instructions, Version 2.1
      - 9.4 Atomic Memory Operations
      url: "/riscv-user-isa-manual/Priv-v1.12/a.html#sec:amo"
    "#sec:lrsc":
      headers:
      - 9 "A" Standard Extension for Atomic Instructions, Version 2.1
      - 9.2 Load-Reserved/Store-Conditional Instructions
      url: "/riscv-user-isa-manual/Priv-v1.12/a.html#sec:lrsc"
    "#sec:lrscseq":
      headers:
      - 9 "A" Standard Extension for Atomic Instructions, Version 2.1
      - 9.3 Eventual Success of Store-Conditional Instructions
      url: "/riscv-user-isa-manual/Priv-v1.12/a.html#sec:lrscseq"
    "#specifying-ordering-of-atomic-instructions":
      headers:
      - 9 "A" Standard Extension for Atomic Instructions, Version 2.1
      - 9.1 Specifying Ordering of Atomic Instructions
      url: "/riscv-user-isa-manual/Priv-v1.12/a.html#specifying-ordering-of-atomic-instructions"
  b:
    '':
      headers: []
      url: "/riscv-user-isa-manual/Priv-v1.12/b.html"
    "#sec:bits":
      headers:
      - 18 "B" Standard Extension for Bit Manipulation, Version 0.0
      url: "/riscv-user-isa-manual/Priv-v1.12/b.html#sec:bits"
  c:
    '':
      headers: []
      url: "/riscv-user-isa-manual/Priv-v1.12/c.html"
    "#breakpoint-instruction":
      headers:
      - 17 "C" Standard Extension for Compressed Instructions, Version 2.0
      - 17.5 Integer Computational Instructions
      - Breakpoint Instruction
      url: "/riscv-user-isa-manual/Priv-v1.12/c.html#breakpoint-instruction"
    "#compressed":
      headers:
      - 17 "C" Standard Extension for Compressed Instructions, Version 2.0
      url: "/riscv-user-isa-manual/Priv-v1.12/c.html#compressed"
    "#compressed-instruction-formats":
      headers:
      - 17 "C" Standard Extension for Compressed Instructions, Version 2.0
      - 17.2 Compressed Instruction Formats
      url: "/riscv-user-isa-manual/Priv-v1.12/c.html#compressed-instruction-formats"
    "#control-transfer-instructions":
      headers:
      - 17 "C" Standard Extension for Compressed Instructions, Version 2.0
      - 17.4 Control Transfer Instructions
      url: "/riscv-user-isa-manual/Priv-v1.12/c.html#control-transfer-instructions"
    "#defined-illegal-instruction":
      headers:
      - 17 "C" Standard Extension for Compressed Instructions, Version 2.0
      - 17.5 Integer Computational Instructions
      - Defined Illegal Instruction
      url: "/riscv-user-isa-manual/Priv-v1.12/c.html#defined-illegal-instruction"
    "#integer-computational-instructions":
      headers:
      - 17 "C" Standard Extension for Compressed Instructions, Version 2.0
      - 17.5 Integer Computational Instructions
      url: "/riscv-user-isa-manual/Priv-v1.12/c.html#integer-computational-instructions"
    "#integer-constant-generation-instructions":
      headers:
      - 17 "C" Standard Extension for Compressed Instructions, Version 2.0
      - 17.5 Integer Computational Instructions
      - Integer Constant-Generation Instructions
      url: "/riscv-user-isa-manual/Priv-v1.12/c.html#integer-constant-generation-instructions"
    "#integer-register-immediate-operations":
      headers:
      - 17 "C" Standard Extension for Compressed Instructions, Version 2.0
      - 17.5 Integer Computational Instructions
      - Integer Register-Immediate Operations
      url: "/riscv-user-isa-manual/Priv-v1.12/c.html#integer-register-immediate-operations"
    "#integer-register-register-operations":
      headers:
      - 17 "C" Standard Extension for Compressed Instructions, Version 2.0
      - 17.5 Integer Computational Instructions
      - Integer Register-Register Operations
      url: "/riscv-user-isa-manual/Priv-v1.12/c.html#integer-register-register-operations"
    "#load-and-store-instructions":
      headers:
      - 17 "C" Standard Extension for Compressed Instructions, Version 2.0
      - 17.3 Load and Store Instructions
      url: "/riscv-user-isa-manual/Priv-v1.12/c.html#load-and-store-instructions"
    "#nop-instruction":
      headers:
      - 17 "C" Standard Extension for Compressed Instructions, Version 2.0
      - 17.5 Integer Computational Instructions
      - NOP Instruction
      url: "/riscv-user-isa-manual/Priv-v1.12/c.html#nop-instruction"
    "#overview":
      headers:
      - 17 "C" Standard Extension for Compressed Instructions, Version 2.0
      - 17.1 Overview
      url: "/riscv-user-isa-manual/Priv-v1.12/c.html#overview"
    "#register-based-loads-and-stores":
      headers:
      - 17 "C" Standard Extension for Compressed Instructions, Version 2.0
      - 17.3 Load and Store Instructions
      - Register-Based Loads and Stores
      url: "/riscv-user-isa-manual/Priv-v1.12/c.html#register-based-loads-and-stores"
    "#rvc-instruction-set-listings":
      headers:
      - 17 "C" Standard Extension for Compressed Instructions, Version 2.0
      - 17.8 RVC Instruction Set Listings
      url: "/riscv-user-isa-manual/Priv-v1.12/c.html#rvc-instruction-set-listings"
    "#sec:rvc-hints":
      headers:
      - 17 "C" Standard Extension for Compressed Instructions, Version 2.0
      - 17.7 HINT Instructions
      url: "/riscv-user-isa-manual/Priv-v1.12/c.html#sec:rvc-hints"
    "#stack-pointer-based-loads-and-stores":
      headers:
      - 17 "C" Standard Extension for Compressed Instructions, Version 2.0
      - 17.3 Load and Store Instructions
      - Stack-Pointer-Based Loads and Stores
      url: "/riscv-user-isa-manual/Priv-v1.12/c.html#stack-pointer-based-loads-and-stores"
    "#usage-of-c-instructions-in-lrsc-sequences":
      headers:
      - 17 "C" Standard Extension for Compressed Instructions, Version 2.0
      - 17.6 Usage of C Instructions in LR/SC Sequences
      url: "/riscv-user-isa-manual/Priv-v1.12/c.html#usage-of-c-instructions-in-lrsc-sequences"
  counters:
    '':
      headers: []
      url: "/riscv-user-isa-manual/Priv-v1.12/counters.html"
    "#counters":
      headers:
      - 11 Counters
      url: "/riscv-user-isa-manual/Priv-v1.12/counters.html#counters"
    "#zicntr-standard-extension-for-base-counters-and-timers":
      headers:
      - 11 Counters
      - 11.1 "Zicntr" Standard Extension for Base Counters and Timers
      url: "/riscv-user-isa-manual/Priv-v1.12/counters.html#zicntr-standard-extension-for-base-counters-and-timers"
    "#zihpm-standard-extension-for-hardware-performance-counters":
      headers:
      - 11 Counters
      - 11.2 "Zihpm" Standard Extension for Hardware Performance Counters
      url: "/riscv-user-isa-manual/Priv-v1.12/counters.html#zihpm-standard-extension-for-hardware-performance-counters"
  csr:
    '':
      headers: []
      url: "/riscv-user-isa-manual/Priv-v1.12/csr.html"
    "#csr-access-ordering":
      headers:
      - 10 "Zicsr", Control and Status Register (CSR) Instructions, Version 2.0
      - 10.1 CSR Instructions
      - CSR Access Ordering
      url: "/riscv-user-isa-manual/Priv-v1.12/csr.html#csr-access-ordering"
    "#csr-instructions":
      headers:
      - 10 "Zicsr", Control and Status Register (CSR) Instructions, Version 2.0
      - 10.1 CSR Instructions
      url: "/riscv-user-isa-manual/Priv-v1.12/csr.html#csr-instructions"
    "#csrinsts":
      headers:
      - 10 "Zicsr", Control and Status Register (CSR) Instructions, Version 2.0
      url: "/riscv-user-isa-manual/Priv-v1.12/csr.html#csrinsts"
  d:
    '':
      headers: []
      url: "/riscv-user-isa-manual/Priv-v1.12/d.html"
    "#d-register-state":
      headers:
      - 13 "D" Standard Extension for Double-Precision Floating-Point, Version 2.2
      - 13.1 D Register State
      url: "/riscv-user-isa-manual/Priv-v1.12/d.html#d-register-state"
    "#d-standard-extension-for-double-precision-floating-point-version-2.2":
      headers:
      - 13 "D" Standard Extension for Double-Precision Floating-Point, Version 2.2
      url: "/riscv-user-isa-manual/Priv-v1.12/d.html#d-standard-extension-for-double-precision-floating-point-version-2.2"
    "#double-precision-floating-point-classify-instruction":
      headers:
      - 13 "D" Standard Extension for Double-Precision Floating-Point, Version 2.2
      - 13.7 Double-Precision Floating-Point Classify Instruction
      url: "/riscv-user-isa-manual/Priv-v1.12/d.html#double-precision-floating-point-classify-instruction"
    "#double-precision-floating-point-compare-instructions":
      headers:
      - 13 "D" Standard Extension for Double-Precision Floating-Point, Version 2.2
      - 13.6 Double-Precision Floating-Point Compare Instructions
      url: "/riscv-user-isa-manual/Priv-v1.12/d.html#double-precision-floating-point-compare-instructions"
    "#double-precision-floating-point-computational-instructions":
      headers:
      - 13 "D" Standard Extension for Double-Precision Floating-Point, Version 2.2
      - 13.4 Double-Precision Floating-Point Computational Instructions
      url: "/riscv-user-isa-manual/Priv-v1.12/d.html#double-precision-floating-point-computational-instructions"
    "#double-precision-floating-point-conversion-and-move-instructions":
      headers:
      - 13 "D" Standard Extension for Double-Precision Floating-Point, Version 2.2
      - 13.5 Double-Precision Floating-Point Conversion and Move Instructions
      url: "/riscv-user-isa-manual/Priv-v1.12/d.html#double-precision-floating-point-conversion-and-move-instructions"
    "#fld_fsd":
      headers:
      - 13 "D" Standard Extension for Double-Precision Floating-Point, Version 2.2
      - 13.3 Double-Precision Load and Store Instructions
      url: "/riscv-user-isa-manual/Priv-v1.12/d.html#fld_fsd"
    "#nanboxing":
      headers:
      - 13 "D" Standard Extension for Double-Precision Floating-Point, Version 2.2
      - 13.2 NaN Boxing of Narrower Values
      url: "/riscv-user-isa-manual/Priv-v1.12/d.html#nanboxing"
    "#sec:single-float-compute":
      headers: &38
      - 12 "F" Standard Extension for Single-Precision Floating-Point, Version 2.2
      - 12.6 Single-Precision Floating-Point Computational Instructions
      url: "/riscv-user-isa-manual/Priv-v1.12//d.html"
    "#single-precision-floating-point-compare-instructions":
      headers: &39
      - 12 "F" Standard Extension for Single-Precision Floating-Point, Version 2.2
      - 12.8 Single-Precision Floating-Point Compare Instructions
      url: "/riscv-user-isa-manual/Priv-v1.12//d.html"
    "#single-precision-floating-point-conversion-and-move-instructions":
      headers: &40
      - 12 "F" Standard Extension for Single-Precision Floating-Point, Version 2.2
      - 12.7 Single-Precision Floating-Point Conversion and Move Instructions
      url: "/riscv-user-isa-manual/Priv-v1.12//d.html"
  f:
    '':
      headers: []
      url: "/riscv-user-isa-manual/Priv-v1.12/f.html"
    "#f-register-state":
      headers:
      - 12 "F" Standard Extension for Single-Precision Floating-Point, Version 2.2
      - 12.1 F Register State
      url: "/riscv-user-isa-manual/Priv-v1.12/f.html#f-register-state"
    "#floating-point-control-and-status-register":
      headers:
      - 12 "F" Standard Extension for Single-Precision Floating-Point, Version 2.2
      - 12.2 Floating-Point Control and Status Register
      url: "/riscv-user-isa-manual/Priv-v1.12/f.html#floating-point-control-and-status-register"
    "#nan-generation-and-propagation":
      headers:
      - 12 "F" Standard Extension for Single-Precision Floating-Point, Version 2.2
      - 12.3 NaN Generation and Propagation
      url: "/riscv-user-isa-manual/Priv-v1.12/f.html#nan-generation-and-propagation"
    "#sec:single-float":
      headers:
      - 12 "F" Standard Extension for Single-Precision Floating-Point, Version 2.2
      url: "/riscv-user-isa-manual/Priv-v1.12/f.html#sec:single-float"
    "#sec:single-float-compute":
      headers: *38
      url: "/riscv-user-isa-manual/Priv-v1.12/f.html#sec:single-float-compute"
    "#single-precision-floating-point-classify-instruction":
      headers:
      - 12 "F" Standard Extension for Single-Precision Floating-Point, Version 2.2
      - 12.9 Single-Precision Floating-Point Classify Instruction
      url: "/riscv-user-isa-manual/Priv-v1.12/f.html#single-precision-floating-point-classify-instruction"
    "#single-precision-floating-point-compare-instructions":
      headers: *39
      url: "/riscv-user-isa-manual/Priv-v1.12/f.html#single-precision-floating-point-compare-instructions"
    "#single-precision-floating-point-conversion-and-move-instructions":
      headers: *40
      url: "/riscv-user-isa-manual/Priv-v1.12/f.html#single-precision-floating-point-conversion-and-move-instructions"
    "#single-precision-load-and-store-instructions":
      headers:
      - 12 "F" Standard Extension for Single-Precision Floating-Point, Version 2.2
      - 12.5 Single-Precision Load and Store Instructions
      url: "/riscv-user-isa-manual/Priv-v1.12/f.html#single-precision-load-and-store-instructions"
    "#subnormal-arithmetic":
      headers:
      - 12 "F" Standard Extension for Single-Precision Floating-Point, Version 2.2
      - 12.4 Subnormal Arithmetic
      url: "/riscv-user-isa-manual/Priv-v1.12/f.html#subnormal-arithmetic"
  hypervisor:
    '':
      headers: []
      url: "/riscv-priv-isa-manual/Priv-v1.12/hypervisor.html"
    "#guest-page-faults":
      headers:
      - 5 Hypervisor Extension, Version 1.0
      - 5.5 Two-Stage Address Translation
      - 5.5.2 Guest-Page Faults
      url: "/riscv-priv-isa-manual/Priv-v1.12/hypervisor.html#guest-page-faults"
    "#hypervisor":
      headers:
      - 5 Hypervisor Extension, Version 1.0
      url: "/riscv-priv-isa-manual/Priv-v1.12/hypervisor.html#hypervisor"
    "#hypervisor-and-virtual-supervisor-csrs":
      headers:
      - 5 Hypervisor Extension, Version 1.0
      - 5.2 Hypervisor and Virtual Supervisor CSRs
      url: "/riscv-priv-isa-manual/Priv-v1.12/hypervisor.html#hypervisor-and-virtual-supervisor-csrs"
    "#hypervisor-counter-enable-register-hcounteren":
      headers:
      - 5 Hypervisor Extension, Version 1.0
      - 5.2 Hypervisor and Virtual Supervisor CSRs
      - 5.2.6 Hypervisor Counter-Enable Register (hcounteren)
      url: "/riscv-priv-isa-manual/Priv-v1.12/hypervisor.html#hypervisor-counter-enable-register-hcounteren"
    "#hypervisor-environment-configuration-registers-henvcfg-and-henvcfgh":
      headers:
      - 5 Hypervisor Extension, Version 1.0
      - 5.2 Hypervisor and Virtual Supervisor CSRs
      - 5.2.5 Hypervisor Environment Configuration Registers (henvcfg and henvcfgh)
      url: "/riscv-priv-isa-manual/Priv-v1.12/hypervisor.html#hypervisor-environment-configuration-registers-henvcfg-and-henvcfgh"
    "#hypervisor-instructions":
      headers:
      - 5 Hypervisor Extension, Version 1.0
      - 5.3 Hypervisor Instructions
      url: "/riscv-priv-isa-manual/Priv-v1.12/hypervisor.html#hypervisor-instructions"
    "#hypervisor-status-register-hstatus":
      headers:
      - 5 Hypervisor Extension, Version 1.0
      - 5.2 Hypervisor and Virtual Supervisor CSRs
      - 5.2.1 Hypervisor Status Register (hstatus)
      url: "/riscv-priv-isa-manual/Priv-v1.12/hypervisor.html#hypervisor-status-register-hstatus"
    "#hypervisor-time-delta-registers-htimedelta-htimedeltah":
      headers:
      - 5 Hypervisor Extension, Version 1.0
      - 5.2 Hypervisor and Virtual Supervisor CSRs
      - 5.2.7 Hypervisor Time Delta Registers (htimedelta, htimedeltah)
      url: "/riscv-priv-isa-manual/Priv-v1.12/hypervisor.html#hypervisor-time-delta-registers-htimedelta-htimedeltah"
    "#hypervisor-trap-delegation-registers-hedeleg-and-hideleg":
      headers:
      - 5 Hypervisor Extension, Version 1.0
      - 5.2 Hypervisor and Virtual Supervisor CSRs
      - 5.2.2 Hypervisor Trap Delegation Registers (hedeleg and hideleg)
      url: "/riscv-priv-isa-manual/Priv-v1.12/hypervisor.html#hypervisor-trap-delegation-registers-hedeleg-and-hideleg"
    "#hypervisor-trap-instruction-register-htinst":
      headers:
      - 5 Hypervisor Extension, Version 1.0
      - 5.2 Hypervisor and Virtual Supervisor CSRs
      - 5.2.9 Hypervisor Trap Instruction Register (htinst)
      url: "/riscv-priv-isa-manual/Priv-v1.12/hypervisor.html#hypervisor-trap-instruction-register-htinst"
    "#hypervisor-trap-value-register-htval":
      headers:
      - 5 Hypervisor Extension, Version 1.0
      - 5.2 Hypervisor and Virtual Supervisor CSRs
      - 5.2.8 Hypervisor Trap Value Register (htval)
      url: "/riscv-priv-isa-manual/Priv-v1.12/hypervisor.html#hypervisor-trap-value-register-htval"
    "#hypervisor-virtual-machine-load-and-store-instructions":
      headers:
      - 5 Hypervisor Extension, Version 1.0
      - 5.3 Hypervisor Instructions
      - 5.3.1 Hypervisor Virtual-Machine Load and Store Instructions
      url: "/riscv-priv-isa-manual/Priv-v1.12/hypervisor.html#hypervisor-virtual-machine-load-and-store-instructions"
    "#machine-interrupt-delegation-register-mideleg":
      headers:
      - 5 Hypervisor Extension, Version 1.0
      - 5.4 Machine-Level CSRs
      - 5.4.2 Machine Interrupt Delegation Register (mideleg)
      url: "/riscv-priv-isa-manual/Priv-v1.12/hypervisor.html#machine-interrupt-delegation-register-mideleg"
    "#machine-interrupt-registers-mip-and-mie":
      headers:
      - 5 Hypervisor Extension, Version 1.0
      - 5.4 Machine-Level CSRs
      - 5.4.3 Machine Interrupt Registers (mip and mie)
      url: "/riscv-priv-isa-manual/Priv-v1.12/hypervisor.html#machine-interrupt-registers-mip-and-mie"
    "#machine-level-csrs":
      headers:
      - 5 Hypervisor Extension, Version 1.0
      - 5.4 Machine-Level CSRs
      url: "/riscv-priv-isa-manual/Priv-v1.12/hypervisor.html#machine-level-csrs"
    "#machine-second-trap-value-register-mtval2":
      headers:
      - 5 Hypervisor Extension, Version 1.0
      - 5.4 Machine-Level CSRs
      - 5.4.4 Machine Second Trap Value Register (mtval2)
      url: "/riscv-priv-isa-manual/Priv-v1.12/hypervisor.html#machine-second-trap-value-register-mtval2"
    "#machine-status-registers-mstatus-and-mstatush":
      headers:
      - 5 Hypervisor Extension, Version 1.0
      - 5.4 Machine-Level CSRs
      - 5.4.1 Machine Status Registers (mstatus and mstatush)
      url: "/riscv-priv-isa-manual/Priv-v1.12/hypervisor.html#machine-status-registers-mstatus-and-mstatush"
    "#machine-trap-instruction-register-mtinst":
      headers:
      - 5 Hypervisor Extension, Version 1.0
      - 5.4 Machine-Level CSRs
      - 5.4.5 Machine Trap Instruction Register (mtinst)
      url: "/riscv-priv-isa-manual/Priv-v1.12/hypervisor.html#machine-trap-instruction-register-mtinst"
    "#memory-management-fences":
      headers:
      - 5 Hypervisor Extension, Version 1.0
      - 5.5 Two-Stage Address Translation
      - 5.5.3 Memory-Management Fences
      url: "/riscv-priv-isa-manual/Priv-v1.12/hypervisor.html#memory-management-fences"
    "#privilege-modes":
      headers:
      - 5 Hypervisor Extension, Version 1.0
      - 5.1 Privilege Modes
      url: "/riscv-priv-isa-manual/Priv-v1.12/hypervisor.html#privilege-modes"
    "#sec:guest-addr-translation":
      headers:
      - 5 Hypervisor Extension, Version 1.0
      - 5.5 Two-Stage Address Translation
      - 5.5.1 Guest Physical Address Translation
      url: "/riscv-priv-isa-manual/Priv-v1.12/hypervisor.html#sec:guest-addr-translation"
    "#sec:hfence.vma":
      headers:
      - 5 Hypervisor Extension, Version 1.0
      - 5.3 Hypervisor Instructions
      - 5.3.2 Hypervisor Memory-Management Fence Instructions
      url: "/riscv-priv-isa-manual/Priv-v1.12/hypervisor.html#sec:hfence.vma"
    "#sec:hgatp":
      headers:
      - 5 Hypervisor Extension, Version 1.0
      - 5.2 Hypervisor and Virtual Supervisor CSRs
      - 5.2.10 Hypervisor Guest Address Translation and Protection Register (hgatp)
      url: "/riscv-priv-isa-manual/Priv-v1.12/hypervisor.html#sec:hgatp"
    "#sec:hgeinterruptregs":
      headers:
      - 5 Hypervisor Extension, Version 1.0
      - 5.2 Hypervisor and Virtual Supervisor CSRs
      - 5.2.4 Hypervisor Guest External Interrupt Registers (hgeip and hgeie)
      url: "/riscv-priv-isa-manual/Priv-v1.12/hypervisor.html#sec:hgeinterruptregs"
    "#sec:hinterruptregs":
      headers:
      - 5 Hypervisor Extension, Version 1.0
      - 5.2 Hypervisor and Virtual Supervisor CSRs
      - 5.2.3 Hypervisor Interrupt Registers (hvip, hip, and hie)
      url: "/riscv-priv-isa-manual/Priv-v1.12/hypervisor.html#sec:hinterruptregs"
    "#sec:tinst-vals":
      headers:
      - 5 Hypervisor Extension, Version 1.0
      - 5.6 Traps
      - 5.6.3 Transformed Instruction or Pseudoinstruction for mtinst or htinst
      url: "/riscv-priv-isa-manual/Priv-v1.12/hypervisor.html#sec:tinst-vals"
    "#sec:two-stage-translation":
      headers:
      - 5 Hypervisor Extension, Version 1.0
      - 5.5 Two-Stage Address Translation
      url: "/riscv-priv-isa-manual/Priv-v1.12/hypervisor.html#sec:two-stage-translation"
    "#trap-cause-codes":
      headers:
      - 5 Hypervisor Extension, Version 1.0
      - 5.6 Traps
      - 5.6.1 Trap Cause Codes
      url: "/riscv-priv-isa-manual/Priv-v1.12/hypervisor.html#trap-cause-codes"
    "#trap-entry":
      headers:
      - 5 Hypervisor Extension, Version 1.0
      - 5.6 Traps
      - 5.6.2 Trap Entry
      url: "/riscv-priv-isa-manual/Priv-v1.12/hypervisor.html#trap-entry"
    "#trap-return":
      headers:
      - 5 Hypervisor Extension, Version 1.0
      - 5.6 Traps
      - 5.6.4 Trap Return
      url: "/riscv-priv-isa-manual/Priv-v1.12/hypervisor.html#trap-return"
    "#traps":
      headers:
      - 5 Hypervisor Extension, Version 1.0
      - 5.6 Traps
      url: "/riscv-priv-isa-manual/Priv-v1.12/hypervisor.html#traps"
    "#virtual-supervisor-address-translation-and-protection-register-vsatp":
      headers:
      - 5 Hypervisor Extension, Version 1.0
      - 5.2 Hypervisor and Virtual Supervisor CSRs
      - 5.2.18 Virtual Supervisor Address Translation and Protection Register (vsatp)
      url: "/riscv-priv-isa-manual/Priv-v1.12/hypervisor.html#virtual-supervisor-address-translation-and-protection-register-vsatp"
    "#virtual-supervisor-cause-register-vscause":
      headers:
      - 5 Hypervisor Extension, Version 1.0
      - 5.2 Hypervisor and Virtual Supervisor CSRs
      - 5.2.16 Virtual Supervisor Cause Register (vscause)
      url: "/riscv-priv-isa-manual/Priv-v1.12/hypervisor.html#virtual-supervisor-cause-register-vscause"
    "#virtual-supervisor-exception-program-counter-vsepc":
      headers:
      - 5 Hypervisor Extension, Version 1.0
      - 5.2 Hypervisor and Virtual Supervisor CSRs
      - 5.2.15 Virtual Supervisor Exception Program Counter (vsepc)
      url: "/riscv-priv-isa-manual/Priv-v1.12/hypervisor.html#virtual-supervisor-exception-program-counter-vsepc"
    "#virtual-supervisor-interrupt-registers-vsip-and-vsie":
      headers:
      - 5 Hypervisor Extension, Version 1.0
      - 5.2 Hypervisor and Virtual Supervisor CSRs
      - 5.2.12 Virtual Supervisor Interrupt Registers (vsip and vsie)
      url: "/riscv-priv-isa-manual/Priv-v1.12/hypervisor.html#virtual-supervisor-interrupt-registers-vsip-and-vsie"
    "#virtual-supervisor-scratch-register-vsscratch":
      headers:
      - 5 Hypervisor Extension, Version 1.0
      - 5.2 Hypervisor and Virtual Supervisor CSRs
      - 5.2.14 Virtual Supervisor Scratch Register (vsscratch)
      url: "/riscv-priv-isa-manual/Priv-v1.12/hypervisor.html#virtual-supervisor-scratch-register-vsscratch"
    "#virtual-supervisor-status-register-vsstatus":
      headers:
      - 5 Hypervisor Extension, Version 1.0
      - 5.2 Hypervisor and Virtual Supervisor CSRs
      - 5.2.11 Virtual Supervisor Status Register (vsstatus)
      url: "/riscv-priv-isa-manual/Priv-v1.12/hypervisor.html#virtual-supervisor-status-register-vsstatus"
    "#virtual-supervisor-trap-value-register-vstval":
      headers:
      - 5 Hypervisor Extension, Version 1.0
      - 5.2 Hypervisor and Virtual Supervisor CSRs
      - 5.2.17 Virtual Supervisor Trap Value Register (vstval)
      url: "/riscv-priv-isa-manual/Priv-v1.12/hypervisor.html#virtual-supervisor-trap-value-register-vstval"
    "#virtual-supervisor-trap-vector-base-address-register-vstvec":
      headers:
      - 5 Hypervisor Extension, Version 1.0
      - 5.2 Hypervisor and Virtual Supervisor CSRs
      - 5.2.13 Virtual Supervisor Trap Vector Base Address Register (vstvec)
      url: "/riscv-priv-isa-manual/Priv-v1.12/hypervisor.html#virtual-supervisor-trap-vector-base-address-register-vstvec"
  j:
    '':
      headers: []
      url: "/riscv-user-isa-manual/Priv-v1.12/j.html"
    "#sec:j":
      headers:
      - 19 "J" Standard Extension for Dynamically Translated Languages, Version 0.0
      url: "/riscv-user-isa-manual/Priv-v1.12/j.html#sec:j"
  m:
    '':
      headers: []
      url: "/riscv-user-isa-manual/Priv-v1.12/m.html"
    "#division-operations":
      headers:
      - 8 "M" Standard Extension for Integer Multiplication and Division, Version
        2.0
      - 8.2 Division Operations
      url: "/riscv-user-isa-manual/Priv-v1.12/m.html#division-operations"
    "#m-standard-extension-for-integer-multiplication-and-division-version-2.0":
      headers:
      - 8 "M" Standard Extension for Integer Multiplication and Division, Version
        2.0
      url: "/riscv-user-isa-manual/Priv-v1.12/m.html#m-standard-extension-for-integer-multiplication-and-division-version-2.0"
    "#multiplication-operations":
      headers:
      - 8 "M" Standard Extension for Integer Multiplication and Division, Version
        2.0
      - 8.1 Multiplication Operations
      url: "/riscv-user-isa-manual/Priv-v1.12/m.html#multiplication-operations"
    "#zmmul-extension-version-0.1":
      headers:
      - 8 "M" Standard Extension for Integer Multiplication and Division, Version
        2.0
      - 8.3 Zmmul Extension, Version 0.1
      url: "/riscv-user-isa-manual/Priv-v1.12/m.html#zmmul-extension-version-0.1"
  machine:
    '':
      headers: []
      url: "/riscv-priv-isa-manual/Priv-v1.12/machine.html"
    "#address-matching":
      headers:
      - 3 Machine-Level ISA, Version 1.12
      - 3.7 Physical Memory Protection
      - 3.7.1 Physical Memory Protection CSRs
      - Address Matching
      url: "/riscv-priv-isa-manual/Priv-v1.12/machine.html#address-matching"
    "#alignment":
      headers:
      - 3 Machine-Level ISA, Version 1.12
      - 3.6 Physical Memory Attributes
      - 3.6.3 Atomicity PMAs
      - 3.6.3.3 Alignment
      url: "/riscv-priv-isa-manual/Priv-v1.12/machine.html#alignment"
    "#amo-pma":
      headers:
      - 3 Machine-Level ISA, Version 1.12
      - 3.6 Physical Memory Attributes
      - 3.6.3 Atomicity PMAs
      - 3.6.3.1 AMO PMA
      url: "/riscv-priv-isa-manual/Priv-v1.12/machine.html#amo-pma"
    "#atomicity-pmas":
      headers:
      - 3 Machine-Level ISA, Version 1.12
      - 3.6 Physical Memory Attributes
      - 3.6.3 Atomicity PMAs
      url: "/riscv-priv-isa-manual/Priv-v1.12/machine.html#atomicity-pmas"
    "#coherence-and-cacheability-pmas":
      headers:
      - 3 Machine-Level ISA, Version 1.12
      - 3.6 Physical Memory Attributes
      - 3.6.5 Coherence and Cacheability PMAs
      url: "/riscv-priv-isa-manual/Priv-v1.12/machine.html#coherence-and-cacheability-pmas"
    "#endianness-control-in-mstatus-and-mstatush-registers":
      headers:
      - 3 Machine-Level ISA, Version 1.12
      - 3.1 Machine-Level CSRs
      - 3.1.6 Machine Status Registers (mstatus and mstatush)
      - 3.1.6.4 Endianness Control in mstatus and mstatush Registers
      url: "/riscv-priv-isa-manual/Priv-v1.12/machine.html#endianness-control-in-mstatus-and-mstatush-registers"
    "#environment-call-and-breakpoint":
      headers:
      - 3 Machine-Level ISA, Version 1.12
      - 3.3 Machine-Mode Privileged Instructions
      - 3.3.1 Environment Call and Breakpoint
      url: "/riscv-priv-isa-manual/Priv-v1.12/machine.html#environment-call-and-breakpoint"
    "#extension-context-status-in-mstatus-register":
      headers:
      - 3 Machine-Level ISA, Version 1.12
      - 3.1 Machine-Level CSRs
      - 3.1.6 Machine Status Registers (mstatus and mstatush)
      - 3.1.6.6 Extension Context Status in mstatus Register
      url: "/riscv-priv-isa-manual/Priv-v1.12/machine.html#extension-context-status-in-mstatus-register"
    "#hardware-performance-monitor":
      headers:
      - 3 Machine-Level ISA, Version 1.12
      - 3.1 Machine-Level CSRs
      - 3.1.10 Hardware Performance Monitor
      url: "/riscv-priv-isa-manual/Priv-v1.12/machine.html#hardware-performance-monitor"
    "#hart-id-register-mhartid":
      headers:
      - 3 Machine-Level ISA, Version 1.12
      - 3.1 Machine-Level CSRs
      - 3.1.5 Hart ID Register mhartid
      url: "/riscv-priv-isa-manual/Priv-v1.12/machine.html#hart-id-register-mhartid"
    "#idempotency-pmas":
      headers:
      - 3 Machine-Level ISA, Version 1.12
      - 3.6 Physical Memory Attributes
      - 3.6.6 Idempotency PMAs
      url: "/riscv-priv-isa-manual/Priv-v1.12/machine.html#idempotency-pmas"
    "#locking-and-privilege-mode":
      headers:
      - 3 Machine-Level ISA, Version 1.12
      - 3.7 Physical Memory Protection
      - 3.7.1 Physical Memory Protection CSRs
      - Locking and Privilege Mode
      url: "/riscv-priv-isa-manual/Priv-v1.12/machine.html#locking-and-privilege-mode"
    "#machine":
      headers:
      - 3 Machine-Level ISA, Version 1.12
      url: "/riscv-priv-isa-manual/Priv-v1.12/machine.html#machine"
    "#machine-architecture-id-register-marchid":
      headers:
      - 3 Machine-Level ISA, Version 1.12
      - 3.1 Machine-Level CSRs
      - 3.1.3 Machine Architecture ID Register marchid
      url: "/riscv-priv-isa-manual/Priv-v1.12/machine.html#machine-architecture-id-register-marchid"
    "#machine-configuration-pointer-register-mconfigptr":
      headers:
      - 3 Machine-Level ISA, Version 1.12
      - 3.1 Machine-Level CSRs
      - 3.1.17 Machine Configuration Pointer Register (mconfigptr)
      url: "/riscv-priv-isa-manual/Priv-v1.12/machine.html#machine-configuration-pointer-register-mconfigptr"
    "#machine-counter-inhibit-csr-mcountinhibit":
      headers:
      - 3 Machine-Level ISA, Version 1.12
      - 3.1 Machine-Level CSRs
      - 3.1.12 Machine Counter-Inhibit CSR (mcountinhibit)
      url: "/riscv-priv-isa-manual/Priv-v1.12/machine.html#machine-counter-inhibit-csr-mcountinhibit"
    "#machine-environment-configuration-registers-menvcfg-and-menvcfgh":
      headers:
      - 3 Machine-Level ISA, Version 1.12
      - 3.1 Machine-Level CSRs
      - 3.1.18 Machine Environment Configuration Registers (menvcfg and menvcfgh)
      url: "/riscv-priv-isa-manual/Priv-v1.12/machine.html#machine-environment-configuration-registers-menvcfg-and-menvcfgh"
    "#machine-exception-program-counter-mepc":
      headers:
      - 3 Machine-Level ISA, Version 1.12
      - 3.1 Machine-Level CSRs
      - 3.1.14 Machine Exception Program Counter (mepc)
      url: "/riscv-priv-isa-manual/Priv-v1.12/machine.html#machine-exception-program-counter-mepc"
    "#machine-implementation-id-register-mimpid":
      headers:
      - 3 Machine-Level ISA, Version 1.12
      - 3.1 Machine-Level CSRs
      - 3.1.4 Machine Implementation ID Register mimpid
      url: "/riscv-priv-isa-manual/Priv-v1.12/machine.html#machine-implementation-id-register-mimpid"
    "#machine-interrupt-registers-mip-and-mie":
      headers:
      - 3 Machine-Level ISA, Version 1.12
      - 3.1 Machine-Level CSRs
      - 3.1.9 Machine Interrupt Registers (mip and mie)
      url: "/riscv-priv-isa-manual/Priv-v1.12/machine.html#machine-interrupt-registers-mip-and-mie"
    "#machine-level-csrs":
      headers:
      - 3 Machine-Level ISA, Version 1.12
      - 3.1 Machine-Level CSRs
      url: "/riscv-priv-isa-manual/Priv-v1.12/machine.html#machine-level-csrs"
    "#machine-level-memory-mapped-registers":
      headers:
      - 3 Machine-Level ISA, Version 1.12
      - 3.2 Machine-Level Memory-Mapped Registers
      url: "/riscv-priv-isa-manual/Priv-v1.12/machine.html#machine-level-memory-mapped-registers"
    "#machine-mode-privileged-instructions":
      headers:
      - 3 Machine-Level ISA, Version 1.12
      - 3.3 Machine-Mode Privileged Instructions
      url: "/riscv-priv-isa-manual/Priv-v1.12/machine.html#machine-mode-privileged-instructions"
    "#machine-scratch-register-mscratch":
      headers:
      - 3 Machine-Level ISA, Version 1.12
      - 3.1 Machine-Level CSRs
      - 3.1.13 Machine Scratch Register (mscratch)
      url: "/riscv-priv-isa-manual/Priv-v1.12/machine.html#machine-scratch-register-mscratch"
    "#machine-status-registers-mstatus-and-mstatush":
      headers:
      - 3 Machine-Level ISA, Version 1.12
      - 3.1 Machine-Level CSRs
      - 3.1.6 Machine Status Registers (mstatus and mstatush)
      url: "/riscv-priv-isa-manual/Priv-v1.12/machine.html#machine-status-registers-mstatus-and-mstatush"
    "#machine-timer-registers-mtime-and-mtimecmp":
      headers:
      - 3 Machine-Level ISA, Version 1.12
      - 3.2 Machine-Level Memory-Mapped Registers
      - 3.2.1 Machine Timer Registers (mtime and mtimecmp)
      url: "/riscv-priv-isa-manual/Priv-v1.12/machine.html#machine-timer-registers-mtime-and-mtimecmp"
    "#machine-trap-delegation-registers-medeleg-and-mideleg":
      headers:
      - 3 Machine-Level ISA, Version 1.12
      - 3.1 Machine-Level CSRs
      - 3.1.8 Machine Trap Delegation Registers (medeleg and mideleg)
      url: "/riscv-priv-isa-manual/Priv-v1.12/machine.html#machine-trap-delegation-registers-medeleg-and-mideleg"
    "#machine-trap-value-register-mtval":
      headers:
      - 3 Machine-Level ISA, Version 1.12
      - 3.1 Machine-Level CSRs
      - 3.1.16 Machine Trap Value Register (mtval)
      url: "/riscv-priv-isa-manual/Priv-v1.12/machine.html#machine-trap-value-register-mtval"
    "#machine-trap-vector-base-address-register-mtvec":
      headers:
      - 3 Machine-Level ISA, Version 1.12
      - 3.1 Machine-Level CSRs
      - 3.1.7 Machine Trap-Vector Base-Address Register (mtvec)
      url: "/riscv-priv-isa-manual/Priv-v1.12/machine.html#machine-trap-vector-base-address-register-mtvec"
    "#machine-vendor-id-register-mvendorid":
      headers:
      - 3 Machine-Level ISA, Version 1.12
      - 3.1 Machine-Level CSRs
      - 3.1.2 Machine Vendor ID Register mvendorid
      url: "/riscv-priv-isa-manual/Priv-v1.12/machine.html#machine-vendor-id-register-mvendorid"
    "#main-memory-versus-io-versus-vacant-regions":
      headers:
      - 3 Machine-Level ISA, Version 1.12
      - 3.6 Physical Memory Attributes
      - 3.6.1 Main Memory versus I/O versus Vacant Regions
      url: "/riscv-priv-isa-manual/Priv-v1.12/machine.html#main-memory-versus-io-versus-vacant-regions"
    "#memory-ordering-pmas":
      headers:
      - 3 Machine-Level ISA, Version 1.12
      - 3.6 Physical Memory Attributes
      - 3.6.4 Memory-Ordering PMAs
      url: "/riscv-priv-isa-manual/Priv-v1.12/machine.html#memory-ordering-pmas"
    "#memory-privilege-in-mstatus-register":
      headers:
      - 3 Machine-Level ISA, Version 1.12
      - 3.1 Machine-Level CSRs
      - 3.1.6 Machine Status Registers (mstatus and mstatush)
      - 3.1.6.3 Memory Privilege in mstatus Register
      url: "/riscv-priv-isa-manual/Priv-v1.12/machine.html#memory-privilege-in-mstatus-register"
    "#otherpriv":
      headers:
      - 3 Machine-Level ISA, Version 1.12
      - 3.3 Machine-Mode Privileged Instructions
      - 3.3.2 Trap-Return Instructions
      url: "/riscv-priv-isa-manual/Priv-v1.12/machine.html#otherpriv"
    "#physical-memory-protection-csrs":
      headers:
      - 3 Machine-Level ISA, Version 1.12
      - 3.7 Physical Memory Protection
      - 3.7.1 Physical Memory Protection CSRs
      url: "/riscv-priv-isa-manual/Priv-v1.12/machine.html#physical-memory-protection-csrs"
    "#pmp-vmem":
      headers:
      - 3 Machine-Level ISA, Version 1.12
      - 3.7 Physical Memory Protection
      - 3.7.2 Physical Memory Protection and Paging
      url: "/riscv-priv-isa-manual/Priv-v1.12/machine.html#pmp-vmem"
    "#priority-and-matching-logic":
      headers:
      - 3 Machine-Level ISA, Version 1.12
      - 3.7 Physical Memory Protection
      - 3.7.1 Physical Memory Protection CSRs
      - Priority and Matching Logic
      url: "/riscv-priv-isa-manual/Priv-v1.12/machine.html#priority-and-matching-logic"
    "#privstack":
      headers:
      - 3 Machine-Level ISA, Version 1.12
      - 3.1 Machine-Level CSRs
      - 3.1.6 Machine Status Registers (mstatus and mstatush)
      - 3.1.6.1 Privilege and Global Interrupt-Enable Stack in mstatus register
      url: "/riscv-priv-isa-manual/Priv-v1.12/machine.html#privstack"
    "#reservability-pma":
      headers:
      - 3 Machine-Level ISA, Version 1.12
      - 3.6 Physical Memory Attributes
      - 3.6.3 Atomicity PMAs
      - 3.6.3.2 Reservability PMA
      url: "/riscv-priv-isa-manual/Priv-v1.12/machine.html#reservability-pma"
    "#sec:customsys":
      headers:
      - 3 Machine-Level ISA, Version 1.12
      - 3.3 Machine-Mode Privileged Instructions
      - 3.3.4 Custom SYSTEM Instructions
      url: "/riscv-priv-isa-manual/Priv-v1.12/machine.html#sec:customsys"
    "#sec:mcause":
      headers:
      - 3 Machine-Level ISA, Version 1.12
      - 3.1 Machine-Level CSRs
      - 3.1.15 Machine Cause Register (mcause)
      url: "/riscv-priv-isa-manual/Priv-v1.12/machine.html#sec:mcause"
    "#sec:mcounteren":
      headers:
      - 3 Machine-Level ISA, Version 1.12
      - 3.1 Machine-Level CSRs
      - 3.1.11 Machine Counter-Enable Register (mcounteren)
      url: "/riscv-priv-isa-manual/Priv-v1.12/machine.html#sec:mcounteren"
    "#sec:misa":
      headers:
      - 3 Machine-Level ISA, Version 1.12
      - 3.1 Machine-Level CSRs
      - 3.1.1 Machine ISA Register misa
      url: "/riscv-priv-isa-manual/Priv-v1.12/machine.html#sec:misa"
    "#sec:mseccfg":
      headers:
      - 3 Machine-Level ISA, Version 1.12
      - 3.1 Machine-Level CSRs
      - 3.1.19 Machine Security Configuration Register (mseccfg)
      url: "/riscv-priv-isa-manual/Priv-v1.12/machine.html#sec:mseccfg"
    "#sec:nmi":
      headers:
      - 3 Machine-Level ISA, Version 1.12
      - 3.5 Non-Maskable Interrupts
      url: "/riscv-priv-isa-manual/Priv-v1.12/machine.html#sec:nmi"
    "#sec:pma":
      headers:
      - 3 Machine-Level ISA, Version 1.12
      - 3.6 Physical Memory Attributes
      url: "/riscv-priv-isa-manual/Priv-v1.12/machine.html#sec:pma"
    "#sec:pmp":
      headers:
      - 3 Machine-Level ISA, Version 1.12
      - 3.7 Physical Memory Protection
      url: "/riscv-priv-isa-manual/Priv-v1.12/machine.html#sec:pmp"
    "#sec:reset":
      headers:
      - 3 Machine-Level ISA, Version 1.12
      - 3.4 Reset
      url: "/riscv-priv-isa-manual/Priv-v1.12/machine.html#sec:reset"
    "#supported-access-type-pmas":
      headers:
      - 3 Machine-Level ISA, Version 1.12
      - 3.6 Physical Memory Attributes
      - 3.6.2 Supported Access Type PMAs
      url: "/riscv-priv-isa-manual/Priv-v1.12/machine.html#supported-access-type-pmas"
    "#virt-control":
      headers:
      - 3 Machine-Level ISA, Version 1.12
      - 3.1 Machine-Level CSRs
      - 3.1.6 Machine Status Registers (mstatus and mstatush)
      - 3.1.6.5 Virtualization Support in mstatus Register
      url: "/riscv-priv-isa-manual/Priv-v1.12/machine.html#virt-control"
    "#wfi":
      headers:
      - 3 Machine-Level ISA, Version 1.12
      - 3.3 Machine-Mode Privileged Instructions
      - 3.3.3 Wait for Interrupt
      url: "/riscv-priv-isa-manual/Priv-v1.12/machine.html#wfi"
    "#xlen-control":
      headers:
      - 3 Machine-Level ISA, Version 1.12
      - 3.1 Machine-Level CSRs
      - 3.1.6 Machine Status Registers (mstatus and mstatush)
      - 3.1.6.2 Base ISA Control in mstatus Register
      url: "/riscv-priv-isa-manual/Priv-v1.12/machine.html#xlen-control"
  p:
    '':
      headers: []
      url: "/riscv-user-isa-manual/Priv-v1.12/p.html"
    "#sec:packedsimd":
      headers:
      - 20 "P" Standard Extension for Packed-SIMD Instructions, Version 0.2
      url: "/riscv-user-isa-manual/Priv-v1.12/p.html#sec:packedsimd"
  q:
    '':
      headers: []
      url: "/riscv-user-isa-manual/Priv-v1.12/q.html"
    "#q-standard-extension-for-quad-precision-floating-point-version-2.2":
      headers:
      - 14 "Q" Standard Extension for Quad-Precision Floating-Point, Version 2.2
      url: "/riscv-user-isa-manual/Priv-v1.12/q.html#q-standard-extension-for-quad-precision-floating-point-version-2.2"
    "#quad-precision-computational-instructions":
      headers:
      - 14 "Q" Standard Extension for Quad-Precision Floating-Point, Version 2.2
      - 14.2 Quad-Precision Computational Instructions
      url: "/riscv-user-isa-manual/Priv-v1.12/q.html#quad-precision-computational-instructions"
    "#quad-precision-convert-and-move-instructions":
      headers:
      - 14 "Q" Standard Extension for Quad-Precision Floating-Point, Version 2.2
      - 14.3 Quad-Precision Convert and Move Instructions
      url: "/riscv-user-isa-manual/Priv-v1.12/q.html#quad-precision-convert-and-move-instructions"
    "#quad-precision-floating-point-classify-instruction":
      headers:
      - 14 "Q" Standard Extension for Quad-Precision Floating-Point, Version 2.2
      - 14.5 Quad-Precision Floating-Point Classify Instruction
      url: "/riscv-user-isa-manual/Priv-v1.12/q.html#quad-precision-floating-point-classify-instruction"
    "#quad-precision-floating-point-compare-instructions":
      headers:
      - 14 "Q" Standard Extension for Quad-Precision Floating-Point, Version 2.2
      - 14.4 Quad-Precision Floating-Point Compare Instructions
      url: "/riscv-user-isa-manual/Priv-v1.12/q.html#quad-precision-floating-point-compare-instructions"
    "#quad-precision-load-and-store-instructions":
      headers:
      - 14 "Q" Standard Extension for Quad-Precision Floating-Point, Version 2.2
      - 14.1 Quad-Precision Load and Store Instructions
      url: "/riscv-user-isa-manual/Priv-v1.12/q.html#quad-precision-load-and-store-instructions"
    "#sec:single-float-compute":
      headers: *38
      url: "/riscv-user-isa-manual/Priv-v1.12//q.html"
    "#single-precision-floating-point-compare-instructions":
      headers: *39
      url: "/riscv-user-isa-manual/Priv-v1.12//q.html"
  rv128:
    '':
      headers: []
      url: "/riscv-user-isa-manual/Priv-v1.12/rv128.html"
    "#rv128":
      headers:
      - 7 RV128I Base Integer Instruction Set, Version 1.7
      url: "/riscv-user-isa-manual/Priv-v1.12/rv128.html#rv128"
  rv32:
    '':
      headers: []
      url: "/riscv-user-isa-manual/Priv-v1.12/rv32.html"
    "#base-instruction-formats":
      headers:
      - 2 RV32I Base Integer Instruction Set, Version 2.1
      - 2.2 Base Instruction Formats
      url: "/riscv-user-isa-manual/Priv-v1.12/rv32.html#base-instruction-formats"
    "#conditional-branches":
      headers:
      - 2 RV32I Base Integer Instruction Set, Version 2.1
      - 2.5 Control Transfer Instructions
      - Conditional Branches
      url: "/riscv-user-isa-manual/Priv-v1.12/rv32.html#conditional-branches"
    "#control-transfer-instructions":
      headers:
      - 2 RV32I Base Integer Instruction Set, Version 2.1
      - 2.5 Control Transfer Instructions
      url: "/riscv-user-isa-manual/Priv-v1.12/rv32.html#control-transfer-instructions"
    "#environment-call-and-breakpoints":
      headers:
      - 2 RV32I Base Integer Instruction Set, Version 2.1
      - 2.8 Environment Call and Breakpoints
      url: "/riscv-user-isa-manual/Priv-v1.12/rv32.html#environment-call-and-breakpoints"
    "#immediate-encoding-variants":
      headers:
      - 2 RV32I Base Integer Instruction Set, Version 2.1
      - 2.3 Immediate Encoding Variants
      url: "/riscv-user-isa-manual/Priv-v1.12/rv32.html#immediate-encoding-variants"
    "#integer-computational-instructions":
      headers:
      - 2 RV32I Base Integer Instruction Set, Version 2.1
      - 2.4 Integer Computational Instructions
      url: "/riscv-user-isa-manual/Priv-v1.12/rv32.html#integer-computational-instructions"
    "#integer-register-immediate-instructions":
      headers:
      - 2 RV32I Base Integer Instruction Set, Version 2.1
      - 2.4 Integer Computational Instructions
      - Integer Register-Immediate Instructions
      url: "/riscv-user-isa-manual/Priv-v1.12/rv32.html#integer-register-immediate-instructions"
    "#integer-register-register-operations":
      headers:
      - 2 RV32I Base Integer Instruction Set, Version 2.1
      - 2.4 Integer Computational Instructions
      - Integer Register-Register Operations
      url: "/riscv-user-isa-manual/Priv-v1.12/rv32.html#integer-register-register-operations"
    "#nop-instruction":
      headers:
      - 2 RV32I Base Integer Instruction Set, Version 2.1
      - 2.4 Integer Computational Instructions
      - NOP Instruction
      url: "/riscv-user-isa-manual/Priv-v1.12/rv32.html#nop-instruction"
    "#programmers-model-for-base-integer-isa":
      headers:
      - 2 RV32I Base Integer Instruction Set, Version 2.1
      - "2.1 Programmers\x80\x99 Model for Base Integer ISA"
      url: "/riscv-user-isa-manual/Priv-v1.12/rv32.html#programmers-model-for-base-integer-isa"
    "#rv32":
      headers:
      - 2 RV32I Base Integer Instruction Set, Version 2.1
      url: "/riscv-user-isa-manual/Priv-v1.12/rv32.html#rv32"
    "#sec:fence":
      headers:
      - 2 RV32I Base Integer Instruction Set, Version 2.1
      - 2.7 Memory Ordering Instructions
      url: "/riscv-user-isa-manual/Priv-v1.12/rv32.html#sec:fence"
    "#sec:rv32:ldst":
      headers:
      - 2 RV32I Base Integer Instruction Set, Version 2.1
      - 2.6 Load and Store Instructions
      url: "/riscv-user-isa-manual/Priv-v1.12/rv32.html#sec:rv32:ldst"
    "#sec:rv32i-hints":
      headers:
      - 2 RV32I Base Integer Instruction Set, Version 2.1
      - 2.9 HINT Instructions
      url: "/riscv-user-isa-manual/Priv-v1.12/rv32.html#sec:rv32i-hints"
    "#unconditional-jumps":
      headers:
      - 2 RV32I Base Integer Instruction Set, Version 2.1
      - 2.5 Control Transfer Instructions
      - Unconditional Jumps
      url: "/riscv-user-isa-manual/Priv-v1.12/rv32.html#unconditional-jumps"
  rv32e:
    '':
      headers: []
      url: "/riscv-user-isa-manual/Priv-v1.12/rv32e.html"
    "#rv32e":
      headers:
      - 5 RV32E Base Integer Instruction Set, Version 1.9
      url: "/riscv-user-isa-manual/Priv-v1.12/rv32e.html#rv32e"
    "#rv32e-instruction-set":
      headers:
      - 5 RV32E Base Integer Instruction Set, Version 1.9
      - 5.2 RV32E Instruction Set
      url: "/riscv-user-isa-manual/Priv-v1.12/rv32e.html#rv32e-instruction-set"
    "#rv32e-programmers-model":
      headers:
      - 5 RV32E Base Integer Instruction Set, Version 1.9
      - "5.1 RV32E Programmers\x80\x99 Model"
      url: "/riscv-user-isa-manual/Priv-v1.12/rv32e.html#rv32e-programmers-model"
  rv64:
    '':
      headers: []
      url: "/riscv-user-isa-manual/Priv-v1.12/rv64.html"
    "#integer-computational-instructions":
      headers:
      - 6 RV64I Base Integer Instruction Set, Version 2.1
      - 6.2 Integer Computational Instructions
      url: "/riscv-user-isa-manual/Priv-v1.12/rv64.html#integer-computational-instructions"
    "#integer-register-immediate-instructions":
      headers:
      - 6 RV64I Base Integer Instruction Set, Version 2.1
      - 6.2 Integer Computational Instructions
      - Integer Register-Immediate Instructions
      url: "/riscv-user-isa-manual/Priv-v1.12/rv64.html#integer-register-immediate-instructions"
    "#integer-register-register-operations":
      headers:
      - 6 RV64I Base Integer Instruction Set, Version 2.1
      - 6.2 Integer Computational Instructions
      - Integer Register-Register Operations
      url: "/riscv-user-isa-manual/Priv-v1.12/rv64.html#integer-register-register-operations"
    "#load-and-store-instructions":
      headers:
      - 6 RV64I Base Integer Instruction Set, Version 2.1
      - 6.3 Load and Store Instructions
      url: "/riscv-user-isa-manual/Priv-v1.12/rv64.html#load-and-store-instructions"
    "#register-state":
      headers:
      - 6 RV64I Base Integer Instruction Set, Version 2.1
      - 6.1 Register State
      url: "/riscv-user-isa-manual/Priv-v1.12/rv64.html#register-state"
    "#rv64":
      headers:
      - 6 RV64I Base Integer Instruction Set, Version 2.1
      url: "/riscv-user-isa-manual/Priv-v1.12/rv64.html#rv64"
    "#sec:rv64i-hints":
      headers:
      - 6 RV64I Base Integer Instruction Set, Version 2.1
      - 6.4 HINT Instructions
      url: "/riscv-user-isa-manual/Priv-v1.12/rv64.html#sec:rv64i-hints"
  rvwmo:
    '':
      headers: []
      url: "/riscv-user-isa-manual/Priv-v1.12/rvwmo.html"
    "#ch:memorymodel":
      headers:
      - 16 RVWMO Memory Consistency Model, Version 2.0
      url: "/riscv-user-isa-manual/Priv-v1.12/rvwmo.html#ch:memorymodel"
    "#memory-model-axioms":
      headers:
      - 16 RVWMO Memory Consistency Model, Version 2.0
      - 16.1 Definition of the RVWMO Memory Model
      - Memory Model Axioms
      url: "/riscv-user-isa-manual/Priv-v1.12/rvwmo.html#memory-model-axioms"
    "#preserved-program-order":
      headers:
      - 16 RVWMO Memory Consistency Model, Version 2.0
      - 16.1 Definition of the RVWMO Memory Model
      - Preserved Program Order
      url: "/riscv-user-isa-manual/Priv-v1.12/rvwmo.html#preserved-program-order"
    "#rvwmo:ax:atom":
      headers:
      - 16 RVWMO Memory Consistency Model, Version 2.0
      - 16.1 Definition of the RVWMO Memory Model
      - Memory Model Axioms
      url: "/riscv-user-isa-manual/Priv-v1.12/rvwmo.html#rvwmo:ax:atom"
    "#rvwmo:ax:load":
      headers:
      - 16 RVWMO Memory Consistency Model, Version 2.0
      - 16.1 Definition of the RVWMO Memory Model
      - Memory Model Axioms
      url: "/riscv-user-isa-manual/Priv-v1.12/rvwmo.html#rvwmo:ax:load"
    "#rvwmo:ax:prog":
      headers:
      - 16 RVWMO Memory Consistency Model, Version 2.0
      - 16.1 Definition of the RVWMO Memory Model
      - Memory Model Axioms
      url: "/riscv-user-isa-manual/Priv-v1.12/rvwmo.html#rvwmo:ax:prog"
    "#sec:memorymodel:dependencies":
      headers:
      - 16 RVWMO Memory Consistency Model, Version 2.0
      - 16.1 Definition of the RVWMO Memory Model
      - Syntactic Dependencies
      url: "/riscv-user-isa-manual/Priv-v1.12/rvwmo.html#sec:memorymodel:dependencies"
    "#sec:rvwmo":
      headers:
      - 16 RVWMO Memory Consistency Model, Version 2.0
      - 16.1 Definition of the RVWMO Memory Model
      url: "/riscv-user-isa-manual/Priv-v1.12/rvwmo.html#sec:rvwmo"
    "#sec:rvwmo:primitives":
      headers:
      - 16 RVWMO Memory Consistency Model, Version 2.0
      - 16.1 Definition of the RVWMO Memory Model
      - Memory Model Primitives
      url: "/riscv-user-isa-manual/Priv-v1.12/rvwmo.html#sec:rvwmo:primitives"
  supervisor:
    '':
      headers: []
      url: "/riscv-priv-isa-manual/Priv-v1.12/supervisor.html"
    "#addressing-and-memory-protection":
      headers:
      - 4 Supervisor-Level ISA, Version 1.12
      - '4.4 Sv39: Page-Based 39-bit Virtual-Memory System'
      - 4.4.1 Addressing and Memory Protection
      url: "/riscv-priv-isa-manual/Priv-v1.12/supervisor.html#addressing-and-memory-protection"
    "#addressing-and-memory-protection-1":
      headers:
      - 4 Supervisor-Level ISA, Version 1.12
      - '4.5 Sv48: Page-Based 48-bit Virtual-Memory System'
      - 4.5.1 Addressing and Memory Protection
      url: "/riscv-priv-isa-manual/Priv-v1.12/supervisor.html#addressing-and-memory-protection-1"
    "#addressing-and-memory-protection-2":
      headers:
      - 4 Supervisor-Level ISA, Version 1.12
      - '4.6 Sv57: Page-Based 57-bit Virtual-Memory System'
      - 4.6.1 Addressing and Memory Protection
      url: "/riscv-priv-isa-manual/Priv-v1.12/supervisor.html#addressing-and-memory-protection-2"
    "#base-isa-control-in-sstatus-register":
      headers:
      - 4 Supervisor-Level ISA, Version 1.12
      - 4.1 Supervisor CSRs
      - 4.1.1 Supervisor Status Register (sstatus)
      - 4.1.1.1 Base ISA Control in sstatus Register
      url: "/riscv-priv-isa-manual/Priv-v1.12/supervisor.html#base-isa-control-in-sstatus-register"
    "#counter-enable-register-scounteren":
      headers:
      - 4 Supervisor-Level ISA, Version 1.12
      - 4.1 Supervisor CSRs
      - 4.1.5 Counter-Enable Register (scounteren)
      url: "/riscv-priv-isa-manual/Priv-v1.12/supervisor.html#counter-enable-register-scounteren"
    "#endianness-control-in-sstatus-register":
      headers:
      - 4 Supervisor-Level ISA, Version 1.12
      - 4.1 Supervisor CSRs
      - 4.1.1 Supervisor Status Register (sstatus)
      - 4.1.1.3 Endianness Control in sstatus Register
      url: "/riscv-priv-isa-manual/Priv-v1.12/supervisor.html#endianness-control-in-sstatus-register"
    "#sec:satp":
      headers:
      - 4 Supervisor-Level ISA, Version 1.12
      - 4.1 Supervisor CSRs
      - 4.1.11 Supervisor Address Translation and Protection (satp) Register
      url: "/riscv-priv-isa-manual/Priv-v1.12/supervisor.html#sec:satp"
    "#sec:scause":
      headers:
      - 4 Supervisor-Level ISA, Version 1.12
      - 4.1 Supervisor CSRs
      - 4.1.8 Supervisor Cause Register (scause)
      url: "/riscv-priv-isa-manual/Priv-v1.12/supervisor.html#sec:scause"
    "#sec:sfence.vma":
      headers:
      - 4 Supervisor-Level ISA, Version 1.12
      - 4.2 Supervisor Instructions
      - 4.2.1 Supervisor Memory-Management Fence Instruction
      url: "/riscv-priv-isa-manual/Priv-v1.12/supervisor.html#sec:sfence.vma"
    "#sec:sum":
      headers:
      - 4 Supervisor-Level ISA, Version 1.12
      - 4.1 Supervisor CSRs
      - 4.1.1 Supervisor Status Register (sstatus)
      - 4.1.1.2 Memory Privilege in sstatus Register
      url: "/riscv-priv-isa-manual/Priv-v1.12/supervisor.html#sec:sum"
    "#sec:sv32":
      headers:
      - 4 Supervisor-Level ISA, Version 1.12
      - '4.3 Sv32: Page-Based 32-bit Virtual-Memory Systems'
      url: "/riscv-priv-isa-manual/Priv-v1.12/supervisor.html#sec:sv32"
    "#sec:sv39":
      headers:
      - 4 Supervisor-Level ISA, Version 1.12
      - '4.4 Sv39: Page-Based 39-bit Virtual-Memory System'
      url: "/riscv-priv-isa-manual/Priv-v1.12/supervisor.html#sec:sv39"
    "#sec:sv48":
      headers:
      - 4 Supervisor-Level ISA, Version 1.12
      - '4.5 Sv48: Page-Based 48-bit Virtual-Memory System'
      url: "/riscv-priv-isa-manual/Priv-v1.12/supervisor.html#sec:sv48"
    "#sec:sv57":
      headers:
      - 4 Supervisor-Level ISA, Version 1.12
      - '4.6 Sv57: Page-Based 57-bit Virtual-Memory System'
      url: "/riscv-priv-isa-manual/Priv-v1.12/supervisor.html#sec:sv57"
    "#sec:translation":
      headers:
      - 4 Supervisor-Level ISA, Version 1.12
      - '4.3 Sv32: Page-Based 32-bit Virtual-Memory Systems'
      - 4.3.1 Addressing and Memory Protection
      url: "/riscv-priv-isa-manual/Priv-v1.12/supervisor.html#sec:translation"
    "#sstatus":
      headers:
      - 4 Supervisor-Level ISA, Version 1.12
      - 4.1 Supervisor CSRs
      - 4.1.1 Supervisor Status Register (sstatus)
      url: "/riscv-priv-isa-manual/Priv-v1.12/supervisor.html#sstatus"
    "#supervisor":
      headers:
      - 4 Supervisor-Level ISA, Version 1.12
      url: "/riscv-priv-isa-manual/Priv-v1.12/supervisor.html#supervisor"
    "#supervisor-csrs":
      headers:
      - 4 Supervisor-Level ISA, Version 1.12
      - 4.1 Supervisor CSRs
      url: "/riscv-priv-isa-manual/Priv-v1.12/supervisor.html#supervisor-csrs"
    "#supervisor-environment-configuration-register-senvcfg":
      headers:
      - 4 Supervisor-Level ISA, Version 1.12
      - 4.1 Supervisor CSRs
      - 4.1.10 Supervisor Environment Configuration Register (senvcfg)
      url: "/riscv-priv-isa-manual/Priv-v1.12/supervisor.html#supervisor-environment-configuration-register-senvcfg"
    "#supervisor-exception-program-counter-sepc":
      headers:
      - 4 Supervisor-Level ISA, Version 1.12
      - 4.1 Supervisor CSRs
      - 4.1.7 Supervisor Exception Program Counter (sepc)
      url: "/riscv-priv-isa-manual/Priv-v1.12/supervisor.html#supervisor-exception-program-counter-sepc"
    "#supervisor-instructions":
      headers:
      - 4 Supervisor-Level ISA, Version 1.12
      - 4.2 Supervisor Instructions
      url: "/riscv-priv-isa-manual/Priv-v1.12/supervisor.html#supervisor-instructions"
    "#supervisor-interrupt-registers-sip-and-sie":
      headers:
      - 4 Supervisor-Level ISA, Version 1.12
      - 4.1 Supervisor CSRs
      - 4.1.3 Supervisor Interrupt Registers (sip and sie)
      url: "/riscv-priv-isa-manual/Priv-v1.12/supervisor.html#supervisor-interrupt-registers-sip-and-sie"
    "#supervisor-scratch-register-sscratch":
      headers:
      - 4 Supervisor-Level ISA, Version 1.12
      - 4.1 Supervisor CSRs
      - 4.1.6 Supervisor Scratch Register (sscratch)
      url: "/riscv-priv-isa-manual/Priv-v1.12/supervisor.html#supervisor-scratch-register-sscratch"
    "#supervisor-timers-and-performance-counters":
      headers:
      - 4 Supervisor-Level ISA, Version 1.12
      - 4.1 Supervisor CSRs
      - 4.1.4 Supervisor Timers and Performance Counters
      url: "/riscv-priv-isa-manual/Priv-v1.12/supervisor.html#supervisor-timers-and-performance-counters"
    "#supervisor-trap-value-stval-register":
      headers:
      - 4 Supervisor-Level ISA, Version 1.12
      - 4.1 Supervisor CSRs
      - 4.1.9 Supervisor Trap Value (stval) Register
      url: "/riscv-priv-isa-manual/Priv-v1.12/supervisor.html#supervisor-trap-value-stval-register"
    "#supervisor-trap-vector-base-address-register-stvec":
      headers:
      - 4 Supervisor-Level ISA, Version 1.12
      - 4.1 Supervisor CSRs
      - 4.1.2 Supervisor Trap Vector Base Address Register (stvec)
      url: "/riscv-priv-isa-manual/Priv-v1.12/supervisor.html#supervisor-trap-vector-base-address-register-stvec"
    "#sv32algorithm":
      headers:
      - 4 Supervisor-Level ISA, Version 1.12
      - '4.3 Sv32: Page-Based 32-bit Virtual-Memory Systems'
      - 4.3.2 Virtual Address Translation Process
      url: "/riscv-priv-isa-manual/Priv-v1.12/supervisor.html#sv32algorithm"
    "#svinval":
      headers:
      - 7 "Svinval" Standard Extension for Fine-Grained Address-Translation Cache
        Invalidation, Version 1.0
      url: "/riscv-priv-isa-manual/Priv-v1.12/supervisor.html#svinval"
    "#svnapot":
      headers:
      - 5 "Svnapot" Standard Extension for NAPOT Translation Contiguity, Version 1.0
      url: "/riscv-priv-isa-manual/Priv-v1.12/supervisor.html#svnapot"
    "#svpbmt":
      headers:
      - 6 "Svpbmt" Standard Extension for Page-Based Memory Types, Version 1.0
      url: "/riscv-priv-isa-manual/Priv-v1.12/supervisor.html#svpbmt"
  v:
    '':
      headers: []
      url: "/riscv-v-spec/v1.0//v-spec.html"
    "#_avl_encoding":
      headers:
      - 6. Configuration-Setting Instructions (vsetvli/vsetivli/vsetvl)
      - 6.2. AVL encoding
      url: "/riscv-v-spec/v1.0//v-spec.html#_avl_encoding"
    "#_c_standard_library_strcmp_example":
      headers:
      - 'Appendix A: Vector Assembly Code Examples'
      - A.9. C standard library strcmp example
      url: "/riscv-v-spec/v1.0//v-spec.html#_c_standard_library_strcmp_example"
    "#_calling_convention_not_authoritative_placeholder_only":
      headers:
      - 'Appendix B: Calling Convention (Not authoritative - Placeholder Only)'
      url: "/riscv-v-spec/v1.0//v-spec.html#_calling_convention_not_authoritative_placeholder_only"
    "#_changes_from_v1_0_rc2":
      headers:
      - Changes from v1.0-rc2
      url: "/riscv-v-spec/v1.0//v-spec.html#_changes_from_v1_0_rc2"
    "#_clarified_that_this_it_the_frozen_version_for_public_review":
      headers:
      - Changes from v1.0-rc2
      - Clarified that this it the frozen version for public review.
      url: "/riscv-v-spec/v1.0//v-spec.html#_clarified_that_this_it_the_frozen_version_for_public_review"
    "#_conditional_example":
      headers:
      - 'Appendix A: Vector Assembly Code Examples'
      - A.4. Conditional example
      url: "/riscv-v-spec/v1.0//v-spec.html#_conditional_example"
    "#_constraints_on_setting_vl":
      headers:
      - 6. Configuration-Setting Instructions (vsetvli/vsetivli/vsetvl)
      - 6.3. Constraints on Setting vl
      url: "/riscv-v-spec/v1.0//v-spec.html#_constraints_on_setting_vl"
    "#_division_approximation_example":
      headers:
      - 'Appendix A: Vector Assembly Code Examples'
      - A.7. Division approximation example
      url: "/riscv-v-spec/v1.0//v-spec.html#_division_approximation_example"
    "#_example_using_vector_mask_instructions":
      headers:
      - 15. Vector Mask Instructions
      - 15.7. Example using vector mask instructions
      url: "/riscv-v-spec/v1.0//v-spec.html#_example_using_vector_mask_instructions"
    "#_example_with_mixed_width_mask_and_compute":
      headers:
      - 'Appendix A: Vector Assembly Code Examples'
      - A.2. Example with mixed-width mask and compute.
      url: "/riscv-v-spec/v1.0//v-spec.html#_example_with_mixed_width_mask_and_compute"
    "#_exception_handling":
      headers:
      - 17. Exception Handling
      url: "/riscv-v-spec/v1.0//v-spec.html#_exception_handling"
    "#_floating_point_scalar_move_instructions":
      headers:
      - 16. Vector Permutation Instructions
      - 16.2. Floating-Point Scalar Move Instructions
      url: "/riscv-v-spec/v1.0//v-spec.html#_floating_point_scalar_move_instructions"
    "#_fractional_lmul_example":
      headers:
      - 'Appendix C: Fractional Lmul example'
      url: "/riscv-v-spec/v1.0//v-spec.html#_fractional_lmul_example"
    "#_implementation_defined_constant_parameters":
      headers:
      - 2. Implementation-defined Constant Parameters
      url: "/riscv-v-spec/v1.0//v-spec.html#_implementation_defined_constant_parameters"
    "#_imprecise_vector_traps":
      headers:
      - 17. Exception Handling
      - 17.2. Imprecise vector traps
      url: "/riscv-v-spec/v1.0//v-spec.html#_imprecise_vector_traps"
    "#_integer_scalar_move_instructions":
      headers:
      - 16. Vector Permutation Instructions
      - 16.1. Integer Scalar Move Instructions
      url: "/riscv-v-spec/v1.0//v-spec.html#_integer_scalar_move_instructions"
    "#_introduction":
      headers:
      - 1. Introduction
      url: "/riscv-v-spec/v1.0//v-spec.html#_introduction"
    "#_mapping_for_lmul_1":
      headers:
      - 4. Mapping of Vector Elements to Vector Register State
      - 4.1. Mapping for LMUL = 1
      url: "/riscv-v-spec/v1.0//v-spec.html#_mapping_for_lmul_1"
    "#_mapping_for_lmul_1_2":
      headers:
      - 4. Mapping of Vector Elements to Vector Register State
      - 4.2. Mapping for LMUL < 1
      url: "/riscv-v-spec/v1.0//v-spec.html#_mapping_for_lmul_1_2"
    "#_mapping_for_lmul_1_3":
      headers:
      - 4. Mapping of Vector Elements to Vector Register State
      - 4.3. Mapping for LMUL > 1
      url: "/riscv-v-spec/v1.0//v-spec.html#_mapping_for_lmul_1_3"
    "#_mapping_of_vector_elements_to_vector_register_state":
      headers:
      - 4. Mapping of Vector Elements to Vector Register State
      url: "/riscv-v-spec/v1.0//v-spec.html#_mapping_of_vector_elements_to_vector_register_state"
    "#_memcpy_example":
      headers:
      - 'Appendix A: Vector Assembly Code Examples'
      - A.3. Memcpy example
      url: "/riscv-v-spec/v1.0//v-spec.html#_memcpy_example"
    "#_narrowing_floating_pointinteger_type_convert_instructions":
      headers:
      - 13. Vector Floating-Point Instructions
      - 13.19. Narrowing Floating-Point/Integer Type-Convert Instructions
      url: "/riscv-v-spec/v1.0//v-spec.html#_narrowing_floating_pointinteger_type_convert_instructions"
    "#_precise_vector_traps":
      headers:
      - 17. Exception Handling
      - 17.1. Precise vector traps
      url: "/riscv-v-spec/v1.0//v-spec.html#_precise_vector_traps"
    "#_saxpy_example":
      headers:
      - 'Appendix A: Vector Assembly Code Examples'
      - A.5. SAXPY example
      url: "/riscv-v-spec/v1.0//v-spec.html#_saxpy_example"
    "#_scalar_operands":
      headers:
      - 5. Vector Instruction Formats
      - 5.1. Scalar Operands
      url: "/riscv-v-spec/v1.0//v-spec.html#_scalar_operands"
    "#_selectable_preciseimprecise_traps":
      headers:
      - 17. Exception Handling
      - 17.3. Selectable precise/imprecise traps
      url: "/riscv-v-spec/v1.0//v-spec.html#_selectable_preciseimprecise_traps"
    "#_sgemm_example":
      headers:
      - 'Appendix A: Vector Assembly Code Examples'
      - A.6. SGEMM example
      url: "/riscv-v-spec/v1.0//v-spec.html#_sgemm_example"
    "#_single_width_floating_pointinteger_type_convert_instructions":
      headers:
      - 13. Vector Floating-Point Instructions
      - 13.17. Single-Width Floating-Point/Integer Type-Convert Instructions
      url: "/riscv-v-spec/v1.0//v-spec.html#_single_width_floating_pointinteger_type_convert_instructions"
    "#_square_root_approximation_example":
      headers:
      - 'Appendix A: Vector Assembly Code Examples'
      - A.8. Square root approximation example
      url: "/riscv-v-spec/v1.0//v-spec.html#_square_root_approximation_example"
    "#_state_of_vector_extension_at_reset":
      headers:
      - 3. Vector Extension Programmer's Model
      - 3.11. State of Vector Extension at Reset
      url: "/riscv-v-spec/v1.0//v-spec.html#_state_of_vector_extension_at_reset"
    "#_swappable_traps":
      headers:
      - 17. Exception Handling
      - 17.4. Swappable traps
      url: "/riscv-v-spec/v1.0//v-spec.html#_swappable_traps"
    "#_synthesizing_vdecompress":
      headers:
      - 16. Vector Permutation Instructions
      - 16.5. Vector Compress Instruction
      - 16.5.1. Synthesizing vdecompress
      url: "/riscv-v-spec/v1.0//v-spec.html#_synthesizing_vdecompress"
    "#_unit_stride_fault_only_first_loads":
      headers:
      - 7. Vector Loads and Stores
      - 7.7. Unit-stride Fault-Only-First Loads
      url: "/riscv-v-spec/v1.0//v-spec.html#_unit_stride_fault_only_first_loads"
    "#_v_vector_extension_for_application_processors":
      headers:
      - 18. Standard Vector Extensions
      - '18.3. V: Vector Extension for Application Processors'
      url: "/riscv-v-spec/v1.0//v-spec.html#_v_vector_extension_for_application_processors"
    "#_vector_arithmetic_instruction_formats":
      headers:
      - 10. Vector Arithmetic Instruction Formats
      url: "/riscv-v-spec/v1.0//v-spec.html#_vector_arithmetic_instruction_formats"
    "#_vector_assembly_code_examples":
      headers:
      - 'Appendix A: Vector Assembly Code Examples'
      url: "/riscv-v-spec/v1.0//v-spec.html#_vector_assembly_code_examples"
    "#_vector_bitwise_logical_instructions":
      headers:
      - 11. Vector Integer Arithmetic Instructions
      - 11.5. Vector Bitwise Logical Instructions
      url: "/riscv-v-spec/v1.0//v-spec.html#_vector_bitwise_logical_instructions"
    "#_vector_byte_length_vlenb":
      headers:
      - 3. Vector Extension Programmer's Model
      - 3.6. Vector Byte Length vlenb
      url: "/riscv-v-spec/v1.0//v-spec.html#_vector_byte_length_vlenb"
    "#_vector_compress_instruction":
      headers:
      - 16. Vector Permutation Instructions
      - 16.5. Vector Compress Instruction
      url: "/riscv-v-spec/v1.0//v-spec.html#_vector_compress_instruction"
    "#_vector_context_status_in_mstatus":
      headers:
      - 3. Vector Extension Programmer's Model
      - 3.2. Vector Context Status in mstatus
      url: "/riscv-v-spec/v1.0//v-spec.html#_vector_context_status_in_mstatus"
    "#_vector_context_status_in_vsstatus":
      headers:
      - 3. Vector Extension Programmer's Model
      - 3.3. Vector Context Status in vsstatus
      url: "/riscv-v-spec/v1.0//v-spec.html#_vector_context_status_in_vsstatus"
    "#_vector_control_and_status_register_vcsr":
      headers:
      - 3. Vector Extension Programmer's Model
      - 3.10. Vector Control and Status Register vcsr
      url: "/riscv-v-spec/v1.0//v-spec.html#_vector_control_and_status_register_vcsr"
    "#_vector_count_population_in_mask_vcpop_m":
      headers:
      - 15. Vector Mask Instructions
      - 15.2. Vector count population in mask vcpop.m
      url: "/riscv-v-spec/v1.0//v-spec.html#_vector_count_population_in_mask_vcpop_m"
    "#_vector_element_index_instruction":
      headers:
      - 15. Vector Mask Instructions
      - 15.9. Vector Element Index Instruction
      url: "/riscv-v-spec/v1.0//v-spec.html#_vector_element_index_instruction"
    "#_vector_extension_programmers_model":
      headers:
      - 3. Vector Extension Programmer's Model
      url: "/riscv-v-spec/v1.0//v-spec.html#_vector_extension_programmers_model"
    "#_vector_fixed_point_rounding_mode_register_vxrm":
      headers:
      - 3. Vector Extension Programmer's Model
      - 3.8. Vector Fixed-Point Rounding Mode Register vxrm
      url: "/riscv-v-spec/v1.0//v-spec.html#_vector_fixed_point_rounding_mode_register_vxrm"
    "#_vector_fixed_point_saturation_flag_vxsat":
      headers:
      - 3. Vector Extension Programmer's Model
      - 3.9. Vector Fixed-Point Saturation Flag vxsat
      url: "/riscv-v-spec/v1.0//v-spec.html#_vector_fixed_point_saturation_flag_vxsat"
    "#_vector_floating_point_classify_instruction":
      headers:
      - 13. Vector Floating-Point Instructions
      - 13.14. Vector Floating-Point Classify Instruction
      url: "/riscv-v-spec/v1.0//v-spec.html#_vector_floating_point_classify_instruction"
    "#_vector_floating_point_compare_instructions":
      headers:
      - 13. Vector Floating-Point Instructions
      - 13.13. Vector Floating-Point Compare Instructions
      url: "/riscv-v-spec/v1.0//v-spec.html#_vector_floating_point_compare_instructions"
    "#_vector_floating_point_exception_flags":
      headers:
      - 13. Vector Floating-Point Instructions
      - 13.1. Vector Floating-Point Exception Flags
      url: "/riscv-v-spec/v1.0//v-spec.html#_vector_floating_point_exception_flags"
    "#_vector_floating_point_merge_instruction":
      headers:
      - 13. Vector Floating-Point Instructions
      - 13.15. Vector Floating-Point Merge Instruction
      url: "/riscv-v-spec/v1.0//v-spec.html#_vector_floating_point_merge_instruction"
    "#_vector_floating_point_minmax_instructions":
      headers:
      - 13. Vector Floating-Point Instructions
      - 13.11. Vector Floating-Point MIN/MAX Instructions
      url: "/riscv-v-spec/v1.0//v-spec.html#_vector_floating_point_minmax_instructions"
    "#_vector_floating_point_move_instruction":
      headers:
      - 13. Vector Floating-Point Instructions
      - 13.16. Vector Floating-Point Move Instruction
      url: "/riscv-v-spec/v1.0//v-spec.html#_vector_floating_point_move_instruction"
    "#_vector_floating_point_reciprocal_estimate_instruction":
      headers:
      - 13. Vector Floating-Point Instructions
      - 13.10. Vector Floating-Point Reciprocal Estimate Instruction
      url: "/riscv-v-spec/v1.0//v-spec.html#_vector_floating_point_reciprocal_estimate_instruction"
    "#_vector_floating_point_reciprocal_square_root_estimate_instruction":
      headers:
      - 13. Vector Floating-Point Instructions
      - 13.9. Vector Floating-Point Reciprocal Square-Root Estimate Instruction
      url: "/riscv-v-spec/v1.0//v-spec.html#_vector_floating_point_reciprocal_square_root_estimate_instruction"
    "#_vector_floating_point_sign_injection_instructions":
      headers:
      - 13. Vector Floating-Point Instructions
      - 13.12. Vector Floating-Point Sign-Injection Instructions
      url: "/riscv-v-spec/v1.0//v-spec.html#_vector_floating_point_sign_injection_instructions"
    "#_vector_floating_point_square_root_instruction":
      headers:
      - 13. Vector Floating-Point Instructions
      - 13.8. Vector Floating-Point Square-Root Instruction
      url: "/riscv-v-spec/v1.0//v-spec.html#_vector_floating_point_square_root_instruction"
    "#_vector_indexed_instructions":
      headers:
      - 7. Vector Loads and Stores
      - 7.6. Vector Indexed Instructions
      url: "/riscv-v-spec/v1.0//v-spec.html#_vector_indexed_instructions"
    "#_vector_indexed_segment_loads_and_stores":
      headers:
      - 7. Vector Loads and Stores
      - 7.8. Vector Load/Store Segment Instructions
      - 7.8.3. Vector Indexed Segment Loads and Stores
      url: "/riscv-v-spec/v1.0//v-spec.html#_vector_indexed_segment_loads_and_stores"
    "#_vector_instruction_formats":
      headers:
      - 5. Vector Instruction Formats
      url: "/riscv-v-spec/v1.0//v-spec.html#_vector_instruction_formats"
    "#_vector_instruction_listing":
      headers:
      - 19. Vector Instruction Listing
      url: "/riscv-v-spec/v1.0//v-spec.html#_vector_instruction_listing"
    "#_vector_integer_add_with_carry_subtract_with_borrow_instructions":
      headers:
      - 11. Vector Integer Arithmetic Instructions
      - 11.4. Vector Integer Add-with-Carry / Subtract-with-Borrow Instructions
      url: "/riscv-v-spec/v1.0//v-spec.html#_vector_integer_add_with_carry_subtract_with_borrow_instructions"
    "#_vector_integer_compare_instructions":
      headers:
      - 11. Vector Integer Arithmetic Instructions
      - 11.8. Vector Integer Compare Instructions
      url: "/riscv-v-spec/v1.0//v-spec.html#_vector_integer_compare_instructions"
    "#_vector_integer_divide_instructions":
      headers:
      - 11. Vector Integer Arithmetic Instructions
      - 11.11. Vector Integer Divide Instructions
      url: "/riscv-v-spec/v1.0//v-spec.html#_vector_integer_divide_instructions"
    "#_vector_integer_extension":
      headers:
      - 11. Vector Integer Arithmetic Instructions
      - 11.3. Vector Integer Extension
      url: "/riscv-v-spec/v1.0//v-spec.html#_vector_integer_extension"
    "#_vector_integer_merge_instructions":
      headers:
      - 11. Vector Integer Arithmetic Instructions
      - 11.15. Vector Integer Merge Instructions
      url: "/riscv-v-spec/v1.0//v-spec.html#_vector_integer_merge_instructions"
    "#_vector_integer_minmax_instructions":
      headers:
      - 11. Vector Integer Arithmetic Instructions
      - 11.9. Vector Integer Min/Max Instructions
      url: "/riscv-v-spec/v1.0//v-spec.html#_vector_integer_minmax_instructions"
    "#_vector_integer_move_instructions":
      headers:
      - 11. Vector Integer Arithmetic Instructions
      - 11.16. Vector Integer Move Instructions
      url: "/riscv-v-spec/v1.0//v-spec.html#_vector_integer_move_instructions"
    "#_vector_iota_instruction":
      headers:
      - 15. Vector Mask Instructions
      - 15.8. Vector Iota Instruction
      url: "/riscv-v-spec/v1.0//v-spec.html#_vector_iota_instruction"
    "#_vector_length_register_vl":
      headers:
      - 3. Vector Extension Programmer's Model
      - 3.5. Vector Length Register vl
      url: "/riscv-v-spec/v1.0//v-spec.html#_vector_length_register_vl"
    "#_vector_loadstore_addressing_modes":
      headers:
      - 7. Vector Loads and Stores
      - 7.2. Vector Load/Store Addressing Modes
      url: "/riscv-v-spec/v1.0//v-spec.html#_vector_loadstore_addressing_modes"
    "#_vector_loadstore_instruction_encoding":
      headers:
      - 7. Vector Loads and Stores
      - 7.1. Vector Load/Store Instruction Encoding
      url: "/riscv-v-spec/v1.0//v-spec.html#_vector_loadstore_instruction_encoding"
    "#_vector_loadstore_whole_register_instructions":
      headers:
      - 7. Vector Loads and Stores
      - 7.9. Vector Load/Store Whole Register Instructions
      url: "/riscv-v-spec/v1.0//v-spec.html#_vector_loadstore_whole_register_instructions"
    "#_vector_masking":
      headers:
      - 5. Vector Instruction Formats
      - 5.3. Vector Masking
      url: "/riscv-v-spec/v1.0//v-spec.html#_vector_masking"
    "#_vector_memory_alignment_constraints":
      headers:
      - 8. Vector Memory Alignment Constraints
      url: "/riscv-v-spec/v1.0//v-spec.html#_vector_memory_alignment_constraints"
    "#_vector_memory_consistency_model":
      headers:
      - 9. Vector Memory Consistency Model
      url: "/riscv-v-spec/v1.0//v-spec.html#_vector_memory_consistency_model"
    "#_vector_narrowing_fixed_point_clip_instructions":
      headers:
      - 12. Vector Fixed-Point Arithmetic Instructions
      - 12.5. Vector Narrowing Fixed-Point Clip Instructions
      url: "/riscv-v-spec/v1.0//v-spec.html#_vector_narrowing_fixed_point_clip_instructions"
    "#_vector_narrowing_integer_right_shift_instructions":
      headers:
      - 11. Vector Integer Arithmetic Instructions
      - 11.7. Vector Narrowing Integer Right Shift Instructions
      url: "/riscv-v-spec/v1.0//v-spec.html#_vector_narrowing_integer_right_shift_instructions"
    "#_vector_ordered_single_width_floating_point_sum_reduction":
      headers:
      - 14. Vector Reduction Operations
      - 14.3. Vector Single-Width Floating-Point Reduction Instructions
      - 14.3.1. Vector Ordered Single-Width Floating-Point Sum Reduction
      url: "/riscv-v-spec/v1.0//v-spec.html#_vector_ordered_single_width_floating_point_sum_reduction"
    "#_vector_reduction_operations":
      headers:
      - 14. Vector Reduction Operations
      url: "/riscv-v-spec/v1.0//v-spec.html#_vector_reduction_operations"
    "#_vector_register_gather_instructions":
      headers:
      - 16. Vector Permutation Instructions
      - 16.4. Vector Register Gather Instructions
      url: "/riscv-v-spec/v1.0//v-spec.html#_vector_register_gather_instructions"
    "#_vector_register_grouping_vlmul20":
      headers:
      - 3. Vector Extension Programmer's Model
      - 3.4. Vector type register, vtype
      - 3.4.2. Vector Register Grouping (vlmul[2:0])
      url: "/riscv-v-spec/v1.0//v-spec.html#_vector_register_grouping_vlmul20"
    "#_vector_registers":
      headers:
      - 3. Vector Extension Programmer's Model
      - 3.1. Vector Registers
      url: "/riscv-v-spec/v1.0//v-spec.html#_vector_registers"
    "#_vector_selected_element_width_vsew20":
      headers:
      - 3. Vector Extension Programmer's Model
      - 3.4. Vector type register, vtype
      - 3.4.1. Vector selected element width vsew[2:0]
      url: "/riscv-v-spec/v1.0//v-spec.html#_vector_selected_element_width_vsew20"
    "#_vector_single_width_averaging_add_and_subtract":
      headers:
      - 12. Vector Fixed-Point Arithmetic Instructions
      - 12.2. Vector Single-Width Averaging Add and Subtract
      url: "/riscv-v-spec/v1.0//v-spec.html#_vector_single_width_averaging_add_and_subtract"
    "#_vector_single_width_floating_point_addsubtract_instructions":
      headers:
      - 13. Vector Floating-Point Instructions
      - 13.2. Vector Single-Width Floating-Point Add/Subtract Instructions
      url: "/riscv-v-spec/v1.0//v-spec.html#_vector_single_width_floating_point_addsubtract_instructions"
    "#_vector_single_width_floating_point_fused_multiply_add_instructions":
      headers:
      - 13. Vector Floating-Point Instructions
      - 13.6. Vector Single-Width Floating-Point Fused Multiply-Add Instructions
      url: "/riscv-v-spec/v1.0//v-spec.html#_vector_single_width_floating_point_fused_multiply_add_instructions"
    "#_vector_single_width_floating_point_max_and_min_reductions":
      headers:
      - 14. Vector Reduction Operations
      - 14.3. Vector Single-Width Floating-Point Reduction Instructions
      - 14.3.3. Vector Single-Width Floating-Point Max and Min Reductions
      url: "/riscv-v-spec/v1.0//v-spec.html#_vector_single_width_floating_point_max_and_min_reductions"
    "#_vector_single_width_floating_point_multiplydivide_instructions":
      headers:
      - 13. Vector Floating-Point Instructions
      - 13.4. Vector Single-Width Floating-Point Multiply/Divide Instructions
      url: "/riscv-v-spec/v1.0//v-spec.html#_vector_single_width_floating_point_multiplydivide_instructions"
    "#_vector_single_width_fractional_multiply_with_rounding_and_saturation":
      headers:
      - 12. Vector Fixed-Point Arithmetic Instructions
      - 12.3. Vector Single-Width Fractional Multiply with Rounding and Saturation
      url: "/riscv-v-spec/v1.0//v-spec.html#_vector_single_width_fractional_multiply_with_rounding_and_saturation"
    "#_vector_single_width_integer_add_and_subtract":
      headers:
      - 11. Vector Integer Arithmetic Instructions
      - 11.1. Vector Single-Width Integer Add and Subtract
      url: "/riscv-v-spec/v1.0//v-spec.html#_vector_single_width_integer_add_and_subtract"
    "#_vector_single_width_integer_multiply_add_instructions":
      headers:
      - 11. Vector Integer Arithmetic Instructions
      - 11.13. Vector Single-Width Integer Multiply-Add Instructions
      url: "/riscv-v-spec/v1.0//v-spec.html#_vector_single_width_integer_multiply_add_instructions"
    "#_vector_single_width_integer_multiply_instructions":
      headers:
      - 11. Vector Integer Arithmetic Instructions
      - 11.10. Vector Single-Width Integer Multiply Instructions
      url: "/riscv-v-spec/v1.0//v-spec.html#_vector_single_width_integer_multiply_instructions"
    "#_vector_single_width_saturating_add_and_subtract":
      headers:
      - 12. Vector Fixed-Point Arithmetic Instructions
      - 12.1. Vector Single-Width Saturating Add and Subtract
      url: "/riscv-v-spec/v1.0//v-spec.html#_vector_single_width_saturating_add_and_subtract"
    "#_vector_single_width_scaling_shift_instructions":
      headers:
      - 12. Vector Fixed-Point Arithmetic Instructions
      - 12.4. Vector Single-Width Scaling Shift Instructions
      url: "/riscv-v-spec/v1.0//v-spec.html#_vector_single_width_scaling_shift_instructions"
    "#_vector_single_width_shift_instructions":
      headers:
      - 11. Vector Integer Arithmetic Instructions
      - 11.6. Vector Single-Width Shift Instructions
      url: "/riscv-v-spec/v1.0//v-spec.html#_vector_single_width_shift_instructions"
    "#_vector_slide1down_instruction":
      headers:
      - 16. Vector Permutation Instructions
      - 16.3. Vector Slide Instructions
      - 16.3.4. Vector Slide1down Instruction
      url: "/riscv-v-spec/v1.0//v-spec.html#_vector_slide1down_instruction"
    "#_vector_slide1up":
      headers:
      - 16. Vector Permutation Instructions
      - 16.3. Vector Slide Instructions
      - 16.3.3. Vector Slide1up
      url: "/riscv-v-spec/v1.0//v-spec.html#_vector_slide1up"
    "#_vector_slide_instructions":
      headers:
      - 16. Vector Permutation Instructions
      - 16.3. Vector Slide Instructions
      url: "/riscv-v-spec/v1.0//v-spec.html#_vector_slide_instructions"
    "#_vector_slidedown_instructions":
      headers:
      - 16. Vector Permutation Instructions
      - 16.3. Vector Slide Instructions
      - 16.3.2. Vector Slidedown Instructions
      url: "/riscv-v-spec/v1.0//v-spec.html#_vector_slidedown_instructions"
    "#_vector_slideup_instructions":
      headers:
      - 16. Vector Permutation Instructions
      - 16.3. Vector Slide Instructions
      - 16.3.1. Vector Slideup Instructions
      url: "/riscv-v-spec/v1.0//v-spec.html#_vector_slideup_instructions"
    "#_vector_start_index_csr_vstart":
      headers:
      - 3. Vector Extension Programmer's Model
      - 3.7. Vector Start Index CSR vstart
      url: "/riscv-v-spec/v1.0//v-spec.html#_vector_start_index_csr_vstart"
    "#_vector_strided_instructions":
      headers:
      - 7. Vector Loads and Stores
      - 7.5. Vector Strided Instructions
      url: "/riscv-v-spec/v1.0//v-spec.html#_vector_strided_instructions"
    "#_vector_strided_segment_loads_and_stores":
      headers:
      - 7. Vector Loads and Stores
      - 7.8. Vector Load/Store Segment Instructions
      - 7.8.2. Vector Strided Segment Loads and Stores
      url: "/riscv-v-spec/v1.0//v-spec.html#_vector_strided_segment_loads_and_stores"
    "#_vector_type_illegal_vill":
      headers:
      - 3. Vector Extension Programmer's Model
      - 3.4. Vector type register, vtype
      - 3.4.4. Vector Type Illegal vill
      url: "/riscv-v-spec/v1.0//v-spec.html#_vector_type_illegal_vill"
    "#_vector_type_register_vtype":
      headers:
      - 3. Vector Extension Programmer's Model
      - 3.4. Vector type register, vtype
      url: "/riscv-v-spec/v1.0//v-spec.html#_vector_type_register_vtype"
    "#_vector_unit_stride_instructions":
      headers:
      - 7. Vector Loads and Stores
      - 7.4. Vector Unit-Stride Instructions
      url: "/riscv-v-spec/v1.0//v-spec.html#_vector_unit_stride_instructions"
    "#_vector_unit_stride_segment_loads_and_stores":
      headers:
      - 7. Vector Loads and Stores
      - 7.8. Vector Load/Store Segment Instructions
      - 7.8.1. Vector Unit-Stride Segment Loads and Stores
      url: "/riscv-v-spec/v1.0//v-spec.html#_vector_unit_stride_segment_loads_and_stores"
    "#_vector_unordered_single_width_floating_point_sum_reduction":
      headers:
      - 14. Vector Reduction Operations
      - 14.3. Vector Single-Width Floating-Point Reduction Instructions
      - 14.3.2. Vector Unordered Single-Width Floating-Point Sum Reduction
      url: "/riscv-v-spec/v1.0//v-spec.html#_vector_unordered_single_width_floating_point_sum_reduction"
    "#_vector_vector_add_example":
      headers:
      - 'Appendix A: Vector Assembly Code Examples'
      - A.1. Vector-vector add example
      url: "/riscv-v-spec/v1.0//v-spec.html#_vector_vector_add_example"
    "#_vector_widening_floating_point_addsubtract_instructions":
      headers:
      - 13. Vector Floating-Point Instructions
      - 13.3. Vector Widening Floating-Point Add/Subtract Instructions
      url: "/riscv-v-spec/v1.0//v-spec.html#_vector_widening_floating_point_addsubtract_instructions"
    "#_vector_widening_floating_point_fused_multiply_add_instructions":
      headers:
      - 13. Vector Floating-Point Instructions
      - 13.7. Vector Widening Floating-Point Fused Multiply-Add Instructions
      url: "/riscv-v-spec/v1.0//v-spec.html#_vector_widening_floating_point_fused_multiply_add_instructions"
    "#_vector_widening_floating_point_multiply":
      headers:
      - 13. Vector Floating-Point Instructions
      - 13.5. Vector Widening Floating-Point Multiply
      url: "/riscv-v-spec/v1.0//v-spec.html#_vector_widening_floating_point_multiply"
    "#_vector_widening_integer_addsubtract":
      headers:
      - 11. Vector Integer Arithmetic Instructions
      - 11.2. Vector Widening Integer Add/Subtract
      url: "/riscv-v-spec/v1.0//v-spec.html#_vector_widening_integer_addsubtract"
    "#_vector_widening_integer_multiply_add_instructions":
      headers:
      - 11. Vector Integer Arithmetic Instructions
      - 11.14. Vector Widening Integer Multiply-Add Instructions
      url: "/riscv-v-spec/v1.0//v-spec.html#_vector_widening_integer_multiply_add_instructions"
    "#_vector_widening_integer_multiply_instructions":
      headers:
      - 11. Vector Integer Arithmetic Instructions
      - 11.12. Vector Widening Integer Multiply Instructions
      url: "/riscv-v-spec/v1.0//v-spec.html#_vector_widening_integer_multiply_instructions"
    "#_vfirst_find_first_set_mask_bit":
      headers:
      - 15. Vector Mask Instructions
      - 15.3. vfirst find-first-set mask bit
      url: "/riscv-v-spec/v1.0//v-spec.html#_vfirst_find_first_set_mask_bit"
    "#_vmsbf_m_set_before_first_mask_bit":
      headers:
      - 15. Vector Mask Instructions
      - 15.4. vmsbf.m set-before-first mask bit
      url: "/riscv-v-spec/v1.0//v-spec.html#_vmsbf_m_set_before_first_mask_bit"
    "#_vmsif_m_set_including_first_mask_bit":
      headers:
      - 15. Vector Mask Instructions
      - 15.5. vmsif.m set-including-first mask bit
      url: "/riscv-v-spec/v1.0//v-spec.html#_vmsif_m_set_including_first_mask_bit"
    "#_vmsof_m_set_only_first_mask_bit":
      headers:
      - 15. Vector Mask Instructions
      - 15.6. vmsof.m set-only-first mask bit
      url: "/riscv-v-spec/v1.0//v-spec.html#_vmsof_m_set_only_first_mask_bit"
    "#_vtype_encoding":
      headers:
      - 6. Configuration-Setting Instructions (vsetvli/vsetivli/vsetvl)
      - 6.1. vtype encoding
      url: "/riscv-v-spec/v1.0//v-spec.html#_vtype_encoding"
    "#_whole_vector_register_move":
      headers:
      - 16. Vector Permutation Instructions
      - 16.6. Whole Vector Register Move
      url: "/riscv-v-spec/v1.0//v-spec.html#_whole_vector_register_move"
    "#_widening_floating_pointinteger_type_convert_instructions":
      headers:
      - 13. Vector Floating-Point Instructions
      - 13.18. Widening Floating-Point/Integer Type-Convert Instructions
      url: "/riscv-v-spec/v1.0//v-spec.html#_widening_floating_pointinteger_type_convert_instructions"
    "#_zve_vector_extensions_for_embedded_processors":
      headers:
      - 18. Standard Vector Extensions
      - '18.2. Zve*: Vector Extensions for Embedded Processors'
      url: "/riscv-v-spec/v1.0//v-spec.html#_zve_vector_extensions_for_embedded_processors"
    "#_zvl_minimum_vector_length_standard_extensions":
      headers:
      - 18. Standard Vector Extensions
      - '18.1. Zvl*: Minimum Vector Length Standard Extensions'
      url: "/riscv-v-spec/v1.0//v-spec.html#_zvl_minimum_vector_length_standard_extensions"
    "#example-stripmine-sew":
      headers:
      - 6. Configuration-Setting Instructions (vsetvli/vsetivli/vsetvl)
      - 6.4. Example of stripmining and changes to SEW
      url: "/riscv-v-spec/v1.0//v-spec.html#example-stripmine-sew"
    "#sec-agnostic":
      headers:
      - 3. Vector Extension Programmer's Model
      - 3.4. Vector type register, vtype
      - 3.4.3. Vector Tail Agnostic and Vector Mask Agnostic vta and vma
      url: "/riscv-v-spec/v1.0//v-spec.html#sec-agnostic"
    "#sec-aos":
      headers:
      - 7. Vector Loads and Stores
      - 7.8. Vector Load/Store Segment Instructions
      url: "/riscv-v-spec/v1.0//v-spec.html#sec-aos"
    "#sec-arithmetic-encoding":
      headers:
      - 10. Vector Arithmetic Instruction Formats
      - 10.1. Vector Arithmetic Instruction encoding
      url: "/riscv-v-spec/v1.0//v-spec.html#sec-arithmetic-encoding"
    "#sec-inactive-defs":
      headers:
      - 5. Vector Instruction Formats
      - 5.4. Prestart, Active, Inactive, Body, and Tail Element Definitions
      url: "/riscv-v-spec/v1.0//v-spec.html#sec-inactive-defs"
    "#sec-mapping-mixed":
      headers:
      - 4. Mapping of Vector Elements to Vector Register State
      - 4.4. Mapping across Mixed-Width Operations
      url: "/riscv-v-spec/v1.0//v-spec.html#sec-mapping-mixed"
    "#sec-mask-register-layout":
      headers:
      - 4. Mapping of Vector Elements to Vector Register State
      - 4.5. Mask Register Layout
      url: "/riscv-v-spec/v1.0//v-spec.html#sec-mask-register-layout"
    "#sec-mask-register-logical":
      headers:
      - 15. Vector Mask Instructions
      - 15.1. Vector Mask-Register Logical Instructions
      url: "/riscv-v-spec/v1.0//v-spec.html#sec-mask-register-logical"
    "#sec-narrowing":
      headers:
      - 10. Vector Arithmetic Instruction Formats
      - 10.3. Narrowing Vector Arithmetic Instructions
      url: "/riscv-v-spec/v1.0//v-spec.html#sec-narrowing"
    "#sec-vec-operands":
      headers:
      - 5. Vector Instruction Formats
      - 5.2. Vector Operands
      url: "/riscv-v-spec/v1.0//v-spec.html#sec-vec-operands"
    "#sec-vector-config":
      headers:
      - 6. Configuration-Setting Instructions (vsetvli/vsetivli/vsetvl)
      url: "/riscv-v-spec/v1.0//v-spec.html#sec-vector-config"
    "#sec-vector-extensions":
      headers:
      - 18. Standard Vector Extensions
      url: "/riscv-v-spec/v1.0//v-spec.html#sec-vector-extensions"
    "#sec-vector-fixed-point":
      headers:
      - 12. Vector Fixed-Point Arithmetic Instructions
      url: "/riscv-v-spec/v1.0//v-spec.html#sec-vector-fixed-point"
    "#sec-vector-float":
      headers:
      - 13. Vector Floating-Point Instructions
      url: "/riscv-v-spec/v1.0//v-spec.html#sec-vector-float"
    "#sec-vector-float-reduce":
      headers:
      - 14. Vector Reduction Operations
      - 14.3. Vector Single-Width Floating-Point Reduction Instructions
      url: "/riscv-v-spec/v1.0//v-spec.html#sec-vector-float-reduce"
    "#sec-vector-float-reduce-widen":
      headers:
      - 14. Vector Reduction Operations
      - 14.4. Vector Widening Floating-Point Reduction Instructions
      url: "/riscv-v-spec/v1.0//v-spec.html#sec-vector-float-reduce-widen"
    "#sec-vector-integer":
      headers:
      - 11. Vector Integer Arithmetic Instructions
      url: "/riscv-v-spec/v1.0//v-spec.html#sec-vector-integer"
    "#sec-vector-integer-reduce":
      headers:
      - 14. Vector Reduction Operations
      - 14.1. Vector Single-Width Integer Reduction Instructions
      url: "/riscv-v-spec/v1.0//v-spec.html#sec-vector-integer-reduce"
    "#sec-vector-integer-reduce-widen":
      headers:
      - 14. Vector Reduction Operations
      - 14.2. Vector Widening Integer Reduction Instructions
      url: "/riscv-v-spec/v1.0//v-spec.html#sec-vector-integer-reduce-widen"
    "#sec-vector-loadstore-width-encoding":
      headers:
      - 7. Vector Loads and Stores
      - 7.3. Vector Load/Store Width Encoding
      url: "/riscv-v-spec/v1.0//v-spec.html#sec-vector-loadstore-width-encoding"
    "#sec-vector-mask":
      headers:
      - 15. Vector Mask Instructions
      url: "/riscv-v-spec/v1.0//v-spec.html#sec-vector-mask"
    "#sec-vector-mask-encoding":
      headers:
      - 5. Vector Instruction Formats
      - 5.3. Vector Masking
      - 5.3.1. Mask Encoding
      url: "/riscv-v-spec/v1.0//v-spec.html#sec-vector-mask-encoding"
    "#sec-vector-memory":
      headers:
      - 7. Vector Loads and Stores
      url: "/riscv-v-spec/v1.0//v-spec.html#sec-vector-memory"
    "#sec-vector-permute":
      headers:
      - 16. Vector Permutation Instructions
      url: "/riscv-v-spec/v1.0//v-spec.html#sec-vector-permute"
    "#sec-widening":
      headers:
      - 10. Vector Arithmetic Instruction Formats
      - 10.2. Widening Vector Arithmetic Instructions
      url: "/riscv-v-spec/v1.0//v-spec.html#sec-widening"
  zam:
    '':
      headers: []
      url: "/riscv-user-isa-manual/Priv-v1.12/zam.html"
    "#rvwmo:ax:misaligned":
      headers:
      - 22 "Zam" Standard Extension for Misaligned Atomics, v0.1
      url: "/riscv-user-isa-manual/Priv-v1.12/zam.html#rvwmo:ax:misaligned"
    "#sec:zam":
      headers:
      - 22 "Zam" Standard Extension for Misaligned Atomics, v0.1
      url: "/riscv-user-isa-manual/Priv-v1.12/zam.html#sec:zam"
  zfh:
    '':
      headers: []
      url: "/riscv-user-isa-manual/Priv-v1.12/zfh.html"
    "#half-precision-computational-instructions":
      headers:
      - 15 "Zfh" and "Zfhmin" Standard Extensions for Half-Precision Floating-Point,
        Version 0.1
      - 15.2 Half-Precision Computational Instructions
      url: "/riscv-user-isa-manual/Priv-v1.12/zfh.html#half-precision-computational-instructions"
    "#half-precision-convert-and-move-instructions":
      headers:
      - 15 "Zfh" and "Zfhmin" Standard Extensions for Half-Precision Floating-Point,
        Version 0.1
      - 15.3 Half-Precision Convert and Move Instructions
      url: "/riscv-user-isa-manual/Priv-v1.12/zfh.html#half-precision-convert-and-move-instructions"
    "#half-precision-floating-point-classify-instruction":
      headers:
      - 15 "Zfh" and "Zfhmin" Standard Extensions for Half-Precision Floating-Point,
        Version 0.1
      - 15.5 Half-Precision Floating-Point Classify Instruction
      url: "/riscv-user-isa-manual/Priv-v1.12/zfh.html#half-precision-floating-point-classify-instruction"
    "#half-precision-floating-point-compare-instructions":
      headers:
      - 15 "Zfh" and "Zfhmin" Standard Extensions for Half-Precision Floating-Point,
        Version 0.1
      - 15.4 Half-Precision Floating-Point Compare Instructions
      url: "/riscv-user-isa-manual/Priv-v1.12/zfh.html#half-precision-floating-point-compare-instructions"
    "#half-precision-load-and-store-instructions":
      headers:
      - 15 "Zfh" and "Zfhmin" Standard Extensions for Half-Precision Floating-Point,
        Version 0.1
      - 15.1 Half-Precision Load and Store Instructions
      url: "/riscv-user-isa-manual/Priv-v1.12/zfh.html#half-precision-load-and-store-instructions"
    "#zfh-and-zfhmin-standard-extensions-for-half-precision-floating-point-version-0.1":
      headers:
      - 15 "Zfh" and "Zfhmin" Standard Extensions for Half-Precision Floating-Point,
        Version 0.1
      url: "/riscv-user-isa-manual/Priv-v1.12/zfh.html#zfh-and-zfhmin-standard-extensions-for-half-precision-floating-point-version-0.1"
    "#zfhmin-standard-extension-for-minimal-half-precision-floating-point-support":
      headers:
      - 15 "Zfh" and "Zfhmin" Standard Extensions for Half-Precision Floating-Point,
        Version 0.1
      - 15.6 "Zfhmin" Standard Extension for Minimal Half-Precision Floating-Point
        Support
      url: "/riscv-user-isa-manual/Priv-v1.12/zfh.html#zfhmin-standard-extension-for-minimal-half-precision-floating-point-support"
  zfinx:
    '':
      headers: []
      url: "/riscv-user-isa-manual/Priv-v1.12/zfinx.html"
    "#privileged-architecture-implications":
      headers:
      - '23 "Zfinx", "Zdinx", "Zhinx", "Zhinxmin": Standard Extensions for Floating-Point
        in Integer Registers, Version 1.0.0-rc'
      - 23.6 Privileged Architecture Implications
      url: "/riscv-user-isa-manual/Priv-v1.12/zfinx.html#privileged-architecture-implications"
    "#processing-of-narrower-values":
      headers:
      - '23 "Zfinx", "Zdinx", "Zhinx", "Zhinxmin": Standard Extensions for Floating-Point
        in Integer Registers, Version 1.0.0-rc'
      - 23.1 Processing of Narrower Values
      url: "/riscv-user-isa-manual/Priv-v1.12/zfinx.html#processing-of-narrower-values"
    "#processing-of-wider-values":
      headers:
      - '23 "Zfinx", "Zdinx", "Zhinx", "Zhinxmin": Standard Extensions for Floating-Point
        in Integer Registers, Version 1.0.0-rc'
      - 23.3 Processing of Wider Values
      url: "/riscv-user-isa-manual/Priv-v1.12/zfinx.html#processing-of-wider-values"
    "#sec:zfinx":
      headers:
      - '23 "Zfinx", "Zdinx", "Zhinx", "Zhinxmin": Standard Extensions for Floating-Point
        in Integer Registers, Version 1.0.0-rc'
      url: "/riscv-user-isa-manual/Priv-v1.12/zfinx.html#sec:zfinx"
    "#zdinx":
      headers:
      - '23 "Zfinx", "Zdinx", "Zhinx", "Zhinxmin": Standard Extensions for Floating-Point
        in Integer Registers, Version 1.0.0-rc'
      - 23.2 Zdinx
      url: "/riscv-user-isa-manual/Priv-v1.12/zfinx.html#zdinx"
    "#zhinx":
      headers:
      - '23 "Zfinx", "Zdinx", "Zhinx", "Zhinxmin": Standard Extensions for Floating-Point
        in Integer Registers, Version 1.0.0-rc'
      - 23.4 Zhinx
      url: "/riscv-user-isa-manual/Priv-v1.12/zfinx.html#zhinx"
    "#zhinxmin":
      headers:
      - '23 "Zfinx", "Zdinx", "Zhinx", "Zhinxmin": Standard Extensions for Floating-Point
        in Integer Registers, Version 1.0.0-rc'
      - 23.5 Zhinxmin
      url: "/riscv-user-isa-manual/Priv-v1.12/zfinx.html#zhinxmin"
  zifencei:
    '':
      headers: []
      url: "/riscv-user-isa-manual/Priv-v1.12/zifencei.html"
    "#chap:zifencei":
      headers:
      - 3 "Zifencei" Instruction-Fetch Fence, Version 2.0
      url: "/riscv-user-isa-manual/Priv-v1.12/zifencei.html#chap:zifencei"
  zihintpause:
    '':
      headers: []
      url: "/riscv-user-isa-manual/Priv-v1.12/zihintpause.html"
    "#chap:zihintpause":
      headers:
      - 4 "Zihintpause" Pause Hint, Version 2.0
      url: "/riscv-user-isa-manual/Priv-v1.12/zihintpause.html#chap:zihintpause"
  ztso:
    '':
      headers: []
      url: "/riscv-user-isa-manual/Priv-v1.12/ztso.html"
    "#sec:ztso":
      headers:
      - 24 "Ztso" Standard Extension for Total Store Ordering, v0.1
      url: "/riscv-user-isa-manual/Priv-v1.12/ztso.html#sec:ztso"
isa:
  a:
  - amoadd.d
  - amoadd.w
  - amoand.d
  - amoand.w
  - amomax.d
  - amomax.w
  - amomaxu.d
  - amomaxu.w
  - amomin.d
  - amomin.w
  - amominu.d
  - amominu.w
  - amoor.d
  - amoor.w
  - amoswap.d
  - amoswap.w
  - amoxor.d
  - amoxor.w
  - lr.d
  - lr.w
  - sc.d
  - sc.w
  c:
  - c.add
  - c.addi
  - c.addi16sp
  - c.addi4spn
  - c.addiw
  - c.addw
  - c.and
  - c.andi
  - c.beqz
  - c.bnez
  - c.ebreak
  - c.fld
  - c.fldsp
  - c.flw
  - c.flwsp
  - c.fsd
  - c.fsdsp
  - c.fsw
  - c.fswsp
  - c.j
  - c.jal
  - c.jalr
  - c.jr
  - c.ld
  - c.ldsp
  - c.li
  - c.lui
  - c.lw
  - c.lwsp
  - c.mv
  - c.nop
  - c.or
  - c.sd
  - c.sdsp
  - c.slli
  - c.slli_rv32
  - c.srai
  - c.srai_rv32
  - c.srli
  - c.srli_rv32
  - c.sub
  - c.subw
  - c.sw
  - c.swsp
  - c.xor
  counters:
  - rdcycle
  - rdcycleh
  - rdinstret
  - rdinstreth
  - rdtime
  - rdtimeh
  csr:
  - csrc
  - csrci
  - csrr
  - csrrc
  - csrrci
  - csrrs
  - csrrsi
  - csrrw
  - csrrwi
  - csrs
  - csrsi
  - csrw
  - csrwi
  d:
  - fabs.d
  - fadd.d
  - fclass.d
  - fcvt.d.l
  - fcvt.d.lu
  - fcvt.d.s
  - fcvt.d.w
  - fcvt.d.wu
  - fcvt.l.d
  - fcvt.lu.d
  - fcvt.s.d
  - fcvt.w.d
  - fcvt.wu.d
  - fdiv.d
  - feq.d
  - fld
  - fle.d
  - flt.d
  - fmadd.d
  - fmax.d
  - fmin.d
  - fmsub.d
  - fmul.d
  - fmv.d
  - fmv.d.x
  - fmv.x.d
  - fneg.d
  - fnmadd.d
  - fnmsub.d
  - fsd
  - fsgnj.d
  - fsgnjn.d
  - fsgnjx.d
  - fsqrt.d
  - fsub.d
  f:
  - fabs.s
  - fadd.s
  - fclass.s
  - fcvt.l.s
  - fcvt.lu.s
  - fcvt.s.l
  - fcvt.s.lu
  - fcvt.s.w
  - fcvt.s.wu
  - fcvt.w.s
  - fcvt.wu.s
  - fdiv.s
  - feq.s
  - fle.s
  - flt.s
  - flw
  - fmadd.s
  - fmax.s
  - fmin.s
  - fmsub.s
  - fmul.s
  - fmv.s
  - fmv.w.x
  - fmv.x.s
  - fmv.x.w
  - fneg.s
  - fnmadd.s
  - fnmsub.s
  - frcsr
  - frflags
  - frrm
  - fscsr
  - fsflags
  - fsgnj.s
  - fsgnjn.s
  - fsgnjx.s
  - fsqrt.s
  - fsrm
  - fsub.s
  - fsw
  - neg
  hypervisor:
  - hlv.b
  - hlv.bu
  - hlv.d
  - hlv.h
  - hlv.hu
  - hlv.w
  - hlv.wu
  - hlvx.hu
  - hlvx.wu
  - hsv.b
  - hsv.d
  - hsv.h
  - hsv.w
  m:
  - div
  - divu
  - divuw
  - divw
  - mul
  - mulh
  - mulhsu
  - mulhu
  - mulw
  - rem
  - remu
  - remuw
  - remw
  machine:
  - mret
  - sinval.vma
  - sret
  - wfi
  q:
  - fadd.q
  - fclass.q
  - fcvt.d.q
  - fcvt.l.q
  - fcvt.lu.q
  - fcvt.q.d
  - fcvt.q.l
  - fcvt.q.lu
  - fcvt.q.s
  - fcvt.q.w
  - fcvt.q.wu
  - fcvt.s.q
  - fcvt.w.q
  - fcvt.wu.q
  - fdiv.q
  - feq.q
  - fle.q
  - flq
  - flt.q
  - fmadd.q
  - fmax.q
  - fmin.q
  - fmsub.q
  - fmul.q
  - fnmadd.q
  - fnmsub.q
  - fsgnj.q
  - fsgnjn.q
  - fsgnjx.q
  - fsq
  - fsqrt.q
  - fsub.q
  rv32:
  - add
  - addi
  - and
  - andi
  - auipc
  - beq
  - bge
  - bgeu
  - bgt
  - bgtu
  - ble
  - bleu
  - blt
  - bltu
  - bne
  - ebreak
  - ecall
  - fence
  - j
  - jal
  - jalr
  - lb
  - lbu
  - lh
  - lhu
  - lui
  - lw
  - mv
  - nop
  - not
  - or
  - ori
  - sb
  - sbreak
  - scall
  - seqz
  - sh
  - sll
  - slli
  - slt
  - slti
  - sltiu
  - sltu
  - snez
  - sra
  - srai
  - srl
  - srli
  - sub
  - sw
  - xor
  - xori
  rv64:
  - addiw
  - addw
  - ld
  - lwu
  - sd
  - sext.w
  - slliw
  - sllw
  - sraiw
  - sraw
  - srliw
  - srlw
  - subw
  rvwmo:
  - sfence.vma
  supervisor:
  - hfence.gvma
  - hfence.vvma
  - hinval.gvma
  - hinval.vvma
  - sfence.inval.ir
  - sfence.w.inval
  unassigned:
  - add.uw
  - aes32dsi
  - aes32dsmi
  - aes32esi
  - aes32esmi
  - aes64ds
  - aes64dsm
  - aes64es
  - aes64esm
  - aes64im
  - aes64ks1i
  - aes64ks2
  - andn
  - bclr
  - bclri
  - beqz
  - bext
  - bexti
  - bgez
  - bgtz
  - binv
  - binvi
  - blez
  - bltz
  - bnez
  - brev8
  - bset
  - bseti
  - c.lbu
  - c.lh
  - c.lhu
  - c.mul
  - c.not
  - c.sb
  - c.sext.b
  - c.sext.h
  - c.sh
  - c.zext.b
  - c.zext.h
  - c.zext.w
  - call
  - cbo.clean
  - cbo.flush
  - cbo.inval
  - cbo.zero
  - clmul
  - clmulh
  - clmulr
  - clz
  - clzw
  - cm.jalt
  - cm.mva01s
  - cm.mvsa01
  - cm.pop
  - cm.popret
  - cm.popretz
  - cm.push
  - cpop
  - cpopw
  - ctz
  - ctzw
  - dret
  - fadd.h
  - fdiv.h
  - fence.i
  - fence.tso
  - feq.h
  - fle.h
  - flt.h
  - fmadd.h
  - fmax.h
  - fmin.h
  - fmsub.h
  - fmul.h
  - fmv.s.x
  - fnmadd.h
  - fnmsub.h
  - fsflagsi
  - fsqrt.h
  - fsrmi
  - fsub.h
  - jr
  - la
  - lga
  - li
  - lla
  - max
  - maxu
  - minu
  - negw
  - orc.b
  - orn
  - prefetch.i
  - prefetch.r
  - prefetch.w
  - ret
  - rev8
  - rol
  - rolw
  - ror
  - rori
  - roriw
  - rorw
  - sext.b
  - sext.h
  - sgtz
  - sh1add
  - sh1add.uw
  - sh2add
  - sh2add.uw
  - sh3add
  - sh3add.uw
  - sha256sig0
  - sha256sig1
  - sha256sum0
  - sha256sum1
  - sha512sig0
  - sha512sig0h
  - sha512sig0l
  - sha512sig1
  - sha512sig1h
  - sha512sig1l
  - sha512sum0
  - sha512sum0r
  - sha512sum1
  - sha512sum1r
  - slli.uw
  - slli_rv32
  - sltz
  - sm3p0
  - sm3p1
  - sm4ed
  - sm4ks
  - srai_rv32
  - srli_rv32
  - tail
  - unzip
  - vfredsum.vs
  - vfwredsum.vs
  - vl1r.v
  - vl2r.v
  - vl4r.v
  - vl8r.v
  - vle1.v
  - vmandnot.mm
  - vmornot.mm
  - vpopc.m
  - vse1.v
  - wrs.nto
  - wrs.sto
  - xnor
  - zext.b
  - zext.h
  - zext.w
  - zip
  v:
  - min
  - vaadd.vv
  - vaadd.vx
  - vaaddu.vv
  - vaaddu.vx
  - vadc.vim
  - vadc.vvm
  - vadc.vxm
  - vadd.vi
  - vadd.vv
  - vadd.vx
  - vamoaddei16.v
  - vamoaddei32.v
  - vamoaddei64.v
  - vamoaddei8.v
  - vamoandei16.v
  - vamoandei32.v
  - vamoandei64.v
  - vamoandei8.v
  - vamomaxei16.v
  - vamomaxei32.v
  - vamomaxei64.v
  - vamomaxei8.v
  - vamomaxuei16.v
  - vamomaxuei32.v
  - vamomaxuei64.v
  - vamomaxuei8.v
  - vamominei16.v
  - vamominei32.v
  - vamominei64.v
  - vamominei8.v
  - vamominuei16.v
  - vamominuei32.v
  - vamominuei64.v
  - vamominuei8.v
  - vamoorei16.v
  - vamoorei32.v
  - vamoorei64.v
  - vamoorei8.v
  - vamoswapei16.v
  - vamoswapei32.v
  - vamoswapei64.v
  - vamoswapei8.v
  - vamoxorei16.v
  - vamoxorei32.v
  - vamoxorei64.v
  - vamoxorei8.v
  - vand.vi
  - vand.vv
  - vand.vx
  - vasub.vv
  - vasub.vx
  - vasubu.vv
  - vasubu.vx
  - vcompress.vm
  - vcpop.m
  - vdiv.vv
  - vdiv.vx
  - vdivu.vv
  - vdivu.vx
  - vfadd.vf
  - vfadd.vv
  - vfclass.v
  - vfcvt.f.x.v
  - vfcvt.f.xu.v
  - vfcvt.rtz.x.f.v
  - vfcvt.rtz.xu.f.v
  - vfcvt.x.f.v
  - vfcvt.xu.f.v
  - vfdiv.vf
  - vfdiv.vv
  - vfirst.m
  - vfmacc.vf
  - vfmacc.vv
  - vfmadd.vf
  - vfmadd.vv
  - vfmax.vf
  - vfmax.vv
  - vfmerge.vfm
  - vfmin.vf
  - vfmin.vv
  - vfmsac.vf
  - vfmsac.vv
  - vfmsub.vf
  - vfmsub.vv
  - vfmul.vf
  - vfmul.vv
  - vfmv.f.s
  - vfmv.s.f
  - vfmv.v.f
  - vfncvt.f.f.w
  - vfncvt.f.x.w
  - vfncvt.f.xu.w
  - vfncvt.rod.f.f.w
  - vfncvt.rtz.x.f.w
  - vfncvt.rtz.xu.f.w
  - vfncvt.x.f.w
  - vfncvt.xu.f.w
  - vfnmacc.vf
  - vfnmacc.vv
  - vfnmadd.vf
  - vfnmadd.vv
  - vfnmsac.vf
  - vfnmsac.vv
  - vfnmsub.vf
  - vfnmsub.vv
  - vfrdiv.vf
  - vfrec7.v
  - vfredmax.vs
  - vfredmin.vs
  - vfredosum.vs
  - vfredusum.vs
  - vfrsqrt7.v
  - vfrsub.vf
  - vfsgnj.vf
  - vfsgnj.vv
  - vfsgnjn.vf
  - vfsgnjn.vv
  - vfsgnjx.vf
  - vfsgnjx.vv
  - vfslide1down.vf
  - vfslide1up.vf
  - vfsqrt.v
  - vfsub.vf
  - vfsub.vv
  - vfwadd.vf
  - vfwadd.vv
  - vfwadd.wf
  - vfwadd.wv
  - vfwcvt.f.f.v
  - vfwcvt.f.x.v
  - vfwcvt.f.xu.v
  - vfwcvt.rtz.x.f.v
  - vfwcvt.rtz.xu.f.v
  - vfwcvt.x.f.v
  - vfwcvt.xu.f.v
  - vfwmacc.vf
  - vfwmacc.vv
  - vfwmsac.vf
  - vfwmsac.vv
  - vfwmul.vf
  - vfwmul.vv
  - vfwnmacc.vf
  - vfwnmacc.vv
  - vfwnmsac.vf
  - vfwnmsac.vv
  - vfwredosum.vs
  - vfwredusum.vs
  - vfwsub.vf
  - vfwsub.vv
  - vfwsub.wf
  - vfwsub.wv
  - vid.v
  - viota.m
  - vl1re16.v
  - vl1re32.v
  - vl1re64.v
  - vl1re8.v
  - vl2re16.v
  - vl2re32.v
  - vl2re64.v
  - vl2re8.v
  - vl4re16.v
  - vl4re32.v
  - vl4re64.v
  - vl4re8.v
  - vl8re16.v
  - vl8re32.v
  - vl8re64.v
  - vl8re8.v
  - vle1024.v
  - vle1024ff.v
  - vle128.v
  - vle128ff.v
  - vle16.v
  - vle16ff.v
  - vle256.v
  - vle256ff.v
  - vle32.v
  - vle32ff.v
  - vle512.v
  - vle512ff.v
  - vle64.v
  - vle64ff.v
  - vle8.v
  - vle8ff.v
  - vlm.v
  - vloxei1024.v
  - vloxei128.v
  - vloxei16.v
  - vloxei256.v
  - vloxei32.v
  - vloxei512.v
  - vloxei64.v
  - vloxei8.v
  - vlse1024.v
  - vlse128.v
  - vlse16.v
  - vlse256.v
  - vlse32.v
  - vlse512.v
  - vlse64.v
  - vlse8.v
  - vluxei1024.v
  - vluxei128.v
  - vluxei16.v
  - vluxei256.v
  - vluxei32.v
  - vluxei512.v
  - vluxei64.v
  - vluxei8.v
  - vmacc.vv
  - vmacc.vx
  - vmadc.vi
  - vmadc.vim
  - vmadc.vv
  - vmadc.vvm
  - vmadc.vx
  - vmadc.vxm
  - vmadd.vv
  - vmadd.vx
  - vmand.mm
  - vmandn.mm
  - vmax.vv
  - vmax.vx
  - vmaxu.vv
  - vmaxu.vx
  - vmerge.vim
  - vmerge.vvm
  - vmerge.vxm
  - vmfeq.vf
  - vmfeq.vv
  - vmfge.vf
  - vmfgt.vf
  - vmfle.vf
  - vmfle.vv
  - vmflt.vf
  - vmflt.vv
  - vmfne.vf
  - vmfne.vv
  - vmin.vv
  - vmin.vx
  - vminu.vv
  - vminu.vx
  - vmnand.mm
  - vmnor.mm
  - vmor.mm
  - vmorn.mm
  - vmsbc.vv
  - vmsbc.vvm
  - vmsbc.vx
  - vmsbc.vxm
  - vmsbf.m
  - vmseq.vi
  - vmseq.vv
  - vmseq.vx
  - vmsgt.vi
  - vmsgt.vx
  - vmsgtu.vi
  - vmsgtu.vx
  - vmsif.m
  - vmsle.vi
  - vmsle.vv
  - vmsle.vx
  - vmsleu.vi
  - vmsleu.vv
  - vmsleu.vx
  - vmslt.vv
  - vmslt.vx
  - vmsltu.vv
  - vmsltu.vx
  - vmsne.vi
  - vmsne.vv
  - vmsne.vx
  - vmsof.m
  - vmul.vv
  - vmul.vx
  - vmulh.vv
  - vmulh.vx
  - vmulhsu.vv
  - vmulhsu.vx
  - vmulhu.vv
  - vmulhu.vx
  - vmv.s.x
  - vmv.v.i
  - vmv.v.v
  - vmv.v.x
  - vmv.x.s
  - vmv1r.v
  - vmv2r.v
  - vmv4r.v
  - vmv8r.v
  - vmxnor.mm
  - vmxor.mm
  - vnclip.wi
  - vnclip.wv
  - vnclip.wx
  - vnclipu.wi
  - vnclipu.wv
  - vnclipu.wx
  - vnmsac.vv
  - vnmsac.vx
  - vnmsub.vv
  - vnmsub.vx
  - vnsra.wi
  - vnsra.wv
  - vnsra.wx
  - vnsrl.wi
  - vnsrl.wv
  - vnsrl.wx
  - vor.vi
  - vor.vv
  - vor.vx
  - vredand.vs
  - vredmax.vs
  - vredmaxu.vs
  - vredmin.vs
  - vredminu.vs
  - vredor.vs
  - vredsum.vs
  - vredxor.vs
  - vrem.vv
  - vrem.vx
  - vremu.vv
  - vremu.vx
  - vrgather.vi
  - vrgather.vv
  - vrgather.vx
  - vrgatherei16.vv
  - vrsub.vi
  - vrsub.vx
  - vs1r.v
  - vs2r.v
  - vs4r.v
  - vs8r.v
  - vsadd.vi
  - vsadd.vv
  - vsadd.vx
  - vsaddu.vi
  - vsaddu.vv
  - vsaddu.vx
  - vsbc.vvm
  - vsbc.vxm
  - vse1024.v
  - vse128.v
  - vse16.v
  - vse256.v
  - vse32.v
  - vse512.v
  - vse64.v
  - vse8.v
  - vsetivli
  - vsetvl
  - vsetvli
  - vsext.vf2
  - vsext.vf4
  - vsext.vf8
  - vslide1down.vx
  - vslide1up.vx
  - vslidedown.vi
  - vslidedown.vx
  - vslideup.vi
  - vslideup.vx
  - vsll.vi
  - vsll.vv
  - vsll.vx
  - vsm.v
  - vsmul.vv
  - vsmul.vx
  - vsoxei1024.v
  - vsoxei128.v
  - vsoxei16.v
  - vsoxei256.v
  - vsoxei32.v
  - vsoxei512.v
  - vsoxei64.v
  - vsoxei8.v
  - vsra.vi
  - vsra.vv
  - vsra.vx
  - vsrl.vi
  - vsrl.vv
  - vsrl.vx
  - vsse1024.v
  - vsse128.v
  - vsse16.v
  - vsse256.v
  - vsse32.v
  - vsse512.v
  - vsse64.v
  - vsse8.v
  - vssra.vi
  - vssra.vv
  - vssra.vx
  - vssrl.vi
  - vssrl.vv
  - vssrl.vx
  - vssub.vv
  - vssub.vx
  - vssubu.vv
  - vssubu.vx
  - vsub.vv
  - vsub.vx
  - vsuxei1024.v
  - vsuxei128.v
  - vsuxei16.v
  - vsuxei256.v
  - vsuxei32.v
  - vsuxei512.v
  - vsuxei64.v
  - vsuxei8.v
  - vwadd.vv
  - vwadd.vx
  - vwadd.wv
  - vwadd.wx
  - vwaddu.vv
  - vwaddu.vx
  - vwaddu.wv
  - vwaddu.wx
  - vwmacc.vv
  - vwmacc.vx
  - vwmaccsu.vv
  - vwmaccsu.vx
  - vwmaccu.vv
  - vwmaccu.vx
  - vwmaccus.vx
  - vwmul.vv
  - vwmul.vx
  - vwmulsu.vv
  - vwmulsu.vx
  - vwmulu.vv
  - vwmulu.vx
  - vwredsum.vs
  - vwredsumu.vs
  - vwsub.vv
  - vwsub.vx
  - vwsub.wv
  - vwsub.wx
  - vwsubu.vv
  - vwsubu.vx
  - vwsubu.wv
  - vwsubu.wx
  - vxor.vi
  - vxor.vv
  - vxor.vx
  - vzext.vf2
  - vzext.vf4
  - vzext.vf8
  zfh:
  - fclass.h
  - fcvt.d.h
  - fcvt.h.d
  - fcvt.h.l
  - fcvt.h.lu
  - fcvt.h.q
  - fcvt.h.s
  - fcvt.h.w
  - fcvt.h.wu
  - fcvt.l.h
  - fcvt.lu.h
  - fcvt.q.h
  - fcvt.s.h
  - fcvt.w.h
  - fcvt.wu.h
  - flh
  - fmv.h.x
  - fmv.x.h
  - fsgnj.h
  - fsgnjn.h
  - fsgnjx.h
  - fsh
  zihintpause:
  - pause
opcode_args_to_asm_args:
- *4
- *2
- *41
- *26
- *3
- *1
- *24
- *21
- *42
- *25
- *22
- *23
- *20
- - rd=2
- - "!rs2"
- - "!rs1"
  - "!rs2=c.jalr"
- *43
- *44
- *33
- *35
- *34
- *37
- *29
- *36
- *28
- *32
- *30
- *45
- - vs2
  - vs1
  - rd
- *31
- *10
- *15
- *46
- *47
- *48
- *49
- *50
- *8
- *51
- *9
- *52
- *53
- *12
- *5
- *54
- *55
- *56
- *19
- *57
- *58
- *59
- *60
- *7
- *6
- *61
- *62
- *63
- *64
- *16
- *65
- *11
- *17
- *27
- *14
- *66
- *67
- *68
- *69
- *13
- *70
- *71
- *18
opcode_args_to_opcodes:
  rd_p:
  - c.lbu
  - c.lhu
  - c.lh
  - c.addi4spn
  - c.lw
  - c.fld
  - c.flw
  - c.ld
  rs1_p:
  - c.lbu
  - c.lhu
  - c.lh
  - c.sb
  - c.sh
  - c.lw
  - c.sw
  - c.beqz
  - c.bnez
  - c.fld
  - c.fsd
  - c.flw
  - c.fsw
  - c.ld
  - c.sd
  c_uimm2:
  - c.lbu
  - c.sb
  c_uimm1:
  - c.lhu
  - c.lh
  - c.sh
  rs2_p:
  - c.sb
  - c.sh
  - c.mul
  - c.sw
  - c.sub
  - c.xor
  - c.or
  - c.and
  - c.fsd
  - c.fsw
  - c.sd
  - c.subw
  - c.addw
  rd_rs1_p:
  - c.zext.b
  - c.sext.b
  - c.zext.h
  - c.sext.h
  - c.not
  - c.mul
  - c.andi
  - c.sub
  - c.xor
  - c.or
  - c.and
  - c.srli
  - c.srai
  - c.srli_rv32
  - c.srai_rv32
  - c.srli
  - c.srai
  - c.subw
  - c.addw
  - c.zext.w
  rd:
  - fcvt.q.h
  - fcvt.h.q
  - bclr
  - bext
  - binv
  - bset
  - brev8
  - mul
  - mulh
  - mulhsu
  - mulhu
  - div
  - divu
  - rem
  - remu
  - vsetivli
  - vsetvli
  - vsetvl
  - vfmv.f.s
  - vmv.x.s
  - vcpop.m
  - vfirst.m
  - c.li
  - c.mv
  - fcvt.d.h
  - fcvt.h.d
  - flq
  - fmadd.q
  - fmsub.q
  - fnmsub.q
  - fnmadd.q
  - fadd.q
  - fsub.q
  - fmul.q
  - fdiv.q
  - fsqrt.q
  - fsgnj.q
  - fsgnjn.q
  - fsgnjx.q
  - fmin.q
  - fmax.q
  - fcvt.s.q
  - fcvt.q.s
  - fcvt.d.q
  - fcvt.q.d
  - feq.q
  - flt.q
  - fle.q
  - fclass.q
  - fcvt.w.q
  - fcvt.wu.q
  - fcvt.q.w
  - fcvt.q.wu
  - fence.i
  - clmul
  - clmulr
  - clmulh
  - csrrw
  - csrrs
  - csrrc
  - csrrwi
  - csrrsi
  - csrrci
  - frflags
  - fsflags
  - fsflagsi
  - frrm
  - fsrm
  - fsrmi
  - fscsr
  - frcsr
  - rdcycle
  - rdtime
  - rdinstret
  - rdcycleh
  - rdtimeh
  - rdinstreth
  - sm3p0
  - sm3p1
  - c.fldsp
  - andn
  - orn
  - xnor
  - clz
  - ctz
  - cpop
  - max
  - maxu
  - min
  - minu
  - sext.b
  - sext.h
  - rol
  - ror
  - orc.b
  - brev8
  - flh
  - fmadd.h
  - fmsub.h
  - fnmsub.h
  - fnmadd.h
  - fadd.h
  - fsub.h
  - fmul.h
  - fdiv.h
  - fsqrt.h
  - fsgnj.h
  - fsgnjn.h
  - fsgnjx.h
  - fmin.h
  - fmax.h
  - fcvt.s.h
  - fcvt.h.s
  - feq.h
  - flt.h
  - fle.h
  - fclass.h
  - fcvt.w.h
  - fcvt.wu.h
  - fmv.x.h
  - fcvt.h.w
  - fcvt.h.wu
  - fmv.h.x
  - sm4ed
  - sm4ks
  - brev8
  - vpopc.m
  - sh1add
  - sh2add
  - sh3add
  - brev8
  - flw
  - fmadd.s
  - fmsub.s
  - fnmsub.s
  - fnmadd.s
  - fadd.s
  - fsub.s
  - fmul.s
  - fdiv.s
  - fsqrt.s
  - fsgnj.s
  - fsgnjn.s
  - fsgnjx.s
  - fmin.s
  - fmax.s
  - fcvt.w.s
  - fcvt.wu.s
  - fmv.x.w
  - feq.s
  - flt.s
  - fle.s
  - fclass.s
  - fcvt.s.w
  - fcvt.s.wu
  - fmv.w.x
  - fmv.x.s
  - fmv.s.x
  - hlv.b
  - hlv.bu
  - hlv.h
  - hlv.hu
  - hlvx.hu
  - hlv.w
  - hlvx.wu
  - lr.w
  - sc.w
  - amoswap.w
  - amoadd.w
  - amoxor.w
  - amoand.w
  - amoor.w
  - amomin.w
  - amomax.w
  - amominu.w
  - amomaxu.w
  - lui
  - auipc
  - jal
  - jalr
  - lb
  - lh
  - lw
  - lbu
  - lhu
  - addi
  - slti
  - sltiu
  - xori
  - ori
  - andi
  - add
  - sub
  - sll
  - slt
  - sltu
  - xor
  - srl
  - sra
  - or
  - and
  - fence
  - fence.tso
  - sha256sum0
  - sha256sum1
  - sha256sig0
  - sha256sig1
  - fld
  - fmadd.d
  - fmsub.d
  - fnmsub.d
  - fnmadd.d
  - fadd.d
  - fsub.d
  - fmul.d
  - fdiv.d
  - fsqrt.d
  - fsgnj.d
  - fsgnjn.d
  - fsgnjx.d
  - fmin.d
  - fmax.d
  - fcvt.s.d
  - fcvt.d.s
  - feq.d
  - flt.d
  - fle.d
  - fclass.d
  - fcvt.w.d
  - fcvt.wu.d
  - fcvt.d.w
  - fcvt.d.wu
  - sha512sum0r
  - sha512sum1r
  - sha512sig0l
  - sha512sig0h
  - sha512sig1l
  - sha512sig1h
  - slli
  - srli
  - srai
  - slli_rv32
  - srli_rv32
  - srai_rv32
  - zext.h
  - rev8
  - rori
  - aes32dsmi
  - aes32dsi
  - bclri
  - bexti
  - binvi
  - bseti
  - zip
  - unzip
  - rori
  - rev8
  - zip
  - unzip
  - rori
  - rev8
  - zip
  - unzip
  - rori
  - rev8
  - aes32esmi
  - aes32esi
  - zip
  - unzip
  - rori
  - rev8
  - c.flwsp
  - rev8
  - aes64dsm
  - aes64ds
  - aes64ks1i
  - aes64im
  - aes64ks2
  - sha512sum0
  - sha512sum1
  - sha512sig0
  - sha512sig1
  - fcvt.l.h
  - fcvt.lu.h
  - fcvt.h.l
  - fcvt.h.lu
  - hlv.wu
  - hlv.d
  - rev8
  - lwu
  - ld
  - slli
  - srli
  - srai
  - addiw
  - slliw
  - srliw
  - sraiw
  - addw
  - subw
  - sllw
  - srlw
  - sraw
  - lr.d
  - sc.d
  - amoswap.d
  - amoadd.d
  - amoxor.d
  - amoand.d
  - amoor.d
  - amomin.d
  - amomax.d
  - amominu.d
  - amomaxu.d
  - clzw
  - ctzw
  - cpopw
  - rolw
  - rorw
  - roriw
  - rori
  - zext.h
  - rev8
  - mulw
  - divw
  - divuw
  - remw
  - remuw
  - fcvt.l.q
  - fcvt.lu.q
  - fcvt.q.l
  - fcvt.q.lu
  - fcvt.l.d
  - fcvt.lu.d
  - fmv.x.d
  - fcvt.d.l
  - fcvt.d.lu
  - fmv.d.x
  - bclri
  - bexti
  - binvi
  - bseti
  - fcvt.l.s
  - fcvt.lu.s
  - fcvt.s.l
  - fcvt.s.lu
  - aes64esm
  - aes64es
  - rev8
  - add.uw
  - sh1add.uw
  - sh2add.uw
  - sh3add.uw
  - slli.uw
  - rev8
  rs1:
  - fcvt.q.h
  - fcvt.h.q
  - bclr
  - bext
  - binv
  - bset
  - brev8
  - mul
  - mulh
  - mulhsu
  - mulhu
  - div
  - divu
  - rem
  - remu
  - vsetvli
  - vsetvl
  - vlm.v
  - vsm.v
  - vle8.v
  - vle16.v
  - vle32.v
  - vle64.v
  - vle128.v
  - vle256.v
  - vle512.v
  - vle1024.v
  - vse8.v
  - vse16.v
  - vse32.v
  - vse64.v
  - vse128.v
  - vse256.v
  - vse512.v
  - vse1024.v
  - vluxei8.v
  - vluxei16.v
  - vluxei32.v
  - vluxei64.v
  - vluxei128.v
  - vluxei256.v
  - vluxei512.v
  - vluxei1024.v
  - vsuxei8.v
  - vsuxei16.v
  - vsuxei32.v
  - vsuxei64.v
  - vsuxei128.v
  - vsuxei256.v
  - vsuxei512.v
  - vsuxei1024.v
  - vlse8.v
  - vlse16.v
  - vlse32.v
  - vlse64.v
  - vlse128.v
  - vlse256.v
  - vlse512.v
  - vlse1024.v
  - vsse8.v
  - vsse16.v
  - vsse32.v
  - vsse64.v
  - vsse128.v
  - vsse256.v
  - vsse512.v
  - vsse1024.v
  - vloxei8.v
  - vloxei16.v
  - vloxei32.v
  - vloxei64.v
  - vloxei128.v
  - vloxei256.v
  - vloxei512.v
  - vloxei1024.v
  - vsoxei8.v
  - vsoxei16.v
  - vsoxei32.v
  - vsoxei64.v
  - vsoxei128.v
  - vsoxei256.v
  - vsoxei512.v
  - vsoxei1024.v
  - vle8ff.v
  - vle16ff.v
  - vle32ff.v
  - vle64ff.v
  - vle128ff.v
  - vle256ff.v
  - vle512ff.v
  - vle1024ff.v
  - vl1re8.v
  - vl1re16.v
  - vl1re32.v
  - vl1re64.v
  - vl2re8.v
  - vl2re16.v
  - vl2re32.v
  - vl2re64.v
  - vl4re8.v
  - vl4re16.v
  - vl4re32.v
  - vl4re64.v
  - vl8re8.v
  - vl8re16.v
  - vl8re32.v
  - vl8re64.v
  - vs1r.v
  - vs2r.v
  - vs4r.v
  - vs8r.v
  - vfadd.vf
  - vfsub.vf
  - vfmin.vf
  - vfmax.vf
  - vfsgnj.vf
  - vfsgnjn.vf
  - vfsgnjx.vf
  - vfslide1up.vf
  - vfslide1down.vf
  - vfmv.s.f
  - vfmerge.vfm
  - vfmv.v.f
  - vmfeq.vf
  - vmfle.vf
  - vmflt.vf
  - vmfne.vf
  - vmfgt.vf
  - vmfge.vf
  - vfdiv.vf
  - vfrdiv.vf
  - vfmul.vf
  - vfrsub.vf
  - vfmadd.vf
  - vfnmadd.vf
  - vfmsub.vf
  - vfnmsub.vf
  - vfmacc.vf
  - vfnmacc.vf
  - vfmsac.vf
  - vfnmsac.vf
  - vfwadd.vf
  - vfwsub.vf
  - vfwadd.wf
  - vfwsub.wf
  - vfwmul.vf
  - vfwmacc.vf
  - vfwnmacc.vf
  - vfwmsac.vf
  - vfwnmsac.vf
  - vadd.vx
  - vsub.vx
  - vrsub.vx
  - vminu.vx
  - vmin.vx
  - vmaxu.vx
  - vmax.vx
  - vand.vx
  - vor.vx
  - vxor.vx
  - vrgather.vx
  - vslideup.vx
  - vslidedown.vx
  - vadc.vxm
  - vmadc.vxm
  - vmadc.vx
  - vsbc.vxm
  - vmsbc.vxm
  - vmsbc.vx
  - vmerge.vxm
  - vmv.v.x
  - vmseq.vx
  - vmsne.vx
  - vmsltu.vx
  - vmslt.vx
  - vmsleu.vx
  - vmsle.vx
  - vmsgtu.vx
  - vmsgt.vx
  - vsaddu.vx
  - vsadd.vx
  - vssubu.vx
  - vssub.vx
  - vsll.vx
  - vsmul.vx
  - vsrl.vx
  - vsra.vx
  - vssrl.vx
  - vssra.vx
  - vnsrl.wx
  - vnsra.wx
  - vnclipu.wx
  - vnclip.wx
  - vaaddu.vx
  - vaadd.vx
  - vasubu.vx
  - vasub.vx
  - vmv.s.x
  - vslide1up.vx
  - vslide1down.vx
  - vdivu.vx
  - vdiv.vx
  - vremu.vx
  - vrem.vx
  - vmulhu.vx
  - vmul.vx
  - vmulhsu.vx
  - vmulh.vx
  - vmadd.vx
  - vnmsub.vx
  - vmacc.vx
  - vnmsac.vx
  - vwaddu.vx
  - vwadd.vx
  - vwsubu.vx
  - vwsub.vx
  - vwaddu.wx
  - vwadd.wx
  - vwsubu.wx
  - vwsub.wx
  - vwmulu.vx
  - vwmulsu.vx
  - vwmul.vx
  - vwmaccu.vx
  - vwmacc.vx
  - vwmaccus.vx
  - vwmaccsu.vx
  - vamoswapei8.v
  - vamoaddei8.v
  - vamoxorei8.v
  - vamoandei8.v
  - vamoorei8.v
  - vamominei8.v
  - vamomaxei8.v
  - vamominuei8.v
  - vamomaxuei8.v
  - vamoswapei16.v
  - vamoaddei16.v
  - vamoxorei16.v
  - vamoandei16.v
  - vamoorei16.v
  - vamominei16.v
  - vamomaxei16.v
  - vamominuei16.v
  - vamomaxuei16.v
  - vamoswapei32.v
  - vamoaddei32.v
  - vamoxorei32.v
  - vamoandei32.v
  - vamoorei32.v
  - vamominei32.v
  - vamomaxei32.v
  - vamominuei32.v
  - vamomaxuei32.v
  - vamoswapei64.v
  - vamoaddei64.v
  - vamoxorei64.v
  - vamoandei64.v
  - vamoorei64.v
  - vamominei64.v
  - vamomaxei64.v
  - vamominuei64.v
  - vamomaxuei64.v
  - fcvt.d.h
  - fcvt.h.d
  - flq
  - fsq
  - fmadd.q
  - fmsub.q
  - fnmsub.q
  - fnmadd.q
  - fadd.q
  - fsub.q
  - fmul.q
  - fdiv.q
  - fsqrt.q
  - fsgnj.q
  - fsgnjn.q
  - fsgnjx.q
  - fmin.q
  - fmax.q
  - fcvt.s.q
  - fcvt.q.s
  - fcvt.d.q
  - fcvt.q.d
  - feq.q
  - flt.q
  - fle.q
  - fclass.q
  - fcvt.w.q
  - fcvt.wu.q
  - fcvt.q.w
  - fcvt.q.wu
  - fence.i
  - clmul
  - clmulr
  - clmulh
  - sfence.vma
  - csrrw
  - csrrs
  - csrrc
  - fsflags
  - fsrm
  - fscsr
  - sm3p0
  - sm3p1
  - cbo.clean
  - cbo.flush
  - cbo.inval
  - cbo.zero
  - prefetch.i
  - prefetch.r
  - prefetch.w
  - andn
  - orn
  - xnor
  - clz
  - ctz
  - cpop
  - max
  - maxu
  - min
  - minu
  - sext.b
  - sext.h
  - rol
  - ror
  - orc.b
  - brev8
  - flh
  - fsh
  - fmadd.h
  - fmsub.h
  - fnmsub.h
  - fnmadd.h
  - fadd.h
  - fsub.h
  - fmul.h
  - fdiv.h
  - fsqrt.h
  - fsgnj.h
  - fsgnjn.h
  - fsgnjx.h
  - fmin.h
  - fmax.h
  - fcvt.s.h
  - fcvt.h.s
  - feq.h
  - flt.h
  - fle.h
  - fclass.h
  - fcvt.w.h
  - fcvt.wu.h
  - fmv.x.h
  - fcvt.h.w
  - fcvt.h.wu
  - fmv.h.x
  - sm4ed
  - sm4ks
  - brev8
  - vl1r.v
  - vl2r.v
  - vl4r.v
  - vl8r.v
  - vle1.v
  - vse1.v
  - sh1add
  - sh2add
  - sh3add
  - brev8
  - flw
  - fsw
  - fmadd.s
  - fmsub.s
  - fnmsub.s
  - fnmadd.s
  - fadd.s
  - fsub.s
  - fmul.s
  - fdiv.s
  - fsqrt.s
  - fsgnj.s
  - fsgnjn.s
  - fsgnjx.s
  - fmin.s
  - fmax.s
  - fcvt.w.s
  - fcvt.wu.s
  - fmv.x.w
  - feq.s
  - flt.s
  - fle.s
  - fclass.s
  - fcvt.s.w
  - fcvt.s.wu
  - fmv.w.x
  - fmv.x.s
  - fmv.s.x
  - hfence.vvma
  - hfence.gvma
  - hlv.b
  - hlv.bu
  - hlv.h
  - hlv.hu
  - hlvx.hu
  - hlv.w
  - hlvx.wu
  - hsv.b
  - hsv.h
  - hsv.w
  - sinval.vma
  - hinval.vvma
  - hinval.gvma
  - lr.w
  - sc.w
  - amoswap.w
  - amoadd.w
  - amoxor.w
  - amoand.w
  - amoor.w
  - amomin.w
  - amomax.w
  - amominu.w
  - amomaxu.w
  - jalr
  - beq
  - bne
  - blt
  - bge
  - bltu
  - bgeu
  - lb
  - lh
  - lw
  - lbu
  - lhu
  - sb
  - sh
  - sw
  - addi
  - slti
  - sltiu
  - xori
  - ori
  - andi
  - add
  - sub
  - sll
  - slt
  - sltu
  - xor
  - srl
  - sra
  - or
  - and
  - fence
  - fence.tso
  - sha256sum0
  - sha256sum1
  - sha256sig0
  - sha256sig1
  - fld
  - fsd
  - fmadd.d
  - fmsub.d
  - fnmsub.d
  - fnmadd.d
  - fadd.d
  - fsub.d
  - fmul.d
  - fdiv.d
  - fsqrt.d
  - fsgnj.d
  - fsgnjn.d
  - fsgnjx.d
  - fmin.d
  - fmax.d
  - fcvt.s.d
  - fcvt.d.s
  - feq.d
  - flt.d
  - fle.d
  - fclass.d
  - fcvt.w.d
  - fcvt.wu.d
  - fcvt.d.w
  - fcvt.d.wu
  - sha512sum0r
  - sha512sum1r
  - sha512sig0l
  - sha512sig0h
  - sha512sig1l
  - sha512sig1h
  - slli
  - srli
  - srai
  - slli_rv32
  - srli_rv32
  - srai_rv32
  - zext.h
  - rev8
  - rori
  - aes32dsmi
  - aes32dsi
  - bclri
  - bexti
  - binvi
  - bseti
  - zip
  - unzip
  - rori
  - rev8
  - zip
  - unzip
  - rori
  - rev8
  - zip
  - unzip
  - rori
  - rev8
  - aes32esmi
  - aes32esi
  - zip
  - unzip
  - rori
  - rev8
  - rev8
  - aes64dsm
  - aes64ds
  - aes64ks1i
  - aes64im
  - aes64ks2
  - sha512sum0
  - sha512sum1
  - sha512sig0
  - sha512sig1
  - fcvt.l.h
  - fcvt.lu.h
  - fcvt.h.l
  - fcvt.h.lu
  - hlv.wu
  - hlv.d
  - hsv.d
  - rev8
  - lwu
  - ld
  - sd
  - slli
  - srli
  - srai
  - addiw
  - slliw
  - srliw
  - sraiw
  - addw
  - subw
  - sllw
  - srlw
  - sraw
  - lr.d
  - sc.d
  - amoswap.d
  - amoadd.d
  - amoxor.d
  - amoand.d
  - amoor.d
  - amomin.d
  - amomax.d
  - amominu.d
  - amomaxu.d
  - clzw
  - ctzw
  - cpopw
  - rolw
  - rorw
  - roriw
  - rori
  - zext.h
  - rev8
  - mulw
  - divw
  - divuw
  - remw
  - remuw
  - fcvt.l.q
  - fcvt.lu.q
  - fcvt.q.l
  - fcvt.q.lu
  - fcvt.l.d
  - fcvt.lu.d
  - fmv.x.d
  - fcvt.d.l
  - fcvt.d.lu
  - fmv.d.x
  - bclri
  - bexti
  - binvi
  - bseti
  - fcvt.l.s
  - fcvt.lu.s
  - fcvt.s.l
  - fcvt.s.lu
  - aes64esm
  - aes64es
  - rev8
  - add.uw
  - sh1add.uw
  - sh2add.uw
  - sh3add.uw
  - slli.uw
  - rev8
  rs2:
  - bclr
  - bext
  - binv
  - bset
  - mul
  - mulh
  - mulhsu
  - mulhu
  - div
  - divu
  - rem
  - remu
  - vsetvl
  - vlse8.v
  - vlse16.v
  - vlse32.v
  - vlse64.v
  - vlse128.v
  - vlse256.v
  - vlse512.v
  - vlse1024.v
  - vsse8.v
  - vsse16.v
  - vsse32.v
  - vsse64.v
  - vsse128.v
  - vsse256.v
  - vsse512.v
  - vsse1024.v
  - fsq
  - fmadd.q
  - fmsub.q
  - fnmsub.q
  - fnmadd.q
  - fadd.q
  - fsub.q
  - fmul.q
  - fdiv.q
  - fsgnj.q
  - fsgnjn.q
  - fsgnjx.q
  - fmin.q
  - fmax.q
  - feq.q
  - flt.q
  - fle.q
  - clmul
  - clmulr
  - clmulh
  - sfence.vma
  - andn
  - orn
  - xnor
  - max
  - maxu
  - min
  - minu
  - rol
  - ror
  - fsh
  - fmadd.h
  - fmsub.h
  - fnmsub.h
  - fnmadd.h
  - fadd.h
  - fsub.h
  - fmul.h
  - fdiv.h
  - fsgnj.h
  - fsgnjn.h
  - fsgnjx.h
  - fmin.h
  - fmax.h
  - feq.h
  - flt.h
  - fle.h
  - sm4ed
  - sm4ks
  - sh1add
  - sh2add
  - sh3add
  - fsw
  - fmadd.s
  - fmsub.s
  - fnmsub.s
  - fnmadd.s
  - fadd.s
  - fsub.s
  - fmul.s
  - fdiv.s
  - fsgnj.s
  - fsgnjn.s
  - fsgnjx.s
  - fmin.s
  - fmax.s
  - feq.s
  - flt.s
  - fle.s
  - hfence.vvma
  - hfence.gvma
  - hsv.b
  - hsv.h
  - hsv.w
  - sinval.vma
  - hinval.vvma
  - hinval.gvma
  - sc.w
  - amoswap.w
  - amoadd.w
  - amoxor.w
  - amoand.w
  - amoor.w
  - amomin.w
  - amomax.w
  - amominu.w
  - amomaxu.w
  - beq
  - bne
  - blt
  - bge
  - bltu
  - bgeu
  - sb
  - sh
  - sw
  - add
  - sub
  - sll
  - slt
  - sltu
  - xor
  - srl
  - sra
  - or
  - and
  - fsd
  - fmadd.d
  - fmsub.d
  - fnmsub.d
  - fnmadd.d
  - fadd.d
  - fsub.d
  - fmul.d
  - fdiv.d
  - fsgnj.d
  - fsgnjn.d
  - fsgnjx.d
  - fmin.d
  - fmax.d
  - feq.d
  - flt.d
  - fle.d
  - sha512sum0r
  - sha512sum1r
  - sha512sig0l
  - sha512sig0h
  - sha512sig1l
  - sha512sig1h
  - aes32dsmi
  - aes32dsi
  - aes32esmi
  - aes32esi
  - aes64dsm
  - aes64ds
  - aes64ks2
  - hsv.d
  - sd
  - addw
  - subw
  - sllw
  - srlw
  - sraw
  - sc.d
  - amoswap.d
  - amoadd.d
  - amoxor.d
  - amoand.d
  - amoor.d
  - amomin.d
  - amomax.d
  - amominu.d
  - amomaxu.d
  - rolw
  - rorw
  - mulw
  - divw
  - divuw
  - remw
  - remuw
  - aes64esm
  - aes64es
  - add.uw
  - sh1add.uw
  - sh2add.uw
  - sh3add.uw
  zimm10:
  - vsetivli
  zimm:
  - vsetivli
  - csrrwi
  - csrrsi
  - csrrci
  - fsflagsi
  - fsrmi
  zimm11:
  - vsetvli
  vd:
  - vlm.v
  - vle8.v
  - vle16.v
  - vle32.v
  - vle64.v
  - vle128.v
  - vle256.v
  - vle512.v
  - vle1024.v
  - vluxei8.v
  - vluxei16.v
  - vluxei32.v
  - vluxei64.v
  - vluxei128.v
  - vluxei256.v
  - vluxei512.v
  - vluxei1024.v
  - vlse8.v
  - vlse16.v
  - vlse32.v
  - vlse64.v
  - vlse128.v
  - vlse256.v
  - vlse512.v
  - vlse1024.v
  - vloxei8.v
  - vloxei16.v
  - vloxei32.v
  - vloxei64.v
  - vloxei128.v
  - vloxei256.v
  - vloxei512.v
  - vloxei1024.v
  - vle8ff.v
  - vle16ff.v
  - vle32ff.v
  - vle64ff.v
  - vle128ff.v
  - vle256ff.v
  - vle512ff.v
  - vle1024ff.v
  - vl1re8.v
  - vl1re16.v
  - vl1re32.v
  - vl1re64.v
  - vl2re8.v
  - vl2re16.v
  - vl2re32.v
  - vl2re64.v
  - vl4re8.v
  - vl4re16.v
  - vl4re32.v
  - vl4re64.v
  - vl8re8.v
  - vl8re16.v
  - vl8re32.v
  - vl8re64.v
  - vfadd.vf
  - vfsub.vf
  - vfmin.vf
  - vfmax.vf
  - vfsgnj.vf
  - vfsgnjn.vf
  - vfsgnjx.vf
  - vfslide1up.vf
  - vfslide1down.vf
  - vfmv.s.f
  - vfmerge.vfm
  - vfmv.v.f
  - vmfeq.vf
  - vmfle.vf
  - vmflt.vf
  - vmfne.vf
  - vmfgt.vf
  - vmfge.vf
  - vfdiv.vf
  - vfrdiv.vf
  - vfmul.vf
  - vfrsub.vf
  - vfmadd.vf
  - vfnmadd.vf
  - vfmsub.vf
  - vfnmsub.vf
  - vfmacc.vf
  - vfnmacc.vf
  - vfmsac.vf
  - vfnmsac.vf
  - vfwadd.vf
  - vfwsub.vf
  - vfwadd.wf
  - vfwsub.wf
  - vfwmul.vf
  - vfwmacc.vf
  - vfwnmacc.vf
  - vfwmsac.vf
  - vfwnmsac.vf
  - vfadd.vv
  - vfredusum.vs
  - vfsub.vv
  - vfredosum.vs
  - vfmin.vv
  - vfredmin.vs
  - vfmax.vv
  - vfredmax.vs
  - vfsgnj.vv
  - vfsgnjn.vv
  - vfsgnjx.vv
  - vmfeq.vv
  - vmfle.vv
  - vmflt.vv
  - vmfne.vv
  - vfdiv.vv
  - vfmul.vv
  - vfmadd.vv
  - vfnmadd.vv
  - vfmsub.vv
  - vfnmsub.vv
  - vfmacc.vv
  - vfnmacc.vv
  - vfmsac.vv
  - vfnmsac.vv
  - vfcvt.xu.f.v
  - vfcvt.x.f.v
  - vfcvt.f.xu.v
  - vfcvt.f.x.v
  - vfcvt.rtz.xu.f.v
  - vfcvt.rtz.x.f.v
  - vfwcvt.xu.f.v
  - vfwcvt.x.f.v
  - vfwcvt.f.xu.v
  - vfwcvt.f.x.v
  - vfwcvt.f.f.v
  - vfwcvt.rtz.xu.f.v
  - vfwcvt.rtz.x.f.v
  - vfncvt.xu.f.w
  - vfncvt.x.f.w
  - vfncvt.f.xu.w
  - vfncvt.f.x.w
  - vfncvt.f.f.w
  - vfncvt.rod.f.f.w
  - vfncvt.rtz.xu.f.w
  - vfncvt.rtz.x.f.w
  - vfsqrt.v
  - vfrsqrt7.v
  - vfrec7.v
  - vfclass.v
  - vfwadd.vv
  - vfwredusum.vs
  - vfwsub.vv
  - vfwredosum.vs
  - vfwadd.wv
  - vfwsub.wv
  - vfwmul.vv
  - vfwmacc.vv
  - vfwnmacc.vv
  - vfwmsac.vv
  - vfwnmsac.vv
  - vadd.vx
  - vsub.vx
  - vrsub.vx
  - vminu.vx
  - vmin.vx
  - vmaxu.vx
  - vmax.vx
  - vand.vx
  - vor.vx
  - vxor.vx
  - vrgather.vx
  - vslideup.vx
  - vslidedown.vx
  - vadc.vxm
  - vmadc.vxm
  - vmadc.vx
  - vsbc.vxm
  - vmsbc.vxm
  - vmsbc.vx
  - vmerge.vxm
  - vmv.v.x
  - vmseq.vx
  - vmsne.vx
  - vmsltu.vx
  - vmslt.vx
  - vmsleu.vx
  - vmsle.vx
  - vmsgtu.vx
  - vmsgt.vx
  - vsaddu.vx
  - vsadd.vx
  - vssubu.vx
  - vssub.vx
  - vsll.vx
  - vsmul.vx
  - vsrl.vx
  - vsra.vx
  - vssrl.vx
  - vssra.vx
  - vnsrl.wx
  - vnsra.wx
  - vnclipu.wx
  - vnclip.wx
  - vadd.vv
  - vsub.vv
  - vminu.vv
  - vmin.vv
  - vmaxu.vv
  - vmax.vv
  - vand.vv
  - vor.vv
  - vxor.vv
  - vrgather.vv
  - vrgatherei16.vv
  - vadc.vvm
  - vmadc.vvm
  - vmadc.vv
  - vsbc.vvm
  - vmsbc.vvm
  - vmsbc.vv
  - vmerge.vvm
  - vmv.v.v
  - vmseq.vv
  - vmsne.vv
  - vmsltu.vv
  - vmslt.vv
  - vmsleu.vv
  - vmsle.vv
  - vsaddu.vv
  - vsadd.vv
  - vssubu.vv
  - vssub.vv
  - vsll.vv
  - vsmul.vv
  - vsrl.vv
  - vsra.vv
  - vssrl.vv
  - vssra.vv
  - vnsrl.wv
  - vnsra.wv
  - vnclipu.wv
  - vnclip.wv
  - vwredsumu.vs
  - vwredsum.vs
  - vadd.vi
  - vrsub.vi
  - vand.vi
  - vor.vi
  - vxor.vi
  - vrgather.vi
  - vslideup.vi
  - vslidedown.vi
  - vadc.vim
  - vmadc.vim
  - vmadc.vi
  - vmerge.vim
  - vmv.v.i
  - vmseq.vi
  - vmsne.vi
  - vmsleu.vi
  - vmsle.vi
  - vmsgtu.vi
  - vmsgt.vi
  - vsaddu.vi
  - vsadd.vi
  - vsll.vi
  - vmv1r.v
  - vmv2r.v
  - vmv4r.v
  - vmv8r.v
  - vsrl.vi
  - vsra.vi
  - vssrl.vi
  - vssra.vi
  - vnsrl.wi
  - vnsra.wi
  - vnclipu.wi
  - vnclip.wi
  - vredsum.vs
  - vredand.vs
  - vredor.vs
  - vredxor.vs
  - vredminu.vs
  - vredmin.vs
  - vredmaxu.vs
  - vredmax.vs
  - vaaddu.vv
  - vaadd.vv
  - vasubu.vv
  - vasub.vv
  - vzext.vf8
  - vsext.vf8
  - vzext.vf4
  - vsext.vf4
  - vzext.vf2
  - vsext.vf2
  - vcompress.vm
  - vmandn.mm
  - vmand.mm
  - vmor.mm
  - vmxor.mm
  - vmorn.mm
  - vmnand.mm
  - vmnor.mm
  - vmxnor.mm
  - vmsbf.m
  - vmsof.m
  - vmsif.m
  - viota.m
  - vid.v
  - vdivu.vv
  - vdiv.vv
  - vremu.vv
  - vrem.vv
  - vmulhu.vv
  - vmul.vv
  - vmulhsu.vv
  - vmulh.vv
  - vmadd.vv
  - vnmsub.vv
  - vmacc.vv
  - vnmsac.vv
  - vwaddu.vv
  - vwadd.vv
  - vwsubu.vv
  - vwsub.vv
  - vwaddu.wv
  - vwadd.wv
  - vwsubu.wv
  - vwsub.wv
  - vwmulu.vv
  - vwmulsu.vv
  - vwmul.vv
  - vwmaccu.vv
  - vwmacc.vv
  - vwmaccsu.vv
  - vaaddu.vx
  - vaadd.vx
  - vasubu.vx
  - vasub.vx
  - vmv.s.x
  - vslide1up.vx
  - vslide1down.vx
  - vdivu.vx
  - vdiv.vx
  - vremu.vx
  - vrem.vx
  - vmulhu.vx
  - vmul.vx
  - vmulhsu.vx
  - vmulh.vx
  - vmadd.vx
  - vnmsub.vx
  - vmacc.vx
  - vnmsac.vx
  - vwaddu.vx
  - vwadd.vx
  - vwsubu.vx
  - vwsub.vx
  - vwaddu.wx
  - vwadd.wx
  - vwsubu.wx
  - vwsub.wx
  - vwmulu.vx
  - vwmulsu.vx
  - vwmul.vx
  - vwmaccu.vx
  - vwmacc.vx
  - vwmaccus.vx
  - vwmaccsu.vx
  - vamoswapei8.v
  - vamoaddei8.v
  - vamoxorei8.v
  - vamoandei8.v
  - vamoorei8.v
  - vamominei8.v
  - vamomaxei8.v
  - vamominuei8.v
  - vamomaxuei8.v
  - vamoswapei16.v
  - vamoaddei16.v
  - vamoxorei16.v
  - vamoandei16.v
  - vamoorei16.v
  - vamominei16.v
  - vamomaxei16.v
  - vamominuei16.v
  - vamomaxuei16.v
  - vamoswapei32.v
  - vamoaddei32.v
  - vamoxorei32.v
  - vamoandei32.v
  - vamoorei32.v
  - vamominei32.v
  - vamomaxei32.v
  - vamominuei32.v
  - vamomaxuei32.v
  - vamoswapei64.v
  - vamoaddei64.v
  - vamoxorei64.v
  - vamoandei64.v
  - vamoorei64.v
  - vamominei64.v
  - vamomaxei64.v
  - vamominuei64.v
  - vamomaxuei64.v
  - vl1r.v
  - vl2r.v
  - vl4r.v
  - vl8r.v
  - vle1.v
  - vfredsum.vs
  - vfwredsum.vs
  - vmornot.mm
  - vmandnot.mm
  vs3:
  - vsm.v
  - vse8.v
  - vse16.v
  - vse32.v
  - vse64.v
  - vse128.v
  - vse256.v
  - vse512.v
  - vse1024.v
  - vsuxei8.v
  - vsuxei16.v
  - vsuxei32.v
  - vsuxei64.v
  - vsuxei128.v
  - vsuxei256.v
  - vsuxei512.v
  - vsuxei1024.v
  - vsse8.v
  - vsse16.v
  - vsse32.v
  - vsse64.v
  - vsse128.v
  - vsse256.v
  - vsse512.v
  - vsse1024.v
  - vsoxei8.v
  - vsoxei16.v
  - vsoxei32.v
  - vsoxei64.v
  - vsoxei128.v
  - vsoxei256.v
  - vsoxei512.v
  - vsoxei1024.v
  - vs1r.v
  - vs2r.v
  - vs4r.v
  - vs8r.v
  - vse1.v
  vs2:
  - vluxei8.v
  - vluxei16.v
  - vluxei32.v
  - vluxei64.v
  - vluxei128.v
  - vluxei256.v
  - vluxei512.v
  - vluxei1024.v
  - vsuxei8.v
  - vsuxei16.v
  - vsuxei32.v
  - vsuxei64.v
  - vsuxei128.v
  - vsuxei256.v
  - vsuxei512.v
  - vsuxei1024.v
  - vloxei8.v
  - vloxei16.v
  - vloxei32.v
  - vloxei64.v
  - vloxei128.v
  - vloxei256.v
  - vloxei512.v
  - vloxei1024.v
  - vsoxei8.v
  - vsoxei16.v
  - vsoxei32.v
  - vsoxei64.v
  - vsoxei128.v
  - vsoxei256.v
  - vsoxei512.v
  - vsoxei1024.v
  - vfadd.vf
  - vfsub.vf
  - vfmin.vf
  - vfmax.vf
  - vfsgnj.vf
  - vfsgnjn.vf
  - vfsgnjx.vf
  - vfslide1up.vf
  - vfslide1down.vf
  - vfmerge.vfm
  - vmfeq.vf
  - vmfle.vf
  - vmflt.vf
  - vmfne.vf
  - vmfgt.vf
  - vmfge.vf
  - vfdiv.vf
  - vfrdiv.vf
  - vfmul.vf
  - vfrsub.vf
  - vfmadd.vf
  - vfnmadd.vf
  - vfmsub.vf
  - vfnmsub.vf
  - vfmacc.vf
  - vfnmacc.vf
  - vfmsac.vf
  - vfnmsac.vf
  - vfwadd.vf
  - vfwsub.vf
  - vfwadd.wf
  - vfwsub.wf
  - vfwmul.vf
  - vfwmacc.vf
  - vfwnmacc.vf
  - vfwmsac.vf
  - vfwnmsac.vf
  - vfadd.vv
  - vfredusum.vs
  - vfsub.vv
  - vfredosum.vs
  - vfmin.vv
  - vfredmin.vs
  - vfmax.vv
  - vfredmax.vs
  - vfsgnj.vv
  - vfsgnjn.vv
  - vfsgnjx.vv
  - vfmv.f.s
  - vmfeq.vv
  - vmfle.vv
  - vmflt.vv
  - vmfne.vv
  - vfdiv.vv
  - vfmul.vv
  - vfmadd.vv
  - vfnmadd.vv
  - vfmsub.vv
  - vfnmsub.vv
  - vfmacc.vv
  - vfnmacc.vv
  - vfmsac.vv
  - vfnmsac.vv
  - vfcvt.xu.f.v
  - vfcvt.x.f.v
  - vfcvt.f.xu.v
  - vfcvt.f.x.v
  - vfcvt.rtz.xu.f.v
  - vfcvt.rtz.x.f.v
  - vfwcvt.xu.f.v
  - vfwcvt.x.f.v
  - vfwcvt.f.xu.v
  - vfwcvt.f.x.v
  - vfwcvt.f.f.v
  - vfwcvt.rtz.xu.f.v
  - vfwcvt.rtz.x.f.v
  - vfncvt.xu.f.w
  - vfncvt.x.f.w
  - vfncvt.f.xu.w
  - vfncvt.f.x.w
  - vfncvt.f.f.w
  - vfncvt.rod.f.f.w
  - vfncvt.rtz.xu.f.w
  - vfncvt.rtz.x.f.w
  - vfsqrt.v
  - vfrsqrt7.v
  - vfrec7.v
  - vfclass.v
  - vfwadd.vv
  - vfwredusum.vs
  - vfwsub.vv
  - vfwredosum.vs
  - vfwadd.wv
  - vfwsub.wv
  - vfwmul.vv
  - vfwmacc.vv
  - vfwnmacc.vv
  - vfwmsac.vv
  - vfwnmsac.vv
  - vadd.vx
  - vsub.vx
  - vrsub.vx
  - vminu.vx
  - vmin.vx
  - vmaxu.vx
  - vmax.vx
  - vand.vx
  - vor.vx
  - vxor.vx
  - vrgather.vx
  - vslideup.vx
  - vslidedown.vx
  - vadc.vxm
  - vmadc.vxm
  - vmadc.vx
  - vsbc.vxm
  - vmsbc.vxm
  - vmsbc.vx
  - vmerge.vxm
  - vmseq.vx
  - vmsne.vx
  - vmsltu.vx
  - vmslt.vx
  - vmsleu.vx
  - vmsle.vx
  - vmsgtu.vx
  - vmsgt.vx
  - vsaddu.vx
  - vsadd.vx
  - vssubu.vx
  - vssub.vx
  - vsll.vx
  - vsmul.vx
  - vsrl.vx
  - vsra.vx
  - vssrl.vx
  - vssra.vx
  - vnsrl.wx
  - vnsra.wx
  - vnclipu.wx
  - vnclip.wx
  - vadd.vv
  - vsub.vv
  - vminu.vv
  - vmin.vv
  - vmaxu.vv
  - vmax.vv
  - vand.vv
  - vor.vv
  - vxor.vv
  - vrgather.vv
  - vrgatherei16.vv
  - vadc.vvm
  - vmadc.vvm
  - vmadc.vv
  - vsbc.vvm
  - vmsbc.vvm
  - vmsbc.vv
  - vmerge.vvm
  - vmseq.vv
  - vmsne.vv
  - vmsltu.vv
  - vmslt.vv
  - vmsleu.vv
  - vmsle.vv
  - vsaddu.vv
  - vsadd.vv
  - vssubu.vv
  - vssub.vv
  - vsll.vv
  - vsmul.vv
  - vsrl.vv
  - vsra.vv
  - vssrl.vv
  - vssra.vv
  - vnsrl.wv
  - vnsra.wv
  - vnclipu.wv
  - vnclip.wv
  - vwredsumu.vs
  - vwredsum.vs
  - vadd.vi
  - vrsub.vi
  - vand.vi
  - vor.vi
  - vxor.vi
  - vrgather.vi
  - vslideup.vi
  - vslidedown.vi
  - vadc.vim
  - vmadc.vim
  - vmadc.vi
  - vmerge.vim
  - vmseq.vi
  - vmsne.vi
  - vmsleu.vi
  - vmsle.vi
  - vmsgtu.vi
  - vmsgt.vi
  - vsaddu.vi
  - vsadd.vi
  - vsll.vi
  - vmv1r.v
  - vmv2r.v
  - vmv4r.v
  - vmv8r.v
  - vsrl.vi
  - vsra.vi
  - vssrl.vi
  - vssra.vi
  - vnsrl.wi
  - vnsra.wi
  - vnclipu.wi
  - vnclip.wi
  - vredsum.vs
  - vredand.vs
  - vredor.vs
  - vredxor.vs
  - vredminu.vs
  - vredmin.vs
  - vredmaxu.vs
  - vredmax.vs
  - vaaddu.vv
  - vaadd.vv
  - vasubu.vv
  - vasub.vv
  - vmv.x.s
  - vzext.vf8
  - vsext.vf8
  - vzext.vf4
  - vsext.vf4
  - vzext.vf2
  - vsext.vf2
  - vcompress.vm
  - vmandn.mm
  - vmand.mm
  - vmor.mm
  - vmxor.mm
  - vmorn.mm
  - vmnand.mm
  - vmnor.mm
  - vmxnor.mm
  - vmsbf.m
  - vmsof.m
  - vmsif.m
  - viota.m
  - vcpop.m
  - vfirst.m
  - vdivu.vv
  - vdiv.vv
  - vremu.vv
  - vrem.vv
  - vmulhu.vv
  - vmul.vv
  - vmulhsu.vv
  - vmulh.vv
  - vmadd.vv
  - vnmsub.vv
  - vmacc.vv
  - vnmsac.vv
  - vwaddu.vv
  - vwadd.vv
  - vwsubu.vv
  - vwsub.vv
  - vwaddu.wv
  - vwadd.wv
  - vwsubu.wv
  - vwsub.wv
  - vwmulu.vv
  - vwmulsu.vv
  - vwmul.vv
  - vwmaccu.vv
  - vwmacc.vv
  - vwmaccsu.vv
  - vaaddu.vx
  - vaadd.vx
  - vasubu.vx
  - vasub.vx
  - vslide1up.vx
  - vslide1down.vx
  - vdivu.vx
  - vdiv.vx
  - vremu.vx
  - vrem.vx
  - vmulhu.vx
  - vmul.vx
  - vmulhsu.vx
  - vmulh.vx
  - vmadd.vx
  - vnmsub.vx
  - vmacc.vx
  - vnmsac.vx
  - vwaddu.vx
  - vwadd.vx
  - vwsubu.vx
  - vwsub.vx
  - vwaddu.wx
  - vwadd.wx
  - vwsubu.wx
  - vwsub.wx
  - vwmulu.vx
  - vwmulsu.vx
  - vwmul.vx
  - vwmaccu.vx
  - vwmacc.vx
  - vwmaccus.vx
  - vwmaccsu.vx
  - vamoswapei8.v
  - vamoaddei8.v
  - vamoxorei8.v
  - vamoandei8.v
  - vamoorei8.v
  - vamominei8.v
  - vamomaxei8.v
  - vamominuei8.v
  - vamomaxuei8.v
  - vamoswapei16.v
  - vamoaddei16.v
  - vamoxorei16.v
  - vamoandei16.v
  - vamoorei16.v
  - vamominei16.v
  - vamomaxei16.v
  - vamominuei16.v
  - vamomaxuei16.v
  - vamoswapei32.v
  - vamoaddei32.v
  - vamoxorei32.v
  - vamoandei32.v
  - vamoorei32.v
  - vamominei32.v
  - vamomaxei32.v
  - vamominuei32.v
  - vamomaxuei32.v
  - vamoswapei64.v
  - vamoaddei64.v
  - vamoxorei64.v
  - vamoandei64.v
  - vamoorei64.v
  - vamominei64.v
  - vamomaxei64.v
  - vamominuei64.v
  - vamomaxuei64.v
  - vfredsum.vs
  - vfwredsum.vs
  - vpopc.m
  - vmornot.mm
  - vmandnot.mm
  vs1:
  - vfadd.vv
  - vfredusum.vs
  - vfsub.vv
  - vfredosum.vs
  - vfmin.vv
  - vfredmin.vs
  - vfmax.vv
  - vfredmax.vs
  - vfsgnj.vv
  - vfsgnjn.vv
  - vfsgnjx.vv
  - vmfeq.vv
  - vmfle.vv
  - vmflt.vv
  - vmfne.vv
  - vfdiv.vv
  - vfmul.vv
  - vfmadd.vv
  - vfnmadd.vv
  - vfmsub.vv
  - vfnmsub.vv
  - vfmacc.vv
  - vfnmacc.vv
  - vfmsac.vv
  - vfnmsac.vv
  - vfwadd.vv
  - vfwredusum.vs
  - vfwsub.vv
  - vfwredosum.vs
  - vfwadd.wv
  - vfwsub.wv
  - vfwmul.vv
  - vfwmacc.vv
  - vfwnmacc.vv
  - vfwmsac.vv
  - vfwnmsac.vv
  - vadd.vv
  - vsub.vv
  - vminu.vv
  - vmin.vv
  - vmaxu.vv
  - vmax.vv
  - vand.vv
  - vor.vv
  - vxor.vv
  - vrgather.vv
  - vrgatherei16.vv
  - vadc.vvm
  - vmadc.vvm
  - vmadc.vv
  - vsbc.vvm
  - vmsbc.vvm
  - vmsbc.vv
  - vmerge.vvm
  - vmv.v.v
  - vmseq.vv
  - vmsne.vv
  - vmsltu.vv
  - vmslt.vv
  - vmsleu.vv
  - vmsle.vv
  - vsaddu.vv
  - vsadd.vv
  - vssubu.vv
  - vssub.vv
  - vsll.vv
  - vsmul.vv
  - vsrl.vv
  - vsra.vv
  - vssrl.vv
  - vssra.vv
  - vnsrl.wv
  - vnsra.wv
  - vnclipu.wv
  - vnclip.wv
  - vwredsumu.vs
  - vwredsum.vs
  - vredsum.vs
  - vredand.vs
  - vredor.vs
  - vredxor.vs
  - vredminu.vs
  - vredmin.vs
  - vredmaxu.vs
  - vredmax.vs
  - vaaddu.vv
  - vaadd.vv
  - vasubu.vv
  - vasub.vv
  - vcompress.vm
  - vmandn.mm
  - vmand.mm
  - vmor.mm
  - vmxor.mm
  - vmorn.mm
  - vmnand.mm
  - vmnor.mm
  - vmxnor.mm
  - vdivu.vv
  - vdiv.vv
  - vremu.vv
  - vrem.vv
  - vmulhu.vv
  - vmul.vv
  - vmulhsu.vv
  - vmulh.vv
  - vmadd.vv
  - vnmsub.vv
  - vmacc.vv
  - vnmsac.vv
  - vwaddu.vv
  - vwadd.vv
  - vwsubu.vv
  - vwsub.vv
  - vwaddu.wv
  - vwadd.wv
  - vwsubu.wv
  - vwsub.wv
  - vwmulu.vv
  - vwmulsu.vv
  - vwmul.vv
  - vwmaccu.vv
  - vwmacc.vv
  - vwmaccsu.vv
  - vfredsum.vs
  - vfwredsum.vs
  - vmornot.mm
  - vmandnot.mm
  simm5:
  - vadd.vi
  - vrsub.vi
  - vand.vi
  - vor.vi
  - vxor.vi
  - vrgather.vi
  - vslideup.vi
  - vslidedown.vi
  - vadc.vim
  - vmadc.vim
  - vmadc.vi
  - vmerge.vim
  - vmv.v.i
  - vmseq.vi
  - vmsne.vi
  - vmsleu.vi
  - vmsle.vi
  - vmsgtu.vi
  - vmsgt.vi
  - vsaddu.vi
  - vsadd.vi
  - vsll.vi
  - vsrl.vi
  - vsra.vi
  - vssrl.vi
  - vssra.vi
  - vnsrl.wi
  - vnsra.wi
  - vnclipu.wi
  - vnclip.wi
  c_spimm:
  - cm.push
  - cm.pop
  - cm.popretz
  - cm.popret
  c_nzuimm10:
  - c.addi4spn
  c_uimm7:
  - c.lw
  - c.sw
  - c.flw
  - c.fsw
  c_nzimm6:
  - c.nop
  - c.addi
  - c.addi
  rd_rs1_n0:
  - c.addi
  - c.slli
  - c.slli_rv32
  - c.addiw
  - c.slli
  c_imm6:
  - c.li
  - c.andi
  - c.addiw
  c_nzimm10:
  - c.addi16sp
  rd_n2:
  - c.lui
  c_nzimm18:
  - c.lui
  c_imm12:
  - c.j
  - c.jal
  c_bimm9:
  - c.beqz
  - c.bnez
  rd_n0:
  - c.lwsp
  - c.ldsp
  c_uimm8sp:
  - c.lwsp
  - c.flwsp
  rs1_n0:
  - c.jr
  c_rs2_n0:
  - c.mv
  - c.add
  c_rs1_n0:
  - c.jalr
  rd_rs1:
  - c.add
  c_rs2:
  - c.swsp
  - c.fsdsp
  - c.fswsp
  - c.sdsp
  c_uimm8sp_s:
  - c.swsp
  - c.fswsp
  imm12:
  - flq
  - fsq
  - fence.i
  - flh
  - fsh
  - flw
  - fsw
  - jalr
  - lb
  - lh
  - lw
  - lbu
  - lhu
  - sb
  - sh
  - sw
  - addi
  - slti
  - sltiu
  - xori
  - ori
  - andi
  - fld
  - fsd
  - lwu
  - ld
  - sd
  - addiw
  rs3:
  - fmadd.q
  - fmsub.q
  - fnmsub.q
  - fnmadd.q
  - fmadd.h
  - fmsub.h
  - fnmsub.h
  - fnmadd.h
  - fmadd.s
  - fmsub.s
  - fnmsub.s
  - fnmadd.s
  - fmadd.d
  - fmsub.d
  - fnmsub.d
  - fnmadd.d
  c_uimm8:
  - c.fld
  - c.fsd
  - c.ld
  - c.sd
  c_uimm9sp:
  - c.fldsp
  - c.ldsp
  c_uimm9sp_s:
  - c.fsdsp
  - c.sdsp
  imm12hi:
  - prefetch.i
  - prefetch.r
  - prefetch.w
  imm20:
  - lui
  - auipc
  jimm20:
  - jal
  bimm12:
  - beq
  - bne
  - blt
  - bge
  - bltu
  - bgeu
  c_nzuimm5:
  - c.srli
  - c.srai
  - c.srli_rv32
  - c.srai_rv32
  c_nzuimm6lo:
  - c.slli
  - c.slli_rv32
  c_nzuimm6:
  - c.srli
  - c.srai
  - c.slli
